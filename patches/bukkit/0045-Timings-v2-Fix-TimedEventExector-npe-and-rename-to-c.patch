From 8585b05deec95fc98d59aa79b6c55f2f8d8e8e16 Mon Sep 17 00:00:00 2001
From: Aikar <aikar@aikar.co>
Date: Sun, 10 Jan 2016 01:04:20 -0500
Subject: [PATCH] Timings v2: Fix TimedEventExector npe and rename to
 co.aikar.timings

---
 .../co/aikar/timings/FullServerTickHandler.java    |  79 +++++
 .../java/co/aikar/timings/NullTimingHandler.java   |  61 ++++
 .../java/co/aikar/timings/TimedEventExecutor.java  |  79 +++++
 src/main/java/co/aikar/timings/Timing.java         |  72 ++++
 src/main/java/co/aikar/timings/TimingData.java     | 105 ++++++
 src/main/java/co/aikar/timings/TimingHandler.java  | 190 +++++++++++
 src/main/java/co/aikar/timings/TimingHistory.java  | 276 +++++++++++++++
 .../java/co/aikar/timings/TimingHistoryEntry.java  |  59 ++++
 .../java/co/aikar/timings/TimingIdentifier.java    | 102 ++++++
 src/main/java/co/aikar/timings/Timings.java        | 273 +++++++++++++++
 src/main/java/co/aikar/timings/TimingsCommand.java | 110 ++++++
 src/main/java/co/aikar/timings/TimingsExport.java  | 371 ++++++++++++++++++++
 src/main/java/co/aikar/timings/TimingsManager.java | 194 +++++++++++
 .../java/co/aikar/timings/UnsafeTimingHandler.java |  51 +++
 src/main/java/org/bukkit/command/Command.java      |   2 +-
 .../org/bukkit/command/FormattedCommandAlias.java  |   2 +-
 .../java/org/bukkit/command/SimpleCommandMap.java  |   4 +-
 .../org/bukkit/plugin/SimplePluginManager.java     |   6 +-
 .../org/bukkit/plugin/java/JavaPluginLoader.java   |   2 +-
 .../java/org/spigotmc/CustomTimingsHandler.java    |  10 +-
 .../spigotmc/timings/FullServerTickHandler.java    |  79 -----
 .../org/spigotmc/timings/NullTimingHandler.java    |  61 ----
 .../org/spigotmc/timings/TimedEventExecutor.java   |  73 ----
 src/main/java/org/spigotmc/timings/Timing.java     |  72 ----
 src/main/java/org/spigotmc/timings/TimingData.java | 105 ------
 .../java/org/spigotmc/timings/TimingHandler.java   | 193 -----------
 .../java/org/spigotmc/timings/TimingHistory.java   | 276 ---------------
 .../org/spigotmc/timings/TimingHistoryEntry.java   |  59 ----
 .../org/spigotmc/timings/TimingIdentifier.java     | 102 ------
 src/main/java/org/spigotmc/timings/Timings.java    | 273 ---------------
 .../java/org/spigotmc/timings/TimingsCommand.java  | 110 ------
 .../java/org/spigotmc/timings/TimingsExport.java   | 372 ---------------------
 .../java/org/spigotmc/timings/TimingsManager.java  | 194 -----------
 .../org/spigotmc/timings/UnsafeTimingHandler.java  |  51 ---
 src/main/java/org/spigotmc/util/LoadingMap.java    |   2 +-
 35 files changed, 2036 insertions(+), 2034 deletions(-)
 create mode 100644 src/main/java/co/aikar/timings/FullServerTickHandler.java
 create mode 100644 src/main/java/co/aikar/timings/NullTimingHandler.java
 create mode 100644 src/main/java/co/aikar/timings/TimedEventExecutor.java
 create mode 100644 src/main/java/co/aikar/timings/Timing.java
 create mode 100644 src/main/java/co/aikar/timings/TimingData.java
 create mode 100644 src/main/java/co/aikar/timings/TimingHandler.java
 create mode 100644 src/main/java/co/aikar/timings/TimingHistory.java
 create mode 100644 src/main/java/co/aikar/timings/TimingHistoryEntry.java
 create mode 100644 src/main/java/co/aikar/timings/TimingIdentifier.java
 create mode 100644 src/main/java/co/aikar/timings/Timings.java
 create mode 100644 src/main/java/co/aikar/timings/TimingsCommand.java
 create mode 100644 src/main/java/co/aikar/timings/TimingsExport.java
 create mode 100644 src/main/java/co/aikar/timings/TimingsManager.java
 create mode 100644 src/main/java/co/aikar/timings/UnsafeTimingHandler.java
 delete mode 100644 src/main/java/org/spigotmc/timings/FullServerTickHandler.java
 delete mode 100644 src/main/java/org/spigotmc/timings/NullTimingHandler.java
 delete mode 100644 src/main/java/org/spigotmc/timings/TimedEventExecutor.java
 delete mode 100644 src/main/java/org/spigotmc/timings/Timing.java
 delete mode 100644 src/main/java/org/spigotmc/timings/TimingData.java
 delete mode 100644 src/main/java/org/spigotmc/timings/TimingHandler.java
 delete mode 100644 src/main/java/org/spigotmc/timings/TimingHistory.java
 delete mode 100644 src/main/java/org/spigotmc/timings/TimingHistoryEntry.java
 delete mode 100644 src/main/java/org/spigotmc/timings/TimingIdentifier.java
 delete mode 100644 src/main/java/org/spigotmc/timings/Timings.java
 delete mode 100644 src/main/java/org/spigotmc/timings/TimingsCommand.java
 delete mode 100644 src/main/java/org/spigotmc/timings/TimingsExport.java
 delete mode 100644 src/main/java/org/spigotmc/timings/TimingsManager.java
 delete mode 100644 src/main/java/org/spigotmc/timings/UnsafeTimingHandler.java

diff --git a/src/main/java/co/aikar/timings/FullServerTickHandler.java b/src/main/java/co/aikar/timings/FullServerTickHandler.java
new file mode 100644
index 0000000..cb4e7ba
--- /dev/null
+++ b/src/main/java/co/aikar/timings/FullServerTickHandler.java
@@ -0,0 +1,79 @@
+package co.aikar.timings;
+
+import static co.aikar.timings.TimingsManager.*;
+
+public class FullServerTickHandler extends TimingHandler {
+    static final TimingIdentifier IDENTITY = new TimingIdentifier("Minecraft", "Full Server Tick", null, false);
+    final TimingData minuteData;
+    double avgFreeMemory = -1D;
+    double avgUsedMemory = -1D;
+    FullServerTickHandler() {
+        super(IDENTITY);
+        minuteData = new TimingData(id);
+
+        TIMING_MAP.put(IDENTITY, this);
+    }
+
+    @Override
+    public void startTiming() {
+        if (TimingsManager.needsFullReset) {
+            TimingsManager.resetTimings();
+        } else if (TimingsManager.needsRecheckEnabled) {
+            TimingsManager.recheckEnabled();
+        }
+        super.startTiming();
+    }
+
+    @Override
+    public void stopTiming() {
+        super.stopTiming();
+        if (!enabled) {
+            return;
+        }
+        if (TimingHistory.timedTicks % 20 == 0) {
+            final Runtime runtime = Runtime.getRuntime();
+            double usedMemory = runtime.totalMemory() - runtime.freeMemory();
+            double freeMemory = runtime.maxMemory() - usedMemory;
+            if (this.avgFreeMemory == -1) {
+                this.avgFreeMemory = freeMemory;
+            } else {
+                this.avgFreeMemory = (this.avgFreeMemory * (59 / 60D)) + (freeMemory * (1 / 60D));
+            }
+
+            if (this.avgUsedMemory == -1) {
+                this.avgUsedMemory = usedMemory;
+            } else {
+                this.avgUsedMemory = (this.avgUsedMemory * (59 / 60D)) + (usedMemory * (1 / 60D));
+            }
+        }
+
+        long start = System.nanoTime();
+        TimingsManager.tick();
+        long diff = System.nanoTime() - start;
+        CURRENT = TIMINGS_TICK;
+        TIMINGS_TICK.addDiff(diff);
+        // addDiff for TIMINGS_TICK incremented this, bring it back down to 1 per tick.
+        record.curTickCount--;
+        minuteData.curTickTotal = record.curTickTotal;
+        minuteData.curTickCount = 1;
+        boolean violated = isViolated();
+        minuteData.processTick(violated);
+        TIMINGS_TICK.processTick(violated);
+        processTick(violated);
+
+
+        if (TimingHistory.timedTicks % 1200 == 0) {
+            MINUTE_REPORTS.add(new TimingHistory.MinuteReport());
+            TimingHistory.resetTicks(false);
+            minuteData.reset();
+        }
+        if (TimingHistory.timedTicks % Timings.getHistoryInterval() == 0) {
+            TimingsManager.HISTORY.add(new TimingHistory());
+            TimingsManager.resetTimings();
+        }
+    }
+
+    boolean isViolated() {
+        return record.curTickTotal > 50000000;
+    }
+}
diff --git a/src/main/java/co/aikar/timings/NullTimingHandler.java b/src/main/java/co/aikar/timings/NullTimingHandler.java
new file mode 100644
index 0000000..c73b617
--- /dev/null
+++ b/src/main/java/co/aikar/timings/NullTimingHandler.java
@@ -0,0 +1,61 @@
+/*
+ * This file is licensed under the MIT License (MIT).
+ *
+ * Copyright (c) 2014 Daniel Ennis <http://aikar.co>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+package co.aikar.timings;
+
+public final class NullTimingHandler implements Timing {
+    @Override
+    public void startTiming() {
+
+    }
+
+    @Override
+    public void stopTiming() {
+
+    }
+
+    @Override
+    public void startTimingIfSync() {
+
+    }
+
+    @Override
+    public void stopTimingIfSync() {
+
+    }
+
+    @Override
+    public void abort() {
+
+    }
+
+    @Override
+    public TimingHandler getTimingHandler() {
+        return null;
+    }
+
+    @Override
+    public void close() {
+
+    }
+}
diff --git a/src/main/java/co/aikar/timings/TimedEventExecutor.java b/src/main/java/co/aikar/timings/TimedEventExecutor.java
new file mode 100644
index 0000000..11edbfd
--- /dev/null
+++ b/src/main/java/co/aikar/timings/TimedEventExecutor.java
@@ -0,0 +1,79 @@
+/*
+ * This file is licensed under the MIT License (MIT).
+ *
+ * Copyright (c) 2014 Daniel Ennis <http://aikar.co>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+package co.aikar.timings;
+
+import org.bukkit.Bukkit;
+import org.bukkit.event.Event;
+import org.bukkit.event.EventException;
+import org.bukkit.event.Listener;
+import org.bukkit.plugin.EventExecutor;
+import org.bukkit.plugin.Plugin;
+
+import java.lang.reflect.Method;
+
+public class TimedEventExecutor implements EventExecutor {
+
+    private final EventExecutor executor;
+    private final Timing timings;
+
+    /**
+     * Wraps an event executor and associates a timing handler to it.
+     *
+     * @param executor
+     * @param plugin
+     * @param method
+     * @param eventClass
+     */
+    public TimedEventExecutor(EventExecutor executor, Plugin plugin, Method method, Class<? extends Event> eventClass) {
+        this.executor = executor;
+        String id;
+
+        if (method == null && executor.getClass().getEnclosingClass() != null) {
+            method = executor.getClass().getEnclosingMethod();
+        }
+
+        if (method != null) {
+            id = method.getDeclaringClass().getName();
+        } else {
+            id = executor.getClass().getName();
+        }
+
+
+        final String eventName = eventClass.getSimpleName();
+        boolean verbose = "BlockPhysicsEvent".equals(eventName) || "Drain".equals(eventName) || "Fill".equals(eventName);
+        this.timings = Timings.ofSafe(plugin.getName(), (verbose ? "## " : "") +
+            "Event: " + id + " (" + eventName + ")", null);
+    }
+
+    @Override
+    public void execute(Listener listener, Event event) throws EventException {
+        if (event.isAsynchronous() || !Timings.timingsEnabled || !Bukkit.isPrimaryThread()) {
+            executor.execute(listener, event);
+            return;
+        }
+        timings.startTiming();
+        executor.execute(listener, event);
+        timings.stopTiming();
+    }
+}
diff --git a/src/main/java/co/aikar/timings/Timing.java b/src/main/java/co/aikar/timings/Timing.java
new file mode 100644
index 0000000..2ac1237
--- /dev/null
+++ b/src/main/java/co/aikar/timings/Timing.java
@@ -0,0 +1,72 @@
+/*
+ * This file is licensed under the MIT License (MIT).
+ *
+ * Copyright (c) 2014 Daniel Ennis <http://aikar.co>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+package co.aikar.timings;
+
+/**
+ * Provides an ability to time sections of code within the Minecraft Server
+ */
+public interface Timing extends AutoCloseable {
+    /**
+     * Starts timing the execution until {@link #stopTiming()} is called.
+     */
+    public void startTiming();
+
+    /**
+     * Stops timing and records the data. Propagates the data up to group handlers.
+     * <p/>
+     * Will automatically be called when this Timing is used with try-with-resources
+     */
+    public void stopTiming();
+
+    /**
+     * Starts timing the execution until {@link #stopTiming()} is called.
+     *
+     * But only if we are on the primary thread.
+     */
+    public void startTimingIfSync();
+
+    /**
+     * Stops timing and records the data. Propagates the data up to group handlers.
+     * <p/>
+     * Will automatically be called when this Timing is used with try-with-resources
+     *
+     * But only if we are on the primary thread.
+     */
+    public void stopTimingIfSync();
+
+    /**
+     * Stops timing and disregards current timing data.
+     */
+    public void abort();
+
+    /**
+     * Used internally to get the actual backing Handler in the case of delegated Handlers
+     *
+     * @return TimingHandler
+     */
+    TimingHandler getTimingHandler();
+
+    @Override
+    void close();
+}
diff --git a/src/main/java/co/aikar/timings/TimingData.java b/src/main/java/co/aikar/timings/TimingData.java
new file mode 100644
index 0000000..4d5189d
--- /dev/null
+++ b/src/main/java/co/aikar/timings/TimingData.java
@@ -0,0 +1,105 @@
+/*
+ * This file is licensed under the MIT License (MIT).
+ *
+ * Copyright (c) 2014 Daniel Ennis <http://aikar.co>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+package co.aikar.timings;
+
+import com.google.common.base.Function;
+
+import java.util.List;
+
+import static org.spigotmc.util.JSONUtil.toArray;
+
+/**
+ * Lightweight object for tracking timing data
+ * <p/>
+ * This is broken out to reduce memory usage
+ */
+class TimingData {
+    static Function<Integer, TimingData> LOADER = new Function<Integer, TimingData>() {
+        @Override
+        public TimingData apply(Integer input) {
+            return new TimingData(input);
+        }
+    };
+    int id;
+    int count = 0;
+    int lagCount = 0;
+    long totalTime = 0;
+    long lagTotalTime = 0;
+
+    int curTickCount = 0;
+    int curTickTotal = 0;
+
+    TimingData(int id) {
+        this.id = id;
+    }
+
+    TimingData(TimingData data) {
+        this.id = data.id;
+        this.totalTime = data.totalTime;
+        this.lagTotalTime = data.lagTotalTime;
+        this.count = data.count;
+        this.lagCount = data.lagCount;
+    }
+
+    void add(long diff) {
+        ++curTickCount;
+        curTickTotal += diff;
+    }
+
+    void processTick(boolean violated) {
+        totalTime += curTickTotal;
+        count += curTickCount;
+        if (violated) {
+            lagTotalTime += curTickTotal;
+            lagCount += curTickCount;
+        }
+        curTickTotal = 0;
+        curTickCount = 0;
+    }
+
+    void reset() {
+        count = 0;
+        lagCount = 0;
+        curTickTotal = 0;
+        curTickCount = 0;
+        totalTime = 0;
+        lagTotalTime = 0;
+    }
+
+    protected TimingData clone() {
+        return new TimingData(this);
+    }
+
+    public List export() {
+        List list = toArray(
+            id,
+            count,
+            totalTime);
+        if (lagCount > 0) {
+            list.add(lagCount);
+            list.add(lagTotalTime);
+        }
+        return list;
+    }
+}
diff --git a/src/main/java/co/aikar/timings/TimingHandler.java b/src/main/java/co/aikar/timings/TimingHandler.java
new file mode 100644
index 0000000..1c1cee2
--- /dev/null
+++ b/src/main/java/co/aikar/timings/TimingHandler.java
@@ -0,0 +1,190 @@
+/*
+ * This file is licensed under the MIT License (MIT).
+ *
+ * Copyright (c) 2014 Daniel Ennis <http://aikar.co>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+package co.aikar.timings;
+
+import gnu.trove.map.hash.TIntObjectHashMap;
+import org.bukkit.Bukkit;
+import org.spigotmc.util.LoadingIntMap;
+
+import java.util.logging.Level;
+
+class TimingHandler implements Timing {
+
+    private static int idPool = 1;
+    final int id = idPool++;
+
+    final String name;
+    final boolean verbose;
+
+    final TIntObjectHashMap<TimingData> children = new LoadingIntMap<TimingData>(TimingData.LOADER);
+
+    final TimingData record;
+    final TimingHandler groupHandler;
+
+    long start = 0;
+    int timingDepth = 0;
+    boolean added;
+    boolean timed;
+    boolean enabled;
+    TimingHandler parent;
+
+    TimingHandler(TimingIdentifier id) {
+        if (id.name.startsWith("##")) {
+            verbose = true;
+            this.name = id.name.substring(3);
+        } else {
+            this.name = id.name;
+            verbose = false;
+        }
+
+        this.record = new TimingData(this.id);
+        this.groupHandler = id.groupHandler;
+
+        TimingIdentifier.getGroup(id.group).handlers.add(this);
+        checkEnabled();
+    }
+
+    final void checkEnabled() {
+        enabled = Timings.timingsEnabled && (!verbose || Timings.verboseEnabled);
+    }
+
+    void processTick(boolean violated) {
+        if (timingDepth != 0 || record.curTickCount == 0) {
+            timingDepth = 0;
+            start = 0;
+            return;
+        }
+
+        record.processTick(violated);
+        for (TimingData handler : children.valueCollection()) {
+            handler.processTick(violated);
+        }
+    }
+
+    @Override
+    public void startTimingIfSync() {
+        if (Bukkit.isPrimaryThread()) {
+            startTiming();
+        }
+    }
+
+    @Override
+    public void stopTimingIfSync() {
+        if (Bukkit.isPrimaryThread()) {
+            stopTiming();
+        }
+    }
+
+    public void startTiming() {
+        if (enabled && ++timingDepth == 1) {
+            start = System.nanoTime();
+            parent = TimingsManager.CURRENT;
+            TimingsManager.CURRENT = this;
+        }
+    }
+
+    public void stopTiming() {
+        if (enabled && --timingDepth == 0 && start != 0) {
+            if (!Bukkit.isPrimaryThread()) {
+                Bukkit.getLogger().log(Level.SEVERE, "stopTiming called async for " + name);
+                new Throwable().printStackTrace();
+                start = 0;
+                return;
+            }
+            addDiff(System.nanoTime() - start);
+            start = 0;
+        }
+    }
+
+    @Override
+    public void abort() {
+        if (enabled && timingDepth > 0) {
+            start = 0;
+        }
+    }
+
+    void addDiff(long diff) {
+        if (TimingsManager.CURRENT == this) {
+            TimingsManager.CURRENT = parent;
+            if (parent != null) {
+                parent.children.get(id).add(diff);
+            }
+        }
+        record.add(diff);
+        if (!added) {
+            added = true;
+            timed = true;
+            TimingsManager.HANDLERS.add(this);
+        }
+        if (groupHandler != null) {
+            groupHandler.addDiff(diff);
+            groupHandler.children.get(id).add(diff);
+        }
+    }
+
+    /**
+     * Reset this timer, setting all values to zero.
+     *
+     * @param full
+     */
+    void reset(boolean full) {
+        record.reset();
+        if (full) {
+            timed = false;
+        }
+        start = 0;
+        timingDepth = 0;
+        added = false;
+        children.clear();
+        checkEnabled();
+    }
+
+    @Override
+    public TimingHandler getTimingHandler() {
+        return this;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        return (this == o);
+    }
+
+    @Override
+    public int hashCode() {
+        return id;
+    }
+
+    /**
+     * This is simply for the Closeable interface so it can be used with
+     * try-with-resources ()
+     */
+    @Override
+    public void close() {
+        stopTimingIfSync();
+    }
+
+    public boolean isSpecial() {
+        return this == TimingsManager.FULL_SERVER_TICK || this == TimingsManager.TIMINGS_TICK;
+    }
+}
diff --git a/src/main/java/co/aikar/timings/TimingHistory.java b/src/main/java/co/aikar/timings/TimingHistory.java
new file mode 100644
index 0000000..ba213e2
--- /dev/null
+++ b/src/main/java/co/aikar/timings/TimingHistory.java
@@ -0,0 +1,276 @@
+/*
+ * This file is licensed under the MIT License (MIT).
+ *
+ * Copyright (c) 2014 Daniel Ennis <http://aikar.co>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+package co.aikar.timings;
+
+import com.google.common.base.Function;
+import com.google.common.collect.Sets;
+import org.bukkit.Bukkit;
+import org.bukkit.Chunk;
+import org.bukkit.Material;
+import org.bukkit.World;
+import org.bukkit.block.BlockState;
+import org.bukkit.entity.Entity;
+import org.bukkit.entity.EntityType;
+import org.bukkit.entity.Player;
+import org.spigotmc.util.LoadingMap;
+import org.spigotmc.util.MRUMapCache;
+
+import java.lang.management.ManagementFactory;
+import java.util.Collection;
+import java.util.EnumMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import static co.aikar.timings.TimingsManager.FULL_SERVER_TICK;
+import static co.aikar.timings.TimingsManager.MINUTE_REPORTS;
+import static org.spigotmc.util.JSONUtil.*;
+
+@SuppressWarnings({"deprecation", "SuppressionAnnotation"})
+public class TimingHistory {
+    public static long lastMinuteTime;
+    public static long timedTicks;
+    public static long playerTicks;
+    public static long entityTicks;
+    public static long tileEntityTicks;
+    public static long activatedEntityTicks;
+    static int worldIdPool = 1;
+    static Map<String, Integer> worldMap = LoadingMap.newHashMap(new Function<String, Integer>() {
+        @Override
+        public Integer apply(String input) {
+            return worldIdPool++;
+        }
+    });
+    final long endTime;
+    final long startTime;
+    final long totalTicks;
+    final long totalTime; // Represents all time spent running the server this history
+    final MinuteReport[] minuteReports;
+
+    final TimingHistoryEntry[] entries;
+    final Set<Material> tileEntityTypeSet = Sets.newHashSet();
+    final Set<EntityType> entityTypeSet = Sets.newHashSet();
+    final Map<Object, Object> worlds;
+
+    TimingHistory() {
+        this.endTime = System.currentTimeMillis() / 1000;
+        this.startTime = TimingsManager.historyStart / 1000;
+        if (timedTicks % 1200 != 0 || MINUTE_REPORTS.isEmpty()) {
+            this.minuteReports = MINUTE_REPORTS.toArray(new MinuteReport[MINUTE_REPORTS.size() + 1]);
+            this.minuteReports[this.minuteReports.length - 1] = new MinuteReport();
+        } else {
+            this.minuteReports = MINUTE_REPORTS.toArray(new MinuteReport[MINUTE_REPORTS.size()]);
+        }
+        long ticks = 0;
+        for (MinuteReport mp : this.minuteReports) {
+            ticks += mp.ticksRecord.timed;
+        }
+        this.totalTicks = ticks;
+        this.totalTime = FULL_SERVER_TICK.record.totalTime;
+        this.entries = new TimingHistoryEntry[TimingsManager.HANDLERS.size()];
+
+        int i = 0;
+        for (TimingHandler handler : TimingsManager.HANDLERS) {
+            entries[i++] = new TimingHistoryEntry(handler);
+        }
+
+        final Map<EntityType, Counter> entityCounts = MRUMapCache.of(LoadingMap.of(
+            new EnumMap<EntityType, Counter>(EntityType.class), Counter.LOADER
+        ));
+        final Map<Material, Counter> tileEntityCounts = MRUMapCache.of(LoadingMap.of(
+            new EnumMap<Material, Counter>(Material.class), Counter.LOADER
+        ));
+        // Information about all loaded chunks/entities
+        this.worlds = toObjectMapper(Bukkit.getWorlds(), new Function<World, JSONPair>() {
+                @Override
+                public JSONPair apply(World world) {
+                return pair(
+                    worldMap.get(world.getName()),
+                    toArrayMapper(world.getLoadedChunks(), new Function<Chunk, Object>() {
+                        @Override
+                        public Object apply(Chunk chunk) {
+                        entityCounts.clear();
+                        tileEntityCounts.clear();
+
+                        for (Entity entity : chunk.getEntities()) {
+                            entityCounts.get(entity.getType()).increment();
+                        }
+
+                        for (BlockState tileEntity : chunk.getTileEntities()) {
+                            tileEntityCounts.get(tileEntity.getBlock().getType()).increment();
+                        }
+
+                        if (tileEntityCounts.isEmpty() && entityCounts.isEmpty()) {
+                            return null;
+                        }
+                        return toArray(
+                            chunk.getX(),
+                            chunk.getZ(),
+                            toObjectMapper(entityCounts.entrySet(),
+                                new Function<Map.Entry<EntityType, Counter>, JSONPair>() {
+                                    @Override
+                                    public JSONPair apply(Map.Entry<EntityType, Counter> entry) {
+                                    entityTypeSet.add(entry.getKey());
+                                    return pair(
+                                        String.valueOf(entry.getKey().getTypeId()),
+                                        entry.getValue().count()
+                                    );
+                                    }
+                                }
+                            ),
+                            toObjectMapper(tileEntityCounts.entrySet(),
+                                new Function<Map.Entry<Material, Counter>, JSONPair>() {
+                                    @Override
+                                    public JSONPair apply(Map.Entry<Material, Counter> entry) {
+                                    tileEntityTypeSet.add(entry.getKey());
+                                    return pair(
+                                        String.valueOf(entry.getKey().getId()),
+                                        entry.getValue().count()
+                                    );
+                                    }
+                                }
+                            )
+                        );
+                        }
+                    })
+                );
+            }
+        });
+    }
+
+    public static void resetTicks(boolean fullReset) {
+        if (fullReset) {
+            // Non full is simply for 1 minute reports
+            timedTicks = 0;
+        }
+        lastMinuteTime = System.nanoTime();
+        playerTicks = 0;
+        tileEntityTicks = 0;
+        entityTicks = 0;
+        activatedEntityTicks = 0;
+    }
+
+    Object export() {
+        return createObject(
+            pair("s", startTime),
+            pair("e", endTime),
+            pair("tk", totalTicks),
+            pair("tm", totalTime),
+            pair("w", worlds),
+            pair("h", toArrayMapper(entries, new Function<TimingHistoryEntry, Object>() {
+                @Override
+                public Object apply(TimingHistoryEntry entry) {
+                    TimingData record = entry.data;
+                    if (record.count == 0) {
+                        return null;
+                    }
+                    return entry.export();
+                }
+            })),
+            pair("mp", toArrayMapper(minuteReports, new Function<MinuteReport, Object>() {
+                @Override
+                public Object apply(MinuteReport input) {
+                    return input.export();
+                }
+            }))
+        );
+    }
+
+    static class MinuteReport {
+        final long time = System.currentTimeMillis() / 1000;
+
+        final TicksRecord ticksRecord = new TicksRecord();
+        final PingRecord pingRecord = new PingRecord();
+        final TimingData fst = TimingsManager.FULL_SERVER_TICK.minuteData.clone();
+        final double tps = 1E9 / ( System.nanoTime() - lastMinuteTime ) * ticksRecord.timed;
+        final double usedMemory = TimingsManager.FULL_SERVER_TICK.avgUsedMemory;
+        final double freeMemory = TimingsManager.FULL_SERVER_TICK.avgFreeMemory;
+        final double loadAvg = ManagementFactory.getOperatingSystemMXBean().getSystemLoadAverage();
+
+        public List export() {
+            return toArray(
+                time,
+                Math.round(tps * 100D) / 100D,
+                Math.round(pingRecord.avg * 100D) / 100D,
+                fst.export(),
+                toArray(ticksRecord.timed,
+                    ticksRecord.player,
+                    ticksRecord.entity,
+                    ticksRecord.activatedEntity,
+                    ticksRecord.tileEntity
+                ),
+                usedMemory,
+                freeMemory,
+                loadAvg
+            );
+        }
+    }
+
+    static class TicksRecord {
+        final long timed;
+        final long player;
+        final long entity;
+        final long tileEntity;
+        final long activatedEntity;
+
+        TicksRecord() {
+            timed = timedTicks - (TimingsManager.MINUTE_REPORTS.size() * 1200);
+            player = playerTicks;
+            entity = entityTicks;
+            tileEntity = tileEntityTicks;
+            activatedEntity = activatedEntityTicks;
+        }
+
+    }
+
+    static class PingRecord {
+        final double avg;
+
+        PingRecord() {
+            final Collection<? extends Player> onlinePlayers = Bukkit.getOnlinePlayers();
+            int totalPing = 0;
+            for (Player player : onlinePlayers) {
+                totalPing += player.spigot().getPing();
+            }
+            avg = onlinePlayers.isEmpty() ? 0 : totalPing / onlinePlayers.size();
+        }
+    }
+
+    static class Counter {
+        int count = 0;
+        @SuppressWarnings({"rawtypes", "SuppressionAnnotation"})
+        static Function LOADER = new LoadingMap.Feeder<Counter>() {
+            @Override
+            public Counter apply() {
+                return new Counter();
+            }
+        };
+        public int increment() {
+            return ++count;
+        }
+        public int count() {
+            return count;
+        }
+    }
+}
diff --git a/src/main/java/co/aikar/timings/TimingHistoryEntry.java b/src/main/java/co/aikar/timings/TimingHistoryEntry.java
new file mode 100644
index 0000000..2bbe12a
--- /dev/null
+++ b/src/main/java/co/aikar/timings/TimingHistoryEntry.java
@@ -0,0 +1,59 @@
+/*
+ * This file is licensed under the MIT License (MIT).
+ *
+ * Copyright (c) 2014 Daniel Ennis <http://aikar.co>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+package co.aikar.timings;
+
+import com.google.common.base.Function;
+
+import java.util.List;
+
+import static org.spigotmc.util.JSONUtil.toArrayMapper;
+
+class TimingHistoryEntry {
+    final TimingData data;
+    final TimingData[] children;
+
+    TimingHistoryEntry(TimingHandler handler) {
+        this.data = handler.record.clone();
+        children = new TimingData[handler.children.size()];
+        int i = 0;
+        for (TimingData child : handler.children.valueCollection()) {
+            children[i++] = child.clone();
+        }
+    }
+
+    List export() {
+        List result = data.export();
+        if (children.length > 0) {
+            result.add(
+                toArrayMapper(children, new Function<TimingData, Object>() {
+                    @Override
+                    public Object apply(TimingData child) {
+                        return child.export();
+                    }
+                })
+            );
+        }
+        return result;
+    }
+}
diff --git a/src/main/java/co/aikar/timings/TimingIdentifier.java b/src/main/java/co/aikar/timings/TimingIdentifier.java
new file mode 100644
index 0000000..3158610
--- /dev/null
+++ b/src/main/java/co/aikar/timings/TimingIdentifier.java
@@ -0,0 +1,102 @@
+/*
+ * This file is licensed under the MIT License (MIT).
+ *
+ * Copyright (c) 2014 Daniel Ennis <http://aikar.co>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+package co.aikar.timings;
+
+import com.google.common.base.Function;
+import org.spigotmc.util.LoadingMap;
+import org.spigotmc.util.MRUMapCache;
+
+import java.util.ArrayDeque;
+import java.util.Map;
+
+/**
+ * Used as a basis for fast HashMap key comparisons for the Timing Map.
+ * <p/>
+ * This class uses interned strings giving us the ability to do an identity check instead of equals() on the strings
+ */
+final class TimingIdentifier {
+    /**
+     * Holds all groups. Autoloads on request for a group by name.
+     */
+    static final Map<String, TimingGroup> GROUP_MAP = MRUMapCache.of(
+        LoadingMap.newIdentityHashMap(new Function<String, TimingGroup>() {
+            @Override
+            public TimingGroup apply(String group) {
+                return new TimingGroup(group);
+            }
+        }, 64)
+    );
+    static final TimingGroup DEFAULT_GROUP = getGroup("Minecraft");
+    final String group;
+    final String name;
+    final TimingHandler groupHandler;
+    final boolean protect;
+    private final int hashCode;
+
+    TimingIdentifier(String group, String name, Timing groupHandler, boolean protect) {
+        this.group = group != null ? group.intern() : DEFAULT_GROUP.name;
+        this.name = name.intern();
+        this.groupHandler = groupHandler != null ? groupHandler.getTimingHandler() : null;
+        this.protect = protect;
+        this.hashCode = (31 * this.group.hashCode()) + this.name.hashCode();
+    }
+
+    static TimingGroup getGroup(String groupName) {
+        if (groupName == null) {
+            return DEFAULT_GROUP;
+        }
+
+        return GROUP_MAP.get(groupName.intern());
+    }
+
+    // We are using .intern() on the strings so it is guaranteed to be an identity comparison.
+    @SuppressWarnings("StringEquality")
+    @Override
+    public boolean equals(Object o) {
+        if (o == null) {
+            return false;
+        }
+
+        TimingIdentifier that = (TimingIdentifier) o;
+        return group == that.group && name == that.name;
+    }
+
+    @Override
+    public int hashCode() {
+        return hashCode;
+    }
+
+    static class TimingGroup {
+
+        private static int idPool = 1;
+        final int id = idPool++;
+
+        final String name;
+        ArrayDeque<TimingHandler> handlers = new ArrayDeque<TimingHandler>(64);
+
+        private TimingGroup(String name) {
+            this.name = name;
+        }
+    }
+}
diff --git a/src/main/java/co/aikar/timings/Timings.java b/src/main/java/co/aikar/timings/Timings.java
new file mode 100644
index 0000000..e51e232
--- /dev/null
+++ b/src/main/java/co/aikar/timings/Timings.java
@@ -0,0 +1,273 @@
+/*
+ * This file is licensed under the MIT License (MIT).
+ *
+ * Copyright (c) 2014 Daniel Ennis <http://aikar.co>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+package co.aikar.timings;
+
+import com.google.common.base.Preconditions;
+import com.google.common.collect.EvictingQueue;
+import org.bukkit.Bukkit;
+import org.bukkit.command.CommandSender;
+import org.bukkit.plugin.Plugin;
+
+import java.util.Queue;
+import java.util.logging.Level;
+
+@SuppressWarnings("UnusedDeclaration")
+public final class Timings {
+
+    private static final int MAX_HISTORY_FRAMES = 12;
+    public static final Timing NULL_HANDLER = new NullTimingHandler();
+    static boolean timingsEnabled = false;
+    static boolean verboseEnabled = false;
+    private static int historyInterval = -1;
+    private static int historyLength = -1;
+
+    private Timings() {}
+
+    /**
+     * Returns a Timing for a plugin corresponding to a name.
+     *
+     * @param plugin Plugin to own the Timing
+     * @param name   Name of Timing
+     * @return Handler
+     */
+    public static Timing of(Plugin plugin, String name) {
+        Timing pluginHandler = null;
+        if (plugin != null) {
+            pluginHandler = ofSafe(plugin.getName(), "Combined Total", TimingsManager.PLUGIN_GROUP_HANDLER);
+        }
+        return of(plugin, name, pluginHandler);
+    }
+
+    /**
+     * Returns a handler that has a groupHandler timer handler. Parent timers should not have their
+     * start/stop methods called directly, as the children will call it for you.
+     * <p/>
+     * Parent Timers are used to group multiple subsections togethers and get a summary of them combined
+     * Parent Handler can not be changed after first call
+     *
+     * @param plugin       Plugin to own the Timing
+     * @param name         Name of Timing
+     * @param groupHandler Parent handler to mirror .start/stop calls to
+     * @return Timing Handler
+     */
+    public static Timing of(Plugin plugin, String name, Timing groupHandler) {
+        Preconditions.checkNotNull(plugin, "Plugin can not be null");
+        return TimingsManager.getHandler(plugin.getName(), name, groupHandler, true);
+    }
+
+    /**
+     * Returns a Timing object after starting it, useful for Java7 try-with-resources.
+     *
+     * try (Timing ignored = Timings.ofStart(plugin, someName)) {
+     * // timed section
+     * }
+     *
+     * @param plugin Plugin to own the Timing
+     * @param name   Name of Timing
+     * @return Timing Handler
+     */
+    public static Timing ofStart(Plugin plugin, String name) {
+        return ofStart(plugin, name, null);
+    }
+
+    /**
+     * Returns a Timing object after starting it, useful for Java7 try-with-resources.
+     *
+     * try (Timing ignored = Timings.ofStart(plugin, someName, groupHandler)) {
+     * // timed section
+     * }
+     *
+     * @param plugin       Plugin to own the Timing
+     * @param name         Name of Timing
+     * @param groupHandler Parent handler to mirror .start/stop calls to
+     * @return Timing Handler
+     */
+    public static Timing ofStart(Plugin plugin, String name, Timing groupHandler) {
+        Timing timing = of(plugin, name, groupHandler);
+        timing.startTimingIfSync();
+        return timing;
+    }
+
+    /**
+     * Gets whether or not the Spigot Timings system is enabled
+     *
+     * @return Enabled or not
+     */
+    public static boolean isTimingsEnabled() {
+        return timingsEnabled;
+    }
+
+    /**
+     * Sets whether or not the Spigot Timings system should be enabled
+     * <p/>
+     * Calling this will reset timing data.
+     *
+     * @param enabled Should timings be reported
+     */
+    public static void setTimingsEnabled(boolean enabled) {
+        timingsEnabled = enabled;
+        reset();
+    }
+
+    /**
+     * Gets whether or not the Verbose level of timings is enabled.
+     * <p/>
+     * When Verbose is disabled, high-frequency timings will not be available
+     *
+     * @return Enabled or not
+     */
+    public static boolean isVerboseTimingsEnabled() {
+        return timingsEnabled;
+    }
+
+    /**
+     * Sets whether or not the Timings should monitor at Verbose level.
+     * <p/>
+     * When Verbose is disabled, high-frequency timings will not be available.
+     * Calling this will reset timing data.
+     *
+     * @param enabled Should high-frequency timings be reported
+     */
+    public static void setVerboseTimingsEnabled(boolean enabled) {
+        verboseEnabled = enabled;
+        TimingsManager.needsRecheckEnabled = true;
+    }
+
+    /**
+     * Gets the interval between Timing History report generation.
+     * <p/>
+     * Defaults to 5 minutes (6000 ticks)
+     *
+     * @return Interval in ticks
+     */
+    public static int getHistoryInterval() {
+        return historyInterval;
+    }
+
+    /**
+     * Sets the interval between Timing History report generations.
+     * <p/>
+     * Defaults to 5 minutes (6000 ticks)
+     *
+     * This will recheck your history length, so lowering this value will lower your
+     * history length if you need more than 60 history windows.
+     *
+     * @param interval Interval in ticks
+     */
+    public static void setHistoryInterval(int interval) {
+        historyInterval = Math.max(20*60, interval);
+        // Recheck the history length with the new Interval
+        if (historyLength != -1) {
+            setHistoryLength(historyLength);
+        }
+    }
+
+    /**
+     * Gets how long in ticks Timings history is kept for the server.
+     *
+     * Defaults to 1 hour (72000 ticks)
+     *
+     * @return Duration in Ticks
+     */
+    public static int getHistoryLength() {
+        return historyLength;
+    }
+
+    /**
+     * Sets how long Timing History reports are kept for the server.
+     *
+     * Defaults to 1 hours(72000 ticks)
+     *
+     * This value is capped at a maximum of getHistoryInterval() * MAX_HISTORY_FRAMES (12)
+     *
+     * Will not reset Timing Data but may truncate old history if the new length is less than old length.
+     *
+     * @param length Duration in ticks
+     */
+    public static void setHistoryLength(int length) {
+        // Cap at 12 History Frames, 1 hour at 5 minute frames.
+        int maxLength = historyInterval * MAX_HISTORY_FRAMES;
+        // For special cases of servers with special permission to bypass the max.
+        // This max helps keep data file sizes reasonable for processing on Aikar's Timing parser side.
+        // Setting this will not help you bypass the max unless Aikar has added an exception on the API side.
+        if (System.getProperty("timings.bypassMax") != null) {
+            maxLength = Integer.MAX_VALUE;
+        }
+        historyLength = Math.max(Math.min(maxLength, length), historyInterval);
+        Queue<TimingHistory> oldQueue = TimingsManager.HISTORY;
+        int frames = (getHistoryLength() / getHistoryInterval());
+        if (length > maxLength) {
+            Bukkit.getLogger().log(Level.WARNING, "Timings Length too high. Requested " + length + ", max is " + maxLength + ". To get longer history, you must increase your interval. Set Interval to " + Math.ceil(length / MAX_HISTORY_FRAMES) + " to achieve this length.");
+        }
+        TimingsManager.HISTORY = EvictingQueue.create(frames);
+        TimingsManager.HISTORY.addAll(oldQueue);
+    }
+
+    /**
+     * Resets all Timing Data
+     */
+    public static void reset() {
+        TimingsManager.reset();
+    }
+
+    /**
+     * Generates a report and sends it to the specified command sender.
+     *
+     * If sender is null, ConsoleCommandSender will be used.
+     * @param sender
+     */
+    public static void generateReport(CommandSender sender) {
+        if (sender == null) {
+            sender = Bukkit.getConsoleSender();
+        }
+        TimingsExport.reportTimings(sender);
+    }
+
+    /*
+    =================
+    Protected API: These are for internal use only in Bukkit/CraftBukkit
+    These do not have isPrimaryThread() checks in the startTiming/stopTiming
+    =================
+    */
+
+    static TimingHandler ofSafe(String name) {
+        return ofSafe(null, name, null);
+    }
+
+    static Timing ofSafe(Plugin plugin, String name) {
+        Timing pluginHandler = null;
+        if (plugin != null) {
+            pluginHandler = ofSafe(plugin.getName(), "Combined Total", TimingsManager.PLUGIN_GROUP_HANDLER);
+        }
+        return ofSafe(plugin != null ? plugin.getName() : "Minecraft - Invalid Plugin", name, pluginHandler);
+    }
+
+    static TimingHandler ofSafe(String name, Timing groupHandler) {
+        return ofSafe(null, name, groupHandler);
+    }
+
+    static TimingHandler ofSafe(String groupName, String name, Timing groupHandler) {
+        return TimingsManager.getHandler(groupName, name, groupHandler, false);
+    }
+}
diff --git a/src/main/java/co/aikar/timings/TimingsCommand.java b/src/main/java/co/aikar/timings/TimingsCommand.java
new file mode 100644
index 0000000..3dba3aa
--- /dev/null
+++ b/src/main/java/co/aikar/timings/TimingsCommand.java
@@ -0,0 +1,110 @@
+/*
+ * This file is licensed under the MIT License (MIT).
+ *
+ * Copyright (c) 2014 Daniel Ennis <http://aikar.co>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+package co.aikar.timings;
+
+import com.google.common.collect.ImmutableList;
+import org.apache.commons.lang.Validate;
+import org.bukkit.ChatColor;
+import org.bukkit.command.CommandSender;
+import org.bukkit.command.defaults.BukkitCommand;
+import org.bukkit.util.StringUtil;
+
+import java.util.ArrayList;
+import java.util.List;
+
+
+public class TimingsCommand extends BukkitCommand {
+    public static final List<String> TIMINGS_SUBCOMMANDS = ImmutableList.of("report", "reset", "on", "off", "paste", "verbon", "verboff");
+
+    public TimingsCommand(String name) {
+        super(name);
+        this.description = "Manages Spigot Timings data to see performance of the server.";
+        this.usageMessage = "/timings <reset|report|on|off|verbon|verboff>";
+        this.setPermission("bukkit.command.timings");
+    }
+
+    @Override
+    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
+        if (!testPermission(sender)) {
+            return true;
+        }
+        if (args.length < 1) {
+            sender.sendMessage(ChatColor.RED + "Usage: " + usageMessage);
+            return true;
+        }
+        final String arg = args[0];
+        if ("on".equalsIgnoreCase(arg)) {
+            Timings.setTimingsEnabled(true);
+            sender.sendMessage("Enabled Timings & Reset");
+            return true;
+        } else if ("off".equalsIgnoreCase(arg)) {
+            Timings.setTimingsEnabled(false);
+            sender.sendMessage("Disabled Timings");
+            return true;
+        }
+
+        if (!Timings.isTimingsEnabled()) {
+            sender.sendMessage("Please enable timings by typing /timings on");
+            return true;
+        }
+        if ("verbon".equalsIgnoreCase(arg)) {
+            Timings.setVerboseTimingsEnabled(true);
+            sender.sendMessage("Enabled Verbose Timings");
+            return true;
+        } else if ("verboff".equalsIgnoreCase(arg)) {
+            Timings.setVerboseTimingsEnabled(false);
+            sender.sendMessage("Disabled Verbose Timings");
+            return true;
+        } else if ("reset".equalsIgnoreCase(arg)) {
+            TimingsManager.reset();
+            sender.sendMessage("Timings reset");
+        } else if ("cost".equals(arg)) {
+            sender.sendMessage("Timings cost: " + TimingsExport.getCost());
+        } else  if (
+            "paste".equalsIgnoreCase(arg) ||
+                "report".equalsIgnoreCase(arg) ||
+                "get".equalsIgnoreCase(arg) ||
+                "merged".equalsIgnoreCase(arg) ||
+                "separate".equalsIgnoreCase(arg)
+            ) {
+            TimingsExport.reportTimings(sender);
+        } else {
+            sender.sendMessage(ChatColor.RED + "Usage: " + usageMessage);
+        }
+        return true;
+    }
+
+    @Override
+    public List<String> tabComplete(CommandSender sender, String alias, String[] args) {
+        Validate.notNull(sender, "Sender cannot be null");
+        Validate.notNull(args, "Arguments cannot be null");
+        Validate.notNull(alias, "Alias cannot be null");
+
+        if (args.length == 1) {
+            return StringUtil.copyPartialMatches(args[0], TIMINGS_SUBCOMMANDS,
+                new ArrayList<String>(TIMINGS_SUBCOMMANDS.size()));
+        }
+        return ImmutableList.of();
+    }
+}
diff --git a/src/main/java/co/aikar/timings/TimingsExport.java b/src/main/java/co/aikar/timings/TimingsExport.java
new file mode 100644
index 0000000..db0b078
--- /dev/null
+++ b/src/main/java/co/aikar/timings/TimingsExport.java
@@ -0,0 +1,371 @@
+/*
+ * This file is licensed under the MIT License (MIT).
+ *
+ * Copyright (c) 2014 Daniel Ennis <http://aikar.co>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+package co.aikar.timings;
+
+import com.google.common.base.Function;
+import com.google.common.collect.Sets;
+import org.apache.commons.lang.StringUtils;
+import org.bukkit.Bukkit;
+import org.bukkit.ChatColor;
+import org.bukkit.Material;
+import org.bukkit.command.CommandSender;
+import org.bukkit.command.ConsoleCommandSender;
+import org.bukkit.command.RemoteConsoleCommandSender;
+import org.bukkit.configuration.ConfigurationSection;
+import org.bukkit.configuration.MemorySection;
+import org.bukkit.entity.EntityType;
+import org.bukkit.plugin.Plugin;
+import org.json.simple.JSONObject;
+import org.json.simple.JSONValue;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.lang.management.GarbageCollectorMXBean;
+import java.lang.management.ManagementFactory;
+import java.lang.management.RuntimeMXBean;
+import java.net.HttpURLConnection;
+import java.net.InetAddress;
+import java.net.URL;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.logging.Level;
+import java.util.zip.GZIPOutputStream;
+
+import static co.aikar.timings.TimingsManager.HISTORY;
+import static org.spigotmc.util.JSONUtil.*;
+
+@SuppressWarnings({"rawtypes", "SuppressionAnnotation"})
+class TimingsExport extends Thread {
+
+    private final CommandSender sender;
+    private final Map out;
+    private final TimingHistory[] history;
+
+    TimingsExport(CommandSender sender, Map out, TimingHistory[] history) {
+        super("Timings paste thread");
+        this.sender = sender;
+        this.out = out;
+        this.history = history;
+    }
+
+
+    /**
+     * Builds an XML report of the timings to be uploaded for parsing.
+     *
+     * @param sender Who to report to
+     */
+    static void reportTimings(CommandSender sender) {
+        Map parent = createObject(
+            // Get some basic system details about the server
+            pair("version", Bukkit.getVersion()),
+            pair("maxplayers", Bukkit.getMaxPlayers()),
+            pair("start", TimingsManager.timingStart / 1000),
+            pair("end", System.currentTimeMillis() / 1000),
+            pair("sampletime", (System.currentTimeMillis() - TimingsManager.timingStart) / 1000)
+        );
+        if (!TimingsManager.privacy) {
+            appendObjectData(parent,
+                pair("server", Bukkit.getServerName()),
+                pair("motd", Bukkit.getServer().getMotd()),
+                pair("online-mode", Bukkit.getServer().getOnlineMode()),
+                pair("icon", Bukkit.getServer().getServerIcon().getData())
+            );
+        }
+
+        final Runtime runtime = Runtime.getRuntime();
+        RuntimeMXBean runtimeBean = ManagementFactory.getRuntimeMXBean();
+
+        parent.put("system", createObject(
+                pair("timingcost", getCost()),
+                pair("name", System.getProperty("os.name")),
+                pair("version", System.getProperty("os.version")),
+                pair("jvmversion", System.getProperty("java.version")),
+                pair("arch", System.getProperty("os.arch")),
+                pair("maxmem", runtime.maxMemory()),
+                pair("cpu", runtime.availableProcessors()),
+                pair("runtime", ManagementFactory.getRuntimeMXBean().getUptime()),
+                pair("flags", StringUtils.join(runtimeBean.getInputArguments(), " ")),
+                pair("gc", toObjectMapper(ManagementFactory.getGarbageCollectorMXBeans(), new Function<GarbageCollectorMXBean, JSONPair>() {
+                    @Override
+                    public JSONPair apply(GarbageCollectorMXBean input) {
+                        return pair(input.getName(), toArray(input.getCollectionCount(), input.getCollectionTime()));
+                    }
+                }))
+            )
+        );
+
+        Set<Material> tileEntityTypeSet = Sets.newHashSet();
+        Set<EntityType> entityTypeSet = Sets.newHashSet();
+
+        int size = HISTORY.size();
+        TimingHistory[] history = new TimingHistory[size + 1];
+        int i = 0;
+        for (TimingHistory timingHistory : HISTORY) {
+            tileEntityTypeSet.addAll(timingHistory.tileEntityTypeSet);
+            entityTypeSet.addAll(timingHistory.entityTypeSet);
+            history[i++] = timingHistory;
+        }
+
+        history[i] = new TimingHistory(); // Current snapshot
+        tileEntityTypeSet.addAll(history[i].tileEntityTypeSet);
+        entityTypeSet.addAll(history[i].entityTypeSet);
+
+
+        Map handlers = createObject();
+        for (TimingIdentifier.TimingGroup group : TimingIdentifier.GROUP_MAP.values()) {
+            for (TimingHandler id : group.handlers) {
+                if (!id.timed && !id.isSpecial()) {
+                    continue;
+                }
+                handlers.put(id.id, toArray(
+                    group.id,
+                    id.name
+                ));
+            }
+        }
+
+        parent.put("idmap", createObject(
+            pair("groups", toObjectMapper(
+                TimingIdentifier.GROUP_MAP.values(), new Function<TimingIdentifier.TimingGroup, JSONPair>() {
+                @Override
+                public JSONPair apply(TimingIdentifier.TimingGroup group) {
+                    return pair(group.id, group.name);
+                }
+            })),
+            pair("handlers", handlers),
+            pair("worlds", toObjectMapper(TimingHistory.worldMap.entrySet(), new Function<Map.Entry<String, Integer>, JSONPair>() {
+                    @Override
+                    public JSONPair apply(Map.Entry<String, Integer> input) {
+                        return pair(input.getValue(), input.getKey());
+                    }
+                })),
+            pair("tileentity",
+                toObjectMapper(tileEntityTypeSet, new Function<Material, JSONPair>() {
+                    @Override
+                    public JSONPair apply(Material input) {
+                        return pair(input.getId(), input.name());
+                    }
+                })),
+            pair("entity",
+                toObjectMapper(entityTypeSet, new Function<EntityType, JSONPair>() {
+                    @Override
+                    public JSONPair apply(EntityType input) {
+                        return pair(input.getTypeId(), input.name());
+                    }
+                }))
+        ));
+
+        // Information about loaded plugins
+
+        parent.put("plugins", toObjectMapper(Bukkit.getPluginManager().getPlugins(),
+            new Function<Plugin, JSONPair>() {
+                @Override
+                public JSONPair apply(Plugin plugin) {
+                    return pair(plugin.getName(), createObject(
+                        pair("version", plugin.getDescription().getVersion()),
+                        pair("description", String.valueOf(plugin.getDescription().getDescription()).trim()),
+                        pair("website", plugin.getDescription().getWebsite()),
+                        pair("authors", StringUtils.join(plugin.getDescription().getAuthors(), ", "))
+                    ));
+                }
+            }));
+
+
+
+        // Information on the users Config
+
+        parent.put("config", createObject(
+            pair("spigot", mapAsJSON(Bukkit.spigot().getSpigotConfig(), null)),
+            pair("bukkit", mapAsJSON(Bukkit.spigot().getBukkitConfig(), null))
+        ));
+
+        new TimingsExport(sender, parent, history).start();
+    }
+
+    static long getCost() {
+        // Benchmark the users System.nanotime() for cost basis
+        int passes = 500000;
+        TimingHandler SAMPLER1 = Timings.ofSafe("Timings Sampler 1");
+        TimingHandler SAMPLER2 = Timings.ofSafe("Timings Sampler 2");
+        TimingHandler SAMPLER3 = Timings.ofSafe("Timings Sampler 3");
+        TimingHandler SAMPLER4 = Timings.ofSafe("Timings Sampler 4");
+        TimingHandler SAMPLER5 = Timings.ofSafe("Timings Sampler 5");
+        TimingHandler SAMPLER6 = Timings.ofSafe("Timings Sampler 6");
+
+        long start = System.nanoTime();
+        for (int i = 0; i < passes; i++) {
+            SAMPLER1.startTiming();
+            SAMPLER2.startTiming();
+            SAMPLER3.startTiming();
+            SAMPLER3.stopTiming();
+            SAMPLER4.startTiming();
+            SAMPLER5.startTiming();
+            SAMPLER6.startTiming();
+            SAMPLER6.stopTiming();
+            SAMPLER5.stopTiming();
+            SAMPLER4.stopTiming();
+            SAMPLER2.stopTiming();
+            SAMPLER1.stopTiming();
+        }
+        long timingsCost = (System.nanoTime() - start) / passes / 6;
+        SAMPLER1.reset(true);
+        SAMPLER2.reset(true);
+        SAMPLER3.reset(true);
+        SAMPLER4.reset(true);
+        SAMPLER5.reset(true);
+        SAMPLER6.reset(true);
+        return timingsCost;
+    }
+
+    private static JSONObject mapAsJSON(ConfigurationSection config, String parentKey) {
+
+        JSONObject object = new JSONObject();
+        for (String key : config.getKeys(false)) {
+            String fullKey = (parentKey != null ? parentKey + "." + key : key);
+            if (fullKey.equals("database") || fullKey.equals("settings.bungeecord-addresses") || TimingsManager.hiddenConfigs.contains(fullKey)) {
+                continue;
+            }
+            final Object val = config.get(key);
+
+            object.put(key, valAsJSON(val, fullKey));
+        }
+        return object;
+    }
+
+    private static Object valAsJSON(Object val, final String parentKey) {
+        if (!(val instanceof MemorySection)) {
+            if (val instanceof List) {
+                Iterable<Object> v = (Iterable<Object>) val;
+                return toArrayMapper(v, new Function<Object, Object>() {
+                    @Override
+                    public Object apply(Object input) {
+                        return valAsJSON(input, parentKey);
+                    }
+                });
+            } else {
+                return val.toString();
+            }
+        } else {
+            return mapAsJSON((ConfigurationSection) val, parentKey);
+        }
+    }
+
+    @SuppressWarnings("CallToThreadRun")
+    @Override
+    public synchronized void start() {
+        if (sender instanceof RemoteConsoleCommandSender) {
+            sender.sendMessage(ChatColor.RED + "Warning: Timings report done over RCON will cause lag spikes.");
+            sender.sendMessage(ChatColor.RED + "You should use " + ChatColor.YELLOW +
+                "/timings report" + ChatColor.RED + " in game or console.");
+            run();
+        } else {
+            super.start();
+        }
+    }
+
+    @Override
+    public void run() {
+        sender.sendMessage(ChatColor.GREEN + "Preparing Timings Report...");
+
+
+        out.put("data", toArrayMapper(history, new Function<TimingHistory, Object>() {
+            @Override
+            public Object apply(TimingHistory input) {
+                return input.export();
+            }
+        }));
+
+
+        String response = null;
+        try {
+            HttpURLConnection con = (HttpURLConnection) new URL("http://timings.aikar.co/post").openConnection();
+            con.setDoOutput(true);
+            con.setRequestProperty("User-Agent", "Spigot/" + Bukkit.getServerName() + "/" + InetAddress.getLocalHost().getHostName());
+            con.setRequestMethod("POST");
+            con.setInstanceFollowRedirects(false);
+
+            OutputStream request = new GZIPOutputStream(con.getOutputStream()) {{
+                this.def.setLevel(7);
+            }};
+
+            request.write(JSONValue.toJSONString(out).getBytes("UTF-8"));
+            request.close();
+
+            response = getResponse(con);
+
+            if (con.getResponseCode() != 302) {
+                sender.sendMessage(
+                    ChatColor.RED + "Upload Error: " + con.getResponseCode() + ": " + con.getResponseMessage());
+                sender.sendMessage(ChatColor.RED + "Check your logs for more information");
+                if (response != null) {
+                    Bukkit.getLogger().log(Level.SEVERE, response);
+                }
+                return;
+            }
+
+            String location = con.getHeaderField("Location");
+            sender.sendMessage(ChatColor.GREEN + "View Timings Report: " + location);
+            if (!(sender instanceof ConsoleCommandSender)) {
+                Bukkit.getLogger().log(Level.INFO, "View Timings Report: " + location);
+            }
+
+            if (response != null && !response.isEmpty()) {
+                Bukkit.getLogger().log(Level.INFO, "Timing Response: " + response);
+            }
+        } catch (IOException ex) {
+            sender.sendMessage(ChatColor.RED + "Error uploading timings, check your logs for more information");
+            if (response != null) {
+                Bukkit.getLogger().log(Level.SEVERE, response);
+            }
+            Bukkit.getLogger().log(Level.SEVERE, "Could not paste timings", ex);
+        }
+    }
+
+    private String getResponse(HttpURLConnection con) throws IOException {
+        InputStream is = null;
+        try {
+            is = con.getInputStream();
+            ByteArrayOutputStream bos = new ByteArrayOutputStream();
+
+            byte[] b = new byte[1024];
+            int bytesRead;
+            while ((bytesRead = is.read(b)) != -1) {
+                bos.write(b, 0, bytesRead);
+            }
+            return bos.toString();
+
+        } catch (IOException ex) {
+            sender.sendMessage(ChatColor.RED + "Error uploading timings, check your logs for more information");
+            Bukkit.getLogger().log(Level.WARNING, con.getResponseMessage(), ex);
+            return null;
+        } finally {
+            if (is != null) {
+                is.close();
+            }
+        }
+    }
+}
diff --git a/src/main/java/co/aikar/timings/TimingsManager.java b/src/main/java/co/aikar/timings/TimingsManager.java
new file mode 100644
index 0000000..f39dbe0
--- /dev/null
+++ b/src/main/java/co/aikar/timings/TimingsManager.java
@@ -0,0 +1,194 @@
+/*
+ * This file is licensed under the MIT License (MIT).
+ *
+ * Copyright (c) 2014 Daniel Ennis <http://aikar.co>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+package co.aikar.timings;
+
+import com.google.common.base.Function;
+import com.google.common.collect.EvictingQueue;
+import org.bukkit.Bukkit;
+import org.bukkit.Server;
+import org.bukkit.command.Command;
+import org.bukkit.plugin.Plugin;
+import org.bukkit.plugin.java.PluginClassLoader;
+import org.spigotmc.util.LoadingMap;
+
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+import java.util.logging.Level;
+
+public final class TimingsManager {
+    static final Map<TimingIdentifier, TimingHandler> TIMING_MAP =
+        Collections.synchronizedMap(LoadingMap.newHashMap(
+            new Function<TimingIdentifier, TimingHandler>() {
+                @Override
+                public TimingHandler apply(TimingIdentifier id) {
+                    return (id.protect ?
+                        new UnsafeTimingHandler(id) :
+                        new TimingHandler(id)
+                    );
+                }
+            },
+            256, .5F
+        ));
+    public static final FullServerTickHandler FULL_SERVER_TICK = new FullServerTickHandler();
+    public static final TimingHandler TIMINGS_TICK = Timings.ofSafe("Timings Tick", FULL_SERVER_TICK);
+    public static final Timing PLUGIN_GROUP_HANDLER = Timings.ofSafe("Plugins");
+    public static List<String> hiddenConfigs = new ArrayList<String>();
+    public static boolean privacy = false;
+
+    static final Collection<TimingHandler> HANDLERS = new ArrayDeque<TimingHandler>();
+    static final ArrayDeque<TimingHistory.MinuteReport> MINUTE_REPORTS = new ArrayDeque<TimingHistory.MinuteReport>();
+
+    static EvictingQueue<TimingHistory> HISTORY = EvictingQueue.create(12);
+    static TimingHandler CURRENT;
+    static long timingStart = 0;
+    static long historyStart = 0;
+    static boolean needsFullReset = false;
+    static boolean needsRecheckEnabled = false;
+
+    private TimingsManager() {}
+
+    /**
+     * Resets all timing data on the next tick
+     */
+    static void reset() {
+        needsFullReset = true;
+    }
+
+    /**
+     * Ticked every tick by CraftBukkit to count the number of times a timer
+     * caused TPS loss.
+     */
+    static void tick() {
+        if (Timings.timingsEnabled) {
+            boolean violated = FULL_SERVER_TICK.isViolated();
+
+            for (TimingHandler handler : HANDLERS) {
+                if (handler.isSpecial()) {
+                    // We manually call this
+                    continue;
+                }
+                handler.processTick(violated);
+            }
+
+            TimingHistory.playerTicks += Bukkit.getOnlinePlayers().size();
+            TimingHistory.timedTicks++;
+            // Generate TPS/Ping/Tick reports every minute
+        }
+    }
+    static void stopServer() {
+        Timings.timingsEnabled = false;
+        recheckEnabled();
+    }
+    static void recheckEnabled() {
+        synchronized (TIMING_MAP) {
+            for (TimingHandler timings : TIMING_MAP.values()) {
+                timings.checkEnabled();
+            }
+        }
+        needsRecheckEnabled = false;
+    }
+    static void resetTimings() {
+        if (needsFullReset) {
+            // Full resets need to re-check every handlers enabled state
+            // Timing map can be modified from async so we must sync on it.
+            synchronized (TIMING_MAP) {
+                for (TimingHandler timings : TIMING_MAP.values()) {
+                    timings.reset(true);
+                }
+            }
+            Bukkit.getLogger().log(Level.INFO, "Timings Reset");
+            HISTORY.clear();
+            needsFullReset = false;
+            needsRecheckEnabled = false;
+            timingStart = System.currentTimeMillis();
+        } else {
+            // Soft resets only need to act on timings that have done something
+            // Handlers can only be modified on main thread.
+            for (TimingHandler timings : HANDLERS) {
+                timings.reset(false);
+            }
+        }
+
+        HANDLERS.clear();
+        MINUTE_REPORTS.clear();
+
+        TimingHistory.resetTicks(true);
+        historyStart = System.currentTimeMillis();
+    }
+
+    static TimingHandler getHandler(String group, String name, Timing parent, boolean protect) {
+        return TIMING_MAP.get(new TimingIdentifier(group, name, parent, protect));
+    }
+
+
+    /**
+     * Due to access restrictions, we need a helper method to get a Command TimingHandler with String group
+     * <p/>
+     * Plugins should never call this
+     *
+     * @param pluginName Plugin this command is associated with
+     * @param command    Command to get timings for
+     * @return TimingHandler
+     */
+    public static Timing getCommandTiming(String pluginName, Command command) {
+        Plugin plugin = null;
+        final Server server = Bukkit.getServer();
+        if (!("minecraft".equals(pluginName) || "bukkit".equals(pluginName) || "Spigot".equals(pluginName) ||
+            server == null)) {
+            plugin = server.getPluginManager().getPlugin(pluginName);
+            if (plugin == null) {
+                // Plugin is passing custom fallback prefix, try to look up by class loader
+                plugin = getPluginByClassloader(command.getClass());
+            }
+        }
+        if (plugin == null) {
+            return Timings.ofSafe("Command: " + pluginName + ":" + command.getTimingName());
+        }
+
+        return Timings.ofSafe(plugin, "Command: " + pluginName + ":" + command.getTimingName());
+    }
+
+    /**
+     * Looks up the class loader for the specified class, and if it is a PluginClassLoader, return the
+     * Plugin that created this class.
+     *
+     * @param clazz Class to check
+     * @return Plugin if created by a plugin
+     */
+    public static Plugin getPluginByClassloader(Class<?> clazz) {
+        if (clazz == null) {
+            return null;
+        }
+        final ClassLoader classLoader = clazz.getClassLoader();
+        if (classLoader instanceof PluginClassLoader) {
+            PluginClassLoader pluginClassLoader = (PluginClassLoader) classLoader;
+            return pluginClassLoader.getPlugin();
+        }
+        return null;
+    }
+}
diff --git a/src/main/java/co/aikar/timings/UnsafeTimingHandler.java b/src/main/java/co/aikar/timings/UnsafeTimingHandler.java
new file mode 100644
index 0000000..e3b0ed8
--- /dev/null
+++ b/src/main/java/co/aikar/timings/UnsafeTimingHandler.java
@@ -0,0 +1,51 @@
+/*
+ * This file is licensed under the MIT License (MIT).
+ *
+ * Copyright (c) 2014 Daniel Ennis <http://aikar.co>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+package co.aikar.timings;
+
+import org.bukkit.Bukkit;
+
+class UnsafeTimingHandler extends TimingHandler {
+
+    UnsafeTimingHandler(TimingIdentifier id) {
+        super(id);
+    }
+
+    private static void checkThread() {
+        if (!Bukkit.isPrimaryThread()) {
+            throw new IllegalStateException("Calling Timings from Async Operation");
+        }
+    }
+
+    @Override
+    public void startTiming() {
+        checkThread();
+        super.startTiming();
+    }
+
+    @Override
+    public void stopTiming() {
+        checkThread();
+        super.stopTiming();
+    }
+}
diff --git a/src/main/java/org/bukkit/command/Command.java b/src/main/java/org/bukkit/command/Command.java
index 535cdd6..548d570 100644
--- a/src/main/java/org/bukkit/command/Command.java
+++ b/src/main/java/org/bukkit/command/Command.java
@@ -31,7 +31,7 @@ public abstract class Command {
     protected String usageMessage;
     private String permission;
     private String permissionMessage;
-    public org.spigotmc.timings.Timing timings; // Spigot
+    public co.aikar.timings.Timing timings; // Spigot
     public String getTimingName() {return getName();} // Spigot
 
     protected Command(String name) {
diff --git a/src/main/java/org/bukkit/command/FormattedCommandAlias.java b/src/main/java/org/bukkit/command/FormattedCommandAlias.java
index ced5511..af72944 100644
--- a/src/main/java/org/bukkit/command/FormattedCommandAlias.java
+++ b/src/main/java/org/bukkit/command/FormattedCommandAlias.java
@@ -16,7 +16,7 @@ public class FormattedCommandAlias extends Command {
 
     public FormattedCommandAlias(String alias, String[] formatStrings) {
         super(alias);
-        timings = org.spigotmc.timings.TimingsManager.getCommandTiming("minecraft", this); // Spigot
+        timings = co.aikar.timings.TimingsManager.getCommandTiming("minecraft", this); // Spigot
         this.formatStrings = formatStrings;
     }
 
diff --git a/src/main/java/org/bukkit/command/SimpleCommandMap.java b/src/main/java/org/bukkit/command/SimpleCommandMap.java
index 0661ffb..f5b62f9 100644
--- a/src/main/java/org/bukkit/command/SimpleCommandMap.java
+++ b/src/main/java/org/bukkit/command/SimpleCommandMap.java
@@ -31,7 +31,7 @@ public class SimpleCommandMap implements CommandMap {
         register("bukkit", new VersionCommand("version"));
         register("bukkit", new ReloadCommand("reload"));
         register("bukkit", new PluginsCommand("plugins"));
-        register("bukkit", new org.spigotmc.timings.TimingsCommand("timings")); // Spigot
+        register("bukkit", new co.aikar.timings.TimingsCommand("timings")); // Spigot
     }
 
     public void setFallbackCommands() {
@@ -60,7 +60,7 @@ public class SimpleCommandMap implements CommandMap {
      * {@inheritDoc}
      */
     public boolean register(String label, String fallbackPrefix, Command command) {
-        command.timings = org.spigotmc.timings.TimingsManager.getCommandTiming(fallbackPrefix, command); // Spigot
+        command.timings = co.aikar.timings.TimingsManager.getCommandTiming(fallbackPrefix, command); // Spigot
         label = label.toLowerCase().trim();
         fallbackPrefix = fallbackPrefix.toLowerCase().trim();
         boolean registered = register(label, command, false, fallbackPrefix);
diff --git a/src/main/java/org/bukkit/plugin/SimplePluginManager.java b/src/main/java/org/bukkit/plugin/SimplePluginManager.java
index d30790c..95b8a6b 100644
--- a/src/main/java/org/bukkit/plugin/SimplePluginManager.java
+++ b/src/main/java/org/bukkit/plugin/SimplePluginManager.java
@@ -556,7 +556,7 @@ public final class SimplePluginManager implements PluginManager {
             throw new IllegalPluginAccessException("Plugin attempted to register " + event + " while not enabled");
         }
 
-        executor = new org.spigotmc.timings.TimedEventExecutor(executor, plugin, null, event); // Spigot
+        executor = new co.aikar.timings.TimedEventExecutor(executor, plugin, null, event); // Spigot
         if (false) { // Spigot - RL handles useTimings check now
             getEventListeners(event).register(new TimedRegisteredListener(listener, executor, priority, plugin, ignoreCancelled));
         } else {
@@ -718,7 +718,7 @@ public final class SimplePluginManager implements PluginManager {
     }
 
     public boolean useTimings() {
-        return org.spigotmc.timings.Timings.isTimingsEnabled(); // Spigot
+        return co.aikar.timings.Timings.isTimingsEnabled(); // Spigot
     }
 
     /**
@@ -727,6 +727,6 @@ public final class SimplePluginManager implements PluginManager {
      * @param use True if per event timing code should be used
      */
     public void useTimings(boolean use) {
-        org.spigotmc.timings.Timings.setTimingsEnabled(use); // Spigot
+        co.aikar.timings.Timings.setTimingsEnabled(use); // Spigot
     }
 }
diff --git a/src/main/java/org/bukkit/plugin/java/JavaPluginLoader.java b/src/main/java/org/bukkit/plugin/java/JavaPluginLoader.java
index d59795b..a5f6cc1 100644
--- a/src/main/java/org/bukkit/plugin/java/JavaPluginLoader.java
+++ b/src/main/java/org/bukkit/plugin/java/JavaPluginLoader.java
@@ -292,7 +292,7 @@ public final class JavaPluginLoader implements PluginLoader {
                 }
             }
 
-            EventExecutor executor = new org.spigotmc.timings.TimedEventExecutor(new EventExecutor() { // Spigot
+            EventExecutor executor = new co.aikar.timings.TimedEventExecutor(new EventExecutor() { // Spigot
                 public void execute(Listener listener, Event event) throws EventException {
                     try {
                         if (!eventClass.isAssignableFrom(event.getClass())) {
diff --git a/src/main/java/org/spigotmc/CustomTimingsHandler.java b/src/main/java/org/spigotmc/CustomTimingsHandler.java
index ed89acc..7e89b97 100644
--- a/src/main/java/org/spigotmc/CustomTimingsHandler.java
+++ b/src/main/java/org/spigotmc/CustomTimingsHandler.java
@@ -26,10 +26,10 @@ package org.spigotmc;
 import org.bukkit.Bukkit;
 import org.bukkit.plugin.AuthorNagException;
 import org.bukkit.plugin.Plugin;
-import org.spigotmc.timings.NullTimingHandler;
-import org.spigotmc.timings.Timing;
-import org.spigotmc.timings.Timings;
-import org.spigotmc.timings.TimingsManager;
+import co.aikar.timings.NullTimingHandler;
+import co.aikar.timings.Timing;
+import co.aikar.timings.Timings;
+import co.aikar.timings.TimingsManager;
 import sun.reflect.Reflection;
 
 import java.lang.reflect.Method;
@@ -41,7 +41,7 @@ import java.util.logging.Level;
  * If you use this, migrate ASAP as this will be removed in the future!
  *
  * @deprecated
- * @see org.spigotmc.timings.Timings#of
+ * @see co.aikar.timings.Timings#of
  */
 @Deprecated
 public final class CustomTimingsHandler {
diff --git a/src/main/java/org/spigotmc/timings/FullServerTickHandler.java b/src/main/java/org/spigotmc/timings/FullServerTickHandler.java
deleted file mode 100644
index 1d3926f..0000000
--- a/src/main/java/org/spigotmc/timings/FullServerTickHandler.java
+++ /dev/null
@@ -1,79 +0,0 @@
-package org.spigotmc.timings;
-
-import static org.spigotmc.timings.TimingsManager.*;
-
-public class FullServerTickHandler extends TimingHandler {
-    static final TimingIdentifier IDENTITY = new TimingIdentifier("Minecraft", "Full Server Tick", null, false);
-    final TimingData minuteData;
-    double avgFreeMemory = -1D;
-    double avgUsedMemory = -1D;
-    FullServerTickHandler() {
-        super(IDENTITY);
-        minuteData = new TimingData(id);
-
-        TIMING_MAP.put(IDENTITY, this);
-    }
-
-    @Override
-    public void startTiming() {
-        if (TimingsManager.needsFullReset) {
-            TimingsManager.resetTimings();
-        } else if (TimingsManager.needsRecheckEnabled) {
-            TimingsManager.recheckEnabled();
-        }
-        super.startTiming();
-    }
-
-    @Override
-    public void stopTiming() {
-        super.stopTiming();
-        if (!enabled) {
-            return;
-        }
-        if (TimingHistory.timedTicks % 20 == 0) {
-            final Runtime runtime = Runtime.getRuntime();
-            double usedMemory = runtime.totalMemory() - runtime.freeMemory();
-            double freeMemory = runtime.maxMemory() - usedMemory;
-            if (this.avgFreeMemory == -1) {
-                this.avgFreeMemory = freeMemory;
-            } else {
-                this.avgFreeMemory = (this.avgFreeMemory * (59 / 60D)) + (freeMemory * (1 / 60D));
-            }
-
-            if (this.avgUsedMemory == -1) {
-                this.avgUsedMemory = usedMemory;
-            } else {
-                this.avgUsedMemory = (this.avgUsedMemory * (59 / 60D)) + (usedMemory * (1 / 60D));
-            }
-        }
-
-        long start = System.nanoTime();
-        TimingsManager.tick();
-        long diff = System.nanoTime() - start;
-        CURRENT = TIMINGS_TICK;
-        TIMINGS_TICK.addDiff(diff);
-        // addDiff for TIMINGS_TICK incremented this, bring it back down to 1 per tick.
-        record.curTickCount--;
-        minuteData.curTickTotal = record.curTickTotal;
-        minuteData.curTickCount = 1;
-        boolean violated = isViolated();
-        minuteData.processTick(violated);
-        TIMINGS_TICK.processTick(violated);
-        processTick(violated);
-
-
-        if (TimingHistory.timedTicks % 1200 == 0) {
-            MINUTE_REPORTS.add(new TimingHistory.MinuteReport());
-            TimingHistory.resetTicks(false);
-            minuteData.reset();
-        }
-        if (TimingHistory.timedTicks % Timings.getHistoryInterval() == 0) {
-            TimingsManager.HISTORY.add(new TimingHistory());
-            TimingsManager.resetTimings();
-        }
-    }
-
-    boolean isViolated() {
-        return record.curTickTotal > 50000000;
-    }
-}
diff --git a/src/main/java/org/spigotmc/timings/NullTimingHandler.java b/src/main/java/org/spigotmc/timings/NullTimingHandler.java
deleted file mode 100644
index 2993971..0000000
--- a/src/main/java/org/spigotmc/timings/NullTimingHandler.java
+++ /dev/null
@@ -1,61 +0,0 @@
-/*
- * This file is licensed under the MIT License (MIT).
- *
- * Copyright (c) 2014 Daniel Ennis <http://aikar.co>
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
- * THE SOFTWARE.
- */
-package org.spigotmc.timings;
-
-public final class NullTimingHandler implements Timing {
-    @Override
-    public void startTiming() {
-
-    }
-
-    @Override
-    public void stopTiming() {
-
-    }
-
-    @Override
-    public void startTimingIfSync() {
-
-    }
-
-    @Override
-    public void stopTimingIfSync() {
-
-    }
-
-    @Override
-    public void abort() {
-
-    }
-
-    @Override
-    public TimingHandler getTimingHandler() {
-        return null;
-    }
-
-    @Override
-    public void close() {
-
-    }
-}
diff --git a/src/main/java/org/spigotmc/timings/TimedEventExecutor.java b/src/main/java/org/spigotmc/timings/TimedEventExecutor.java
deleted file mode 100644
index a704015..0000000
--- a/src/main/java/org/spigotmc/timings/TimedEventExecutor.java
+++ /dev/null
@@ -1,73 +0,0 @@
-/*
- * This file is licensed under the MIT License (MIT).
- *
- * Copyright (c) 2014 Daniel Ennis <http://aikar.co>
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
- * THE SOFTWARE.
- */
-package org.spigotmc.timings;
-
-import org.bukkit.Bukkit;
-import org.bukkit.event.Event;
-import org.bukkit.event.EventException;
-import org.bukkit.event.Listener;
-import org.bukkit.plugin.EventExecutor;
-import org.bukkit.plugin.Plugin;
-
-import java.lang.reflect.Method;
-
-public class TimedEventExecutor implements EventExecutor {
-
-    private final EventExecutor executor;
-    private final Timing timings;
-
-    /**
-     * Wraps an event executor and associates a timing handler to it.
-     *
-     * @param executor
-     * @param plugin
-     * @param method
-     * @param eventClass
-     */
-    public TimedEventExecutor(EventExecutor executor, Plugin plugin, Method method, Class<? extends Event> eventClass) {
-        this.executor = executor;
-        String id;
-
-        if (method == null) {
-            method = executor.getClass().getEnclosingMethod();
-        }
-        id = method.getDeclaringClass().getName();
-
-        final String eventName = eventClass.getSimpleName();
-        boolean verbose = "BlockPhysicsEvent".equals(eventName) || "Drain".equals(eventName) || "Fill".equals(eventName);
-        this.timings = Timings.ofSafe(plugin.getName(), (verbose ? "## " : "") +
-            "Event: " + id + " (" + eventName + ")", null);
-    }
-
-    @Override
-    public void execute(Listener listener, Event event) throws EventException {
-        if (event.isAsynchronous() || !Timings.timingsEnabled || !Bukkit.isPrimaryThread()) {
-            executor.execute(listener, event);
-            return;
-        }
-        timings.startTiming();
-        executor.execute(listener, event);
-        timings.stopTiming();
-    }
-}
diff --git a/src/main/java/org/spigotmc/timings/Timing.java b/src/main/java/org/spigotmc/timings/Timing.java
deleted file mode 100644
index 817aca8..0000000
--- a/src/main/java/org/spigotmc/timings/Timing.java
+++ /dev/null
@@ -1,72 +0,0 @@
-/*
- * This file is licensed under the MIT License (MIT).
- *
- * Copyright (c) 2014 Daniel Ennis <http://aikar.co>
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
- * THE SOFTWARE.
- */
-package org.spigotmc.timings;
-
-/**
- * Provides an ability to time sections of code within the Minecraft Server
- */
-public interface Timing extends AutoCloseable {
-    /**
-     * Starts timing the execution until {@link #stopTiming()} is called.
-     */
-    public void startTiming();
-
-    /**
-     * Stops timing and records the data. Propagates the data up to group handlers.
-     * <p/>
-     * Will automatically be called when this Timing is used with try-with-resources
-     */
-    public void stopTiming();
-
-    /**
-     * Starts timing the execution until {@link #stopTiming()} is called.
-     *
-     * But only if we are on the primary thread.
-     */
-    public void startTimingIfSync();
-
-    /**
-     * Stops timing and records the data. Propagates the data up to group handlers.
-     * <p/>
-     * Will automatically be called when this Timing is used with try-with-resources
-     *
-     * But only if we are on the primary thread.
-     */
-    public void stopTimingIfSync();
-
-    /**
-     * Stops timing and disregards current timing data.
-     */
-    public void abort();
-
-    /**
-     * Used internally to get the actual backing Handler in the case of delegated Handlers
-     *
-     * @return TimingHandler
-     */
-    TimingHandler getTimingHandler();
-
-    @Override
-    void close();
-}
diff --git a/src/main/java/org/spigotmc/timings/TimingData.java b/src/main/java/org/spigotmc/timings/TimingData.java
deleted file mode 100644
index 677b597..0000000
--- a/src/main/java/org/spigotmc/timings/TimingData.java
+++ /dev/null
@@ -1,105 +0,0 @@
-/*
- * This file is licensed under the MIT License (MIT).
- *
- * Copyright (c) 2014 Daniel Ennis <http://aikar.co>
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
- * THE SOFTWARE.
- */
-package org.spigotmc.timings;
-
-import com.google.common.base.Function;
-
-import java.util.List;
-
-import static org.spigotmc.util.JSONUtil.toArray;
-
-/**
- * Lightweight object for tracking timing data
- * <p/>
- * This is broken out to reduce memory usage
- */
-class TimingData {
-    static Function<Integer, TimingData> LOADER = new Function<Integer, TimingData>() {
-        @Override
-        public TimingData apply(Integer input) {
-            return new TimingData(input);
-        }
-    };
-    int id;
-    int count = 0;
-    int lagCount = 0;
-    long totalTime = 0;
-    long lagTotalTime = 0;
-
-    int curTickCount = 0;
-    int curTickTotal = 0;
-
-    TimingData(int id) {
-        this.id = id;
-    }
-
-    TimingData(TimingData data) {
-        this.id = data.id;
-        this.totalTime = data.totalTime;
-        this.lagTotalTime = data.lagTotalTime;
-        this.count = data.count;
-        this.lagCount = data.lagCount;
-    }
-
-    void add(long diff) {
-        ++curTickCount;
-        curTickTotal += diff;
-    }
-
-    void processTick(boolean violated) {
-        totalTime += curTickTotal;
-        count += curTickCount;
-        if (violated) {
-            lagTotalTime += curTickTotal;
-            lagCount += curTickCount;
-        }
-        curTickTotal = 0;
-        curTickCount = 0;
-    }
-
-    void reset() {
-        count = 0;
-        lagCount = 0;
-        curTickTotal = 0;
-        curTickCount = 0;
-        totalTime = 0;
-        lagTotalTime = 0;
-    }
-
-    protected TimingData clone() {
-        return new TimingData(this);
-    }
-
-    public List export() {
-        List list = toArray(
-            id,
-            count,
-            totalTime);
-        if (lagCount > 0) {
-            list.add(lagCount);
-            list.add(lagTotalTime);
-        }
-        return list;
-    }
-}
diff --git a/src/main/java/org/spigotmc/timings/TimingHandler.java b/src/main/java/org/spigotmc/timings/TimingHandler.java
deleted file mode 100644
index c956a90..0000000
--- a/src/main/java/org/spigotmc/timings/TimingHandler.java
+++ /dev/null
@@ -1,193 +0,0 @@
-/*
- * This file is licensed under the MIT License (MIT).
- *
- * Copyright (c) 2014 Daniel Ennis <http://aikar.co>
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
- * THE SOFTWARE.
- */
-package org.spigotmc.timings;
-
-import gnu.trove.map.hash.TIntObjectHashMap;
-import org.bukkit.Bukkit;
-import org.spigotmc.util.LoadingIntMap;
-import org.spigotmc.util.LoadingMap;
-import org.spigotmc.util.MRUMapCache;
-
-import java.util.Map;
-import java.util.logging.Level;
-
-class TimingHandler implements Timing {
-
-    private static int idPool = 1;
-    final int id = idPool++;
-
-    final String name;
-    final boolean verbose;
-
-    final TIntObjectHashMap<TimingData> children = new LoadingIntMap<TimingData>(TimingData.LOADER);
-
-    final TimingData record;
-    final TimingHandler groupHandler;
-
-    long start = 0;
-    int timingDepth = 0;
-    boolean added;
-    boolean timed;
-    boolean enabled;
-    TimingHandler parent;
-
-    TimingHandler(TimingIdentifier id) {
-        if (id.name.startsWith("##")) {
-            verbose = true;
-            this.name = id.name.substring(3);
-        } else {
-            this.name = id.name;
-            verbose = false;
-        }
-
-        this.record = new TimingData(this.id);
-        this.groupHandler = id.groupHandler;
-
-        TimingIdentifier.getGroup(id.group).handlers.add(this);
-        checkEnabled();
-    }
-
-    final void checkEnabled() {
-        enabled = Timings.timingsEnabled && (!verbose || Timings.verboseEnabled);
-    }
-
-    void processTick(boolean violated) {
-        if (timingDepth != 0 || record.curTickCount == 0) {
-            timingDepth = 0;
-            start = 0;
-            return;
-        }
-
-        record.processTick(violated);
-        for (TimingData handler : children.valueCollection()) {
-            handler.processTick(violated);
-        }
-    }
-
-    @Override
-    public void startTimingIfSync() {
-        if (Bukkit.isPrimaryThread()) {
-            startTiming();
-        }
-    }
-
-    @Override
-    public void stopTimingIfSync() {
-        if (Bukkit.isPrimaryThread()) {
-            stopTiming();
-        }
-    }
-
-    public void startTiming() {
-        if (enabled && ++timingDepth == 1) {
-            start = System.nanoTime();
-            parent = TimingsManager.CURRENT;
-            TimingsManager.CURRENT = this;
-        }
-    }
-
-    public void stopTiming() {
-        if (enabled && --timingDepth == 0 && start != 0) {
-            if (!Bukkit.isPrimaryThread()) {
-                Bukkit.getLogger().log(Level.SEVERE, "stopTiming called async for " + name);
-                new Throwable().printStackTrace();
-                start = 0;
-                return;
-            }
-            addDiff(System.nanoTime() - start);
-            start = 0;
-        }
-    }
-
-    @Override
-    public void abort() {
-        if (enabled && timingDepth > 0) {
-            start = 0;
-        }
-    }
-
-    void addDiff(long diff) {
-        if (TimingsManager.CURRENT == this) {
-            TimingsManager.CURRENT = parent;
-            if (parent != null) {
-                parent.children.get(id).add(diff);
-            }
-        }
-        record.add(diff);
-        if (!added) {
-            added = true;
-            timed = true;
-            TimingsManager.HANDLERS.add(this);
-        }
-        if (groupHandler != null) {
-            groupHandler.addDiff(diff);
-            groupHandler.children.get(id).add(diff);
-        }
-    }
-
-    /**
-     * Reset this timer, setting all values to zero.
-     *
-     * @param full
-     */
-    void reset(boolean full) {
-        record.reset();
-        if (full) {
-            timed = false;
-        }
-        start = 0;
-        timingDepth = 0;
-        added = false;
-        children.clear();
-        checkEnabled();
-    }
-
-    @Override
-    public TimingHandler getTimingHandler() {
-        return this;
-    }
-
-    @Override
-    public boolean equals(Object o) {
-        return (this == o);
-    }
-
-    @Override
-    public int hashCode() {
-        return id;
-    }
-
-    /**
-     * This is simply for the Closeable interface so it can be used with
-     * try-with-resources ()
-     */
-    @Override
-    public void close() {
-        stopTimingIfSync();
-    }
-
-    public boolean isSpecial() {
-        return this == TimingsManager.FULL_SERVER_TICK || this == TimingsManager.TIMINGS_TICK;
-    }
-}
diff --git a/src/main/java/org/spigotmc/timings/TimingHistory.java b/src/main/java/org/spigotmc/timings/TimingHistory.java
deleted file mode 100644
index b99f73c..0000000
--- a/src/main/java/org/spigotmc/timings/TimingHistory.java
+++ /dev/null
@@ -1,276 +0,0 @@
-/*
- * This file is licensed under the MIT License (MIT).
- *
- * Copyright (c) 2014 Daniel Ennis <http://aikar.co>
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
- * THE SOFTWARE.
- */
-package org.spigotmc.timings;
-
-import com.google.common.base.Function;
-import com.google.common.collect.Sets;
-import org.bukkit.Bukkit;
-import org.bukkit.Chunk;
-import org.bukkit.Material;
-import org.bukkit.World;
-import org.bukkit.block.BlockState;
-import org.bukkit.entity.Entity;
-import org.bukkit.entity.EntityType;
-import org.bukkit.entity.Player;
-import org.spigotmc.util.LoadingMap;
-import org.spigotmc.util.MRUMapCache;
-
-import java.lang.management.ManagementFactory;
-import java.util.Collection;
-import java.util.EnumMap;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
-import static org.spigotmc.timings.TimingsManager.FULL_SERVER_TICK;
-import static org.spigotmc.timings.TimingsManager.MINUTE_REPORTS;
-import static org.spigotmc.util.JSONUtil.*;
-
-@SuppressWarnings({"deprecation", "SuppressionAnnotation"})
-public class TimingHistory {
-    public static long lastMinuteTime;
-    public static long timedTicks;
-    public static long playerTicks;
-    public static long entityTicks;
-    public static long tileEntityTicks;
-    public static long activatedEntityTicks;
-    static int worldIdPool = 1;
-    static Map<String, Integer> worldMap = LoadingMap.newHashMap(new Function<String, Integer>() {
-        @Override
-        public Integer apply(String input) {
-            return worldIdPool++;
-        }
-    });
-    final long endTime;
-    final long startTime;
-    final long totalTicks;
-    final long totalTime; // Represents all time spent running the server this history
-    final MinuteReport[] minuteReports;
-
-    final TimingHistoryEntry[] entries;
-    final Set<Material> tileEntityTypeSet = Sets.newHashSet();
-    final Set<EntityType> entityTypeSet = Sets.newHashSet();
-    final Map<Object, Object> worlds;
-
-    TimingHistory() {
-        this.endTime = System.currentTimeMillis() / 1000;
-        this.startTime = TimingsManager.historyStart / 1000;
-        if (timedTicks % 1200 != 0 || MINUTE_REPORTS.isEmpty()) {
-            this.minuteReports = MINUTE_REPORTS.toArray(new MinuteReport[MINUTE_REPORTS.size() + 1]);
-            this.minuteReports[this.minuteReports.length - 1] = new MinuteReport();
-        } else {
-            this.minuteReports = MINUTE_REPORTS.toArray(new MinuteReport[MINUTE_REPORTS.size()]);
-        }
-        long ticks = 0;
-        for (MinuteReport mp : this.minuteReports) {
-            ticks += mp.ticksRecord.timed;
-        }
-        this.totalTicks = ticks;
-        this.totalTime = FULL_SERVER_TICK.record.totalTime;
-        this.entries = new TimingHistoryEntry[TimingsManager.HANDLERS.size()];
-
-        int i = 0;
-        for (TimingHandler handler : TimingsManager.HANDLERS) {
-            entries[i++] = new TimingHistoryEntry(handler);
-        }
-
-        final Map<EntityType, Counter> entityCounts = MRUMapCache.of(LoadingMap.of(
-            new EnumMap<EntityType, Counter>(EntityType.class), Counter.LOADER
-        ));
-        final Map<Material, Counter> tileEntityCounts = MRUMapCache.of(LoadingMap.of(
-            new EnumMap<Material, Counter>(Material.class), Counter.LOADER
-        ));
-        // Information about all loaded chunks/entities
-        this.worlds = toObjectMapper(Bukkit.getWorlds(), new Function<World, JSONPair>() {
-                @Override
-                public JSONPair apply(World world) {
-                return pair(
-                    worldMap.get(world.getName()),
-                    toArrayMapper(world.getLoadedChunks(), new Function<Chunk, Object>() {
-                        @Override
-                        public Object apply(Chunk chunk) {
-                        entityCounts.clear();
-                        tileEntityCounts.clear();
-
-                        for (Entity entity : chunk.getEntities()) {
-                            entityCounts.get(entity.getType()).increment();
-                        }
-
-                        for (BlockState tileEntity : chunk.getTileEntities()) {
-                            tileEntityCounts.get(tileEntity.getBlock().getType()).increment();
-                        }
-
-                        if (tileEntityCounts.isEmpty() && entityCounts.isEmpty()) {
-                            return null;
-                        }
-                        return toArray(
-                            chunk.getX(),
-                            chunk.getZ(),
-                            toObjectMapper(entityCounts.entrySet(),
-                                new Function<Map.Entry<EntityType, Counter>, JSONPair>() {
-                                    @Override
-                                    public JSONPair apply(Map.Entry<EntityType, Counter> entry) {
-                                    entityTypeSet.add(entry.getKey());
-                                    return pair(
-                                        String.valueOf(entry.getKey().getTypeId()),
-                                        entry.getValue().count()
-                                    );
-                                    }
-                                }
-                            ),
-                            toObjectMapper(tileEntityCounts.entrySet(),
-                                new Function<Map.Entry<Material, Counter>, JSONPair>() {
-                                    @Override
-                                    public JSONPair apply(Map.Entry<Material, Counter> entry) {
-                                    tileEntityTypeSet.add(entry.getKey());
-                                    return pair(
-                                        String.valueOf(entry.getKey().getId()),
-                                        entry.getValue().count()
-                                    );
-                                    }
-                                }
-                            )
-                        );
-                        }
-                    })
-                );
-            }
-        });
-    }
-
-    public static void resetTicks(boolean fullReset) {
-        if (fullReset) {
-            // Non full is simply for 1 minute reports
-            timedTicks = 0;
-        }
-        lastMinuteTime = System.nanoTime();
-        playerTicks = 0;
-        tileEntityTicks = 0;
-        entityTicks = 0;
-        activatedEntityTicks = 0;
-    }
-
-    Object export() {
-        return createObject(
-            pair("s", startTime),
-            pair("e", endTime),
-            pair("tk", totalTicks),
-            pair("tm", totalTime),
-            pair("w", worlds),
-            pair("h", toArrayMapper(entries, new Function<TimingHistoryEntry, Object>() {
-                @Override
-                public Object apply(TimingHistoryEntry entry) {
-                    TimingData record = entry.data;
-                    if (record.count == 0) {
-                        return null;
-                    }
-                    return entry.export();
-                }
-            })),
-            pair("mp", toArrayMapper(minuteReports, new Function<MinuteReport, Object>() {
-                @Override
-                public Object apply(MinuteReport input) {
-                    return input.export();
-                }
-            }))
-        );
-    }
-
-    static class MinuteReport {
-        final long time = System.currentTimeMillis() / 1000;
-
-        final TicksRecord ticksRecord = new TicksRecord();
-        final PingRecord pingRecord = new PingRecord();
-        final TimingData fst = TimingsManager.FULL_SERVER_TICK.minuteData.clone();
-        final double tps = 1E9 / ( System.nanoTime() - lastMinuteTime ) * ticksRecord.timed;
-        final double usedMemory = TimingsManager.FULL_SERVER_TICK.avgUsedMemory;
-        final double freeMemory = TimingsManager.FULL_SERVER_TICK.avgFreeMemory;
-        final double loadAvg = ManagementFactory.getOperatingSystemMXBean().getSystemLoadAverage();
-
-        public List export() {
-            return toArray(
-                time,
-                Math.round(tps * 100D) / 100D,
-                Math.round(pingRecord.avg * 100D) / 100D,
-                fst.export(),
-                toArray(ticksRecord.timed,
-                    ticksRecord.player,
-                    ticksRecord.entity,
-                    ticksRecord.activatedEntity,
-                    ticksRecord.tileEntity
-                ),
-                usedMemory,
-                freeMemory,
-                loadAvg
-            );
-        }
-    }
-
-    static class TicksRecord {
-        final long timed;
-        final long player;
-        final long entity;
-        final long tileEntity;
-        final long activatedEntity;
-
-        TicksRecord() {
-            timed = timedTicks - (TimingsManager.MINUTE_REPORTS.size() * 1200);
-            player = playerTicks;
-            entity = entityTicks;
-            tileEntity = tileEntityTicks;
-            activatedEntity = activatedEntityTicks;
-        }
-
-    }
-
-    static class PingRecord {
-        final double avg;
-
-        PingRecord() {
-            final Collection<? extends Player> onlinePlayers = Bukkit.getOnlinePlayers();
-            int totalPing = 0;
-            for (Player player : onlinePlayers) {
-                totalPing += player.spigot().getPing();
-            }
-            avg = onlinePlayers.isEmpty() ? 0 : totalPing / onlinePlayers.size();
-        }
-    }
-
-    static class Counter {
-        int count = 0;
-        @SuppressWarnings({"rawtypes", "SuppressionAnnotation"})
-        static Function LOADER = new LoadingMap.Feeder<Counter>() {
-            @Override
-            public Counter apply() {
-                return new Counter();
-            }
-        };
-        public int increment() {
-            return ++count;
-        }
-        public int count() {
-            return count;
-        }
-    }
-}
diff --git a/src/main/java/org/spigotmc/timings/TimingHistoryEntry.java b/src/main/java/org/spigotmc/timings/TimingHistoryEntry.java
deleted file mode 100644
index 2b37cbe..0000000
--- a/src/main/java/org/spigotmc/timings/TimingHistoryEntry.java
+++ /dev/null
@@ -1,59 +0,0 @@
-/*
- * This file is licensed under the MIT License (MIT).
- *
- * Copyright (c) 2014 Daniel Ennis <http://aikar.co>
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
- * THE SOFTWARE.
- */
-package org.spigotmc.timings;
-
-import com.google.common.base.Function;
-
-import java.util.List;
-
-import static org.spigotmc.util.JSONUtil.toArrayMapper;
-
-class TimingHistoryEntry {
-    final TimingData data;
-    final TimingData[] children;
-
-    TimingHistoryEntry(TimingHandler handler) {
-        this.data = handler.record.clone();
-        children = new TimingData[handler.children.size()];
-        int i = 0;
-        for (TimingData child : handler.children.valueCollection()) {
-            children[i++] = child.clone();
-        }
-    }
-
-    List export() {
-        List result = data.export();
-        if (children.length > 0) {
-            result.add(
-                toArrayMapper(children, new Function<TimingData, Object>() {
-                    @Override
-                    public Object apply(TimingData child) {
-                        return child.export();
-                    }
-                })
-            );
-        }
-        return result;
-    }
-}
diff --git a/src/main/java/org/spigotmc/timings/TimingIdentifier.java b/src/main/java/org/spigotmc/timings/TimingIdentifier.java
deleted file mode 100644
index 69ed2b0..0000000
--- a/src/main/java/org/spigotmc/timings/TimingIdentifier.java
+++ /dev/null
@@ -1,102 +0,0 @@
-/*
- * This file is licensed under the MIT License (MIT).
- *
- * Copyright (c) 2014 Daniel Ennis <http://aikar.co>
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
- * THE SOFTWARE.
- */
-package org.spigotmc.timings;
-
-import com.google.common.base.Function;
-import org.spigotmc.util.LoadingMap;
-import org.spigotmc.util.MRUMapCache;
-
-import java.util.ArrayDeque;
-import java.util.Map;
-
-/**
- * Used as a basis for fast HashMap key comparisons for the Timing Map.
- * <p/>
- * This class uses interned strings giving us the ability to do an identity check instead of equals() on the strings
- */
-final class TimingIdentifier {
-    /**
-     * Holds all groups. Autoloads on request for a group by name.
-     */
-    static final Map<String, TimingGroup> GROUP_MAP = MRUMapCache.of(
-        LoadingMap.newIdentityHashMap(new Function<String, TimingGroup>() {
-            @Override
-            public TimingGroup apply(String group) {
-                return new TimingGroup(group);
-            }
-        }, 64)
-    );
-    static final TimingGroup DEFAULT_GROUP = getGroup("Minecraft");
-    final String group;
-    final String name;
-    final TimingHandler groupHandler;
-    final boolean protect;
-    private final int hashCode;
-
-    TimingIdentifier(String group, String name, Timing groupHandler, boolean protect) {
-        this.group = group != null ? group.intern() : DEFAULT_GROUP.name;
-        this.name = name.intern();
-        this.groupHandler = groupHandler != null ? groupHandler.getTimingHandler() : null;
-        this.protect = protect;
-        this.hashCode = (31 * this.group.hashCode()) + this.name.hashCode();
-    }
-
-    static TimingGroup getGroup(String groupName) {
-        if (groupName == null) {
-            return DEFAULT_GROUP;
-        }
-
-        return GROUP_MAP.get(groupName.intern());
-    }
-
-    // We are using .intern() on the strings so it is guaranteed to be an identity comparison.
-    @SuppressWarnings("StringEquality")
-    @Override
-    public boolean equals(Object o) {
-        if (o == null) {
-            return false;
-        }
-
-        TimingIdentifier that = (TimingIdentifier) o;
-        return group == that.group && name == that.name;
-    }
-
-    @Override
-    public int hashCode() {
-        return hashCode;
-    }
-
-    static class TimingGroup {
-
-        private static int idPool = 1;
-        final int id = idPool++;
-
-        final String name;
-        ArrayDeque<TimingHandler> handlers = new ArrayDeque<TimingHandler>(64);
-
-        private TimingGroup(String name) {
-            this.name = name;
-        }
-    }
-}
diff --git a/src/main/java/org/spigotmc/timings/Timings.java b/src/main/java/org/spigotmc/timings/Timings.java
deleted file mode 100644
index a7218aa..0000000
--- a/src/main/java/org/spigotmc/timings/Timings.java
+++ /dev/null
@@ -1,273 +0,0 @@
-/*
- * This file is licensed under the MIT License (MIT).
- *
- * Copyright (c) 2014 Daniel Ennis <http://aikar.co>
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
- * THE SOFTWARE.
- */
-package org.spigotmc.timings;
-
-import com.google.common.base.Preconditions;
-import com.google.common.collect.EvictingQueue;
-import org.bukkit.Bukkit;
-import org.bukkit.command.CommandSender;
-import org.bukkit.plugin.Plugin;
-
-import java.util.Queue;
-import java.util.logging.Level;
-
-@SuppressWarnings("UnusedDeclaration")
-public final class Timings {
-
-    private static final int MAX_HISTORY_FRAMES = 12;
-    public static final Timing NULL_HANDLER = new NullTimingHandler();
-    static boolean timingsEnabled = false;
-    static boolean verboseEnabled = false;
-    private static int historyInterval = -1;
-    private static int historyLength = -1;
-
-    private Timings() {}
-
-    /**
-     * Returns a Timing for a plugin corresponding to a name.
-     *
-     * @param plugin Plugin to own the Timing
-     * @param name   Name of Timing
-     * @return Handler
-     */
-    public static Timing of(Plugin plugin, String name) {
-        Timing pluginHandler = null;
-        if (plugin != null) {
-            pluginHandler = ofSafe(plugin.getName(), "Combined Total", TimingsManager.PLUGIN_GROUP_HANDLER);
-        }
-        return of(plugin, name, pluginHandler);
-    }
-
-    /**
-     * Returns a handler that has a groupHandler timer handler. Parent timers should not have their
-     * start/stop methods called directly, as the children will call it for you.
-     * <p/>
-     * Parent Timers are used to group multiple subsections togethers and get a summary of them combined
-     * Parent Handler can not be changed after first call
-     *
-     * @param plugin       Plugin to own the Timing
-     * @param name         Name of Timing
-     * @param groupHandler Parent handler to mirror .start/stop calls to
-     * @return Timing Handler
-     */
-    public static Timing of(Plugin plugin, String name, Timing groupHandler) {
-        Preconditions.checkNotNull(plugin, "Plugin can not be null");
-        return TimingsManager.getHandler(plugin.getName(), name, groupHandler, true);
-    }
-
-    /**
-     * Returns a Timing object after starting it, useful for Java7 try-with-resources.
-     *
-     * try (Timing ignored = Timings.ofStart(plugin, someName)) {
-     * // timed section
-     * }
-     *
-     * @param plugin Plugin to own the Timing
-     * @param name   Name of Timing
-     * @return Timing Handler
-     */
-    public static Timing ofStart(Plugin plugin, String name) {
-        return ofStart(plugin, name, null);
-    }
-
-    /**
-     * Returns a Timing object after starting it, useful for Java7 try-with-resources.
-     *
-     * try (Timing ignored = Timings.ofStart(plugin, someName, groupHandler)) {
-     * // timed section
-     * }
-     *
-     * @param plugin       Plugin to own the Timing
-     * @param name         Name of Timing
-     * @param groupHandler Parent handler to mirror .start/stop calls to
-     * @return Timing Handler
-     */
-    public static Timing ofStart(Plugin plugin, String name, Timing groupHandler) {
-        Timing timing = of(plugin, name, groupHandler);
-        timing.startTimingIfSync();
-        return timing;
-    }
-
-    /**
-     * Gets whether or not the Spigot Timings system is enabled
-     *
-     * @return Enabled or not
-     */
-    public static boolean isTimingsEnabled() {
-        return timingsEnabled;
-    }
-
-    /**
-     * Sets whether or not the Spigot Timings system should be enabled
-     * <p/>
-     * Calling this will reset timing data.
-     *
-     * @param enabled Should timings be reported
-     */
-    public static void setTimingsEnabled(boolean enabled) {
-        timingsEnabled = enabled;
-        reset();
-    }
-
-    /**
-     * Gets whether or not the Verbose level of timings is enabled.
-     * <p/>
-     * When Verbose is disabled, high-frequency timings will not be available
-     *
-     * @return Enabled or not
-     */
-    public static boolean isVerboseTimingsEnabled() {
-        return timingsEnabled;
-    }
-
-    /**
-     * Sets whether or not the Timings should monitor at Verbose level.
-     * <p/>
-     * When Verbose is disabled, high-frequency timings will not be available.
-     * Calling this will reset timing data.
-     *
-     * @param enabled Should high-frequency timings be reported
-     */
-    public static void setVerboseTimingsEnabled(boolean enabled) {
-        verboseEnabled = enabled;
-        TimingsManager.needsRecheckEnabled = true;
-    }
-
-    /**
-     * Gets the interval between Timing History report generation.
-     * <p/>
-     * Defaults to 5 minutes (6000 ticks)
-     *
-     * @return Interval in ticks
-     */
-    public static int getHistoryInterval() {
-        return historyInterval;
-    }
-
-    /**
-     * Sets the interval between Timing History report generations.
-     * <p/>
-     * Defaults to 5 minutes (6000 ticks)
-     *
-     * This will recheck your history length, so lowering this value will lower your
-     * history length if you need more than 60 history windows.
-     *
-     * @param interval Interval in ticks
-     */
-    public static void setHistoryInterval(int interval) {
-        historyInterval = Math.max(20*60, interval);
-        // Recheck the history length with the new Interval
-        if (historyLength != -1) {
-            setHistoryLength(historyLength);
-        }
-    }
-
-    /**
-     * Gets how long in ticks Timings history is kept for the server.
-     *
-     * Defaults to 1 hour (72000 ticks)
-     *
-     * @return Duration in Ticks
-     */
-    public static int getHistoryLength() {
-        return historyLength;
-    }
-
-    /**
-     * Sets how long Timing History reports are kept for the server.
-     *
-     * Defaults to 1 hours(72000 ticks)
-     *
-     * This value is capped at a maximum of getHistoryInterval() * MAX_HISTORY_FRAMES (12)
-     *
-     * Will not reset Timing Data but may truncate old history if the new length is less than old length.
-     *
-     * @param length Duration in ticks
-     */
-    public static void setHistoryLength(int length) {
-        // Cap at 12 History Frames, 1 hour at 5 minute frames.
-        int maxLength = historyInterval * MAX_HISTORY_FRAMES;
-        // For special cases of servers with special permission to bypass the max.
-        // This max helps keep data file sizes reasonable for processing on Aikar's Timing parser side.
-        // Setting this will not help you bypass the max unless Aikar has added an exception on the API side.
-        if (System.getProperty("timings.bypassMax") != null) {
-            maxLength = Integer.MAX_VALUE;
-        }
-        historyLength = Math.max(Math.min(maxLength, length), historyInterval);
-        Queue<TimingHistory> oldQueue = TimingsManager.HISTORY;
-        int frames = (getHistoryLength() / getHistoryInterval());
-        if (length > maxLength) {
-            Bukkit.getLogger().log(Level.WARNING, "Timings Length too high. Requested " + length + ", max is " + maxLength + ". To get longer history, you must increase your interval. Set Interval to " + Math.ceil(length / MAX_HISTORY_FRAMES) + " to achieve this length.");
-        }
-        TimingsManager.HISTORY = EvictingQueue.create(frames);
-        TimingsManager.HISTORY.addAll(oldQueue);
-    }
-
-    /**
-     * Resets all Timing Data
-     */
-    public static void reset() {
-        TimingsManager.reset();
-    }
-
-    /**
-     * Generates a report and sends it to the specified command sender.
-     *
-     * If sender is null, ConsoleCommandSender will be used.
-     * @param sender
-     */
-    public static void generateReport(CommandSender sender) {
-        if (sender == null) {
-            sender = Bukkit.getConsoleSender();
-        }
-        TimingsExport.reportTimings(sender);
-    }
-
-    /*
-    =================
-    Protected API: These are for internal use only in Bukkit/CraftBukkit
-    These do not have isPrimaryThread() checks in the startTiming/stopTiming
-    =================
-    */
-
-    static TimingHandler ofSafe(String name) {
-        return ofSafe(null, name, null);
-    }
-
-    static Timing ofSafe(Plugin plugin, String name) {
-        Timing pluginHandler = null;
-        if (plugin != null) {
-            pluginHandler = ofSafe(plugin.getName(), "Combined Total", TimingsManager.PLUGIN_GROUP_HANDLER);
-        }
-        return ofSafe(plugin != null ? plugin.getName() : "Minecraft - Invalid Plugin", name, pluginHandler);
-    }
-
-    static TimingHandler ofSafe(String name, Timing groupHandler) {
-        return ofSafe(null, name, groupHandler);
-    }
-
-    static TimingHandler ofSafe(String groupName, String name, Timing groupHandler) {
-        return TimingsManager.getHandler(groupName, name, groupHandler, false);
-    }
-}
diff --git a/src/main/java/org/spigotmc/timings/TimingsCommand.java b/src/main/java/org/spigotmc/timings/TimingsCommand.java
deleted file mode 100644
index aa1867f..0000000
--- a/src/main/java/org/spigotmc/timings/TimingsCommand.java
+++ /dev/null
@@ -1,110 +0,0 @@
-/*
- * This file is licensed under the MIT License (MIT).
- *
- * Copyright (c) 2014 Daniel Ennis <http://aikar.co>
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
- * THE SOFTWARE.
- */
-package org.spigotmc.timings;
-
-import com.google.common.collect.ImmutableList;
-import org.apache.commons.lang.Validate;
-import org.bukkit.ChatColor;
-import org.bukkit.command.CommandSender;
-import org.bukkit.command.defaults.BukkitCommand;
-import org.bukkit.util.StringUtil;
-
-import java.util.ArrayList;
-import java.util.List;
-
-
-public class TimingsCommand extends BukkitCommand {
-    public static final List<String> TIMINGS_SUBCOMMANDS = ImmutableList.of("report", "reset", "on", "off", "paste", "verbon", "verboff");
-
-    public TimingsCommand(String name) {
-        super(name);
-        this.description = "Manages Spigot Timings data to see performance of the server.";
-        this.usageMessage = "/timings <reset|report|on|off|verbon|verboff>";
-        this.setPermission("bukkit.command.timings");
-    }
-
-    @Override
-    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
-        if (!testPermission(sender)) {
-            return true;
-        }
-        if (args.length < 1) {
-            sender.sendMessage(ChatColor.RED + "Usage: " + usageMessage);
-            return true;
-        }
-        final String arg = args[0];
-        if ("on".equalsIgnoreCase(arg)) {
-            Timings.setTimingsEnabled(true);
-            sender.sendMessage("Enabled Timings & Reset");
-            return true;
-        } else if ("off".equalsIgnoreCase(arg)) {
-            Timings.setTimingsEnabled(false);
-            sender.sendMessage("Disabled Timings");
-            return true;
-        }
-
-        if (!Timings.isTimingsEnabled()) {
-            sender.sendMessage("Please enable timings by typing /timings on");
-            return true;
-        }
-        if ("verbon".equalsIgnoreCase(arg)) {
-            Timings.setVerboseTimingsEnabled(true);
-            sender.sendMessage("Enabled Verbose Timings");
-            return true;
-        } else if ("verboff".equalsIgnoreCase(arg)) {
-            Timings.setVerboseTimingsEnabled(false);
-            sender.sendMessage("Disabled Verbose Timings");
-            return true;
-        } else if ("reset".equalsIgnoreCase(arg)) {
-            TimingsManager.reset();
-            sender.sendMessage("Timings reset");
-        } else if ("cost".equals(arg)) {
-            sender.sendMessage("Timings cost: " + TimingsExport.getCost());
-        } else  if (
-            "paste".equalsIgnoreCase(arg) ||
-                "report".equalsIgnoreCase(arg) ||
-                "get".equalsIgnoreCase(arg) ||
-                "merged".equalsIgnoreCase(arg) ||
-                "separate".equalsIgnoreCase(arg)
-            ) {
-            TimingsExport.reportTimings(sender);
-        } else {
-            sender.sendMessage(ChatColor.RED + "Usage: " + usageMessage);
-        }
-        return true;
-    }
-
-    @Override
-    public List<String> tabComplete(CommandSender sender, String alias, String[] args) {
-        Validate.notNull(sender, "Sender cannot be null");
-        Validate.notNull(args, "Arguments cannot be null");
-        Validate.notNull(alias, "Alias cannot be null");
-
-        if (args.length == 1) {
-            return StringUtil.copyPartialMatches(args[0], TIMINGS_SUBCOMMANDS,
-                new ArrayList<String>(TIMINGS_SUBCOMMANDS.size()));
-        }
-        return ImmutableList.of();
-    }
-}
diff --git a/src/main/java/org/spigotmc/timings/TimingsExport.java b/src/main/java/org/spigotmc/timings/TimingsExport.java
deleted file mode 100644
index 2ed5028..0000000
--- a/src/main/java/org/spigotmc/timings/TimingsExport.java
+++ /dev/null
@@ -1,372 +0,0 @@
-/*
- * This file is licensed under the MIT License (MIT).
- *
- * Copyright (c) 2014 Daniel Ennis <http://aikar.co>
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
- * THE SOFTWARE.
- */
-package org.spigotmc.timings;
-
-import com.google.common.base.Function;
-import com.google.common.collect.Sets;
-import org.apache.commons.lang.StringUtils;
-import org.bukkit.Bukkit;
-import org.bukkit.ChatColor;
-import org.bukkit.Material;
-import org.bukkit.command.CommandSender;
-import org.bukkit.command.ConsoleCommandSender;
-import org.bukkit.command.RemoteConsoleCommandSender;
-import org.bukkit.configuration.ConfigurationSection;
-import org.bukkit.configuration.MemorySection;
-import org.bukkit.entity.EntityType;
-import org.bukkit.plugin.Plugin;
-import org.json.simple.JSONObject;
-import org.json.simple.JSONValue;
-
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.lang.management.GarbageCollectorMXBean;
-import java.lang.management.ManagementFactory;
-import java.lang.management.OperatingSystemMXBean;
-import java.lang.management.RuntimeMXBean;
-import java.net.HttpURLConnection;
-import java.net.InetAddress;
-import java.net.URL;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import java.util.logging.Level;
-import java.util.zip.GZIPOutputStream;
-
-import static org.spigotmc.timings.TimingsManager.HISTORY;
-import static org.spigotmc.util.JSONUtil.*;
-
-@SuppressWarnings({"rawtypes", "SuppressionAnnotation"})
-class TimingsExport extends Thread {
-
-    private final CommandSender sender;
-    private final Map out;
-    private final TimingHistory[] history;
-
-    TimingsExport(CommandSender sender, Map out, TimingHistory[] history) {
-        super("Timings paste thread");
-        this.sender = sender;
-        this.out = out;
-        this.history = history;
-    }
-
-
-    /**
-     * Builds an XML report of the timings to be uploaded for parsing.
-     *
-     * @param sender Who to report to
-     */
-    static void reportTimings(CommandSender sender) {
-        Map parent = createObject(
-            // Get some basic system details about the server
-            pair("version", Bukkit.getVersion()),
-            pair("maxplayers", Bukkit.getMaxPlayers()),
-            pair("start", TimingsManager.timingStart / 1000),
-            pair("end", System.currentTimeMillis() / 1000),
-            pair("sampletime", (System.currentTimeMillis() - TimingsManager.timingStart) / 1000)
-        );
-        if (!TimingsManager.privacy) {
-            appendObjectData(parent,
-                pair("server", Bukkit.getServerName()),
-                pair("motd", Bukkit.getServer().getMotd()),
-                pair("online-mode", Bukkit.getServer().getOnlineMode()),
-                pair("icon", Bukkit.getServer().getServerIcon().getData())
-            );
-        }
-
-        final Runtime runtime = Runtime.getRuntime();
-        RuntimeMXBean runtimeBean = ManagementFactory.getRuntimeMXBean();
-
-        parent.put("system", createObject(
-                pair("timingcost", getCost()),
-                pair("name", System.getProperty("os.name")),
-                pair("version", System.getProperty("os.version")),
-                pair("jvmversion", System.getProperty("java.version")),
-                pair("arch", System.getProperty("os.arch")),
-                pair("maxmem", runtime.maxMemory()),
-                pair("cpu", runtime.availableProcessors()),
-                pair("runtime", ManagementFactory.getRuntimeMXBean().getUptime()),
-                pair("flags", StringUtils.join(runtimeBean.getInputArguments(), " ")),
-                pair("gc", toObjectMapper(ManagementFactory.getGarbageCollectorMXBeans(), new Function<GarbageCollectorMXBean, JSONPair>() {
-                    @Override
-                    public JSONPair apply(GarbageCollectorMXBean input) {
-                        return pair(input.getName(), toArray(input.getCollectionCount(), input.getCollectionTime()));
-                    }
-                }))
-            )
-        );
-
-        Set<Material> tileEntityTypeSet = Sets.newHashSet();
-        Set<EntityType> entityTypeSet = Sets.newHashSet();
-
-        int size = HISTORY.size();
-        TimingHistory[] history = new TimingHistory[size + 1];
-        int i = 0;
-        for (TimingHistory timingHistory : HISTORY) {
-            tileEntityTypeSet.addAll(timingHistory.tileEntityTypeSet);
-            entityTypeSet.addAll(timingHistory.entityTypeSet);
-            history[i++] = timingHistory;
-        }
-
-        history[i] = new TimingHistory(); // Current snapshot
-        tileEntityTypeSet.addAll(history[i].tileEntityTypeSet);
-        entityTypeSet.addAll(history[i].entityTypeSet);
-
-
-        Map handlers = createObject();
-        for (TimingIdentifier.TimingGroup group : TimingIdentifier.GROUP_MAP.values()) {
-            for (TimingHandler id : group.handlers) {
-                if (!id.timed && !id.isSpecial()) {
-                    continue;
-                }
-                handlers.put(id.id, toArray(
-                    group.id,
-                    id.name
-                ));
-            }
-        }
-
-        parent.put("idmap", createObject(
-            pair("groups", toObjectMapper(
-                TimingIdentifier.GROUP_MAP.values(), new Function<TimingIdentifier.TimingGroup, JSONPair>() {
-                @Override
-                public JSONPair apply(TimingIdentifier.TimingGroup group) {
-                    return pair(group.id, group.name);
-                }
-            })),
-            pair("handlers", handlers),
-            pair("worlds", toObjectMapper(TimingHistory.worldMap.entrySet(), new Function<Map.Entry<String, Integer>, JSONPair>() {
-                    @Override
-                    public JSONPair apply(Map.Entry<String, Integer> input) {
-                        return pair(input.getValue(), input.getKey());
-                    }
-                })),
-            pair("tileentity",
-                toObjectMapper(tileEntityTypeSet, new Function<Material, JSONPair>() {
-                    @Override
-                    public JSONPair apply(Material input) {
-                        return pair(input.getId(), input.name());
-                    }
-                })),
-            pair("entity",
-                toObjectMapper(entityTypeSet, new Function<EntityType, JSONPair>() {
-                    @Override
-                    public JSONPair apply(EntityType input) {
-                        return pair(input.getTypeId(), input.name());
-                    }
-                }))
-        ));
-
-        // Information about loaded plugins
-
-        parent.put("plugins", toObjectMapper(Bukkit.getPluginManager().getPlugins(),
-            new Function<Plugin, JSONPair>() {
-                @Override
-                public JSONPair apply(Plugin plugin) {
-                    return pair(plugin.getName(), createObject(
-                        pair("version", plugin.getDescription().getVersion()),
-                        pair("description", String.valueOf(plugin.getDescription().getDescription()).trim()),
-                        pair("website", plugin.getDescription().getWebsite()),
-                        pair("authors", StringUtils.join(plugin.getDescription().getAuthors(), ", "))
-                    ));
-                }
-            }));
-
-
-
-        // Information on the users Config
-
-        parent.put("config", createObject(
-            pair("spigot", mapAsJSON(Bukkit.spigot().getSpigotConfig(), null)),
-            pair("bukkit", mapAsJSON(Bukkit.spigot().getBukkitConfig(), null))
-        ));
-
-        new TimingsExport(sender, parent, history).start();
-    }
-
-    static long getCost() {
-        // Benchmark the users System.nanotime() for cost basis
-        int passes = 500000;
-        TimingHandler SAMPLER1 = Timings.ofSafe("Timings Sampler 1");
-        TimingHandler SAMPLER2 = Timings.ofSafe("Timings Sampler 2");
-        TimingHandler SAMPLER3 = Timings.ofSafe("Timings Sampler 3");
-        TimingHandler SAMPLER4 = Timings.ofSafe("Timings Sampler 4");
-        TimingHandler SAMPLER5 = Timings.ofSafe("Timings Sampler 5");
-        TimingHandler SAMPLER6 = Timings.ofSafe("Timings Sampler 6");
-
-        long start = System.nanoTime();
-        for (int i = 0; i < passes; i++) {
-            SAMPLER1.startTiming();
-            SAMPLER2.startTiming();
-            SAMPLER3.startTiming();
-            SAMPLER3.stopTiming();
-            SAMPLER4.startTiming();
-            SAMPLER5.startTiming();
-            SAMPLER6.startTiming();
-            SAMPLER6.stopTiming();
-            SAMPLER5.stopTiming();
-            SAMPLER4.stopTiming();
-            SAMPLER2.stopTiming();
-            SAMPLER1.stopTiming();
-        }
-        long timingsCost = (System.nanoTime() - start) / passes / 6;
-        SAMPLER1.reset(true);
-        SAMPLER2.reset(true);
-        SAMPLER3.reset(true);
-        SAMPLER4.reset(true);
-        SAMPLER5.reset(true);
-        SAMPLER6.reset(true);
-        return timingsCost;
-    }
-
-    private static JSONObject mapAsJSON(ConfigurationSection config, String parentKey) {
-
-        JSONObject object = new JSONObject();
-        for (String key : config.getKeys(false)) {
-            String fullKey = (parentKey != null ? parentKey + "." + key : key);
-            if (fullKey.equals("database") || fullKey.equals("settings.bungeecord-addresses") || TimingsManager.hiddenConfigs.contains(fullKey)) {
-                continue;
-            }
-            final Object val = config.get(key);
-
-            object.put(key, valAsJSON(val, fullKey));
-        }
-        return object;
-    }
-
-    private static Object valAsJSON(Object val, final String parentKey) {
-        if (!(val instanceof MemorySection)) {
-            if (val instanceof List) {
-                Iterable<Object> v = (Iterable<Object>) val;
-                return toArrayMapper(v, new Function<Object, Object>() {
-                    @Override
-                    public Object apply(Object input) {
-                        return valAsJSON(input, parentKey);
-                    }
-                });
-            } else {
-                return val.toString();
-            }
-        } else {
-            return mapAsJSON((ConfigurationSection) val, parentKey);
-        }
-    }
-
-    @SuppressWarnings("CallToThreadRun")
-    @Override
-    public synchronized void start() {
-        if (sender instanceof RemoteConsoleCommandSender) {
-            sender.sendMessage(ChatColor.RED + "Warning: Timings report done over RCON will cause lag spikes.");
-            sender.sendMessage(ChatColor.RED + "You should use " + ChatColor.YELLOW +
-                "/timings report" + ChatColor.RED + " in game or console.");
-            run();
-        } else {
-            super.start();
-        }
-    }
-
-    @Override
-    public void run() {
-        sender.sendMessage(ChatColor.GREEN + "Preparing Timings Report...");
-
-
-        out.put("data", toArrayMapper(history, new Function<TimingHistory, Object>() {
-            @Override
-            public Object apply(TimingHistory input) {
-                return input.export();
-            }
-        }));
-
-
-        String response = null;
-        try {
-            HttpURLConnection con = (HttpURLConnection) new URL("http://timings.aikar.co/post").openConnection();
-            con.setDoOutput(true);
-            con.setRequestProperty("User-Agent", "Spigot/" + Bukkit.getServerName() + "/" + InetAddress.getLocalHost().getHostName());
-            con.setRequestMethod("POST");
-            con.setInstanceFollowRedirects(false);
-
-            OutputStream request = new GZIPOutputStream(con.getOutputStream()) {{
-                this.def.setLevel(7);
-            }};
-
-            request.write(JSONValue.toJSONString(out).getBytes("UTF-8"));
-            request.close();
-
-            response = getResponse(con);
-
-            if (con.getResponseCode() != 302) {
-                sender.sendMessage(
-                    ChatColor.RED + "Upload Error: " + con.getResponseCode() + ": " + con.getResponseMessage());
-                sender.sendMessage(ChatColor.RED + "Check your logs for more information");
-                if (response != null) {
-                    Bukkit.getLogger().log(Level.SEVERE, response);
-                }
-                return;
-            }
-
-            String location = con.getHeaderField("Location");
-            sender.sendMessage(ChatColor.GREEN + "View Timings Report: " + location);
-            if (!(sender instanceof ConsoleCommandSender)) {
-                Bukkit.getLogger().log(Level.INFO, "View Timings Report: " + location);
-            }
-
-            if (response != null && !response.isEmpty()) {
-                Bukkit.getLogger().log(Level.INFO, "Timing Response: " + response);
-            }
-        } catch (IOException ex) {
-            sender.sendMessage(ChatColor.RED + "Error uploading timings, check your logs for more information");
-            if (response != null) {
-                Bukkit.getLogger().log(Level.SEVERE, response);
-            }
-            Bukkit.getLogger().log(Level.SEVERE, "Could not paste timings", ex);
-        }
-    }
-
-    private String getResponse(HttpURLConnection con) throws IOException {
-        InputStream is = null;
-        try {
-            is = con.getInputStream();
-            ByteArrayOutputStream bos = new ByteArrayOutputStream();
-
-            byte[] b = new byte[1024];
-            int bytesRead;
-            while ((bytesRead = is.read(b)) != -1) {
-                bos.write(b, 0, bytesRead);
-            }
-            return bos.toString();
-
-        } catch (IOException ex) {
-            sender.sendMessage(ChatColor.RED + "Error uploading timings, check your logs for more information");
-            Bukkit.getLogger().log(Level.WARNING, con.getResponseMessage(), ex);
-            return null;
-        } finally {
-            if (is != null) {
-                is.close();
-            }
-        }
-    }
-}
diff --git a/src/main/java/org/spigotmc/timings/TimingsManager.java b/src/main/java/org/spigotmc/timings/TimingsManager.java
deleted file mode 100644
index f6b31cb..0000000
--- a/src/main/java/org/spigotmc/timings/TimingsManager.java
+++ /dev/null
@@ -1,194 +0,0 @@
-/*
- * This file is licensed under the MIT License (MIT).
- *
- * Copyright (c) 2014 Daniel Ennis <http://aikar.co>
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
- * THE SOFTWARE.
- */
-package org.spigotmc.timings;
-
-import com.google.common.base.Function;
-import com.google.common.collect.EvictingQueue;
-import org.bukkit.Bukkit;
-import org.bukkit.Server;
-import org.bukkit.command.Command;
-import org.bukkit.plugin.Plugin;
-import org.bukkit.plugin.java.PluginClassLoader;
-import org.spigotmc.util.LoadingMap;
-
-import java.util.ArrayDeque;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.List;
-import java.util.Map;
-import java.util.logging.Level;
-
-public final class TimingsManager {
-    static final Map<TimingIdentifier, TimingHandler> TIMING_MAP =
-        Collections.synchronizedMap(LoadingMap.newHashMap(
-            new Function<TimingIdentifier, TimingHandler>() {
-                @Override
-                public TimingHandler apply(TimingIdentifier id) {
-                    return (id.protect ?
-                        new UnsafeTimingHandler(id) :
-                        new TimingHandler(id)
-                    );
-                }
-            },
-            256, .5F
-        ));
-    public static final FullServerTickHandler FULL_SERVER_TICK = new FullServerTickHandler();
-    public static final TimingHandler TIMINGS_TICK = Timings.ofSafe("Timings Tick", FULL_SERVER_TICK);
-    public static final Timing PLUGIN_GROUP_HANDLER = Timings.ofSafe("Plugins");
-    public static List<String> hiddenConfigs = new ArrayList<String>();
-    public static boolean privacy = false;
-
-    static final Collection<TimingHandler> HANDLERS = new ArrayDeque<TimingHandler>();
-    static final ArrayDeque<TimingHistory.MinuteReport> MINUTE_REPORTS = new ArrayDeque<TimingHistory.MinuteReport>();
-
-    static EvictingQueue<TimingHistory> HISTORY = EvictingQueue.create(12);
-    static TimingHandler CURRENT;
-    static long timingStart = 0;
-    static long historyStart = 0;
-    static boolean needsFullReset = false;
-    static boolean needsRecheckEnabled = false;
-
-    private TimingsManager() {}
-
-    /**
-     * Resets all timing data on the next tick
-     */
-    static void reset() {
-        needsFullReset = true;
-    }
-
-    /**
-     * Ticked every tick by CraftBukkit to count the number of times a timer
-     * caused TPS loss.
-     */
-    static void tick() {
-        if (Timings.timingsEnabled) {
-            boolean violated = FULL_SERVER_TICK.isViolated();
-
-            for (TimingHandler handler : HANDLERS) {
-                if (handler.isSpecial()) {
-                    // We manually call this
-                    continue;
-                }
-                handler.processTick(violated);
-            }
-
-            TimingHistory.playerTicks += Bukkit.getOnlinePlayers().size();
-            TimingHistory.timedTicks++;
-            // Generate TPS/Ping/Tick reports every minute
-        }
-    }
-    static void stopServer() {
-        Timings.timingsEnabled = false;
-        recheckEnabled();
-    }
-    static void recheckEnabled() {
-        synchronized (TIMING_MAP) {
-            for (TimingHandler timings : TIMING_MAP.values()) {
-                timings.checkEnabled();
-            }
-        }
-        needsRecheckEnabled = false;
-    }
-    static void resetTimings() {
-        if (needsFullReset) {
-            // Full resets need to re-check every handlers enabled state
-            // Timing map can be modified from async so we must sync on it.
-            synchronized (TIMING_MAP) {
-                for (TimingHandler timings : TIMING_MAP.values()) {
-                    timings.reset(true);
-                }
-            }
-            Bukkit.getLogger().log(Level.INFO, "Timings Reset");
-            HISTORY.clear();
-            needsFullReset = false;
-            needsRecheckEnabled = false;
-            timingStart = System.currentTimeMillis();
-        } else {
-            // Soft resets only need to act on timings that have done something
-            // Handlers can only be modified on main thread.
-            for (TimingHandler timings : HANDLERS) {
-                timings.reset(false);
-            }
-        }
-
-        HANDLERS.clear();
-        MINUTE_REPORTS.clear();
-
-        TimingHistory.resetTicks(true);
-        historyStart = System.currentTimeMillis();
-    }
-
-    static TimingHandler getHandler(String group, String name, Timing parent, boolean protect) {
-        return TIMING_MAP.get(new TimingIdentifier(group, name, parent, protect));
-    }
-
-
-    /**
-     * Due to access restrictions, we need a helper method to get a Command TimingHandler with String group
-     * <p/>
-     * Plugins should never call this
-     *
-     * @param pluginName Plugin this command is associated with
-     * @param command    Command to get timings for
-     * @return TimingHandler
-     */
-    public static Timing getCommandTiming(String pluginName, Command command) {
-        Plugin plugin = null;
-        final Server server = Bukkit.getServer();
-        if (!("minecraft".equals(pluginName) || "bukkit".equals(pluginName) || "Spigot".equals(pluginName) ||
-            server == null)) {
-            plugin = server.getPluginManager().getPlugin(pluginName);
-            if (plugin == null) {
-                // Plugin is passing custom fallback prefix, try to look up by class loader
-                plugin = getPluginByClassloader(command.getClass());
-            }
-        }
-        if (plugin == null) {
-            return Timings.ofSafe("Command: " + pluginName + ":" + command.getTimingName());
-        }
-
-        return Timings.ofSafe(plugin, "Command: " + pluginName + ":" + command.getTimingName());
-    }
-
-    /**
-     * Looks up the class loader for the specified class, and if it is a PluginClassLoader, return the
-     * Plugin that created this class.
-     *
-     * @param clazz Class to check
-     * @return Plugin if created by a plugin
-     */
-    public static Plugin getPluginByClassloader(Class<?> clazz) {
-        if (clazz == null) {
-            return null;
-        }
-        final ClassLoader classLoader = clazz.getClassLoader();
-        if (classLoader instanceof PluginClassLoader) {
-            PluginClassLoader pluginClassLoader = (PluginClassLoader) classLoader;
-            return pluginClassLoader.getPlugin();
-        }
-        return null;
-    }
-}
diff --git a/src/main/java/org/spigotmc/timings/UnsafeTimingHandler.java b/src/main/java/org/spigotmc/timings/UnsafeTimingHandler.java
deleted file mode 100644
index 971106f..0000000
--- a/src/main/java/org/spigotmc/timings/UnsafeTimingHandler.java
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
- * This file is licensed under the MIT License (MIT).
- *
- * Copyright (c) 2014 Daniel Ennis <http://aikar.co>
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
- * THE SOFTWARE.
- */
-package org.spigotmc.timings;
-
-import org.bukkit.Bukkit;
-
-class UnsafeTimingHandler extends TimingHandler {
-
-    UnsafeTimingHandler(TimingIdentifier id) {
-        super(id);
-    }
-
-    private static void checkThread() {
-        if (!Bukkit.isPrimaryThread()) {
-            throw new IllegalStateException("Calling Timings from Async Operation");
-        }
-    }
-
-    @Override
-    public void startTiming() {
-        checkThread();
-        super.startTiming();
-    }
-
-    @Override
-    public void stopTiming() {
-        checkThread();
-        super.stopTiming();
-    }
-}
diff --git a/src/main/java/org/spigotmc/util/LoadingMap.java b/src/main/java/org/spigotmc/util/LoadingMap.java
index 17aead4..d97211d 100644
--- a/src/main/java/org/spigotmc/util/LoadingMap.java
+++ b/src/main/java/org/spigotmc/util/LoadingMap.java
@@ -26,7 +26,7 @@ package org.spigotmc.util;
 
 import com.google.common.base.Function;
 import org.bukkit.Material;
-import org.spigotmc.timings.TimingHistory;
+import co.aikar.timings.TimingHistory;
 import org.w3c.dom.css.Counter;
 
 import java.lang.reflect.Constructor;
-- 
2.7.0

