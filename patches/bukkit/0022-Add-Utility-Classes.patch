From 5b2cd506f019822d5b865730a4eeff5172d50e27 Mon Sep 17 00:00:00 2001
From: Aikar <aikar@aikar.co>
Date: Wed, 8 Oct 2014 19:02:16 -0400
Subject: [PATCH] Add Utility Classes

Provides Utility classes for Spigot and plugins to use.

EvictingQueue: Backport of Guava v15 Class.
JSONUtil: Provides utility methods for building json-simple documents.
LoadingMap: Create a map with an auto loader to auto load on .get() if missing, similar to a LoadingCache.
MRUMapCache: Caches most recently used key/value for faster lookups on on 1 or 2 key maps.
---
 src/main/java/org/spigotmc/util/EvictingQueue.java | 123 ++++++++
 src/main/java/org/spigotmc/util/JSONUtil.java      | 123 ++++++++
 src/main/java/org/spigotmc/util/LoadingMap.java    | 332 +++++++++++++++++++++
 src/main/java/org/spigotmc/util/MRUMapCache.java   | 100 +++++++
 4 files changed, 678 insertions(+)
 create mode 100644 src/main/java/org/spigotmc/util/EvictingQueue.java
 create mode 100644 src/main/java/org/spigotmc/util/JSONUtil.java
 create mode 100644 src/main/java/org/spigotmc/util/LoadingMap.java
 create mode 100644 src/main/java/org/spigotmc/util/MRUMapCache.java

diff --git a/src/main/java/org/spigotmc/util/EvictingQueue.java b/src/main/java/org/spigotmc/util/EvictingQueue.java
new file mode 100644
index 0000000..c01e3a0
--- /dev/null
+++ b/src/main/java/org/spigotmc/util/EvictingQueue.java
@@ -0,0 +1,123 @@
+/*
+ * Copyright (C) 2012 The Guava Authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.spigotmc.util;
+
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkNotNull;
+
+import com.google.common.collect.ForwardingQueue;
+
+import java.io.Serializable;
+import java.util.ArrayDeque;
+import java.util.Collection;
+import java.util.Queue;
+
+/**
+ * A non-blocking queue which automatically evicts elements from the head of the queue when
+ * attempting to add new elements onto the queue and it is full.
+ *
+ * <p>An evicting queue must be configured with a maximum size. Each time an element is added
+ * to a full queue, the queue automatically removes its head element. This is different from
+ * conventional bounded queues, which either block or reject new elements when full.
+ *
+ * <p>This class is not thread-safe, and does not accept null elements.
+ *
+ * @author Kurt Alfred Kluever
+ * @since 15.0
+ */
+public final class EvictingQueue<E> extends ForwardingQueue<E> implements Serializable {
+
+    private final Queue<E> delegate;
+
+    final int maxSize;
+
+    private EvictingQueue(int maxSize) {
+        checkArgument(maxSize >= 0, "maxSize (%s) must >= 0", maxSize);
+        this.delegate = new ArrayDeque<E>(maxSize);
+        this.maxSize = maxSize;
+    }
+
+    /**
+     * Creates and returns a new evicting queue that will hold up to {@code maxSize} elements.
+     *
+     * <p>When {@code maxSize} is zero, elements will be evicted immediately after being added to the
+     * queue.
+     */
+    public static <E> EvictingQueue<E> create(int maxSize) {
+        return new EvictingQueue<E>(maxSize);
+    }
+
+    /**
+     * Returns the number of additional elements that this queue can accept without evicting;
+     * zero if the queue is currently full.
+     *
+     * @since 16.0
+     */
+    public int remainingCapacity() {
+        return maxSize - size();
+    }
+
+    @Override protected Queue<E> delegate() {
+        return delegate;
+    }
+
+    /**
+     * Adds the given element to this queue. If the queue is currently full, the element at the head
+     * of the queue is evicted to make room.
+     *
+     * @return {@code true} always
+     */
+    @Override public boolean offer(E e) {
+        return add(e);
+    }
+
+    /**
+     * Adds the given element to this queue. If the queue is currently full, the element at the head
+     * of the queue is evicted to make room.
+     *
+     * @return {@code true} always
+     */
+    @Override public boolean add(E e) {
+        checkNotNull(e);  // check before removing
+        if (maxSize == 0) {
+            return true;
+        }
+        if (size() == maxSize) {
+            delegate.remove();
+        }
+        delegate.add(e);
+        return true;
+    }
+
+    @Override public boolean addAll(Collection<? extends E> collection) {
+        return standardAddAll(collection);
+    }
+
+    @Override
+    public boolean contains(Object object) {
+        return delegate().contains(checkNotNull(object));
+    }
+
+    @Override
+    public boolean remove(Object object) {
+        return delegate().remove(checkNotNull(object));
+    }
+
+    // TODO(user): Do we want to checkNotNull each element in containsAll, removeAll, and retainAll?
+
+    private static final long serialVersionUID = 0L;
+}
diff --git a/src/main/java/org/spigotmc/util/JSONUtil.java b/src/main/java/org/spigotmc/util/JSONUtil.java
new file mode 100644
index 0000000..134fb2d
--- /dev/null
+++ b/src/main/java/org/spigotmc/util/JSONUtil.java
@@ -0,0 +1,123 @@
+package org.spigotmc.util;
+
+import com.google.common.base.Function;
+import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
+import org.json.simple.JSONArray;
+import org.json.simple.JSONObject;
+
+import java.util.ArrayList;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * Provides Utility methods that assist with generating JSON Objects
+ */
+@SuppressWarnings({"rawtypes", "SuppressionAnnotation"})
+public final class JSONUtil {
+    private JSONUtil() {}
+
+    /**
+     * Creates a key/value "JSONPair" object
+     * @param key
+     * @param obj
+     * @return
+     */
+    public static JSONPair pair(String key, Object obj) {
+        return new JSONPair(key, obj);
+    }
+
+    public static JSONPair pair(long key, Object obj) {
+        return new JSONPair(String.valueOf(key), obj);
+    }
+
+    /**
+     * Creates a new JSON object from multiple JsonPair key/value pairs
+     * @param data
+     * @return
+     */
+    public static Map createObject(JSONPair... data) {
+        return appendObjectData(new LinkedHashMap(), data);
+    }
+
+    /**
+     * This appends multiple key/value Obj pairs into a JSON Object
+     * @param parent
+     * @param data
+     * @return
+     */
+    public static Map appendObjectData(Map parent, JSONPair... data) {
+        for (JSONPair JSONPair : data) {
+            parent.put(JSONPair.key, JSONPair.val);
+        }
+        return parent;
+    }
+
+    /**
+     * This builds a JSON array from a set of data
+     * @param data
+     * @return
+     */
+    public static List toArray(Object... data) {
+        return Lists.newArrayList(data);
+    }
+
+    /**
+     * These help build a single JSON array using a mapper function
+     * @param collection
+     * @param mapper
+     * @param <E>
+     * @return
+     */
+    public static <E> List toArrayMapper(E[] collection, Function<E, Object> mapper) {
+        return toArrayMapper(Lists.newArrayList(collection), mapper);
+    }
+
+    public static <E> List toArrayMapper(Iterable<E> collection, Function<E, Object> mapper) {
+        List array = Lists.newArrayList();
+        for (E e : collection) {
+            Object object = mapper.apply(e);
+            if (object != null) {
+                array.add(object);
+            }
+        }
+        return array;
+    }
+
+    /**
+     * These help build a single JSON Object from a collection, using a mapper function
+     * @param collection
+     * @param mapper
+     * @param <E>
+     * @return
+     */
+    public static <E> Map toObjectMapper(E[] collection, Function<E, JSONPair> mapper) {
+        return toObjectMapper(Lists.newArrayList(collection), mapper);
+    }
+
+    public static <E> Map toObjectMapper(Iterable<E> collection, Function<E, JSONPair> mapper) {
+        Map object = Maps.newLinkedHashMap();
+        for (E e : collection) {
+            JSONPair JSONPair = mapper.apply(e);
+            if (JSONPair != null) {
+                object.put(JSONPair.key, JSONPair.val);
+            }
+        }
+        return object;
+    }
+
+    /**
+     * Simply stores a key and a value, used internally by many methods below.
+     */
+    @SuppressWarnings("PublicInnerClass")
+    public static class JSONPair {
+        final String key;
+        final Object val;
+
+        JSONPair(String key, Object val) {
+            this.key = key;
+            this.val = val;
+        }
+    }
+}
diff --git a/src/main/java/org/spigotmc/util/LoadingMap.java b/src/main/java/org/spigotmc/util/LoadingMap.java
new file mode 100644
index 0000000..17aead4
--- /dev/null
+++ b/src/main/java/org/spigotmc/util/LoadingMap.java
@@ -0,0 +1,332 @@
+/*
+ * This file is licensed under the MIT License (MIT).
+ *
+ * Copyright (c) 2014 Daniel Ennis <http://aikar.co>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+package org.spigotmc.util;
+
+
+import com.google.common.base.Function;
+import org.bukkit.Material;
+import org.spigotmc.timings.TimingHistory;
+import org.w3c.dom.css.Counter;
+
+import java.lang.reflect.Constructor;
+import java.util.AbstractMap;
+import java.util.Collection;
+import java.util.EnumMap;
+import java.util.HashMap;
+import java.util.IdentityHashMap;
+import java.util.Map;
+import java.util.Set;
+
+/**
+ * Allows you to pass a Loader function that when a key is accessed that doesn't exists,
+ * automatically loads the entry into the map by calling the loader Function.
+ *
+ * .get() Will only return null if the Loader can return null.
+ *
+ * You may pass any backing Map to use.
+ *
+ * This class is not thread safe and should be wrapped with Collections.synchronizedMap on the OUTSIDE of the LoadingMap if needed.
+ *
+ * Do not wrap the backing map with Collections.synchronizedMap.
+ *
+ * @param <K> Key
+ * @param <V> Value
+ */
+public class LoadingMap <K,V> extends AbstractMap<K, V> {
+    private final Map<K, V> backingMap;
+    private final Function<K, V> loader;
+
+    /**
+     * Initializes an auto loading map using specified loader and backing map
+     * @param backingMap
+     * @param loader
+     */
+    public LoadingMap(Map<K, V> backingMap, Function<K, V> loader) {
+        this.backingMap = backingMap;
+        this.loader = loader;
+    }
+
+    /**
+     * Creates a new LoadingMap with the specified map and loader
+     * @param backingMap
+     * @param loader
+     * @param <K>
+     * @param <V>
+     * @return
+     */
+    public static <K, V> Map<K, V> of(Map<K, V> backingMap, Function<K, V> loader) {
+        return new LoadingMap<K, V>(backingMap, loader);
+    }
+
+    /**
+     * Creates a LoadingMap with an auto instantiating loader.
+     *
+     * Will auto construct class of of Value when not found
+     *
+     * Since this uses Reflection, It is more effecient to define your own static loader
+     * than using this helper, but if performance is not critical, this is easier.
+     *
+     * @param backingMap Actual map being used.
+     * @param keyClass Class used for the K generic
+     * @param valueClass Class used for the V generic
+     * @param <K> Key Type of the Map
+     * @param <V> Value Type of the Map
+     * @return Map that auto instantiates on .get()
+     */
+    public static <K, V> Map<K, V> newAutoMap(Map<K, V> backingMap, final Class<? extends K> keyClass,
+                                              final Class<? extends V> valueClass) {
+        return new LoadingMap<K, V>(backingMap, new AutoInstantiatingLoader<K, V>(keyClass, valueClass));
+    }
+    /**
+     * Creates a LoadingMap with an auto instantiating loader.
+     *
+     * Will auto construct class of of Value when not found
+     *
+     * Since this uses Reflection, It is more effecient to define your own static loader
+     * than using this helper, but if performance is not critical, this is easier.
+     *
+     * @param backingMap Actual map being used.
+     * @param valueClass Class used for the V generic
+     * @param <K> Key Type of the Map
+     * @param <V> Value Type of the Map
+     * @return Map that auto instantiates on .get()
+     */
+    public static <K, V> Map<K, V> newAutoMap(Map<K, V> backingMap,
+                                              final Class<? extends V> valueClass) {
+        return newAutoMap(backingMap, null, valueClass);
+    }
+
+    /**
+     * @see #newAutoMap
+     *
+     * new Auto initializing map using a HashMap.
+     * @param keyClass
+     * @param valueClass
+     * @param <K>
+     * @param <V>
+     * @return
+     */
+    public static <K, V> Map<K, V> newHashAutoMap(final Class<? extends K> keyClass, final Class<? extends V> valueClass) {
+        return newAutoMap(new HashMap<K, V>(), keyClass, valueClass);
+    }
+
+    /**
+     * @see #newAutoMap
+     *
+     * new Auto initializing map using a HashMap.
+     * @param valueClass
+     * @param <K>
+     * @param <V>
+     * @return
+     */
+    public static <K, V> Map<K, V> newHashAutoMap(final Class<? extends V> valueClass) {
+        return newHashAutoMap(null, valueClass);
+    }
+
+    /**
+     * @see #newAutoMap
+     *
+     * new Auto initializing map using a HashMap.
+     *
+     * @param keyClass
+     * @param valueClass
+     * @param initialCapacity
+     * @param loadFactor
+     * @param <K>
+     * @param <V>
+     * @return
+     */
+    public static <K, V> Map<K, V> newHashAutoMap(final Class<? extends K> keyClass, final Class<? extends V> valueClass, int initialCapacity, float loadFactor) {
+        return newAutoMap(new HashMap<K, V>(initialCapacity, loadFactor), keyClass, valueClass);
+    }
+
+    /**
+     * @see #newAutoMap
+     *
+     * new Auto initializing map using a HashMap.
+     *
+     * @param valueClass
+     * @param initialCapacity
+     * @param loadFactor
+     * @param <K>
+     * @param <V>
+     * @return
+     */
+    public static <K, V> Map<K, V> newHashAutoMap(final Class<? extends V> valueClass, int initialCapacity, float loadFactor) {
+        return newHashAutoMap(null, valueClass, initialCapacity, loadFactor);
+    }
+
+    /**
+     * Initializes an auto loading map using a HashMap
+     * @param loader
+     * @param <K>
+     * @param <V>
+     * @return
+     */
+    public static <K, V> Map<K, V> newHashMap(Function<K, V> loader) {
+        return new LoadingMap<K, V>(new HashMap<K, V>(), loader);
+    }
+
+    /**
+     * Initializes an auto loading map using a HashMap
+     * @param loader
+     * @param initialCapacity
+     * @param loadFactor
+     * @param <K>
+     * @param <V>
+     * @return
+     */
+    public static <K, V> Map<K, V> newHashMap(Function<K, V> loader, int initialCapacity, float loadFactor) {
+        return new LoadingMap<K, V>(new HashMap<K, V>(initialCapacity, loadFactor), loader);
+    }
+
+    /**
+     * Initializes an auto loading map using an Identity HashMap
+     * @param loader
+     * @param <K>
+     * @param <V>
+     * @return
+     */
+    public static <K, V> Map<K, V> newIdentityHashMap(Function<K, V> loader) {
+        return new LoadingMap<K, V>(new IdentityHashMap<K, V>(), loader);
+    }
+
+    /**
+     * Initializes an auto loading map using an Identity HashMap
+     * @param loader
+     * @param initialCapacity
+     * @param <K>
+     * @param <V>
+     * @return
+     */
+    public static <K, V> Map<K, V> newIdentityHashMap(Function<K, V> loader, int initialCapacity) {
+        return new LoadingMap<K, V>(new IdentityHashMap<K, V>(initialCapacity), loader);
+    }
+
+    @Override
+    public int size() {return backingMap.size();}
+
+    @Override
+    public boolean isEmpty() {return backingMap.isEmpty();}
+
+    @Override
+    public boolean containsKey(Object key) {return backingMap.containsKey(key);}
+
+    @Override
+    public boolean containsValue(Object value) {return backingMap.containsValue(value);}
+
+    @Override
+    public V get(Object key) {
+        V res =  backingMap.get(key);
+        if (res == null && key != null) {
+            res = loader.apply((K) key);
+            if (res != null) {
+                backingMap.put((K) key, res);
+            }
+        }
+        return res;
+    }
+
+    public V put(K key, V value) {return backingMap.put(key, value);}
+
+    @Override
+    public V remove(Object key) {return backingMap.remove(key);}
+
+    public void putAll(Map<? extends K, ? extends V> m) {backingMap.putAll(m);}
+
+    @Override
+    public void clear() {backingMap.clear();}
+
+    @Override
+    public Set<K> keySet() {return backingMap.keySet();}
+
+    @Override
+    public Collection<V> values() {return backingMap.values();}
+
+    @Override
+    public boolean equals(Object o) {return backingMap.equals(o);}
+
+    @Override
+    public int hashCode() {return backingMap.hashCode();}
+
+    @Override
+    public Set<Entry<K, V>> entrySet() {
+        return backingMap.entrySet();
+    }
+
+    public LoadingMap<K, V> clone() {
+        return new LoadingMap<K, V>(backingMap, loader);
+    }
+
+    private static class AutoInstantiatingLoader<K, V> implements Function<K, V> {
+        final Constructor<? extends V> constructor;
+        private final Class<? extends V> valueClass;
+
+        AutoInstantiatingLoader(Class<? extends K> keyClass, Class<? extends V> valueClass) {
+            try {
+                this.valueClass = valueClass;
+                if (keyClass != null) {
+                    constructor = valueClass.getConstructor(keyClass);
+                } else {
+                    constructor = null;
+                }
+            } catch (NoSuchMethodException e) {
+                throw new IllegalStateException(
+                    valueClass.getName() + " does not have a constructor for " + (keyClass != null ? keyClass.getName() : null));
+            }
+        }
+
+        @Override
+        public V apply(K input) {
+            try {
+                return (constructor != null ? constructor.newInstance(input) : valueClass.newInstance());
+            } catch (Exception e) {
+                throw new ExceptionInInitializerError(e);
+            }
+        }
+
+        @Override
+        public int hashCode() {
+            return super.hashCode();
+        }
+
+        @Override
+        public boolean equals(Object object) {
+            return false;
+        }
+    }
+
+    /**
+     * Due to java stuff, you will need to cast it to (Function) for some cases
+     * @param <T>
+     */
+    public abstract static class Feeder <T> implements Function<T, T> {
+        @Override
+        public T apply(Object input) {
+            return apply();
+        }
+
+        public abstract T apply();
+    }
+}
diff --git a/src/main/java/org/spigotmc/util/MRUMapCache.java b/src/main/java/org/spigotmc/util/MRUMapCache.java
new file mode 100644
index 0000000..7b44039
--- /dev/null
+++ b/src/main/java/org/spigotmc/util/MRUMapCache.java
@@ -0,0 +1,100 @@
+/*
+ * This file is licensed under the MIT License (MIT).
+ *
+ * Copyright (c) 2014 Daniel Ennis <http://aikar.co>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+package org.spigotmc.util;
+
+import java.util.AbstractMap;
+import java.util.Collection;
+import java.util.Map;
+import java.util.Set;
+
+/**
+ * Implements a Most Recently Used cache in front of a backing map, to quickly access the last accessed result.
+ * @param <K>
+ * @param <V>
+ */
+public class MRUMapCache<K, V> extends AbstractMap<K, V> {
+    final Map<K, V> backingMap;
+    Object cacheKey;
+    V cacheValue;
+    public MRUMapCache(final Map<K, V> backingMap) {
+        this.backingMap = backingMap;
+    }
+
+    public int size() {return backingMap.size();}
+
+    public boolean isEmpty() {return backingMap.isEmpty();}
+
+    public boolean containsKey(Object key) {
+        return key != null && key.equals(cacheKey) || backingMap.containsKey(key);
+    }
+
+    public boolean containsValue(Object value) {
+        return value != null && value == cacheValue || backingMap.containsValue(value);
+    }
+
+    public V get(Object key) {
+        if (cacheKey != null && cacheKey.equals(key)) {
+            return cacheValue;
+        }
+        cacheKey = key;
+        return cacheValue = backingMap.get(key);
+    }
+
+    public V put(K key, V value) {
+        cacheKey = key;
+        return cacheValue = backingMap.put(key, value);
+    }
+
+    public V remove(Object key) {
+        if (key != null && key.equals(cacheKey)) {
+            cacheKey = null;
+        }
+        return backingMap.remove(key);
+    }
+
+    public void putAll(Map<? extends K, ? extends V> m) {backingMap.putAll(m);}
+
+    public void clear() {
+        cacheKey = null;
+        cacheValue = null;
+        backingMap.clear();
+    }
+
+    public Set<K> keySet() {return backingMap.keySet();}
+
+    public Collection<V> values() {return backingMap.values();}
+
+    public Set<Map.Entry<K, V>> entrySet() {return backingMap.entrySet();}
+
+    /**
+     * Wraps the specified map with a most recently used cache
+     * @param map
+     * @param <K>
+     * @param <V>
+     * @return
+     */
+    public static <K, V> Map<K, V> of(Map<K, V> map) {
+        return new MRUMapCache<K, V>(map);
+    }
+}
-- 
1.9.1

