From b118166c17d0b9574d7d44a89f7fe5344c9b7e87 Mon Sep 17 00:00:00 2001
From: Aikar <aikar@aikar.co>
Date: Mon, 4 Mar 2013 23:35:02 -0500
Subject: [PATCH] Block Meta API

This adds an API for getting and setting PERSISTENT MetaData on a block level.

Meta is is provided in a simple Map/List setup and does not expose raw NBT access.
---
 .../java/com/empireminecraft/BlockMetaApi.java     | 120 ++++++++++
 .../net/minecraft/server/BlockMetaApiAccessor.java | 260 +++++++++++++++++++++
 src/main/java/net/minecraft/server/Chunk.java      |   1 +
 .../net/minecraft/server/ChunkRegionLoader.java    |  12 +-
 4 files changed, 388 insertions(+), 5 deletions(-)
 create mode 100644 src/main/java/com/empireminecraft/BlockMetaApi.java
 create mode 100644 src/main/java/net/minecraft/server/BlockMetaApiAccessor.java

diff --git a/src/main/java/com/empireminecraft/BlockMetaApi.java b/src/main/java/com/empireminecraft/BlockMetaApi.java
new file mode 100644
index 0000000..9c736f4
--- /dev/null
+++ b/src/main/java/com/empireminecraft/BlockMetaApi.java
@@ -0,0 +1,120 @@
+package com.empireminecraft;
+
+import net.minecraft.server.BlockMetaApiAccessor;
+import org.bukkit.Location;
+import org.bukkit.craftbukkit.CraftChunk;
+import org.bukkit.inventory.ItemStack;
+
+import java.security.InvalidParameterException;
+import java.util.ArrayList;
+import java.util.HashMap;
+
+public class BlockMetaApi {
+    /**
+     * Gets all block meta for a block.
+     * @param loc
+     * @return
+     */
+    public static MetaMap getBlockMeta(Location loc) {
+        return BlockMetaApiAccessor.getMetaMap((CraftChunk) loc.getChunk(),
+            loc.getBlockX(),
+            loc.getBlockY(),
+            loc.getBlockZ());
+    }
+
+    /**
+     * Checks if meta by the specified key exists for this block.
+     * @param loc
+     * @param key
+     * @return
+     */
+    public static boolean hasMeta(Location loc, String key) {
+        return getMeta(loc, key) != null;
+    }
+
+    /**
+     * Gets a specific meta value for the specified block
+     * @param loc
+     * @param key
+     * @param <T>
+     * @return
+     */
+    public static <T> T getMeta(Location loc, String key) {
+        return (T) BlockMetaApiAccessor.getMeta((CraftChunk) loc.getChunk(),
+            loc.getBlockX(),
+            loc.getBlockY(),
+            loc.getBlockZ(),
+            key);
+    }
+
+    /**
+     * Sets block meta for the specified block
+     * @param loc
+     * @param key
+     * @param val
+     * @param <T>
+     * @return
+     */
+    public static <T> T setMeta(Location loc, String key, Object val) {
+        return (T) BlockMetaApiAccessor.setMeta((CraftChunk) loc.getChunk(),
+            loc.getBlockX(),
+            loc.getBlockY(),
+            loc.getBlockZ(),
+            key,
+            val);
+    }
+
+    /**
+     * Checks if the passed object can be stored as Meta Data
+     * @param value
+     * @return
+     */
+    public static boolean isValidMeta(Object value) {
+        return (value instanceof String) || (value instanceof Long) ||
+            (value instanceof Integer) || (value instanceof ItemStack) ||
+            (value instanceof Float) || (value instanceof Double) ||
+            (value instanceof MetaMap) || (value instanceof MetaList);
+    }
+
+    /**
+     * A type protected array for storing meta values
+     */
+    public static class MetaList<T> extends ArrayList<T> {
+        @Override
+        public boolean add(T o) {
+            if (!isValidMeta(o)) {
+                throw new InvalidParameterException();
+            }
+            return super.add(o);
+        }
+
+        @Override
+        public T set(int index, T element) {
+            if (!isValidMeta(element)) {
+                throw new InvalidParameterException();
+            }
+            return super.set(index, element);
+        }
+
+        @Override
+        public void add(int index, T element) {
+            if (!isValidMeta(element)) {
+                throw new InvalidParameterException();
+            }
+            super.add(index, element);
+        }
+    }
+
+    /**
+     * A type protected hashmap for storing meta values
+     */
+    public static class MetaMap extends HashMap<String, Object> {
+        @Override
+        public Object put(String key, Object value) {
+            if (!isValidMeta(value)) {
+                throw new InvalidParameterException();
+            }
+            return super.put(key, value);
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/BlockMetaApiAccessor.java b/src/main/java/net/minecraft/server/BlockMetaApiAccessor.java
new file mode 100644
index 0000000..dd143e9
--- /dev/null
+++ b/src/main/java/net/minecraft/server/BlockMetaApiAccessor.java
@@ -0,0 +1,260 @@
+package net.minecraft.server;
+
+import com.empireminecraft.BlockMetaApi;
+import org.bukkit.craftbukkit.CraftChunk;
+import org.bukkit.craftbukkit.inventory.CraftItemStack;
+
+import java.util.*;
+
+import static com.empireminecraft.BlockMetaApi.*;
+
+public class BlockMetaApiAccessor {
+
+    /**
+     * Util for getting a MetaMap by location
+     * @param chunk
+     * @param x
+     * @param y
+     * @param z
+     * @return
+     */
+    public static MetaMap getMetaMap(CraftChunk chunk, int x, int y, int z) {
+        ChunkMeta meta = chunk.getHandle().chunkMeta;
+        ChunkCoordinates coords = new ChunkCoordinates(x, y, z);
+        return meta.get(coords);
+    }
+
+    /**
+     * Gets metadata at the specific location and key
+     * @param chunk
+     * @param x
+     * @param y
+     * @param z
+     * @param key
+     * @return
+     */
+    public static Object getMeta(CraftChunk chunk, int x, int y, int z, String key) {
+        MetaMap metaMap = getMetaMap(chunk, x, y, z);
+        if (metaMap != null) {
+            return metaMap.get(key);
+        }
+        return null;
+    }
+
+    /**
+     * Sets metadata at the specific location and key
+     * @param chunk
+     * @param x
+     * @param y
+     * @param z
+     * @param key
+     * @param value
+     * @return
+     */
+    public static Object setMeta(CraftChunk chunk, int x, int y, int z, String key, Object value) {
+        MetaMap metaMap = getMetaMap(chunk, x, y, z);
+        if (metaMap == null && value != null) {
+            metaMap = new MetaMap();
+            ChunkMeta meta = chunk.getHandle().chunkMeta;
+            ChunkCoordinates coords = new ChunkCoordinates(x, y, z);
+            meta.put(coords, metaMap);
+        }
+        if (value == null) {
+            if (metaMap != null) {
+                return metaMap.remove(key);
+            }
+            return null;
+        }
+        return metaMap.put(key, value);
+    }
+
+    /**
+     * Saves this chunks Meta Data into NBT
+     * @param cmp
+     * @param chunkMeta
+     */
+    static void saveChunkMetaNbt(NBTTagCompound cmp, ChunkMeta chunkMeta) {
+        NBTTagCompound meta = new NBTTagCompound();
+        for (Map.Entry<ChunkCoordinates, MetaMap> entry : chunkMeta.entrySet()) {
+            ChunkCoordinates coords = entry.getKey();
+            MetaMap list = entry.getValue();
+            NBTTagCompound metalist = getCompoundFromMetaList(list);
+            if (!metalist.isEmpty()) {
+                meta.set(getCoordAsStr(coords), metalist);
+            }
+        }
+        if (!meta.isEmpty()) {
+            cmp.set("ChunkMeta", meta);
+        }
+    }
+
+    /**
+     * Loads this chunks Meta Data from NBT
+     * @param cmp
+     * @param chunk
+     */
+    static void loadChunkMetaNbt(NBTTagCompound cmp, Chunk chunk) {
+        ChunkMeta meta = chunk.chunkMeta;
+        if (cmp.hasKey("ChunkMeta")) {
+            NBTTagCompound chunkMeta = cmp.getCompound("ChunkMeta");
+            for (NBTTagCompound e : (Collection <NBTTagCompound>) chunkMeta.c()) {
+                MetaMap metalist = getMetaListFromCompound(e);
+                if (!metalist.isEmpty()) {
+                    meta.put(getStrAsCoord(e.getName()), metalist);
+                }
+            }
+        }
+    }
+
+    /**
+     * Converts an Object into NBT
+     * @param value
+     * @return
+     */
+    private static NBTBase getNbtFromObject(Object value) {
+        if (value instanceof String) {
+            return new NBTTagString("string", (String) value);
+        } else if (value instanceof ItemStack || value instanceof org.bukkit.inventory.ItemStack) {
+            ItemStack item;
+            if (value instanceof org.bukkit.inventory.ItemStack) {
+                item = CraftItemStack.asNMSCopy((org.bukkit.inventory.ItemStack) value);
+            } else {
+                item = (ItemStack) value;
+            }
+            NBTTagCompound itemnbt = new NBTTagCompound();
+            itemnbt.setString("MetaType", "Item");
+            return item.save(itemnbt);
+        } else if (value instanceof Long) {
+            return new NBTTagLong("long", (Long) value);
+        } else if (value instanceof Integer) {
+            return new NBTTagInt("int", (Integer) value);
+        } else if (value instanceof Double) {
+            return new NBTTagDouble("double", (Double) value);
+        } else if (value instanceof Float) {
+            return new NBTTagFloat("float", (Float) value);
+        } else if (value instanceof MetaMap) {
+            return getCompoundFromMetaList((MetaMap) value);
+        } else if (value instanceof MetaList) {
+            NBTTagList list = new NBTTagList();
+            for (Object obj : (List) value) {
+                NBTBase add = getNbtFromObject(obj);
+                if (add != null) {
+                    list.add(add);
+                }
+            }
+            return list;
+        }
+
+        return null;
+    }
+
+    /**
+     * Converts NBT into an Object
+     * @param nbt
+     * @return
+     */
+    private static Object getObjectFromNbt(NBTBase nbt) {
+        if (nbt instanceof NBTTagString) {
+            return ((NBTTagString) nbt).data;
+        } else if (nbt instanceof NBTTagInt) {
+            return ((NBTTagInt) nbt).data;
+        } else if (nbt instanceof NBTTagLong) {
+            return ((NBTTagLong) nbt).data;
+        } else if (nbt instanceof NBTTagFloat) {
+            return ((NBTTagFloat) nbt).data;
+        } else if (nbt instanceof NBTTagDouble) {
+            return ((NBTTagDouble) nbt).data;
+        } else if (nbt instanceof NBTTagList) {
+            ArrayList<Object> list = new ArrayList<Object>();
+            NBTTagList nbtlist = (NBTTagList) nbt;
+            for (int i = 0; i < nbtlist.size(); i++) {
+                list.add(nbtlist.get(i));
+            }
+            return list;
+        } else if (nbt instanceof NBTTagCompound) {
+            NBTTagCompound cmp = (NBTTagCompound) nbt;
+            if (cmp.hasKey("MetaType")) {
+                String type = cmp.getString("MetaType");
+                if ("Item".equals(type)) {
+                    return CraftItemStack.asBukkitCopy(ItemStack.createStack(cmp));
+                } else if ("MetaMap".equals(type)) {
+                    return getMetaListFromCompound(cmp);
+                }
+            }
+        }
+        return null;
+    }
+
+    /**
+     * Converts a NBTTagCompound to a MetaMap
+     * @param cmp
+     * @return
+     */
+    private static MetaMap getMetaListFromCompound(NBTTagCompound cmp) {
+        MetaMap list = new MetaMap();
+        for (Object entryobj : cmp.c()) {
+            NBTBase nbt = (NBTBase) entryobj;
+            if (nbt != null) {
+                list.put(nbt.getName(), getObjectFromNbt(nbt));
+            }
+        }
+        return list;
+    }
+
+    /**
+     * Converts a MetaMap into an NBTTagCompount
+     * @param list
+     * @return
+     */
+    private static NBTTagCompound getCompoundFromMetaList(MetaMap list) {
+        NBTTagCompound cmp = new NBTTagCompound();
+        cmp.setString("MetaType", "MetaMap");
+        for (Map.Entry<String, Object> entry : list.entrySet()) {
+            NBTBase add = getNbtFromObject(entry.getValue());
+            if (add != null) {
+                cmp.set(entry.getKey(), add);
+            }
+        }
+        return cmp;
+    }
+
+    /**
+     * Translates ChunkCoordinates to a String form
+     * @param coords
+     * @return
+     */
+    static String getCoordAsStr(ChunkCoordinates coords) {
+        if (coords == null) {
+            return null;
+        }
+        return "" + coords.x + ":" + coords.y + ":" + coords.z;
+    }
+
+    /**
+     * Parses a string into ChunkCoordinates
+     * @param loc
+     * @return
+     */
+    static ChunkCoordinates getStrAsCoord(String loc) {
+        if (loc != null)  {
+            String[] args = loc.split(":", 3);
+            if (args.length == 3) {
+                int x = (int) Math.floor(Integer.parseInt(args[0]));
+                int y = (int) Math.floor(Integer.parseInt(args[1]));
+                int z = (int) Math.floor(Integer.parseInt(args[2]));
+                return new ChunkCoordinates(x, y, z);
+            }
+        }
+        return null;
+    }
+
+    static class PendingChunkToSaveWithMeta extends PendingChunkToSave {
+        public final ChunkMeta meta;
+        public PendingChunkToSaveWithMeta(ChunkCoordIntPair chunkcoordintpair, NBTTagCompound nbttagcompound, ChunkMeta meta) {
+            super(chunkcoordintpair, nbttagcompound);
+            this.meta = meta;
+        }
+    }
+
+    public static class ChunkMeta extends HashMap<ChunkCoordinates, MetaMap> {}
+}
diff --git a/src/main/java/net/minecraft/server/Chunk.java b/src/main/java/net/minecraft/server/Chunk.java
index 720a536..250828b 100644
--- a/src/main/java/net/minecraft/server/Chunk.java
+++ b/src/main/java/net/minecraft/server/Chunk.java
@@ -73,6 +73,7 @@ public class Chunk {
 
     public org.bukkit.Chunk bukkitChunk;
     public boolean mustSave;
+    public BlockMetaApiAccessor.ChunkMeta chunkMeta = new BlockMetaApiAccessor.ChunkMeta(); // EMC
     // CraftBukkit end
 
     public Chunk(World world, byte[] abyte, int i, int j) {
diff --git a/src/main/java/net/minecraft/server/ChunkRegionLoader.java b/src/main/java/net/minecraft/server/ChunkRegionLoader.java
index 2e72ab5..a901bc2 100644
--- a/src/main/java/net/minecraft/server/ChunkRegionLoader.java
+++ b/src/main/java/net/minecraft/server/ChunkRegionLoader.java
@@ -104,6 +104,7 @@ public class ChunkRegionLoader implements IAsyncChunkSaver, IChunkLoader {
             }
 
             // CraftBukkit start
+            BlockMetaApiAccessor.loadChunkMetaNbt(nbttagcompound, chunk); // EMC
             Object[] data = new Object[2];
             data[0] = chunk;
             data[1] = nbttagcompound;
@@ -127,18 +128,18 @@ public class ChunkRegionLoader implements IAsyncChunkSaver, IChunkLoader {
 
             nbttagcompound.set("Level", nbttagcompound1);
             this.a(chunk, world, nbttagcompound1);
-            this.a(chunk.l(), nbttagcompound);
+            this.a(chunk.l(), nbttagcompound, chunk.chunkMeta); // EMC
         } catch (Exception exception) {
             exception.printStackTrace();
         }
     }
 
-    protected void a(ChunkCoordIntPair chunkcoordintpair, NBTTagCompound nbttagcompound) {
+    protected void a(ChunkCoordIntPair chunkcoordintpair, NBTTagCompound nbttagcompound, BlockMetaApiAccessor.ChunkMeta meta) { // EMC
         Object object = this.c;
 
         synchronized (this.c) {
             // Spigot start
-            if (this.pendingSaves.put(chunkcoordintpair, new PendingChunkToSave(chunkcoordintpair, nbttagcompound)) != null) {
+            if (this.pendingSaves.put(chunkcoordintpair, new BlockMetaApiAccessor.PendingChunkToSaveWithMeta(chunkcoordintpair, nbttagcompound, meta)) != null) { // EMC
                 return;
             }
             /*
@@ -159,7 +160,7 @@ public class ChunkRegionLoader implements IAsyncChunkSaver, IChunkLoader {
     }
 
     public boolean c() {
-        PendingChunkToSave pendingchunktosave = null;
+        BlockMetaApiAccessor.PendingChunkToSaveWithMeta pendingchunktosave = null; // EMC
         Object object = this.c;
 
         synchronized (this.c) {
@@ -167,7 +168,8 @@ public class ChunkRegionLoader implements IAsyncChunkSaver, IChunkLoader {
             if (this.pendingSaves.isEmpty()) {
                 return false;
             }
-            pendingchunktosave = this.pendingSaves.values().iterator().next();
+            pendingchunktosave = (BlockMetaApiAccessor.PendingChunkToSaveWithMeta) this.pendingSaves.values().iterator().next(); // EMC
+            BlockMetaApiAccessor.saveChunkMetaNbt(pendingchunktosave.b, pendingchunktosave.meta); // EMC
             this.pendingSaves.remove(pendingchunktosave.a);
             /*
             if (this.a.isEmpty()) {
-- 
1.8.1.5

