From d95665f16b97051563330ea38bcb5359f3171455 Mon Sep 17 00:00:00 2001
From: md_5 <md_5@bigpond.com>
Date: Fri, 5 Sep 2014 18:31:29 -0400
Subject: [PATCH] Spigot

---
 README.md                                          |  14 +-
 pom.xml                                            |  76 +--
 .../java/net/minecraft/server/AttributeRanged.java |  42 ++
 .../net/minecraft/server/BanEntrySerializer.java   |  89 +++
 .../java/net/minecraft/server/BiomeDecorator.java  | 286 +++++++++
 src/main/java/net/minecraft/server/Block.java      |  20 +-
 src/main/java/net/minecraft/server/BlockAnvil.java |  88 +++
 .../net/minecraft/server/BlockBrewingStand.java    | 115 ++++
 .../java/net/minecraft/server/BlockCactus.java     |   2 +-
 src/main/java/net/minecraft/server/BlockCrops.java |   2 +-
 .../java/net/minecraft/server/BlockFlowerPot.java  | 187 ++++++
 src/main/java/net/minecraft/server/BlockGrass.java |   3 +-
 .../java/net/minecraft/server/BlockHopper.java     |  24 +
 .../java/net/minecraft/server/BlockMushroom.java   |   2 +-
 src/main/java/net/minecraft/server/BlockMycel.java |   3 +-
 .../java/net/minecraft/server/BlockPortal.java     |   2 +-
 .../net/minecraft/server/BlockRedstoneTorch.java   |   2 +-
 src/main/java/net/minecraft/server/BlockReed.java  |   2 +-
 .../java/net/minecraft/server/BlockSapling.java    |   2 +-
 src/main/java/net/minecraft/server/BlockStem.java  |   2 +-
 src/main/java/net/minecraft/server/BlockTNT.java   |  85 +++
 src/main/java/net/minecraft/server/Chunk.java      |  96 ++-
 .../net/minecraft/server/ChunkProviderServer.java  |   4 +
 .../net/minecraft/server/ChunkRegionLoader.java    |  56 +-
 .../server/CommandBlockListenerAbstract.java       |   8 +
 .../net/minecraft/server/CommandDispatcher.java    |  94 +++
 .../minecraft/server/ContainerEnchantTable.java    |   6 +-
 .../java/net/minecraft/server/DataWatcher.java     | 392 +++++++++++++
 .../java/net/minecraft/server/DedicatedServer.java |  38 +-
 .../minecraft/server/DispenseBehaviorBonemeal.java |   2 +-
 .../minecraft/server/DispenseBehaviorFireball.java |   2 +-
 src/main/java/net/minecraft/server/EmptyClass.java |   3 +
 .../net/minecraft/server/EnchantmentManager.java   | 360 ++++++++++++
 .../server/EnchantmentModifierArthropods.java      |  17 +
 .../server/EnchantmentModifierDamage.java          |  17 +
 .../server/EnchantmentModifierProtection.java      |  17 +
 .../server/EnchantmentModifierThorns.java          |  17 +
 src/main/java/net/minecraft/server/Entity.java     |  43 +-
 .../java/net/minecraft/server/EntityAgeable.java   |  31 +-
 .../java/net/minecraft/server/EntityAnimal.java    | 271 +++++++++
 .../java/net/minecraft/server/EntityArrow.java     |  16 +-
 src/main/java/net/minecraft/server/EntityBoat.java |   2 +-
 .../net/minecraft/server/EntityEnderDragon.java    |   1 +
 .../java/net/minecraft/server/EntityEnderman.java  |   7 +-
 .../net/minecraft/server/EntityFallingBlock.java   |   2 +
 .../java/net/minecraft/server/EntityFireball.java  |   9 +
 .../java/net/minecraft/server/EntityFireworks.java |   9 +
 .../java/net/minecraft/server/EntityHanging.java   |   2 +-
 .../java/net/minecraft/server/EntityHorse.java     |   8 +
 .../java/net/minecraft/server/EntityHuman.java     |  35 +-
 .../net/minecraft/server/EntityInsentient.java     |  12 +
 src/main/java/net/minecraft/server/EntityItem.java |  42 +-
 .../java/net/minecraft/server/EntityItemFrame.java |   9 +
 .../java/net/minecraft/server/EntityLightning.java |  12 +-
 .../java/net/minecraft/server/EntityLiving.java    |  26 +-
 .../minecraft/server/EntityMinecartAbstract.java   |  37 +-
 .../minecraft/server/EntityMinecartContainer.java  |   6 +
 .../java/net/minecraft/server/EntityOcelot.java    |  28 +-
 .../java/net/minecraft/server/EntityPlayer.java    |  64 +-
 .../java/net/minecraft/server/EntityTNTPrimed.java |   1 +
 .../java/net/minecraft/server/EntityTracker.java   |   3 +
 .../net/minecraft/server/EntityTrackerEntry.java   |  19 +-
 .../java/net/minecraft/server/EntityWither.java    |   1 +
 .../net/minecraft/server/EntityWitherSkull.java    |  10 +-
 .../java/net/minecraft/server/EntityZombie.java    |   4 +-
 src/main/java/net/minecraft/server/Explosion.java  |   5 +-
 .../java/net/minecraft/server/FoodMetaData.java    |   2 +-
 .../net/minecraft/server/GameProfileBanEntry.java  |  57 ++
 .../net/minecraft/server/GenericAttributes.java    | 107 ++++
 .../net/minecraft/server/HandshakeListener.java    |  37 +-
 src/main/java/net/minecraft/server/IRecipe.java    |   2 +
 src/main/java/net/minecraft/server/IntCache.java   |  63 ++
 .../java/net/minecraft/server/ItemFishingRod.java  |   1 +
 src/main/java/net/minecraft/server/ItemSkull.java  | 117 ++++
 src/main/java/net/minecraft/server/ItemStack.java  |  80 ++-
 .../java/net/minecraft/server/ItemWorldMap.java    |   2 +-
 src/main/java/net/minecraft/server/JsonList.java   |  11 +
 .../java/net/minecraft/server/LoginListener.java   |  45 +-
 .../java/net/minecraft/server/MerchantRecipe.java  | 101 ++++
 .../net/minecraft/server/MerchantRecipeList.java   |  96 +++
 .../java/net/minecraft/server/MinecraftServer.java | 143 ++++-
 .../net/minecraft/server/MobSpawnerAbstract.java   |  37 +-
 src/main/java/net/minecraft/server/NBTBase.java    |  83 +++
 .../minecraft/server/NBTCompressedStreamTools.java | 132 +++++
 .../java/net/minecraft/server/NBTTagByteArray.java |  58 ++
 .../java/net/minecraft/server/NBTTagIntArray.java  |  74 +++
 src/main/java/net/minecraft/server/NBTTagList.java | 167 ++++++
 .../server/NameReferencingFileConverter.java       |   2 +-
 .../java/net/minecraft/server/NetworkManager.java  |  55 +-
 .../net/minecraft/server/NextTickListEntry.java    |  60 ++
 .../java/net/minecraft/server/NibbleArray.java     |  40 ++
 .../java/net/minecraft/server/OldChunkLoader.java  | 120 ++++
 src/main/java/net/minecraft/server/Packet.java     |  31 +-
 .../net/minecraft/server/PacketDataSerializer.java | 168 +++++-
 .../java/net/minecraft/server/PacketDecoder.java   |  49 ++
 .../java/net/minecraft/server/PacketEncoder.java   |  45 ++
 .../server/PacketHandshakingInSetProtocol.java     |   2 +-
 .../minecraft/server/PacketLoginOutSuccess.java    |  44 ++
 .../minecraft/server/PacketPlayInArmAnimation.java |  42 ++
 .../net/minecraft/server/PacketPlayInBlockDig.java |  67 +++
 .../minecraft/server/PacketPlayInBlockPlace.java   |  88 +++
 .../net/minecraft/server/PacketPlayInChat.java     |  20 +-
 .../server/PacketPlayInCustomPayload.java          |  10 +-
 .../minecraft/server/PacketPlayInEntityAction.java |  48 ++
 .../minecraft/server/PacketPlayInKeepAlive.java    |  40 ++
 .../net/minecraft/server/PacketPlayInPosition.java |  37 ++
 .../minecraft/server/PacketPlayInPositionLook.java |  42 ++
 .../net/minecraft/server/PacketPlayInSettings.java |  83 +++
 .../minecraft/server/PacketPlayInSteerVehicle.java |  58 ++
 .../minecraft/server/PacketPlayInTabComplete.java  |  48 ++
 .../minecraft/server/PacketPlayInUpdateSign.java   |  80 +++
 .../minecraft/server/PacketPlayInUseEntity.java    |  51 ++
 .../minecraft/server/PacketPlayInWindowClick.java  |  67 +++
 .../net/minecraft/server/PacketPlayOutBed.java     |  49 ++
 .../minecraft/server/PacketPlayOutBlockAction.java |  56 ++
 .../server/PacketPlayOutBlockBreakAnimation.java   |  52 ++
 .../minecraft/server/PacketPlayOutBlockChange.java |  21 +-
 .../net/minecraft/server/PacketPlayOutChat.java    |  53 ++
 .../net/minecraft/server/PacketPlayOutCollect.java |  41 ++
 .../server/PacketPlayOutCustomPayload.java         |  59 ++
 .../net/minecraft/server/PacketPlayOutEntity.java  |  50 ++
 .../server/PacketPlayOutEntityDestroy.java         |  61 ++
 .../server/PacketPlayOutEntityEffect.java          |  56 ++
 .../server/PacketPlayOutEntityEquipment.java       |  47 ++
 .../server/PacketPlayOutEntityHeadRotation.java    |  44 ++
 .../minecraft/server/PacketPlayOutEntityLook.java  |  44 ++
 .../server/PacketPlayOutEntityMetadata.java        |  46 ++
 .../server/PacketPlayOutEntityTeleport.java        |  73 +++
 .../server/PacketPlayOutEntityVelocity.java        |  82 +++
 .../minecraft/server/PacketPlayOutExperience.java  |  45 ++
 .../minecraft/server/PacketPlayOutKeepAlive.java   |  40 ++
 .../net/minecraft/server/PacketPlayOutLogin.java   |  77 +++
 .../net/minecraft/server/PacketPlayOutMap.java     |  71 +++
 .../minecraft/server/PacketPlayOutMapChunk.java    | 245 ++++++++
 .../server/PacketPlayOutMapChunkBulk.java          |  67 ++-
 .../server/PacketPlayOutMultiBlockChange.java      | 115 ++++
 .../server/PacketPlayOutNamedEntitySpawn.java      |  22 +-
 .../server/PacketPlayOutOpenSignEditor.java        |  44 ++
 .../minecraft/server/PacketPlayOutOpenWindow.java  | 114 ++++
 .../minecraft/server/PacketPlayOutPlayerInfo.java  | 146 +++++
 .../minecraft/server/PacketPlayOutPosition.java    |  56 ++
 .../server/PacketPlayOutRelEntityMove.java         |  44 ++
 .../server/PacketPlayOutRelEntityMoveLook.java     |  53 ++
 .../server/PacketPlayOutRemoveEntityEffect.java    |  39 ++
 .../server/PacketPlayOutScoreboardObjective.java   |  51 ++
 .../server/PacketPlayOutScoreboardScore.java       |  66 +++
 .../server/PacketPlayOutScoreboardTeam.java        | 110 ++++
 .../net/minecraft/server/PacketPlayOutSetSlot.java |  36 ++
 .../minecraft/server/PacketPlayOutSpawnEntity.java | 168 ++++++
 .../server/PacketPlayOutSpawnEntityLiving.java     | 108 ++++
 .../server/PacketPlayOutSpawnEntityPainting.java   |  84 +++
 .../server/PacketPlayOutSpawnPosition.java         |  13 +-
 .../server/PacketPlayOutTileEntityData.java        |  52 ++
 .../server/PacketPlayOutUpdateAttributes.java      |  94 +++
 .../server/PacketPlayOutUpdateHealth.java          |  44 ++
 .../minecraft/server/PacketPlayOutUpdateSign.java  |  66 +++
 .../minecraft/server/PacketPlayOutWindowItems.java |  54 ++
 .../minecraft/server/PacketPlayOutWorldEvent.java  |  56 ++
 .../server/PacketPlayOutWorldParticles.java        | 174 ++++++
 .../net/minecraft/server/PacketStatusListener.java |   9 +-
 .../PathfinderGoalNearestAttackableTarget.java     |  52 ++
 .../net/minecraft/server/PersistentCollection.java | 185 ++++++
 .../java/net/minecraft/server/PlayerChunk.java     |  17 +-
 .../java/net/minecraft/server/PlayerChunkMap.java  |   6 +-
 .../net/minecraft/server/PlayerConnection.java     | 156 ++++-
 .../minecraft/server/PlayerInteractManager.java    |   8 +
 src/main/java/net/minecraft/server/PlayerList.java |  72 ++-
 .../java/net/minecraft/server/PlayerSelector.java  |   6 +-
 .../java/net/minecraft/server/PropertyManager.java |   2 +-
 .../java/net/minecraft/server/RegionFileCache.java |  67 +++
 .../minecraft/server/RemoteControlListener.java    | 107 ++++
 .../net/minecraft/server/ServerConnection.java     | 113 ++++
 .../minecraft/server/ServerConnectionChannel.java  |  37 ++
 .../minecraft/server/ServerStatisticManager.java   | 212 +++++++
 .../java/net/minecraft/server/ShapedRecipes.java   |   9 +-
 .../net/minecraft/server/ShapelessRecipes.java     |   9 +-
 .../java/net/minecraft/server/SpawnerCreature.java |  35 +-
 .../net/minecraft/server/StructureGenerator.java   | 227 ++++++++
 .../minecraft/server/ThreadPlayerLookupUUID.java   |  93 +--
 src/main/java/net/minecraft/server/TileEntity.java |  49 +-
 .../net/minecraft/server/TileEntityEnderChest.java |  84 +++
 .../net/minecraft/server/TileEntityHopper.java     | 128 +++-
 .../minecraft/server/TileEntityLightDetector.java  |  15 +
 .../java/net/minecraft/server/TileEntitySkull.java |  96 ++-
 src/main/java/net/minecraft/server/UserCache.java  | 252 ++++++++
 .../java/net/minecraft/server/UserCacheEntry.java  |  34 ++
 .../java/net/minecraft/server/WatchableObject.java |  44 ++
 src/main/java/net/minecraft/server/World.java      | 310 ++++++++--
 .../net/minecraft/server/WorldGenForestTree.java   | 171 ++++++
 .../net/minecraft/server/WorldGenGroundBush.java   |   2 +-
 .../net/minecraft/server/WorldGenLargeFeature.java |  97 ++++
 .../net/minecraft/server/WorldGenPackedIce2.java   | 101 ++++
 .../java/net/minecraft/server/WorldGenVillage.java |  75 +++
 src/main/java/net/minecraft/server/WorldMap.java   |   2 +-
 .../net/minecraft/server/WorldMapHumanTracker.java |  24 +-
 .../java/net/minecraft/server/WorldNBTStorage.java |  24 +-
 .../java/net/minecraft/server/WorldServer.java     |  48 +-
 .../java/org/bukkit/craftbukkit/CraftEffect.java   |   2 +
 .../java/org/bukkit/craftbukkit/CraftServer.java   | 195 +++++--
 .../java/org/bukkit/craftbukkit/CraftWorld.java    | 115 +++-
 src/main/java/org/bukkit/craftbukkit/Main.java     |  72 ++-
 .../java/org/bukkit/craftbukkit/SpigotTimings.java | 173 ++++++
 .../org/bukkit/craftbukkit/block/CraftSign.java    |   8 +-
 .../craftbukkit/chunkio/ChunkIOProvider.java       |   2 +
 .../craftbukkit/command/ServerCommandSender.java   |  11 +-
 .../org/bukkit/craftbukkit/entity/CraftArrow.java  |  22 +
 .../org/bukkit/craftbukkit/entity/CraftEntity.java |  25 +-
 .../craftbukkit/entity/CraftLightningStrike.java   |  20 +
 .../org/bukkit/craftbukkit/entity/CraftPlayer.java | 144 ++++-
 .../craftbukkit/event/CraftEventFactory.java       |  25 +-
 .../craftbukkit/inventory/CraftMetaBook.java       |  10 +-
 .../craftbukkit/inventory/CraftMetaFirework.java   |   4 +-
 .../craftbukkit/inventory/CraftMetaItem.java       | 203 ++++++-
 .../craftbukkit/inventory/CraftMetaSkull.java      |  30 +-
 .../org/bukkit/craftbukkit/map/CraftMapView.java   |   2 +-
 .../craftbukkit/scheduler/CraftScheduler.java      |   4 +-
 .../bukkit/craftbukkit/scheduler/CraftTask.java    |  31 +-
 .../craftbukkit/scoreboard/CraftObjective.java     |   1 +
 .../bukkit/craftbukkit/scoreboard/CraftScore.java  |  11 +-
 .../scoreboard/CraftScoreboardManager.java         |   1 +
 .../bukkit/craftbukkit/scoreboard/CraftTeam.java   |  43 +-
 .../bukkit/craftbukkit/util/CraftChatMessage.java  |   7 +-
 .../java/org/bukkit/craftbukkit/util/LongHash.java |   2 +-
 .../org/bukkit/craftbukkit/util/LongHashSet.java   |  33 +-
 .../bukkit/craftbukkit/util/LongObjectHashMap.java |  15 +
 .../org/bukkit/craftbukkit/util/Versioning.java    |   2 +-
 src/main/java/org/spigotmc/ActivationRange.java    | 296 ++++++++++
 src/main/java/org/spigotmc/AntiXray.java           | 257 ++++++++
 src/main/java/org/spigotmc/AsyncCatcher.java       |  17 +
 .../org/spigotmc/CachedMojangAPIConnection.java    | 145 +++++
 .../org/spigotmc/CachedStreamHandlerFactory.java   | 117 ++++
 src/main/java/org/spigotmc/FlatMap.java            |  64 ++
 src/main/java/org/spigotmc/LimitStream.java        |  39 ++
 src/main/java/org/spigotmc/Metrics.java            | 645 +++++++++++++++++++++
 src/main/java/org/spigotmc/ProtocolData.java       | 190 ++++++
 src/main/java/org/spigotmc/ProtocolInjector.java   | 253 ++++++++
 src/main/java/org/spigotmc/RestartCommand.java     | 124 ++++
 src/main/java/org/spigotmc/SneakyThrow.java        |  15 +
 .../java/org/spigotmc/SpigotComponentReverter.java | 105 ++++
 src/main/java/org/spigotmc/SpigotCompressor.java   |  43 ++
 src/main/java/org/spigotmc/SpigotConfig.java       | 401 +++++++++++++
 src/main/java/org/spigotmc/SpigotDebreakifier.java | 102 ++++
 src/main/java/org/spigotmc/SpigotDecompressor.java |  42 ++
 src/main/java/org/spigotmc/SpigotWorldConfig.java  | 358 ++++++++++++
 .../java/org/spigotmc/TicksPerSecondCommand.java   |  45 ++
 src/main/java/org/spigotmc/TrackingRange.java      |  51 ++
 src/main/java/org/spigotmc/ValidateUtils.java      |  14 +
 src/main/java/org/spigotmc/WatchdogThread.java     | 124 ++++
 src/main/resources/blocks.json                     |   1 +
 src/main/resources/configurations/bukkit.yml       |   9 +-
 src/main/resources/configurations/commands.yml     |   9 +-
 src/main/resources/log4j2.xml                      |   6 +-
 src/main/resources/org/spigotmc/SneakyThrow.class  | Bin 0 -> 184 bytes
 253 files changed, 15982 insertions(+), 573 deletions(-)
 create mode 100644 src/main/java/net/minecraft/server/AttributeRanged.java
 create mode 100644 src/main/java/net/minecraft/server/BanEntrySerializer.java
 create mode 100644 src/main/java/net/minecraft/server/BiomeDecorator.java
 create mode 100644 src/main/java/net/minecraft/server/BlockAnvil.java
 create mode 100644 src/main/java/net/minecraft/server/BlockBrewingStand.java
 create mode 100644 src/main/java/net/minecraft/server/BlockFlowerPot.java
 create mode 100644 src/main/java/net/minecraft/server/BlockTNT.java
 create mode 100644 src/main/java/net/minecraft/server/CommandDispatcher.java
 create mode 100644 src/main/java/net/minecraft/server/DataWatcher.java
 create mode 100644 src/main/java/net/minecraft/server/EmptyClass.java
 create mode 100644 src/main/java/net/minecraft/server/EnchantmentManager.java
 create mode 100644 src/main/java/net/minecraft/server/EnchantmentModifierArthropods.java
 create mode 100644 src/main/java/net/minecraft/server/EnchantmentModifierDamage.java
 create mode 100644 src/main/java/net/minecraft/server/EnchantmentModifierProtection.java
 create mode 100644 src/main/java/net/minecraft/server/EnchantmentModifierThorns.java
 create mode 100644 src/main/java/net/minecraft/server/EntityAnimal.java
 create mode 100644 src/main/java/net/minecraft/server/GameProfileBanEntry.java
 create mode 100644 src/main/java/net/minecraft/server/GenericAttributes.java
 create mode 100644 src/main/java/net/minecraft/server/IntCache.java
 create mode 100644 src/main/java/net/minecraft/server/ItemSkull.java
 create mode 100644 src/main/java/net/minecraft/server/MerchantRecipe.java
 create mode 100644 src/main/java/net/minecraft/server/MerchantRecipeList.java
 create mode 100644 src/main/java/net/minecraft/server/NBTBase.java
 create mode 100644 src/main/java/net/minecraft/server/NBTCompressedStreamTools.java
 create mode 100644 src/main/java/net/minecraft/server/NBTTagByteArray.java
 create mode 100644 src/main/java/net/minecraft/server/NBTTagIntArray.java
 create mode 100644 src/main/java/net/minecraft/server/NBTTagList.java
 create mode 100644 src/main/java/net/minecraft/server/NextTickListEntry.java
 create mode 100644 src/main/java/net/minecraft/server/NibbleArray.java
 create mode 100644 src/main/java/net/minecraft/server/OldChunkLoader.java
 create mode 100644 src/main/java/net/minecraft/server/PacketDecoder.java
 create mode 100644 src/main/java/net/minecraft/server/PacketEncoder.java
 create mode 100644 src/main/java/net/minecraft/server/PacketLoginOutSuccess.java
 create mode 100644 src/main/java/net/minecraft/server/PacketPlayInArmAnimation.java
 create mode 100644 src/main/java/net/minecraft/server/PacketPlayInBlockDig.java
 create mode 100644 src/main/java/net/minecraft/server/PacketPlayInBlockPlace.java
 create mode 100644 src/main/java/net/minecraft/server/PacketPlayInEntityAction.java
 create mode 100644 src/main/java/net/minecraft/server/PacketPlayInKeepAlive.java
 create mode 100644 src/main/java/net/minecraft/server/PacketPlayInPosition.java
 create mode 100644 src/main/java/net/minecraft/server/PacketPlayInPositionLook.java
 create mode 100644 src/main/java/net/minecraft/server/PacketPlayInSettings.java
 create mode 100644 src/main/java/net/minecraft/server/PacketPlayInSteerVehicle.java
 create mode 100644 src/main/java/net/minecraft/server/PacketPlayInTabComplete.java
 create mode 100644 src/main/java/net/minecraft/server/PacketPlayInUpdateSign.java
 create mode 100644 src/main/java/net/minecraft/server/PacketPlayInUseEntity.java
 create mode 100644 src/main/java/net/minecraft/server/PacketPlayInWindowClick.java
 create mode 100644 src/main/java/net/minecraft/server/PacketPlayOutBed.java
 create mode 100644 src/main/java/net/minecraft/server/PacketPlayOutBlockAction.java
 create mode 100644 src/main/java/net/minecraft/server/PacketPlayOutBlockBreakAnimation.java
 create mode 100644 src/main/java/net/minecraft/server/PacketPlayOutChat.java
 create mode 100644 src/main/java/net/minecraft/server/PacketPlayOutCollect.java
 create mode 100644 src/main/java/net/minecraft/server/PacketPlayOutCustomPayload.java
 create mode 100644 src/main/java/net/minecraft/server/PacketPlayOutEntity.java
 create mode 100644 src/main/java/net/minecraft/server/PacketPlayOutEntityDestroy.java
 create mode 100644 src/main/java/net/minecraft/server/PacketPlayOutEntityEffect.java
 create mode 100644 src/main/java/net/minecraft/server/PacketPlayOutEntityEquipment.java
 create mode 100644 src/main/java/net/minecraft/server/PacketPlayOutEntityHeadRotation.java
 create mode 100644 src/main/java/net/minecraft/server/PacketPlayOutEntityLook.java
 create mode 100644 src/main/java/net/minecraft/server/PacketPlayOutEntityMetadata.java
 create mode 100644 src/main/java/net/minecraft/server/PacketPlayOutEntityTeleport.java
 create mode 100644 src/main/java/net/minecraft/server/PacketPlayOutEntityVelocity.java
 create mode 100644 src/main/java/net/minecraft/server/PacketPlayOutExperience.java
 create mode 100644 src/main/java/net/minecraft/server/PacketPlayOutKeepAlive.java
 create mode 100644 src/main/java/net/minecraft/server/PacketPlayOutLogin.java
 create mode 100644 src/main/java/net/minecraft/server/PacketPlayOutMap.java
 create mode 100644 src/main/java/net/minecraft/server/PacketPlayOutMapChunk.java
 create mode 100644 src/main/java/net/minecraft/server/PacketPlayOutMultiBlockChange.java
 create mode 100644 src/main/java/net/minecraft/server/PacketPlayOutOpenSignEditor.java
 create mode 100644 src/main/java/net/minecraft/server/PacketPlayOutOpenWindow.java
 create mode 100644 src/main/java/net/minecraft/server/PacketPlayOutPlayerInfo.java
 create mode 100644 src/main/java/net/minecraft/server/PacketPlayOutPosition.java
 create mode 100644 src/main/java/net/minecraft/server/PacketPlayOutRelEntityMove.java
 create mode 100644 src/main/java/net/minecraft/server/PacketPlayOutRelEntityMoveLook.java
 create mode 100644 src/main/java/net/minecraft/server/PacketPlayOutRemoveEntityEffect.java
 create mode 100644 src/main/java/net/minecraft/server/PacketPlayOutScoreboardObjective.java
 create mode 100644 src/main/java/net/minecraft/server/PacketPlayOutScoreboardScore.java
 create mode 100644 src/main/java/net/minecraft/server/PacketPlayOutScoreboardTeam.java
 create mode 100644 src/main/java/net/minecraft/server/PacketPlayOutSetSlot.java
 create mode 100644 src/main/java/net/minecraft/server/PacketPlayOutSpawnEntity.java
 create mode 100644 src/main/java/net/minecraft/server/PacketPlayOutSpawnEntityLiving.java
 create mode 100644 src/main/java/net/minecraft/server/PacketPlayOutSpawnEntityPainting.java
 create mode 100644 src/main/java/net/minecraft/server/PacketPlayOutTileEntityData.java
 create mode 100644 src/main/java/net/minecraft/server/PacketPlayOutUpdateAttributes.java
 create mode 100644 src/main/java/net/minecraft/server/PacketPlayOutUpdateHealth.java
 create mode 100644 src/main/java/net/minecraft/server/PacketPlayOutUpdateSign.java
 create mode 100644 src/main/java/net/minecraft/server/PacketPlayOutWindowItems.java
 create mode 100644 src/main/java/net/minecraft/server/PacketPlayOutWorldEvent.java
 create mode 100644 src/main/java/net/minecraft/server/PacketPlayOutWorldParticles.java
 create mode 100644 src/main/java/net/minecraft/server/PathfinderGoalNearestAttackableTarget.java
 create mode 100644 src/main/java/net/minecraft/server/PersistentCollection.java
 create mode 100644 src/main/java/net/minecraft/server/RegionFileCache.java
 create mode 100644 src/main/java/net/minecraft/server/RemoteControlListener.java
 create mode 100644 src/main/java/net/minecraft/server/ServerConnection.java
 create mode 100644 src/main/java/net/minecraft/server/ServerConnectionChannel.java
 create mode 100644 src/main/java/net/minecraft/server/ServerStatisticManager.java
 create mode 100644 src/main/java/net/minecraft/server/StructureGenerator.java
 create mode 100644 src/main/java/net/minecraft/server/TileEntityEnderChest.java
 create mode 100644 src/main/java/net/minecraft/server/TileEntityLightDetector.java
 create mode 100644 src/main/java/net/minecraft/server/UserCache.java
 create mode 100644 src/main/java/net/minecraft/server/UserCacheEntry.java
 create mode 100644 src/main/java/net/minecraft/server/WatchableObject.java
 create mode 100644 src/main/java/net/minecraft/server/WorldGenForestTree.java
 create mode 100644 src/main/java/net/minecraft/server/WorldGenLargeFeature.java
 create mode 100644 src/main/java/net/minecraft/server/WorldGenPackedIce2.java
 create mode 100644 src/main/java/net/minecraft/server/WorldGenVillage.java
 create mode 100644 src/main/java/org/bukkit/craftbukkit/SpigotTimings.java
 create mode 100644 src/main/java/org/spigotmc/ActivationRange.java
 create mode 100644 src/main/java/org/spigotmc/AntiXray.java
 create mode 100644 src/main/java/org/spigotmc/AsyncCatcher.java
 create mode 100644 src/main/java/org/spigotmc/CachedMojangAPIConnection.java
 create mode 100644 src/main/java/org/spigotmc/CachedStreamHandlerFactory.java
 create mode 100644 src/main/java/org/spigotmc/FlatMap.java
 create mode 100644 src/main/java/org/spigotmc/LimitStream.java
 create mode 100644 src/main/java/org/spigotmc/Metrics.java
 create mode 100644 src/main/java/org/spigotmc/ProtocolData.java
 create mode 100644 src/main/java/org/spigotmc/ProtocolInjector.java
 create mode 100644 src/main/java/org/spigotmc/RestartCommand.java
 create mode 100644 src/main/java/org/spigotmc/SneakyThrow.java
 create mode 100644 src/main/java/org/spigotmc/SpigotComponentReverter.java
 create mode 100644 src/main/java/org/spigotmc/SpigotCompressor.java
 create mode 100644 src/main/java/org/spigotmc/SpigotConfig.java
 create mode 100644 src/main/java/org/spigotmc/SpigotDebreakifier.java
 create mode 100644 src/main/java/org/spigotmc/SpigotDecompressor.java
 create mode 100644 src/main/java/org/spigotmc/SpigotWorldConfig.java
 create mode 100644 src/main/java/org/spigotmc/TicksPerSecondCommand.java
 create mode 100644 src/main/java/org/spigotmc/TrackingRange.java
 create mode 100644 src/main/java/org/spigotmc/ValidateUtils.java
 create mode 100644 src/main/java/org/spigotmc/WatchdogThread.java
 create mode 100644 src/main/resources/blocks.json
 create mode 100644 src/main/resources/org/spigotmc/SneakyThrow.class

diff --git a/README.md b/README.md
index cda766b..1f12a75 100644
--- a/README.md
+++ b/README.md
@@ -1,11 +1,11 @@
-CraftBukkit
+Spigot
 ===========
 
-A Bukkit (Minecraft Server API) implementation
+A Spigot-API and Bukkit implementation
 
-Website: [http://bukkit.org](http://bukkit.org)  
-Bugs/Suggestions: [http://leaky.bukkit.org](http://leaky.bukkit.org)  
-Contributing Guidelines: [CONTRIBUTING.md](https://github.com/Bukkit/CraftBukkit/blob/master/CONTRIBUTING.md)
+Website: [http://spigotmc.org](http://spigotmc.org)  
+Bugs/Suggestions: [http://www.spigotmc.org/forums/bugs-feature-requests.8/](http://www.spigotmc.org/forums/bugs-feature-requests.8/)  
+Contributing Guidelines: [CONTRIBUTING.md](https://github.com/SpigotMC/Spigot-API/blob/master/CONTRIBUTING.md)
 
 Compilation
 -----------
@@ -13,6 +13,6 @@ Compilation
 We use maven to handle our dependencies.
 
 * Install [Maven 3](http://maven.apache.org/download.html)
-* Check out and install [Bukkit](http://github.com/Bukkit/Bukkit)
-    * *Note*: this is not needed as the repository we use has Bukkit too, but you might have a newer one (with your own changes :D)
+* Check out and install [Spigot-API](http://github.com/SpigotMC/Spigot)
+    * *Note*: this is not needed as the repository we use has Spigot-API too, but you might have a newer one (with your own changes :D)
 * Check out this repo and: `mvn clean package`
diff --git a/pom.xml b/pom.xml
index 8dc82eb..0d00e79 100644
--- a/pom.xml
+++ b/pom.xml
@@ -1,12 +1,12 @@
 <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
   <modelVersion>4.0.0</modelVersion>
-  <groupId>org.bukkit</groupId>
-  <artifactId>craftbukkit</artifactId>
+  <groupId>org.spigotmc</groupId>
+  <artifactId>spigot</artifactId>
   <packaging>jar</packaging>
   <version>1.7.10-R0.1-SNAPSHOT</version>
-  <name>CraftBukkit</name>
-  <url>http://www.bukkit.org</url>
+  <name>Spigot</name>
+  <url>http://www.spigotmc.org</url>
 
   <properties>
     <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
@@ -18,24 +18,12 @@
     <buildtag.suffix></buildtag.suffix>
   </properties>
 
-  <scm>
-    <connection>scm:git:git://github.com/Bukkit/CraftBukkit.git</connection>
-    <developerConnection>scm:git:ssh://git@github.com/Bukkit/CraftBukkit.git</developerConnection>
-    <url>https://github.com/Bukkit/CraftBukkit</url>
-  </scm>
-
-  <distributionManagement>
-    <repository>
-      <id>repobo-rel</id>
-      <name>repo.bukkit.org Releases</name>
-      <url>http://repo.bukkit.org/content/repositories/releases/</url>
-    </repository>
-    <snapshotRepository>
-      <id>repobo-snap</id>
-      <name>repo.bukkit.org Snapshots</name>
-      <url>http://repo.bukkit.org/content/repositories/snapshots/</url>
-    </snapshotRepository>
-  </distributionManagement>
+  <parent>
+    <groupId>org.spigotmc</groupId>
+    <artifactId>spigot-parent</artifactId>
+    <version>dev-SNAPSHOT</version>
+    <relativePath>../pom.xml</relativePath>
+  </parent>
 
   <repositories>
     <repository>
@@ -53,16 +41,16 @@
 
   <dependencies>
     <dependency>
-      <groupId>org.bukkit</groupId>
-      <artifactId>bukkit</artifactId>
+      <groupId>org.spigotmc</groupId>
+      <artifactId>spigot-api</artifactId>
       <version>${project.version}</version>
       <type>jar</type>
       <scope>compile</scope>
     </dependency>
     <dependency>
-      <groupId>org.bukkit</groupId>
+      <groupId>org.spigotmc</groupId>
       <artifactId>minecraft-server</artifactId>
-      <version>${minecraft.version}</version>
+      <version>${minecraft.version}-SNAPSHOT</version>
       <type>jar</type>
       <scope>compile</scope>
     </dependency>
@@ -107,33 +95,6 @@
       <artifactId>gson</artifactId>
       <version>2.1</version>
     </dependency>
-    <dependency>
-      <groupId>org.avaje</groupId>
-      <artifactId>ebean</artifactId>
-      <version>2.7.3</version>
-      <type>jar</type>
-      <scope>provided</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.yaml</groupId>
-      <artifactId>snakeyaml</artifactId>
-      <version>1.9</version>
-      <type>jar</type>
-      <scope>provided</scope>
-    </dependency>
-    <dependency>
-      <groupId>com.google.guava</groupId>
-      <artifactId>guava</artifactId>
-      <version>10.0</version>
-      <type>jar</type>
-      <scope>provided</scope>
-    </dependency>
-    <dependency>
-        <groupId>commons-lang</groupId>
-        <artifactId>commons-lang</artifactId>
-        <version>2.3</version>
-        <scope>provided</scope>
-    </dependency>
     <!-- testing -->
     <dependency>
       <groupId>junit</groupId>
@@ -151,15 +112,15 @@
 
   <!-- This builds a completely 'ready to start' jar with all dependencies inside -->
   <build>
-    <defaultGoal>clean install</defaultGoal>
+    <defaultGoal>install</defaultGoal>
     <plugins>
       <plugin>
         <groupId>com.lukegb.mojo</groupId>
         <artifactId>gitdescribe-maven-plugin</artifactId>
         <version>1.3</version>
         <configuration>
-          <outputPrefix>${buildtag.prefix}</outputPrefix>
-          <outputPostfix>${buildtag.suffix}</outputPostfix>
+          <outputPrefix>git-Spigot-</outputPrefix>
+          <outputPostfix></outputPostfix>
         </configuration>
         <executions>
           <execution>
@@ -185,6 +146,7 @@
               <Specification-Version>${api.version}</Specification-Version>
               <Specification-Vendor>Bukkit Team</Specification-Vendor>
               <Sealed>true</Sealed>
+              <Timestamp>${maven.build.timestamp}</Timestamp>
             </manifestEntries>
             <manifestSections>
               <manifestSection>
@@ -212,7 +174,7 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-shade-plugin</artifactId>
-        <version>1.4</version>
+        <version>2.1</version>
         <executions>
           <execution>
             <phase>package</phase>
diff --git a/src/main/java/net/minecraft/server/AttributeRanged.java b/src/main/java/net/minecraft/server/AttributeRanged.java
new file mode 100644
index 0000000..cd613d2
--- /dev/null
+++ b/src/main/java/net/minecraft/server/AttributeRanged.java
@@ -0,0 +1,42 @@
+package net.minecraft.server;
+
+public class AttributeRanged extends AttributeBase {
+
+    private final double a;
+    public double b; // Spigot
+    private String c;
+
+    public AttributeRanged(String s, double d0, double d1, double d2) {
+        super(s, d0);
+        this.a = d1;
+        this.b = d2;
+        if (d1 > d2) {
+            throw new IllegalArgumentException("Minimum value cannot be bigger than maximum value!");
+        } else if (d0 < d1) {
+            throw new IllegalArgumentException("Default value cannot be lower than minimum value!");
+        } else if (d0 > d2) {
+            throw new IllegalArgumentException("Default value cannot be bigger than maximum value!");
+        }
+    }
+
+    public AttributeRanged a(String s) {
+        this.c = s;
+        return this;
+    }
+
+    public String f() {
+        return this.c;
+    }
+
+    public double a(double d0) {
+        if (d0 < this.a) {
+            d0 = this.a;
+        }
+
+        if (d0 > this.b) {
+            d0 = this.b;
+        }
+
+        return d0;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/BanEntrySerializer.java b/src/main/java/net/minecraft/server/BanEntrySerializer.java
new file mode 100644
index 0000000..3b4b596
--- /dev/null
+++ b/src/main/java/net/minecraft/server/BanEntrySerializer.java
@@ -0,0 +1,89 @@
+package net.minecraft.server;
+
+import java.lang.reflect.Type;
+import java.text.ParseException;
+import java.util.Date;
+import java.util.UUID;
+
+import net.minecraft.util.com.google.gson.JsonDeserializationContext;
+import net.minecraft.util.com.google.gson.JsonDeserializer;
+import net.minecraft.util.com.google.gson.JsonElement;
+import net.minecraft.util.com.google.gson.JsonObject;
+import net.minecraft.util.com.google.gson.JsonSerializationContext;
+import net.minecraft.util.com.google.gson.JsonSerializer;
+import net.minecraft.util.com.mojang.authlib.GameProfile;
+
+class BanEntrySerializer implements JsonDeserializer, JsonSerializer {
+
+    final UserCache a;
+
+    private BanEntrySerializer(UserCache usercache) {
+        this.a = usercache;
+    }
+
+    public JsonElement a(UserCacheEntry usercacheentry, Type type, JsonSerializationContext jsonserializationcontext) {
+        JsonObject jsonobject = new JsonObject();
+
+        jsonobject.addProperty("name", usercacheentry.a().getName());
+        UUID uuid = usercacheentry.a().getId();
+
+        jsonobject.addProperty("uuid", uuid == null ? "" : uuid.toString());
+        jsonobject.addProperty("expiresOn", UserCache.a.format(usercacheentry.b()));
+        return jsonobject;
+    }
+
+    public UserCacheEntry a(JsonElement jsonelement, Type type, JsonDeserializationContext jsondeserializationcontext) {
+        if (jsonelement.isJsonObject()) {
+            JsonObject jsonobject = jsonelement.getAsJsonObject();
+            JsonElement jsonelement1 = jsonobject.get("name");
+            JsonElement jsonelement2 = jsonobject.get("uuid");
+            JsonElement jsonelement3 = jsonobject.get("expiresOn");
+
+            if (jsonelement1 != null && jsonelement2 != null) {
+                String s = jsonelement2.getAsString();
+                String s1 = jsonelement1.getAsString();
+                Date date = null;
+
+                if (jsonelement3 != null) {
+                    try {
+                        date = UserCache.a.parse(jsonelement3.getAsString());
+                    } catch (ParseException parseexception) {
+                        date = null;
+                    }
+                }
+
+                if (s1 != null && s != null) {
+                    UUID uuid;
+
+                    try {
+                        uuid = UUID.fromString(s);
+                    } catch (Throwable throwable) {
+                        return null;
+                    }
+
+                    UserCacheEntry usercacheentry = new UserCacheEntry(this.a, new GameProfile(uuid, s1), date, (GameProfileLookup) null);
+
+                    return usercacheentry;
+                } else {
+                    return null;
+                }
+            } else {
+                return null;
+            }
+        } else {
+            return null;
+        }
+    }
+
+    public JsonElement serialize(Object object, Type type, JsonSerializationContext jsonserializationcontext) {
+        return this.a((UserCacheEntry) object, type, jsonserializationcontext);
+    }
+
+    public Object deserialize(JsonElement jsonelement, Type type, JsonDeserializationContext jsondeserializationcontext) {
+        return this.a(jsonelement, type, jsondeserializationcontext);
+    }
+
+    BanEntrySerializer(UserCache usercache, GameProfileLookup gameprofilelookup) {
+        this(usercache);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/BiomeDecorator.java b/src/main/java/net/minecraft/server/BiomeDecorator.java
new file mode 100644
index 0000000..064a125
--- /dev/null
+++ b/src/main/java/net/minecraft/server/BiomeDecorator.java
@@ -0,0 +1,286 @@
+package net.minecraft.server;
+
+import java.util.Random;
+
+public class BiomeDecorator {
+
+    protected World a;
+    protected Random b;
+    protected int c;
+    protected int d;
+    protected WorldGenerator e = new WorldGenClay(4);
+    protected WorldGenerator f;
+    protected WorldGenerator g;
+    protected WorldGenerator h;
+    protected WorldGenerator i;
+    protected WorldGenerator j;
+    protected WorldGenerator k;
+    protected WorldGenerator l;
+    protected WorldGenerator m;
+    protected WorldGenerator n;
+    protected WorldGenerator o;
+    protected WorldGenFlowers p;
+    protected WorldGenerator q;
+    protected WorldGenerator r;
+    protected WorldGenerator s;
+    protected WorldGenerator t;
+    protected WorldGenerator u;
+    protected WorldGenerator v;
+    protected int w;
+    protected int x;
+    protected int y;
+    protected int z;
+    protected int A;
+    protected int B;
+    protected int C;
+    protected int D;
+    protected int E;
+    protected int F;
+    protected int G;
+    protected int H;
+    public boolean I;
+
+    public BiomeDecorator() {
+        this.f = new WorldGenSand(Blocks.SAND, 7);
+        this.g = new WorldGenSand(Blocks.GRAVEL, 6);
+        this.h = new WorldGenMinable(Blocks.DIRT, 32);
+        this.i = new WorldGenMinable(Blocks.GRAVEL, 32);
+        this.j = new WorldGenMinable(Blocks.COAL_ORE, 16);
+        this.k = new WorldGenMinable(Blocks.IRON_ORE, 8);
+        this.l = new WorldGenMinable(Blocks.GOLD_ORE, 8);
+        this.m = new WorldGenMinable(Blocks.REDSTONE_ORE, 7);
+        this.n = new WorldGenMinable(Blocks.DIAMOND_ORE, 7);
+        this.o = new WorldGenMinable(Blocks.LAPIS_ORE, 6);
+        this.p = new WorldGenFlowers(Blocks.YELLOW_FLOWER);
+        this.q = new WorldGenFlowers(Blocks.BROWN_MUSHROOM);
+        this.r = new WorldGenFlowers(Blocks.RED_MUSHROOM);
+        this.s = new WorldGenHugeMushroom();
+        this.t = new WorldGenReed();
+        this.u = new WorldGenCactus();
+        this.v = new WorldGenWaterLily();
+        this.y = 2;
+        this.z = 1;
+        this.E = 1;
+        this.F = 3;
+        this.G = 1;
+        this.I = true;
+    }
+
+    public void a(World world, Random random, BiomeBase biomebase, int i, int j) {
+        if (this.a != null) {
+            throw new RuntimeException("Already decorating!!");
+        } else {
+            this.a = world;
+            this.b = random;
+            this.c = i;
+            this.d = j;
+            this.a(biomebase);
+            this.a = null;
+            this.b = null;
+        }
+    }
+
+    protected void a(BiomeBase biomebase) {
+        this.a();
+
+        int i;
+        int j;
+        int k;
+
+        for (i = 0; i < this.F; ++i) {
+            j = this.c + this.b.nextInt(16) + 8;
+            k = this.d + this.b.nextInt(16) + 8;
+            this.f.generate(this.a, this.b, j, this.a.i(j, k), k);
+        }
+
+        for (i = 0; i < this.G; ++i) {
+            j = this.c + this.b.nextInt(16) + 8;
+            k = this.d + this.b.nextInt(16) + 8;
+            this.e.generate(this.a, this.b, j, this.a.i(j, k), k);
+        }
+
+        for (i = 0; i < this.E; ++i) {
+            j = this.c + this.b.nextInt(16) + 8;
+            k = this.d + this.b.nextInt(16) + 8;
+            this.g.generate(this.a, this.b, j, this.a.i(j, k), k);
+        }
+
+        i = this.x;
+        if (this.b.nextInt(10) == 0) {
+            ++i;
+        }
+
+        int l;
+        int i1;
+
+        for (j = 0; j < i; ++j) {
+            k = this.c + this.b.nextInt(16) + 8;
+            l = this.d + this.b.nextInt(16) + 8;
+            i1 = this.a.getHighestBlockYAt(k, l);
+            WorldGenTreeAbstract worldgentreeabstract = biomebase.a(this.b);
+
+            worldgentreeabstract.a(1.0D, 1.0D, 1.0D);
+            if (worldgentreeabstract.generate(this.a, this.b, k, i1, l)) {
+                worldgentreeabstract.b(this.a, this.b, k, i1, l);
+            }
+        }
+
+        for (j = 0; j < this.H; ++j) {
+            k = this.c + this.b.nextInt(16) + 8;
+            l = this.d + this.b.nextInt(16) + 8;
+            this.s.generate(this.a, this.b, k, this.a.getHighestBlockYAt(k, l), l);
+        }
+
+        for (j = 0; j < this.y; ++j) {
+            k = this.c + this.b.nextInt(16) + 8;
+            l = this.d + this.b.nextInt(16) + 8;
+            i1 = this.b.nextInt(this.a.getHighestBlockYAt(k, l) + 32);
+            String s = biomebase.a(this.b, k, i1, l);
+            BlockFlowers blockflowers = BlockFlowers.e(s);
+
+            if (blockflowers.getMaterial() != Material.AIR) {
+                this.p.a(blockflowers, BlockFlowers.f(s));
+                this.p.generate(this.a, this.b, k, i1, l);
+            }
+        }
+
+        for (j = 0; j < this.z; ++j) {
+            k = this.c + this.b.nextInt(16) + 8;
+            l = this.d + this.b.nextInt(16) + 8;
+            i1 = this.b.nextInt(this.getHighestBlockYAt(k, l) * 2); // Spigot
+            WorldGenerator worldgenerator = biomebase.b(this.b);
+
+            worldgenerator.generate(this.a, this.b, k, i1, l);
+        }
+
+        for (j = 0; j < this.A; ++j) {
+            k = this.c + this.b.nextInt(16) + 8;
+            l = this.d + this.b.nextInt(16) + 8;
+            i1 = this.b.nextInt(this.getHighestBlockYAt(k, l) * 2); // Spigot
+            (new WorldGenDeadBush(Blocks.DEAD_BUSH)).generate(this.a, this.b, k, i1, l);
+        }
+
+        for (j = 0; j < this.w; ++j) {
+            k = this.c + this.b.nextInt(16) + 8;
+            l = this.d + this.b.nextInt(16) + 8;
+
+            for (i1 = this.b.nextInt(this.getHighestBlockYAt(k, l) * 2); i1 > 0 && this.a.isEmpty(k, i1 - 1, l); --i1) { // Spigot
+                ;
+            }
+
+            this.v.generate(this.a, this.b, k, i1, l);
+        }
+
+        for (j = 0; j < this.B; ++j) {
+            if (this.b.nextInt(4) == 0) {
+                k = this.c + this.b.nextInt(16) + 8;
+                l = this.d + this.b.nextInt(16) + 8;
+                i1 = this.a.getHighestBlockYAt(k, l);
+                this.q.generate(this.a, this.b, k, i1, l);
+            }
+
+            if (this.b.nextInt(8) == 0) {
+                k = this.c + this.b.nextInt(16) + 8;
+                l = this.d + this.b.nextInt(16) + 8;
+                i1 = this.b.nextInt(this.getHighestBlockYAt(k, l) * 2); // Spigot
+                this.r.generate(this.a, this.b, k, i1, l);
+            }
+        }
+
+        if (this.b.nextInt(4) == 0) {
+            j = this.c + this.b.nextInt(16) + 8;
+            k = this.d + this.b.nextInt(16) + 8;
+            l = this.b.nextInt(this.getHighestBlockYAt(j, k) * 2); // Spigot
+            this.q.generate(this.a, this.b, j, l, k);
+        }
+
+        if (this.b.nextInt(8) == 0) {
+            j = this.c + this.b.nextInt(16) + 8;
+            k = this.d + this.b.nextInt(16) + 8;
+            l = this.b.nextInt(this.getHighestBlockYAt(j, k) * 2); // Spigot
+            this.r.generate(this.a, this.b, j, l, k);
+        }
+
+        for (j = 0; j < this.C; ++j) {
+            k = this.c + this.b.nextInt(16) + 8;
+            l = this.d + this.b.nextInt(16) + 8;
+            i1 = this.b.nextInt(this.getHighestBlockYAt(k, l) * 2); // Spigot
+            this.t.generate(this.a, this.b, k, i1, l);
+        }
+
+        for (j = 0; j < 10; ++j) {
+            k = this.c + this.b.nextInt(16) + 8;
+            l = this.d + this.b.nextInt(16) + 8;
+            i1 = this.b.nextInt(this.getHighestBlockYAt(k, l) * 2); // Spigot
+            this.t.generate(this.a, this.b, k, i1, l);
+        }
+
+        if (this.b.nextInt(32) == 0) {
+            j = this.c + this.b.nextInt(16) + 8;
+            k = this.d + this.b.nextInt(16) + 8;
+            l = this.b.nextInt(this.getHighestBlockYAt(j, k) * 2); // Spigot
+            (new WorldGenPumpkin()).generate(this.a, this.b, j, l, k);
+        }
+
+        for (j = 0; j < this.D; ++j) {
+            k = this.c + this.b.nextInt(16) + 8;
+            l = this.d + this.b.nextInt(16) + 8;
+            i1 = this.b.nextInt(this.getHighestBlockYAt(k, l) * 2); // Spigot
+            this.u.generate(this.a, this.b, k, i1, l);
+        }
+
+        if (this.I) {
+            for (j = 0; j < 50; ++j) {
+                k = this.c + this.b.nextInt(16) + 8;
+                l = this.b.nextInt(this.b.nextInt(248) + 8);
+                i1 = this.d + this.b.nextInt(16) + 8;
+                (new WorldGenLiquids(Blocks.WATER)).generate(this.a, this.b, k, l, i1);
+            }
+
+            for (j = 0; j < 20; ++j) {
+                k = this.c + this.b.nextInt(16) + 8;
+                l = this.b.nextInt(this.b.nextInt(this.b.nextInt(240) + 8) + 8);
+                i1 = this.d + this.b.nextInt(16) + 8;
+                (new WorldGenLiquids(Blocks.LAVA)).generate(this.a, this.b, k, l, i1);
+            }
+        }
+    }
+
+    protected void a(int i, WorldGenerator worldgenerator, int j, int k) {
+        for (int l = 0; l < i; ++l) {
+            int i1 = this.c + this.b.nextInt(16);
+            int j1 = this.b.nextInt(k - j) + j;
+            int k1 = this.d + this.b.nextInt(16);
+
+            worldgenerator.generate(this.a, this.b, i1, j1, k1);
+        }
+    }
+
+    protected void b(int i, WorldGenerator worldgenerator, int j, int k) {
+        for (int l = 0; l < i; ++l) {
+            int i1 = this.c + this.b.nextInt(16);
+            int j1 = this.b.nextInt(k) + this.b.nextInt(k) + (j - k);
+            int k1 = this.d + this.b.nextInt(16);
+
+            worldgenerator.generate(this.a, this.b, i1, j1, k1);
+        }
+    }
+
+    protected void a() {
+        this.a(20, this.h, 0, 256);
+        this.a(10, this.i, 0, 256);
+        this.a(20, this.j, 0, 128);
+        this.a(20, this.k, 0, 64);
+        this.a(2, this.l, 0, 32);
+        this.a(8, this.m, 0, 16);
+        this.a(1, this.n, 0, 16);
+        this.b(1, this.o, 16, 16);
+    }
+
+    // Spigot Start
+    private int getHighestBlockYAt(int x, int z)
+    {
+        return Math.max( 1, this.a.getHighestBlockYAt( x, z ) );
+    }
+    // Spigot End
+}
diff --git a/src/main/java/net/minecraft/server/Block.java b/src/main/java/net/minecraft/server/Block.java
index 9876ebf..0893a6f 100644
--- a/src/main/java/net/minecraft/server/Block.java
+++ b/src/main/java/net/minecraft/server/Block.java
@@ -433,9 +433,13 @@ public class Block {
         return 10;
     }
 
-    public void onPlace(World world, int i, int j, int k) {}
+    public void onPlace(World world, int i, int j, int k) {
+        org.spigotmc.AsyncCatcher.catchOp( "block onPlace"); // Spigot
+    }
 
-    public void remove(World world, int i, int j, int k, Block block, int l) {}
+    public void remove(World world, int i, int j, int k, Block block, int l) {
+        org.spigotmc.AsyncCatcher.catchOp( "block remove"); // Spigot
+    }
 
     public int a(Random random) {
         return 1;
@@ -804,4 +808,16 @@ public class Block {
         return 0;
     }
     // CraftBukkit end
+
+    // Spigot start
+    public static float range(float min, float value, float max) {
+        if (value < min) {
+            return min;
+        }
+        if (value > max) {
+            return max;
+        }
+        return value;
+    }
+    // Spigot end
 }
diff --git a/src/main/java/net/minecraft/server/BlockAnvil.java b/src/main/java/net/minecraft/server/BlockAnvil.java
new file mode 100644
index 0000000..1fa14c5
--- /dev/null
+++ b/src/main/java/net/minecraft/server/BlockAnvil.java
@@ -0,0 +1,88 @@
+package net.minecraft.server;
+
+public class BlockAnvil extends BlockFalling {
+
+    public static final String[] a = new String[] { "intact", "slightlyDamaged", "veryDamaged"};
+    private static final String[] N = new String[] { "anvil_top_damaged_0", "anvil_top_damaged_1", "anvil_top_damaged_2"};
+
+    protected BlockAnvil() {
+        super(Material.HEAVY);
+        this.g(0);
+        this.a(CreativeModeTab.c);
+    }
+
+    // Spigot start
+    @Override
+    public AxisAlignedBB a( World world, int i, int j, int k )
+    {
+        updateShape( world, i, j, k );
+        return super.a( world, i, j, k );
+    }
+    // Spigot end
+
+    public boolean d() {
+        return false;
+    }
+
+    public boolean c() {
+        return false;
+    }
+
+    public void postPlace(World world, int i, int j, int k, EntityLiving entityliving, ItemStack itemstack) {
+        int l = MathHelper.floor((double) (entityliving.yaw * 4.0F / 360.0F) + 0.5D) & 3;
+        int i1 = world.getData(i, j, k) >> 2;
+
+        ++l;
+        l %= 4;
+        if (l == 0) {
+            world.setData(i, j, k, 2 | i1 << 2, 2);
+        }
+
+        if (l == 1) {
+            world.setData(i, j, k, 3 | i1 << 2, 2);
+        }
+
+        if (l == 2) {
+            world.setData(i, j, k, 0 | i1 << 2, 2);
+        }
+
+        if (l == 3) {
+            world.setData(i, j, k, 1 | i1 << 2, 2);
+        }
+    }
+
+    public boolean interact(World world, int i, int j, int k, EntityHuman entityhuman, int l, float f, float f1, float f2) {
+        if (world.isStatic) {
+            return true;
+        } else {
+            entityhuman.openAnvil(i, j, k);
+            return true;
+        }
+    }
+
+    public int b() {
+        return 35;
+    }
+
+    public int getDropData(int i) {
+        return i >> 2;
+    }
+
+    public void updateShape(IBlockAccess iblockaccess, int i, int j, int k) {
+        int l = iblockaccess.getData(i, j, k) & 3;
+
+        if (l != 3 && l != 1) {
+            this.a(0.125F, 0.0F, 0.0F, 0.875F, 1.0F, 1.0F);
+        } else {
+            this.a(0.0F, 0.0F, 0.125F, 1.0F, 1.0F, 0.875F);
+        }
+    }
+
+    protected void a(EntityFallingBlock entityfallingblock) {
+        entityfallingblock.a(true);
+    }
+
+    public void a(World world, int i, int j, int k, int l) {
+        world.triggerEffect(1022, i, j, k, 0);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/BlockBrewingStand.java b/src/main/java/net/minecraft/server/BlockBrewingStand.java
new file mode 100644
index 0000000..9f49f43
--- /dev/null
+++ b/src/main/java/net/minecraft/server/BlockBrewingStand.java
@@ -0,0 +1,115 @@
+package net.minecraft.server;
+
+import java.util.List;
+import java.util.Random;
+
+public class BlockBrewingStand extends BlockContainer {
+
+    private Random a = new Random();
+
+    public BlockBrewingStand() {
+        super(Material.ORE);
+    }
+
+    public boolean c() {
+        return false;
+    }
+
+    public int b() {
+        return 25;
+    }
+
+    public TileEntity a(World world, int i) {
+        return new TileEntityBrewingStand();
+    }
+
+    public boolean d() {
+        return false;
+    }
+
+    public void a(World world, int i, int j, int k, AxisAlignedBB axisalignedbb, List list, Entity entity) {
+        this.a(0.4375F, 0.0F, 0.4375F, 0.5625F, 0.875F, 0.5625F);
+        super.a(world, i, j, k, axisalignedbb, list, entity);
+        this.g();
+        super.a(world, i, j, k, axisalignedbb, list, entity);
+    }
+
+    public void g() {
+        this.a(0.0F, 0.0F, 0.0F, 1.0F, 0.125F, 1.0F);
+    }
+
+    public boolean interact(World world, int i, int j, int k, EntityHuman entityhuman, int l, float f, float f1, float f2) {
+        if (world.isStatic) {
+            return true;
+        } else {
+            TileEntityBrewingStand tileentitybrewingstand = (TileEntityBrewingStand) world.getTileEntity(i, j, k);
+
+            if (tileentitybrewingstand != null) {
+                entityhuman.openBrewingStand(tileentitybrewingstand);
+            }
+
+            return true;
+        }
+    }
+
+    public void postPlace(World world, int i, int j, int k, EntityLiving entityliving, ItemStack itemstack) {
+        if (itemstack.hasName()) {
+            ((TileEntityBrewingStand) world.getTileEntity(i, j, k)).a(itemstack.getName());
+        }
+    }
+
+    public void remove(World world, int i, int j, int k, Block block, int l) {
+        TileEntity tileentity = world.getTileEntity(i, j, k);
+
+        if (tileentity instanceof TileEntityBrewingStand) {
+            TileEntityBrewingStand tileentitybrewingstand = (TileEntityBrewingStand) tileentity;
+
+            for (int i1 = 0; i1 < tileentitybrewingstand.getSize(); ++i1) {
+                ItemStack itemstack = tileentitybrewingstand.getItem(i1);
+
+                if (itemstack != null) {
+                    float f = this.a.nextFloat() * 0.8F + 0.1F;
+                    float f1 = this.a.nextFloat() * 0.8F + 0.1F;
+                    float f2 = this.a.nextFloat() * 0.8F + 0.1F;
+
+                    while (itemstack.count > 0) {
+                        int j1 = this.a.nextInt(21) + 10;
+
+                        if (j1 > itemstack.count) {
+                            j1 = itemstack.count;
+                        }
+
+                        itemstack.count -= j1;
+                        EntityItem entityitem = new EntityItem(world, (double) ((float) i + f), (double) ((float) j + f1), (double) ((float) k + f2), new ItemStack(itemstack.getItem(), j1, itemstack.getData()));
+                        float f3 = 0.05F;
+
+                        entityitem.motX = (double) ((float) this.a.nextGaussian() * f3);
+                        entityitem.motY = (double) ((float) this.a.nextGaussian() * f3 + 0.2F);
+                        entityitem.motZ = (double) ((float) this.a.nextGaussian() * f3);
+                        // Spigot Start
+                        if ( itemstack.hasTag() )
+                        {
+                            entityitem.getItemStack().setTag( (NBTTagCompound) itemstack.getTag().clone() );
+                        }
+                        // Spigot End
+                        world.addEntity( entityitem );
+                    }
+                }
+            }
+        }
+
+        super.remove(world, i, j, k, block, l);
+    }
+
+    public Item getDropType(int i, Random random, int j) {
+        return Items.BREWING_STAND;
+    }
+
+    public boolean isComplexRedstone() {
+        return true;
+    }
+
+    public int g(World world, int i, int j, int k, int l) {
+        return Container.b((IInventory) world.getTileEntity(i, j, k));
+    }
+}
diff --git a/src/main/java/net/minecraft/server/BlockCactus.java b/src/main/java/net/minecraft/server/BlockCactus.java
index e920c6f..f55e531 100644
--- a/src/main/java/net/minecraft/server/BlockCactus.java
+++ b/src/main/java/net/minecraft/server/BlockCactus.java
@@ -23,7 +23,7 @@ public class BlockCactus extends Block {
             if (l < 3) {
                 int i1 = world.getData(i, j, k);
 
-                if (i1 == 15) {
+                if (i1 >= (byte) range(3, (world.growthOdds / world.spigotConfig.cactusModifier * 15) + 0.5F, 15)) { // Spigot
                     CraftEventFactory.handleBlockGrowEvent(world, i, j + 1, k, this, 0); // CraftBukkit
                     world.setData(i, j, k, 0, 4);
                     this.doPhysics(world, i, j + 1, k, this);
diff --git a/src/main/java/net/minecraft/server/BlockCrops.java b/src/main/java/net/minecraft/server/BlockCrops.java
index 875181f..fd28d85 100644
--- a/src/main/java/net/minecraft/server/BlockCrops.java
+++ b/src/main/java/net/minecraft/server/BlockCrops.java
@@ -29,7 +29,7 @@ public class BlockCrops extends BlockPlant implements IBlockFragilePlantElement
             if (l < 7) {
                 float f = this.n(world, i, j, k);
 
-                if (random.nextInt((int) (25.0F / f) + 1) == 0) {
+                if (random.nextInt((int) (world.growthOdds / world.spigotConfig.wheatModifier * (25.0F / f)) + 1) == 0) { // Spigot
                     ++l;
                     CraftEventFactory.handleBlockGrowEvent(world, i, j, k, this, l); // CraftBukkit
                 }
diff --git a/src/main/java/net/minecraft/server/BlockFlowerPot.java b/src/main/java/net/minecraft/server/BlockFlowerPot.java
new file mode 100644
index 0000000..e468eb8
--- /dev/null
+++ b/src/main/java/net/minecraft/server/BlockFlowerPot.java
@@ -0,0 +1,187 @@
+package net.minecraft.server;
+
+import java.util.Random;
+
+public class BlockFlowerPot extends BlockContainer {
+
+    public BlockFlowerPot() {
+        super(Material.ORIENTABLE);
+        this.g();
+    }
+
+    public void g() {
+        float f = 0.375F;
+        float f1 = f / 2.0F;
+
+        this.a(0.5F - f1, 0.0F, 0.5F - f1, 0.5F + f1, f, 0.5F + f1);
+    }
+
+    public boolean c() {
+        return false;
+    }
+
+    public int b() {
+        return 33;
+    }
+
+    public boolean d() {
+        return false;
+    }
+
+    public boolean interact(World world, int i, int j, int k, EntityHuman entityhuman, int l, float f, float f1, float f2) {
+        ItemStack itemstack = entityhuman.inventory.getItemInHand();
+
+        if (itemstack != null && itemstack.getItem() instanceof ItemBlock) {
+            TileEntityFlowerPot tileentityflowerpot = this.e(world, i, j, k);
+
+            if (tileentityflowerpot != null) {
+                if (tileentityflowerpot.a() != null) {
+                    return false;
+                } else {
+                    Block block = Block.a(itemstack.getItem());
+
+                    if (!this.a(block, itemstack.getData())) {
+                        return false;
+                    } else {
+                        tileentityflowerpot.a(itemstack.getItem(), itemstack.getData());
+                        tileentityflowerpot.update();
+                        if (!world.setData(i, j, k, itemstack.getData(), 2)) {
+                            world.notify(i, j, k);
+                        }
+
+                        if (!entityhuman.abilities.canInstantlyBuild && --itemstack.count <= 0) {
+                            entityhuman.inventory.setItem(entityhuman.inventory.itemInHandIndex, (ItemStack) null);
+                        }
+
+                        return true;
+                    }
+                }
+            } else {
+                return false;
+            }
+        } else {
+            return false;
+        }
+    }
+
+    private boolean a(Block block, int i) {
+        return block != Blocks.YELLOW_FLOWER && block != Blocks.RED_ROSE && block != Blocks.CACTUS && block != Blocks.BROWN_MUSHROOM && block != Blocks.RED_MUSHROOM && block != Blocks.SAPLING && block != Blocks.DEAD_BUSH ? block == Blocks.LONG_GRASS && i == 2 : true;
+    }
+
+    public int getDropData(World world, int i, int j, int k) {
+        TileEntityFlowerPot tileentityflowerpot = this.e(world, i, j, k);
+
+        return tileentityflowerpot != null && tileentityflowerpot.a() != null ? tileentityflowerpot.b() : 0;
+    }
+
+    public boolean canPlace(World world, int i, int j, int k) {
+        return super.canPlace(world, i, j, k) && World.a((IBlockAccess) world, i, j - 1, k);
+    }
+
+    public void doPhysics(World world, int i, int j, int k, Block block) {
+        if (!World.a((IBlockAccess) world, i, j - 1, k)) {
+            this.b(world, i, j, k, world.getData(i, j, k), 0);
+            world.setAir(i, j, k);
+        }
+    }
+
+    public void remove(World world, int i, int j, int k, Block block, int l) {
+        TileEntityFlowerPot tileentityflowerpot = this.e(world, i, j, k);
+
+        if (tileentityflowerpot != null && tileentityflowerpot.a() != null) {
+            this.a(world, i, j, k, new ItemStack(tileentityflowerpot.a(), 1, tileentityflowerpot.b()));
+            tileentityflowerpot.a( null, 0 ); // Spigot
+        }
+
+        super.remove(world, i, j, k, block, l);
+    }
+
+    public void a(World world, int i, int j, int k, int l, EntityHuman entityhuman) {
+        super.a(world, i, j, k, l, entityhuman);
+        if (entityhuman.abilities.canInstantlyBuild) {
+            TileEntityFlowerPot tileentityflowerpot = this.e(world, i, j, k);
+
+            if (tileentityflowerpot != null) {
+                tileentityflowerpot.a(Item.getById(0), 0);
+            }
+        }
+    }
+
+    public Item getDropType(int i, Random random, int j) {
+        return Items.FLOWER_POT;
+    }
+
+    private TileEntityFlowerPot e(World world, int i, int j, int k) {
+        TileEntity tileentity = world.getTileEntity(i, j, k);
+
+        return tileentity != null && tileentity instanceof TileEntityFlowerPot ? (TileEntityFlowerPot) tileentity : null;
+    }
+
+    public TileEntity a(World world, int i) {
+        Object object = null;
+        byte b0 = 0;
+
+        switch (i) {
+        case 1:
+            object = Blocks.RED_ROSE;
+            b0 = 0;
+            break;
+
+        case 2:
+            object = Blocks.YELLOW_FLOWER;
+            break;
+
+        case 3:
+            object = Blocks.SAPLING;
+            b0 = 0;
+            break;
+
+        case 4:
+            object = Blocks.SAPLING;
+            b0 = 1;
+            break;
+
+        case 5:
+            object = Blocks.SAPLING;
+            b0 = 2;
+            break;
+
+        case 6:
+            object = Blocks.SAPLING;
+            b0 = 3;
+            break;
+
+        case 7:
+            object = Blocks.RED_MUSHROOM;
+            break;
+
+        case 8:
+            object = Blocks.BROWN_MUSHROOM;
+            break;
+
+        case 9:
+            object = Blocks.CACTUS;
+            break;
+
+        case 10:
+            object = Blocks.DEAD_BUSH;
+            break;
+
+        case 11:
+            object = Blocks.LONG_GRASS;
+            b0 = 2;
+            break;
+
+        case 12:
+            object = Blocks.SAPLING;
+            b0 = 4;
+            break;
+
+        case 13:
+            object = Blocks.SAPLING;
+            b0 = 5;
+        }
+
+        return new TileEntityFlowerPot(Item.getItemOf((Block) object), b0);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/BlockGrass.java b/src/main/java/net/minecraft/server/BlockGrass.java
index abd991b..7c00158 100644
--- a/src/main/java/net/minecraft/server/BlockGrass.java
+++ b/src/main/java/net/minecraft/server/BlockGrass.java
@@ -39,7 +39,8 @@ public class BlockGrass extends Block implements IBlockFragilePlantElement {
                 }
                 // CraftBukkit end
             } else if (world.getLightLevel(i, j + 1, k) >= 9) {
-                for (int l = 0; l < 4; ++l) {
+                int numGrowth = Math.min(4, Math.max(20, (int) (4 * 100F / world.growthOdds))); // Spigot
+                for (int l = 0; l < numGrowth; ++l) { // Spigot
                     int i1 = i + random.nextInt(3) - 1;
                     int j1 = j + random.nextInt(5) - 3;
                     int k1 = k + random.nextInt(3) - 1;
diff --git a/src/main/java/net/minecraft/server/BlockHopper.java b/src/main/java/net/minecraft/server/BlockHopper.java
index b85b72f..b33ed64 100644
--- a/src/main/java/net/minecraft/server/BlockHopper.java
+++ b/src/main/java/net/minecraft/server/BlockHopper.java
@@ -87,6 +87,17 @@ public class BlockHopper extends BlockContainer {
 
         if (flag != flag1) {
             world.setData(i, j, k, i1 | (flag ? 0 : 8), 4);
+            // Spigot start - When this hopper becomes unpowered, make it active.
+            // Called when this block's power level changes. flag1 is the current
+            // isNotPowered from metadata. flag is the recalculated isNotPowered.
+            if (world.spigotConfig.altHopperTicking) {
+            	// e returns the TileEntityHopper associated with this BlockHopper.
+                TileEntityHopper hopper = e((IBlockAccess) world, i, j, k);
+                if (flag && hopper != null) {
+                    hopper.makeTick();
+                }
+            }
+            // Spigot end
         }
     }
 
@@ -163,4 +174,17 @@ public class BlockHopper extends BlockContainer {
     public static TileEntityHopper e(IBlockAccess iblockaccess, int i, int j, int k) {
         return (TileEntityHopper) iblockaccess.getTileEntity(i, j, k);
     }
+
+    // Spigot start - Use random block updates to make hoppers active.
+    @Override
+    public void a(World world, int i, int j, int k, Random random) {
+        if (world.spigotConfig.altHopperTicking) {
+        	// e returns the TileEntityHopper associated with this BlockHopper.
+            TileEntityHopper hopper = e((IBlockAccess) world, i, j, k);
+            if (hopper != null) {
+                hopper.makeTick();
+            }
+        }
+    }
+    // Spigot end
 }
diff --git a/src/main/java/net/minecraft/server/BlockMushroom.java b/src/main/java/net/minecraft/server/BlockMushroom.java
index 6671a84..4daa273 100644
--- a/src/main/java/net/minecraft/server/BlockMushroom.java
+++ b/src/main/java/net/minecraft/server/BlockMushroom.java
@@ -19,7 +19,7 @@ public class BlockMushroom extends BlockPlant implements IBlockFragilePlantEleme
 
     public void a(World world, int i, int j, int k, Random random) {
         final int sourceX = i, sourceY = j, sourceZ = k; // CraftBukkit
-        if (random.nextInt(25) == 0) {
+        if (random.nextInt(Math.max(1, (int) world.growthOdds / world.spigotConfig.mushroomModifier * 25)) == 0) { // Spigot
             byte b0 = 4;
             int l = 5;
 
diff --git a/src/main/java/net/minecraft/server/BlockMycel.java b/src/main/java/net/minecraft/server/BlockMycel.java
index a01a6e6..2854bbc 100644
--- a/src/main/java/net/minecraft/server/BlockMycel.java
+++ b/src/main/java/net/minecraft/server/BlockMycel.java
@@ -33,7 +33,8 @@ public class BlockMycel extends Block {
                 }
                 // CraftBukkit end
             } else if (world.getLightLevel(i, j + 1, k) >= 9) {
-                for (int l = 0; l < 4; ++l) {
+                int numGrowth = Math.min(4, Math.max(20, (int) (4 * 100F / world.growthOdds))); // Spigot
+                for (int l = 0; l < numGrowth; ++l) { // Spigot
                     int i1 = i + random.nextInt(3) - 1;
                     int j1 = j + random.nextInt(5) - 3;
                     int k1 = k + random.nextInt(3) - 1;
diff --git a/src/main/java/net/minecraft/server/BlockPortal.java b/src/main/java/net/minecraft/server/BlockPortal.java
index bec5aa8..222e3ac 100644
--- a/src/main/java/net/minecraft/server/BlockPortal.java
+++ b/src/main/java/net/minecraft/server/BlockPortal.java
@@ -15,7 +15,7 @@ public class BlockPortal extends BlockHalfTransparent {
 
     public void a(World world, int i, int j, int k, Random random) {
         super.a(world, i, j, k, random);
-        if (world.worldProvider.d() && world.getGameRules().getBoolean("doMobSpawning") && random.nextInt(2000) < world.difficulty.a()) {
+        if (world.spigotConfig.enableZombiePigmenPortalSpawns && world.worldProvider.d() && world.getGameRules().getBoolean("doMobSpawning") && random.nextInt(2000) < world.difficulty.a()) { // Spigot
             int l;
 
             for (l = j; !World.a((IBlockAccess) world, i, l, k) && l > 0; --l) {
diff --git a/src/main/java/net/minecraft/server/BlockRedstoneTorch.java b/src/main/java/net/minecraft/server/BlockRedstoneTorch.java
index 8e01414..e0469bb 100644
--- a/src/main/java/net/minecraft/server/BlockRedstoneTorch.java
+++ b/src/main/java/net/minecraft/server/BlockRedstoneTorch.java
@@ -11,7 +11,7 @@ import org.bukkit.event.block.BlockRedstoneEvent; // CraftBukkit
 public class BlockRedstoneTorch extends BlockTorch {
 
     private boolean isOn;
-    private static Map b = new HashMap();
+    private static Map b = new java.util.WeakHashMap(); // Spigot
 
     private boolean a(World world, int i, int j, int k, boolean flag) {
         if (!b.containsKey(world)) {
diff --git a/src/main/java/net/minecraft/server/BlockReed.java b/src/main/java/net/minecraft/server/BlockReed.java
index a1350f6..6c04ad2 100644
--- a/src/main/java/net/minecraft/server/BlockReed.java
+++ b/src/main/java/net/minecraft/server/BlockReed.java
@@ -24,7 +24,7 @@ public class BlockReed extends Block {
                 if (l < 3) {
                     int i1 = world.getData(i, j, k);
 
-                    if (i1 == 15) {
+                    if (i1 >= (byte) range(3, (world.growthOdds / world.spigotConfig.caneModifier * 15) + 0.5F, 15)) { // Spigot
                         org.bukkit.craftbukkit.event.CraftEventFactory.handleBlockGrowEvent(world, i, j + 1, k, this, 0); // CraftBukkit
                         world.setData(i, j, k, 0, 4);
                     } else {
diff --git a/src/main/java/net/minecraft/server/BlockSapling.java b/src/main/java/net/minecraft/server/BlockSapling.java
index 89e60a8..8258395 100644
--- a/src/main/java/net/minecraft/server/BlockSapling.java
+++ b/src/main/java/net/minecraft/server/BlockSapling.java
@@ -27,7 +27,7 @@ public class BlockSapling extends BlockPlant implements IBlockFragilePlantElemen
     public void a(World world, int i, int j, int k, Random random) {
         if (!world.isStatic) {
             super.a(world, i, j, k, random);
-            if (world.getLightLevel(i, j + 1, k) >= 9 && random.nextInt(7) == 0) {
+            if (world.getLightLevel(i, j + 1, k) >= 9 && (random.nextInt(Math.max(2, (int) ((world.growthOdds / world.spigotConfig.saplingModifier * 7) + 0.5F))) == 0)) { // Spigot
                 // CraftBukkit start
                 world.captureTreeGeneration = true;
                 // CraftBukkit end
diff --git a/src/main/java/net/minecraft/server/BlockStem.java b/src/main/java/net/minecraft/server/BlockStem.java
index 40ad1c6..b37b187 100644
--- a/src/main/java/net/minecraft/server/BlockStem.java
+++ b/src/main/java/net/minecraft/server/BlockStem.java
@@ -26,7 +26,7 @@ public class BlockStem extends BlockPlant implements IBlockFragilePlantElement {
         if (world.getLightLevel(i, j + 1, k) >= 9) {
             float f = this.n(world, i, j, k);
 
-            if (random.nextInt((int) (25.0F / f) + 1) == 0) {
+            if (random.nextInt((int) (world.growthOdds / (this == Blocks.PUMPKIN_STEM? world.spigotConfig.pumpkinModifier : world.spigotConfig.melonModifier) * (25.0F / f)) + 1) == 0) { // Spigot
                 int l = world.getData(i, j, k);
 
                 if (l < 7) {
diff --git a/src/main/java/net/minecraft/server/BlockTNT.java b/src/main/java/net/minecraft/server/BlockTNT.java
new file mode 100644
index 0000000..35bf1a3
--- /dev/null
+++ b/src/main/java/net/minecraft/server/BlockTNT.java
@@ -0,0 +1,85 @@
+package net.minecraft.server;
+
+import java.util.Random;
+
+public class BlockTNT extends Block {
+
+    public BlockTNT() {
+        super(Material.TNT);
+        this.a(CreativeModeTab.d);
+    }
+
+    public void onPlace(World world, int i, int j, int k) {
+        super.onPlace(world, i, j, k);
+        if (world.isBlockIndirectlyPowered(i, j, k)) {
+            this.postBreak(world, i, j, k, 1);
+            world.setAir(i, j, k);
+        }
+    }
+
+    public void doPhysics(World world, int i, int j, int k, Block block) {
+        if (world.isBlockIndirectlyPowered(i, j, k)) {
+            this.postBreak(world, i, j, k, 1);
+            world.setAir(i, j, k);
+        }
+    }
+
+    public int a(Random random) {
+        return 1;
+    }
+
+    public void wasExploded(World world, int i, int j, int k, Explosion explosion) {
+        if (!world.isStatic) {
+            EntityTNTPrimed entitytntprimed = new EntityTNTPrimed(world, (double) ((float) i + 0.5F), (double) ((float) j + 0.5F), (double) ((float) k + 0.5F), explosion.c());
+
+            entitytntprimed.fuseTicks = world.random.nextInt(entitytntprimed.fuseTicks / 4) + entitytntprimed.fuseTicks / 8;
+            world.addEntity(entitytntprimed);
+        }
+    }
+
+    public void postBreak(World world, int i, int j, int k, int l) {
+        this.a(world, i, j, k, l, (EntityLiving) null);
+    }
+
+    public void a(World world, int i, int j, int k, int l, EntityLiving entityliving) {
+        if (!world.isStatic) {
+            if ((l & 1) == 1) {
+                EntityTNTPrimed entitytntprimed = new EntityTNTPrimed(world, (double) ((float) i + 0.5F), (double) ((float) j + 0.5F), (double) ((float) k + 0.5F), entityliving);
+
+                world.addEntity(entitytntprimed);
+                world.makeSound(entitytntprimed, "game.tnt.primed", 1.0F, 1.0F);
+            }
+        }
+    }
+
+    public boolean interact(World world, int i, int j, int k, EntityHuman entityhuman, int l, float f, float f1, float f2) {
+        if (entityhuman.bF() != null && entityhuman.bF().getItem() == Items.FLINT_AND_STEEL) {
+            this.a(world, i, j, k, 1, (EntityLiving) entityhuman); // Spigot - Fix decompile error!
+            world.setAir(i, j, k);
+            entityhuman.bF().damage(1, entityhuman);
+            return true;
+        } else {
+            return super.interact(world, i, j, k, entityhuman, l, f, f1, f2);
+        }
+    }
+
+    public void a(World world, int i, int j, int k, Entity entity) {
+        if (entity instanceof EntityArrow && !world.isStatic) {
+            EntityArrow entityarrow = (EntityArrow) entity;
+
+            if (entityarrow.isBurning()) {
+                // CraftBukkit start
+                if (org.bukkit.craftbukkit.event.CraftEventFactory.callEntityChangeBlockEvent(entityarrow, i, j, k, Blocks.AIR, 0).isCancelled()) {
+                    return;
+                }
+                // CraftBukkit end
+                this.a(world, i, j, k, 1, entityarrow.shooter instanceof EntityLiving ? (EntityLiving) entityarrow.shooter : null);
+                world.setAir(i, j, k);
+            }
+        }
+    }
+
+    public boolean a(Explosion explosion) {
+        return false;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Chunk.java b/src/main/java/net/minecraft/server/Chunk.java
index 3ac0ae4..0423ee9 100644
--- a/src/main/java/net/minecraft/server/Chunk.java
+++ b/src/main/java/net/minecraft/server/Chunk.java
@@ -40,6 +40,7 @@ public class Chunk {
     public int r;
     public long s;
     private int x;
+    protected net.minecraft.util.gnu.trove.map.hash.TObjectIntHashMap<Class> entityCount = new net.minecraft.util.gnu.trove.map.hash.TObjectIntHashMap<Class>(); // Spigot
 
     // CraftBukkit start - Neighbor loaded cache for chunk lighting and entity ticking
     private int neighbors = 0x1 << 12;
@@ -142,7 +143,7 @@ public class Chunk {
                         }
 
                         this.sections[l1].setTypeId(l, j1 & 15, i1, block);
-                        this.sections[l1].setData(l, j1 & 15, i1, abyte[k1]);
+                        this.sections[l1].setData(l, j1 & 15, i1, checkData( block, abyte[k1] ) );
                     }
                 }
             }
@@ -425,6 +426,17 @@ public class Chunk {
         }
     }
 
+    // Spigot start - prevent invalid data values
+    public static int checkData( Block block, int data )
+    {
+        if (block == Blocks.DOUBLE_PLANT )
+        {
+            return data < 6 || data >= 8 ? data : 0;
+        }
+        return data;
+    }
+    // Spigot end
+
     public boolean a(int i, int j, int k, Block block, int l) {
         int i1 = k << 4 | i;
 
@@ -479,7 +491,7 @@ public class Chunk {
             if (chunksection.getTypeId(i, j & 15, k) != block) {
                 return false;
             } else {
-                chunksection.setData(i, j & 15, k, l);
+                chunksection.setData(i, j & 15, k, checkData( block, l ) );
                 if (flag) {
                     this.initLighting();
                 } else {
@@ -544,8 +556,9 @@ public class Chunk {
                 return false;
             } else {
                 this.n = true;
-                chunksection.setData(i, j & 15, k, l);
-                if (chunksection.getTypeId(i, j & 15, k) instanceof IContainer) {
+                Block block = chunksection.getTypeId( i, j & 15, k );
+                chunksection.setData(i, j & 15, k, checkData( block, l ) );
+                if (block instanceof IContainer) {
                     TileEntity tileentity = this.e(i, j, k);
 
                     if (tileentity != null) {
@@ -635,6 +648,22 @@ public class Chunk {
         entity.ai = k;
         entity.aj = this.locZ;
         this.entitySlices[k].add(entity);
+        // Spigot start - increment creature type count
+        // Keep this synced up with World.a(Class)
+        if (entity instanceof EntityInsentient) {
+            EntityInsentient entityinsentient = (EntityInsentient) entity;
+            if (entityinsentient.isTypeNotPersistent() && entityinsentient.isPersistent()) {
+                return;
+            }
+        }
+        for ( EnumCreatureType creatureType : EnumCreatureType.values() )
+        {
+            if ( creatureType.a().isAssignableFrom( entity.getClass() ) )
+            {
+                this.entityCount.adjustOrPutValue( creatureType.a(), 1, 1 );
+            }
+        }
+        // Spigot end
     }
 
     public void b(Entity entity) {
@@ -651,6 +680,22 @@ public class Chunk {
         }
 
         this.entitySlices[i].remove(entity);
+        // Spigot start - decrement creature type count
+        // Keep this synced up with World.a(Class)
+        if (entity instanceof EntityInsentient) {
+            EntityInsentient entityinsentient = (EntityInsentient) entity;
+            if (entityinsentient.isTypeNotPersistent() && entityinsentient.isPersistent()) {
+                return;
+            }
+        }
+        for ( EnumCreatureType creatureType : EnumCreatureType.values() )
+        {
+            if ( creatureType.a().isAssignableFrom( entity.getClass() ) )
+            {
+                this.entityCount.adjustValue( creatureType.a(), -1 );
+            }
+        }
+        // Spigot end
     }
 
     public boolean d(int i, int j, int k) {
@@ -705,6 +750,11 @@ public class Chunk {
 
             tileentity.t();
             this.tileEntities.put(chunkposition, tileentity);
+            // Spigot start - The tile entity has a world, now hoppers can be born ticking.
+            if (this.world.spigotConfig.altHopperTicking) {
+                this.world.triggerHoppersList.add(tileentity);
+            }
+            // Spigot end
             // CraftBukkit start
         } else {
             System.out.println("Attempted to place a tile entity (" + tileentity + ") at " + tileentity.x + "," + tileentity.y + "," + tileentity.z
@@ -750,6 +800,18 @@ public class Chunk {
 
         while (iterator.hasNext()) {
             TileEntity tileentity = (TileEntity) iterator.next();
+            // Spigot Start
+            if ( tileentity instanceof IInventory )
+            {
+                for ( org.bukkit.entity.HumanEntity h : new ArrayList<org.bukkit.entity.HumanEntity>( (List) ( (IInventory) tileentity ).getViewers() ) )
+                {
+                    if ( h instanceof org.bukkit.craftbukkit.entity.CraftHumanEntity )
+                    {
+                       ( (org.bukkit.craftbukkit.entity.CraftHumanEntity) h).getHandle().closeInventory();
+                    }
+                }
+            }
+            // Spigot End
 
             this.world.a(tileentity);
         }
@@ -759,6 +821,18 @@ public class Chunk {
             java.util.Iterator<Object> iter = this.entitySlices[i].iterator();
             while (iter.hasNext()) {
                 Entity entity = (Entity) iter.next();
+                // Spigot Start
+                if ( entity instanceof IInventory )
+                {
+                    for ( org.bukkit.entity.HumanEntity h : new ArrayList<org.bukkit.entity.HumanEntity>( (List) ( (IInventory) entity ).getViewers() ) )
+                    {
+                        if ( h instanceof org.bukkit.craftbukkit.entity.CraftHumanEntity )
+                        {
+                           ( (org.bukkit.craftbukkit.entity.CraftHumanEntity) h).getHandle().closeInventory();
+                        }
+                    }
+                }
+                // Spigot End
 
                 // Do not pass along players, as doing so can get them stuck outside of time.
                 // (which for example disables inventory icon updates and prevents block breaking)
@@ -847,6 +921,7 @@ public class Chunk {
     }
 
     public void loadNearby(IChunkProvider ichunkprovider, IChunkProvider ichunkprovider1, int i, int j) {
+        world.timings.syncChunkLoadPostTimer.startTiming(); // Spigot
         if (!this.done && ichunkprovider.isChunkLoaded(i + 1, j + 1) && ichunkprovider.isChunkLoaded(i, j + 1) && ichunkprovider.isChunkLoaded(i + 1, j)) {
             ichunkprovider.getChunkAt(ichunkprovider1, i, j);
         }
@@ -862,6 +937,7 @@ public class Chunk {
         if (ichunkprovider.isChunkLoaded(i - 1, j - 1) && !ichunkprovider.getOrCreateChunk(i - 1, j - 1).done && ichunkprovider.isChunkLoaded(i, j - 1) && ichunkprovider.isChunkLoaded(i - 1, j)) {
             ichunkprovider.getChunkAt(ichunkprovider1, i - 1, j - 1);
         }
+        world.timings.syncChunkLoadPostTimer.stopTiming(); // Spigot
     }
 
     public int d(int i, int j) {
@@ -896,13 +972,21 @@ public class Chunk {
         }
 
         this.m = true;
-        if (!this.lit && this.done) {
+        if (!this.lit && this.done && this.world.spigotConfig.randomLightUpdates) { // Spigot - also use random light updates setting to determine if we should relight
             this.p();
         }
     }
 
     public boolean isReady() {
-        return this.m && this.done && this.lit;
+        // Spigot Start
+        /*
+         * As of 1.7, Mojang added a check to make sure that only chunks which have been lit are sent to the client.
+         * Unfortunately this interferes with our modified chunk ticking algorithm, which will only tick chunks distant from the player on a very infrequent basis.
+         * We cannot unfortunately do this lighting stage during chunk gen as it appears to put a lot more noticeable load on the server, than when it is done at play time.
+         * For now at least we will simply send all chunks, in accordance with pre 1.7 behaviour.
+         */
+        return true;
+        // Spigot End
     }
 
     public ChunkCoordIntPair l() {
diff --git a/src/main/java/net/minecraft/server/ChunkProviderServer.java b/src/main/java/net/minecraft/server/ChunkProviderServer.java
index c88d5d4..22330c3 100644
--- a/src/main/java/net/minecraft/server/ChunkProviderServer.java
+++ b/src/main/java/net/minecraft/server/ChunkProviderServer.java
@@ -137,6 +137,7 @@ public class ChunkProviderServer implements IChunkProvider {
         boolean newChunk = false;
 
         if (chunk == null) {
+            world.timings.syncChunkLoadTimer.startTiming(); // Spigot
             chunk = this.loadChunk(i, j);
             if (chunk == null) {
                 if (this.chunkProvider == null) {
@@ -187,6 +188,7 @@ public class ChunkProviderServer implements IChunkProvider {
             }
             // CraftBukkit end
             chunk.loadNearby(this, this, i, j);
+            world.timings.syncChunkLoadTimer.stopTiming(); // Spigot
         }
 
         return chunk;
@@ -219,7 +221,9 @@ public class ChunkProviderServer implements IChunkProvider {
                 if (chunk != null) {
                     chunk.lastSaved = this.world.getTime();
                     if (this.chunkProvider != null) {
+                        world.timings.syncChunkLoadStructuresTimer.startTiming(); // Spigot
                         this.chunkProvider.recreateStructures(i, j);
+                        world.timings.syncChunkLoadStructuresTimer.stopTiming(); // Spigot
                     }
                 }
 
diff --git a/src/main/java/net/minecraft/server/ChunkRegionLoader.java b/src/main/java/net/minecraft/server/ChunkRegionLoader.java
index 9402f0f..59fe8ac 100644
--- a/src/main/java/net/minecraft/server/ChunkRegionLoader.java
+++ b/src/main/java/net/minecraft/server/ChunkRegionLoader.java
@@ -15,6 +15,7 @@ import org.apache.logging.log4j.Logger;
 
 public class ChunkRegionLoader implements IChunkLoader, IAsyncChunkSaver {
 
+    private java.util.LinkedHashMap<ChunkCoordIntPair, PendingChunkToSave> pendingSaves = new java.util.LinkedHashMap<ChunkCoordIntPair, PendingChunkToSave>(); // Spigot
     private static final Logger a = LogManager.getLogger();
     private List b = new ArrayList();
     private Set c = new HashSet();
@@ -30,13 +31,11 @@ public class ChunkRegionLoader implements IChunkLoader, IAsyncChunkSaver {
         ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(i, j);
 
         synchronized (this.d) {
-            if (this.c.contains(chunkcoordintpair)) {
-                for (int k = 0; k < this.b.size(); ++k) {
-                    if (((PendingChunkToSave) this.b.get(k)).a.equals(chunkcoordintpair)) {
-                        return true;
-                    }
-                }
-            }
+            // Spigot start
+            if (pendingSaves.containsKey(chunkcoordintpair)) {
+                return true;
+             }
+            // Spigot end
         }
 
         return RegionFileCache.a(this.e, i, j).chunkExists(i & 31, j & 31);
@@ -45,7 +44,9 @@ public class ChunkRegionLoader implements IChunkLoader, IAsyncChunkSaver {
 
     // CraftBukkit start - Add async variant, provide compatibility
     public Chunk a(World world, int i, int j) {
+        world.timings.syncChunkLoadDataTimer.startTiming(); // Spigot
         Object[] data = this.loadChunk(world, i, j);
+        world.timings.syncChunkLoadDataTimer.stopTiming(); // Spigot
         if (data != null) {
             Chunk chunk = (Chunk) data[0];
             NBTTagCompound nbttagcompound = (NBTTagCompound) data[1];
@@ -63,14 +64,12 @@ public class ChunkRegionLoader implements IChunkLoader, IAsyncChunkSaver {
         Object object = this.d;
 
         synchronized (this.d) {
-            if (this.c.contains(chunkcoordintpair)) {
-                for (int k = 0; k < this.b.size(); ++k) {
-                    if (((PendingChunkToSave) this.b.get(k)).a.equals(chunkcoordintpair)) {
-                        nbttagcompound = ((PendingChunkToSave) this.b.get(k)).b;
-                        break;
-                    }
-                }
+            // Spigot start
+            PendingChunkToSave pendingchunktosave = pendingSaves.get(chunkcoordintpair);
+            if (pendingchunktosave != null) {
+                nbttagcompound = pendingchunktosave.b;
             }
+            // Spigot end
         }
 
         if (nbttagcompound == null) {
@@ -150,17 +149,11 @@ public class ChunkRegionLoader implements IChunkLoader, IAsyncChunkSaver {
         Object object = this.d;
 
         synchronized (this.d) {
-            if (this.c.contains(chunkcoordintpair)) {
-                for (int i = 0; i < this.b.size(); ++i) {
-                    if (((PendingChunkToSave) this.b.get(i)).a.equals(chunkcoordintpair)) {
-                        this.b.set(i, new PendingChunkToSave(chunkcoordintpair, nbttagcompound));
-                        return;
-                    }
-                }
+            // Spigot start
+            if (this.pendingSaves.put(chunkcoordintpair, new PendingChunkToSave(chunkcoordintpair, nbttagcompound)) != null) {
+                return;
             }
-
-            this.b.add(new PendingChunkToSave(chunkcoordintpair, nbttagcompound));
-            this.c.add(chunkcoordintpair);
+            // Spigot end
             FileIOThread.a.a(this);
         }
     }
@@ -170,12 +163,14 @@ public class ChunkRegionLoader implements IChunkLoader, IAsyncChunkSaver {
         Object object = this.d;
 
         synchronized (this.d) {
-            if (this.b.isEmpty()) {
+            // Spigot start
+            if (this.pendingSaves.isEmpty()) {
                 return false;
             }
 
-            pendingchunktosave = (PendingChunkToSave) this.b.remove(0);
-            this.c.remove(pendingchunktosave.a);
+            pendingchunktosave = this.pendingSaves.values().iterator().next();
+            this.pendingSaves.remove(pendingchunktosave.a);
+            // Spigot end
         }
 
         if (pendingchunktosave != null) {
@@ -350,6 +345,7 @@ public class ChunkRegionLoader implements IChunkLoader, IAsyncChunkSaver {
 
     public void loadEntities(Chunk chunk, NBTTagCompound nbttagcompound, World world) {
         // CraftBukkit end
+        world.timings.syncChunkLoadEntitiesTimer.startTiming(); // Spigot
         NBTTagList nbttaglist1 = nbttagcompound.getList("Entities", 10);
 
         if (nbttaglist1 != null) {
@@ -375,7 +371,8 @@ public class ChunkRegionLoader implements IChunkLoader, IAsyncChunkSaver {
                 }
             }
         }
-
+        world.timings.syncChunkLoadEntitiesTimer.stopTiming(); // Spigot
+        world.timings.syncChunkLoadTileEntitiesTimer.startTiming(); // Spigot
         NBTTagList nbttaglist2 = nbttagcompound.getList("TileEntities", 10);
 
         if (nbttaglist2 != null) {
@@ -388,6 +385,8 @@ public class ChunkRegionLoader implements IChunkLoader, IAsyncChunkSaver {
                 }
             }
         }
+        world.timings.syncChunkLoadTileEntitiesTimer.stopTiming(); // Spigot
+        world.timings.syncChunkLoadTileTicksTimer.startTiming(); // Spigot
 
         if (nbttagcompound.hasKeyOfType("TileTicks", 9)) {
             NBTTagList nbttaglist3 = nbttagcompound.getList("TileTicks", 10);
@@ -400,6 +399,7 @@ public class ChunkRegionLoader implements IChunkLoader, IAsyncChunkSaver {
                 }
             }
         }
+        world.timings.syncChunkLoadTileTicksTimer.stopTiming(); // Spigot
 
         // return chunk; // CraftBukkit
     }
diff --git a/src/main/java/net/minecraft/server/CommandBlockListenerAbstract.java b/src/main/java/net/minecraft/server/CommandBlockListenerAbstract.java
index 0cd512d..278832c 100644
--- a/src/main/java/net/minecraft/server/CommandBlockListenerAbstract.java
+++ b/src/main/java/net/minecraft/server/CommandBlockListenerAbstract.java
@@ -110,6 +110,14 @@ public abstract class CommandBlockListenerAbstract implements ICommandListener {
                 }
             }
 
+            // Spigot start - check for manually prefixed command or commands that don't need a prefix
+            org.bukkit.command.Command commandBlockCommand = commandMap.getCommand(args[0]);
+            if (commandBlockCommand instanceof VanillaCommandWrapper) {
+                this.b = ((VanillaCommandWrapper) commandBlockCommand).dispatchVanillaCommandBlock(this, this.e);
+                return;
+            }
+            // Spigot end
+
             // Make sure this is a valid command
             if (commandMap.getCommand(args[0]) == null) {
                 this.b = 0;
diff --git a/src/main/java/net/minecraft/server/CommandDispatcher.java b/src/main/java/net/minecraft/server/CommandDispatcher.java
new file mode 100644
index 0000000..84bcca1
--- /dev/null
+++ b/src/main/java/net/minecraft/server/CommandDispatcher.java
@@ -0,0 +1,94 @@
+package net.minecraft.server;
+
+import java.util.Iterator;
+
+public class CommandDispatcher extends CommandHandler implements ICommandDispatcher {
+
+    public CommandDispatcher() {
+        this.a(new CommandTime());
+        this.a(new CommandGamemode());
+        this.a(new CommandDifficulty());
+        this.a(new CommandGamemodeDefault());
+        this.a(new CommandKill());
+        this.a(new CommandToggleDownfall());
+        this.a(new CommandWeather());
+        this.a(new CommandXp());
+        this.a(new CommandTp());
+        this.a(new CommandGive());
+        this.a(new CommandEffect());
+        this.a(new CommandEnchant());
+        this.a(new CommandMe());
+        this.a(new CommandSeed());
+        this.a(new CommandHelp());
+        this.a(new CommandDebug());
+        this.a(new CommandTell());
+        this.a(new CommandSay());
+        this.a(new CommandSpawnpoint());
+        this.a(new CommandSetWorldSpawn());
+        this.a(new CommandGamerule());
+        this.a(new CommandClear());
+        this.a(new CommandTestFor());
+        this.a(new CommandSpreadPlayers());
+        this.a(new CommandPlaySound());
+        this.a(new CommandScoreboard());
+        this.a(new CommandAchievement());
+        this.a(new CommandSummon());
+        this.a(new CommandSetBlock());
+        this.a(new CommandTestForBlock());
+        this.a(new CommandTellRaw());
+        if (MinecraftServer.getServer().X()) {
+            this.a(new CommandOp());
+            this.a(new CommandDeop());
+            this.a(new CommandStop());
+            this.a(new CommandSaveAll());
+            this.a(new CommandSaveOff());
+            this.a(new CommandSaveOn());
+            this.a(new CommandBanIp());
+            this.a(new CommandPardonIP());
+            this.a(new CommandBan());
+            this.a(new CommandBanList());
+            this.a(new CommandPardon());
+            this.a(new CommandKick());
+            this.a(new CommandList());
+            this.a(new CommandWhitelist());
+            this.a(new CommandIdleTimeout());
+            this.a(new CommandNetstat());
+        } else {
+            this.a(new CommandPublish());
+        }
+
+        CommandAbstract.a((ICommandDispatcher) this);
+    }
+
+    public void a(ICommandListener icommandlistener, ICommand icommand, int i, String s, Object... aobject) {
+        boolean flag = true;
+
+        if (icommandlistener instanceof CommandBlockListenerAbstract && !MinecraftServer.getServer().worldServer[0].getGameRules().getBoolean("commandBlockOutput")) {
+            flag = false;
+        }
+
+        ChatMessage chatmessage = new ChatMessage("chat.type.admin", new Object[] { icommandlistener.getName(), new ChatMessage(s, aobject)});
+
+        chatmessage.getChatModifier().setColor(EnumChatFormat.GRAY);
+        chatmessage.getChatModifier().setItalic(Boolean.valueOf(true));
+        if (flag) {
+            Iterator iterator = MinecraftServer.getServer().getPlayerList().players.iterator();
+
+            while (iterator.hasNext()) {
+                EntityHuman entityhuman = (EntityHuman) iterator.next();
+
+                if (entityhuman != icommandlistener && MinecraftServer.getServer().getPlayerList().isOp(entityhuman.getProfile()) && icommand.canUse(entityhuman) && (!(icommandlistener instanceof RemoteControlCommandListener) || MinecraftServer.getServer().m())) {
+                    entityhuman.sendMessage(chatmessage);
+                }
+            }
+        }
+
+        if (icommandlistener != MinecraftServer.getServer() && !org.spigotmc.SpigotConfig.silentCommandBlocks) { // Spigot
+            MinecraftServer.getServer().sendMessage(chatmessage);
+        }
+
+        if ((i & 1) != 1) {
+            icommandlistener.sendMessage(new ChatMessage(s, aobject));
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/ContainerEnchantTable.java b/src/main/java/net/minecraft/server/ContainerEnchantTable.java
index 5f948e4..af3aa1d 100644
--- a/src/main/java/net/minecraft/server/ContainerEnchantTable.java
+++ b/src/main/java/net/minecraft/server/ContainerEnchantTable.java
@@ -249,7 +249,11 @@ public class ContainerEnchantTable extends Container {
                     ((Slot) this.c.get(0)).set(itemstack1.cloneItemStack());
                     itemstack1.count = 0;
                 } else if (itemstack1.count >= 1) {
-                    ((Slot) this.c.get(0)).set(new ItemStack(itemstack1.getItem(), 1, itemstack1.getData()));
+                    // Spigot start
+                    ItemStack clone = itemstack1.cloneItemStack();
+                    clone.count = 1;
+                    ((Slot) this.c.get(0)).set(clone);
+                    // Spigot end
                     --itemstack1.count;
                 }
             }
diff --git a/src/main/java/net/minecraft/server/DataWatcher.java b/src/main/java/net/minecraft/server/DataWatcher.java
new file mode 100644
index 0000000..96e40ec
--- /dev/null
+++ b/src/main/java/net/minecraft/server/DataWatcher.java
@@ -0,0 +1,392 @@
+package net.minecraft.server;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.locks.ReadWriteLock;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
+
+import net.minecraft.util.org.apache.commons.lang3.ObjectUtils;
+import org.spigotmc.ProtocolData; // Spigot - protocol patch
+
+public class DataWatcher {
+
+    private final Entity a;
+    private boolean b = true;
+    // Spigot Start
+    private static final net.minecraft.util.gnu.trove.map.TObjectIntMap classToId = new net.minecraft.util.gnu.trove.map.hash.TObjectIntHashMap( 10, 0.5f, -1 );
+    private final net.minecraft.util.gnu.trove.map.TIntObjectMap dataValues = new net.minecraft.util.gnu.trove.map.hash.TIntObjectHashMap( 10, 0.5f, -1 );
+    // These exist as an attempt at backwards compatability for (broken) NMS plugins
+    private static final Map c = net.minecraft.util.gnu.trove.TDecorators.wrap( classToId );
+    private final Map d = net.minecraft.util.gnu.trove.TDecorators.wrap( dataValues );
+    // Spigot End
+    private boolean e;
+    private ReadWriteLock f = new ReentrantReadWriteLock();
+
+    public DataWatcher(Entity entity) {
+        this.a = entity;
+    }
+
+    public void a(int i, Object object) {
+        int integer = classToId.get(object.getClass()); // Spigot
+
+        // Spigot start - protocol patch
+        if ( object instanceof ProtocolData.ByteShort
+                || object instanceof ProtocolData.DualByte
+                || object instanceof ProtocolData.HiddenByte )
+        {
+            integer = classToId.get( Byte.class );
+        }
+        if ( object instanceof ProtocolData.IntByte
+                || object instanceof ProtocolData.DualInt ) {
+            integer = classToId.get( Integer.class );
+        }
+        // Spigot end
+
+        if (integer == -1) { // Spigot
+            throw new IllegalArgumentException("Unknown data type: " + object.getClass());
+        } else if (i > 31) {
+            throw new IllegalArgumentException("Data value id is too big with " + i + "! (Max is " + 31 + ")");
+        } else if (this.dataValues.containsKey(i)) { // Spigot
+            throw new IllegalArgumentException("Duplicate id value for " + i + "!");
+        } else {
+            WatchableObject watchableobject = new WatchableObject(integer, i, object); // Spigot
+
+            this.f.writeLock().lock();
+            this.dataValues.put(i, watchableobject); // Spigot
+            this.f.writeLock().unlock();
+            this.b = false;
+        }
+    }
+
+    public void add(int i, int j) {
+        WatchableObject watchableobject = new WatchableObject(j, i, null);
+
+        this.f.writeLock().lock();
+        this.dataValues.put(i, watchableobject); // Spigot
+        this.f.writeLock().unlock();
+        this.b = false;
+    }
+
+    public byte getByte(int i) {
+        return ((Number) this.i(i).b()).byteValue(); // Spigot - protocol patch
+    }
+
+    public short getShort(int i) {
+        return ((Number) this.i(i).b()).shortValue(); // Spigot - protocol patch
+    }
+
+    public int getInt(int i) {
+        return ((Number) this.i(i).b()).intValue(); // Spigot - protocol patch
+    }
+
+    public float getFloat(int i) {
+        return ((Number) this.i(i).b()).floatValue(); // Spigot - protocol patch
+    }
+
+    public String getString(int i) {
+        return (String) this.i(i).b();
+    }
+
+    public ItemStack getItemStack(int i) {
+        return (ItemStack) this.i(i).b();
+    }
+
+    // Spigot start - protocol patch
+    public ProtocolData.DualByte getDualByte(int i) {
+        return (ProtocolData.DualByte) this.i(i).b();
+    }
+    public ProtocolData.IntByte getIntByte(int i) {
+        return (ProtocolData.IntByte) this.i(i).b();
+    }
+    public ProtocolData.DualInt getDualInt(int i) {
+        return (ProtocolData.DualInt) this.i(i).b();
+    }
+    // Spigot end
+
+    private WatchableObject i(int i) {
+        this.f.readLock().lock();
+
+        WatchableObject watchableobject;
+
+        try {
+            watchableobject = (WatchableObject) this.dataValues.get(i); // Spigot
+        } catch (Throwable throwable) {
+            CrashReport crashreport = CrashReport.a(throwable, "Getting synched entity data");
+            CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Synched entity data");
+
+            crashreportsystemdetails.a("Data ID", Integer.valueOf(i));
+            throw new ReportedException(crashreport);
+        }
+
+        this.f.readLock().unlock();
+        return watchableobject;
+    }
+
+    public void watch(int i, Object object) {
+        WatchableObject watchableobject = this.i(i);
+
+        if (ObjectUtils.notEqual(object, watchableobject.b())) {
+            watchableobject.a(object);
+            this.a.i(i);
+            watchableobject.a(true);
+            this.e = true;
+        }
+    }
+
+    public void update(int i) {
+        WatchableObject.a(this.i(i), true);
+        this.e = true;
+    }
+
+    public boolean a() {
+        return this.e;
+    }
+
+    // Spigot start - protocol patch
+    public static void a(List list, PacketDataSerializer packetdataserializer) {
+        a(list, packetdataserializer, 5);
+    }
+
+    public static void a(List list, PacketDataSerializer packetdataserializer, int version) {
+    // Spigot end - protocol patch
+        if (list != null) {
+            Iterator iterator = list.iterator();
+
+            while (iterator.hasNext()) {
+                WatchableObject watchableobject = (WatchableObject) iterator.next();
+
+                a(packetdataserializer, watchableobject, version); // Spigot - protocol patch
+            }
+        }
+
+        packetdataserializer.writeByte(127);
+    }
+
+    public List b() {
+        ArrayList arraylist = null;
+
+        if (this.e) {
+            this.f.readLock().lock();
+            Iterator iterator = this.dataValues.valueCollection().iterator(); // Spigot
+
+            while (iterator.hasNext()) {
+                WatchableObject watchableobject = (WatchableObject) iterator.next();
+
+                if (watchableobject.d()) {
+                    watchableobject.a(false);
+                    if (arraylist == null) {
+                        arraylist = new ArrayList();
+                    }
+
+                    // Spigot start - copy ItemStacks to prevent ConcurrentModificationExceptions
+                    if ( watchableobject.b() instanceof ItemStack )
+                    {
+                        watchableobject = new WatchableObject(
+                                watchableobject.c(),
+                                watchableobject.a(),
+                                ( (ItemStack) watchableobject.b() ).cloneItemStack()
+                        );
+                    }
+                    // Spigot end
+
+                    arraylist.add(watchableobject);
+                }
+            }
+
+            this.f.readLock().unlock();
+        }
+
+        this.e = false;
+        return arraylist;
+    }
+
+    // Spigot start - protocol patch
+    public void a(PacketDataSerializer packetdataserializer) {
+        a(packetdataserializer, 5);
+    }
+
+    public void a(PacketDataSerializer packetdataserializer, int version) {
+    // Spigot end
+        this.f.readLock().lock();
+        Iterator iterator = this.dataValues.valueCollection().iterator(); // Spigot
+
+        while (iterator.hasNext()) {
+            WatchableObject watchableobject = (WatchableObject) iterator.next();
+
+            a(packetdataserializer, watchableobject, version); // Spigot - protocol patch
+        }
+
+        this.f.readLock().unlock();
+        packetdataserializer.writeByte(127);
+    }
+
+    public List c() {
+        ArrayList arraylist = new ArrayList(); // Spigot
+
+        this.f.readLock().lock();
+
+        arraylist.addAll(this.dataValues.valueCollection()); // Spigot
+        // Spigot start - copy ItemStacks to prevent ConcurrentModificationExceptions
+        for ( int i = 0; i < arraylist.size(); i++ )
+        {
+            WatchableObject watchableobject = (WatchableObject) arraylist.get( i );
+            if ( watchableobject.b() instanceof ItemStack )
+            {
+                watchableobject = new WatchableObject(
+                        watchableobject.c(),
+                        watchableobject.a(),
+                        ( (ItemStack) watchableobject.b() ).cloneItemStack()
+                );
+                arraylist.set( i, watchableobject );
+            }
+        }
+        // Spigot end
+
+        this.f.readLock().unlock();
+        return arraylist;
+    }
+
+    // Spigot start - protocol patch
+    private static void a(PacketDataSerializer packetdataserializer, WatchableObject watchableobject, int version) {
+        int type = watchableobject.c();
+        if (watchableobject.b() instanceof ProtocolData.ByteShort && version >= 16) {
+            type = 1;
+        }
+        if (watchableobject.b() instanceof ProtocolData.IntByte && version >= 28) {
+            type = 0;
+        }
+        if ( version < 16 && watchableobject.b() instanceof ProtocolData.HiddenByte ) return;
+
+        int i = (type << 5 | watchableobject.a() & 31) & 255;
+
+        packetdataserializer.writeByte(i);
+        switch (type) {
+        case 0:
+            if ( watchableobject.b() instanceof ProtocolData.DualByte )
+            {
+                ProtocolData.DualByte dualByte = (ProtocolData.DualByte) watchableobject.b();
+                packetdataserializer.writeByte( version >= 16 ? dualByte.value2 : dualByte.value );
+            } else
+            {
+                packetdataserializer.writeByte( ( (Number) watchableobject.b() ).byteValue() );
+            }
+            break;
+
+        case 1:
+            packetdataserializer.writeShort(((Number) watchableobject.b()).shortValue());
+            break;
+
+        case 2:
+            int val = ((Number) watchableobject.b()).intValue();
+            if ( watchableobject.b() instanceof ProtocolData.DualInt && version >= 46 ) {
+                val = ((ProtocolData.DualInt) watchableobject.b()).value2;
+            }
+            packetdataserializer.writeInt(val);
+            break;
+
+        case 3:
+            packetdataserializer.writeFloat(((Number) watchableobject.b()).floatValue());
+            break;
+
+        case 4:
+            try {
+                packetdataserializer.a((String) watchableobject.b());
+            } catch (java.io.IOException ex) {
+                throw new RuntimeException(ex);
+            }
+            break;
+
+        case 5:
+            ItemStack itemstack = (ItemStack) watchableobject.b();
+
+            packetdataserializer.a(itemstack);
+            break;
+
+        case 6:
+            ChunkCoordinates chunkcoordinates = (ChunkCoordinates) watchableobject.b();
+
+            packetdataserializer.writeInt(chunkcoordinates.x);
+            packetdataserializer.writeInt(chunkcoordinates.y);
+            packetdataserializer.writeInt(chunkcoordinates.z);
+        }
+    }
+    // Spigot end
+
+    public static List b(PacketDataSerializer packetdataserializer) {
+        ArrayList arraylist = null;
+
+        for (byte b0 = packetdataserializer.readByte(); b0 != 127; b0 = packetdataserializer.readByte()) {
+            if (arraylist == null) {
+                arraylist = new ArrayList();
+            }
+
+            int i = (b0 & 224) >> 5;
+            int j = b0 & 31;
+            WatchableObject watchableobject = null;
+
+            switch (i) {
+            case 0:
+                watchableobject = new WatchableObject(i, j, Byte.valueOf(packetdataserializer.readByte()));
+                break;
+
+            case 1:
+                watchableobject = new WatchableObject(i, j, Short.valueOf(packetdataserializer.readShort()));
+                break;
+
+            case 2:
+                watchableobject = new WatchableObject(i, j, Integer.valueOf(packetdataserializer.readInt()));
+                break;
+
+            case 3:
+                watchableobject = new WatchableObject(i, j, Float.valueOf(packetdataserializer.readFloat()));
+                break;
+
+            case 4:
+                try {
+                    watchableobject = new WatchableObject(i, j, packetdataserializer.c(32767));
+                } catch (java.io.IOException ex) {
+                    throw new RuntimeException(ex);
+                }
+                break;
+
+            case 5:
+                watchableobject = new WatchableObject(i, j, packetdataserializer.c());
+                break;
+
+            case 6:
+                int k = packetdataserializer.readInt();
+                int l = packetdataserializer.readInt();
+                int i1 = packetdataserializer.readInt();
+
+                watchableobject = new WatchableObject(i, j, new ChunkCoordinates(k, l, i1));
+            }
+
+            arraylist.add(watchableobject);
+        }
+
+        return arraylist;
+    }
+
+    public boolean d() {
+        return this.b;
+    }
+
+    public void e() {
+        this.e = false;
+    }
+
+    static {
+        // Spigot Start - remove valueOf
+        classToId.put(Byte.class, 0);
+        classToId.put(Short.class, 1);
+        classToId.put(Integer.class, 2);
+        classToId.put(Float.class, 3);
+        classToId.put(String.class, 4);
+        classToId.put(ItemStack.class, 5);
+        classToId.put(ChunkCoordinates.class, 6);
+        // Spigot End
+    }
+}
diff --git a/src/main/java/net/minecraft/server/DedicatedServer.java b/src/main/java/net/minecraft/server/DedicatedServer.java
index 83f2dad..9cc0526 100644
--- a/src/main/java/net/minecraft/server/DedicatedServer.java
+++ b/src/main/java/net/minecraft/server/DedicatedServer.java
@@ -18,6 +18,7 @@ import java.io.PrintStream;
 import org.apache.logging.log4j.Level;
 
 import org.bukkit.craftbukkit.LoggerOutputStream;
+import org.bukkit.craftbukkit.SpigotTimings; // Spigot
 import org.bukkit.event.server.ServerCommandEvent;
 // CraftBukkit end
 
@@ -76,7 +77,16 @@ public class DedicatedServer extends MinecraftServer implements IMinecraftServer
         i.info("Loading properties");
         this.propertyManager = new PropertyManager(this.options); // CraftBukkit - CLI argument support
         this.n = new EULA(new File("eula.txt"));
-        if (!this.n.a()) {
+        // Spigot Start
+        boolean eulaAgreed = Boolean.getBoolean( "com.mojang.eula.agree" );
+        if ( eulaAgreed )
+        {
+            System.err.println( "You have used the Spigot command line EULA agreement flag." );
+            System.err.println( "By using this setting you are indicating your agreement to Mojang's EULA (https://account.mojang.com/documents/minecraft_eula)." );
+            System.err.println( "If you do not agree to the above EULA please stop your server and remove this flag immediately." );
+        }
+        // Spigot End
+        if (!this.n.a() && !eulaAgreed) {
             i.info("You need to agree to the EULA in order to run the server. Go to eula.txt for more info.");
             this.n.b();
             return false;
@@ -116,11 +126,17 @@ public class DedicatedServer extends MinecraftServer implements IMinecraftServer
             if (this.L() < 0) {
                 this.setPort(this.propertyManager.getInt("server-port", 25565));
             }
+            // Spigot start
+            this.a((PlayerList) (new DedicatedPlayerList(this)));
+            org.spigotmc.SpigotConfig.init();
+            org.spigotmc.SpigotConfig.registerCommands();
+            // Spigot end
 
             i.info("Generating keypair");
             this.a(MinecraftEncryption.b());
             i.info("Starting Minecraft server on " + (this.getServerIp().length() == 0 ? "*" : this.getServerIp()) + ":" + this.L());
 
+        if (!org.spigotmc.SpigotConfig.lateBind) {
             try {
                 this.ai().a(inetaddress, this.L());
             } catch (Throwable ioexception) { // CraftBukkit - IOException -> Throwable
@@ -129,8 +145,13 @@ public class DedicatedServer extends MinecraftServer implements IMinecraftServer
                 i.warn("Perhaps a server is already running on that port?");
                 return false;
             }
+        }
 
-            this.a((PlayerList) (new DedicatedPlayerList(this))); // CraftBukkit
+            // Spigot Start - Move DedicatedPlayerList up and bring plugin loading from CraftServer to here
+            // this.a((PlayerList) (new DedicatedPlayerList(this))); // CraftBukkit
+            server.loadPlugins();
+            server.enablePlugins(org.bukkit.plugin.PluginLoadOrder.STARTUP);
+            // Spigot End
 
             if (!this.getOnlineMode()) {
                 i.warn("**** SERVER IS RUNNING IN OFFLINE/INSECURE MODE!");
@@ -214,6 +235,16 @@ public class DedicatedServer extends MinecraftServer implements IMinecraftServer
                 }
                 // CraftBukkit end
 
+        if (org.spigotmc.SpigotConfig.lateBind) {
+            try {
+                this.ai().a(inetaddress, this.L());
+            } catch (Throwable ioexception) { // CraftBukkit - IOException -> Throwable
+                i.warn("**** FAILED TO BIND TO PORT!");
+                i.warn("The exception was: {}", new Object[] { ioexception.toString()});
+                i.warn("Perhaps a server is already running on that port?");
+                return false;
+            }
+        }
                 return true;
             }
         }
@@ -282,6 +313,7 @@ public class DedicatedServer extends MinecraftServer implements IMinecraftServer
     }
 
     public void aB() {
+        SpigotTimings.serverCommandTimer.startTiming(); // Spigot
         while (!this.j.isEmpty()) {
             ServerCommand servercommand = (ServerCommand) this.j.remove(0);
 
@@ -294,6 +326,7 @@ public class DedicatedServer extends MinecraftServer implements IMinecraftServer
             this.server.dispatchServerCommand(this.console, servercommand);
             // CraftBukkit end
         }
+        SpigotTimings.serverCommandTimer.stopTiming(); // Spigot
     }
 
     public boolean X() {
@@ -389,6 +422,7 @@ public class DedicatedServer extends MinecraftServer implements IMinecraftServer
     }
 
     protected boolean aE() {
+        server.getLogger().info( "**** Beginning UUID conversion, this may take A LONG time ****"); // Spigot, let the user know whats up!
         boolean flag = false;
 
         int i;
diff --git a/src/main/java/net/minecraft/server/DispenseBehaviorBonemeal.java b/src/main/java/net/minecraft/server/DispenseBehaviorBonemeal.java
index b547bc9..c06e9a1 100644
--- a/src/main/java/net/minecraft/server/DispenseBehaviorBonemeal.java
+++ b/src/main/java/net/minecraft/server/DispenseBehaviorBonemeal.java
@@ -21,7 +21,7 @@ final class DispenseBehaviorBonemeal extends DispenseBehaviorItem {
 
             // CraftBukkit start
             org.bukkit.block.Block block = world.getWorld().getBlockAt(isourceblock.getBlockX(), isourceblock.getBlockY(), isourceblock.getBlockZ());
-            CraftItemStack craftItem = CraftItemStack.asNewCraftStack(itemstack.getItem());
+            CraftItemStack craftItem = CraftItemStack.asCraftMirror(itemstack);
 
             BlockDispenseEvent event = new BlockDispenseEvent(block, craftItem.clone(), new org.bukkit.util.Vector(0, 0, 0));
             if (!BlockDispenser.eventFired) {
diff --git a/src/main/java/net/minecraft/server/DispenseBehaviorFireball.java b/src/main/java/net/minecraft/server/DispenseBehaviorFireball.java
index d16f035..9fe2a8b 100644
--- a/src/main/java/net/minecraft/server/DispenseBehaviorFireball.java
+++ b/src/main/java/net/minecraft/server/DispenseBehaviorFireball.java
@@ -15,7 +15,7 @@ final class DispenseBehaviorFireball extends DispenseBehaviorItem {
         EnumFacing enumfacing = BlockDispenser.b(isourceblock.h());
         IPosition iposition = BlockDispenser.a(isourceblock);
         double d0 = iposition.getX() + (double) ((float) enumfacing.getAdjacentX() * 0.3F);
-        double d1 = iposition.getY() + (double) ((float) enumfacing.getAdjacentY() * 0.3F);
+        double d1 = iposition.getY() + (double) ((float) enumfacing.getAdjacentX() * 0.3F);
         double d2 = iposition.getZ() + (double) ((float) enumfacing.getAdjacentZ() * 0.3F);
         World world = isourceblock.k();
         Random random = world.random;
diff --git a/src/main/java/net/minecraft/server/EmptyClass.java b/src/main/java/net/minecraft/server/EmptyClass.java
new file mode 100644
index 0000000..2cafa6e
--- /dev/null
+++ b/src/main/java/net/minecraft/server/EmptyClass.java
@@ -0,0 +1,3 @@
+package net.minecraft.server;
+
+class EmptyClass {}
diff --git a/src/main/java/net/minecraft/server/EnchantmentManager.java b/src/main/java/net/minecraft/server/EnchantmentManager.java
new file mode 100644
index 0000000..ace8fb3
--- /dev/null
+++ b/src/main/java/net/minecraft/server/EnchantmentManager.java
@@ -0,0 +1,360 @@
+package net.minecraft.server;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Random;
+
+public class EnchantmentManager {
+
+    private static final Random random = new Random();
+    private static final EnchantmentModifierProtection b = new EnchantmentModifierProtection((EmptyClass) null);
+    private static final EnchantmentModifierDamage c = new EnchantmentModifierDamage((EmptyClass) null);
+    private static final EnchantmentModifierThorns d = new EnchantmentModifierThorns((EmptyClass) null);
+    private static final EnchantmentModifierArthropods e = new EnchantmentModifierArthropods((EmptyClass) null);
+
+    public static int getEnchantmentLevel(int i, ItemStack itemstack) {
+        if (itemstack == null) {
+            return 0;
+        } else {
+            NBTTagList nbttaglist = itemstack.getEnchantments();
+
+            if (nbttaglist == null) {
+                return 0;
+            } else {
+                for (int j = 0; j < nbttaglist.size(); ++j) {
+                    short short1 = nbttaglist.get(j).getShort("id");
+                    short short2 = nbttaglist.get(j).getShort("lvl");
+
+                    if (short1 == i) {
+                        return short2;
+                    }
+                }
+
+                return 0;
+            }
+        }
+    }
+
+    public static Map a(ItemStack itemstack) {
+        LinkedHashMap linkedhashmap = new LinkedHashMap();
+        NBTTagList nbttaglist = itemstack.getItem() == Items.ENCHANTED_BOOK ? Items.ENCHANTED_BOOK.g(itemstack) : itemstack.getEnchantments();
+
+        if (nbttaglist != null) {
+            for (int i = 0; i < nbttaglist.size(); ++i) {
+                short short1 = nbttaglist.get(i).getShort("id");
+                short short2 = nbttaglist.get(i).getShort("lvl");
+
+                linkedhashmap.put(Integer.valueOf(short1), Integer.valueOf(short2));
+            }
+        }
+
+        return linkedhashmap;
+    }
+
+    public static void a(Map map, ItemStack itemstack) {
+        NBTTagList nbttaglist = new NBTTagList();
+        Iterator iterator = map.keySet().iterator();
+
+        while (iterator.hasNext()) {
+            int i = ((Integer) iterator.next()).intValue();
+            NBTTagCompound nbttagcompound = new NBTTagCompound();
+
+            nbttagcompound.setShort("id", (short) i);
+            nbttagcompound.setShort("lvl", (short) ((Integer) map.get(Integer.valueOf(i))).intValue());
+            nbttaglist.add(nbttagcompound);
+            if (itemstack.getItem() == Items.ENCHANTED_BOOK) {
+                Items.ENCHANTED_BOOK.a(itemstack, new EnchantmentInstance(i, ((Integer) map.get(Integer.valueOf(i))).intValue()));
+            }
+        }
+
+        if (nbttaglist.size() > 0) {
+            if (itemstack.getItem() != Items.ENCHANTED_BOOK) {
+                itemstack.a("ench", (NBTBase) nbttaglist);
+            }
+        } else if (itemstack.hasTag()) {
+            itemstack.getTag().remove("ench");
+        }
+    }
+
+    public static int getEnchantmentLevel(int i, ItemStack[] aitemstack) {
+        if (aitemstack == null) {
+            return 0;
+        } else {
+            int j = 0;
+            ItemStack[] aitemstack1 = aitemstack;
+            int k = aitemstack.length;
+
+            for (int l = 0; l < k; ++l) {
+                ItemStack itemstack = aitemstack1[l];
+                int i1 = getEnchantmentLevel(i, itemstack);
+
+                if (i1 > j) {
+                    j = i1;
+                }
+            }
+
+            return j;
+        }
+    }
+
+    private static void a(EnchantmentModifier enchantmentmodifier, ItemStack itemstack) {
+        if (itemstack != null) {
+            NBTTagList nbttaglist = itemstack.getEnchantments();
+
+            if (nbttaglist != null) {
+                for (int i = 0; i < nbttaglist.size(); ++i) {
+                    short short1 = nbttaglist.get(i).getShort("id");
+                    short short2 = nbttaglist.get(i).getShort("lvl");
+
+                    if (Enchantment.byId[short1] != null) {
+                        enchantmentmodifier.a(Enchantment.byId[short1], short2);
+                    }
+                }
+            }
+        }
+    }
+
+    private static void a(EnchantmentModifier enchantmentmodifier, ItemStack[] aitemstack) {
+        ItemStack[] aitemstack1 = aitemstack;
+        int i = aitemstack.length;
+
+        for (int j = 0; j < i; ++j) {
+            ItemStack itemstack = aitemstack1[j];
+
+            a(enchantmentmodifier, itemstack);
+        }
+    }
+
+    public static int a(ItemStack[] aitemstack, DamageSource damagesource) {
+        b.a = 0;
+        b.b = damagesource;
+        a((EnchantmentModifier) b, aitemstack);
+        if (b.a > 25) {
+            b.a = 25;
+        }
+
+        return (b.a + 1 >> 1) + random.nextInt((b.a >> 1) + 1);
+    }
+
+    public static float a(EntityLiving entityliving, EntityLiving entityliving1) {
+        return a(entityliving.be(), entityliving1.getMonsterType());
+    }
+
+    public static float a(ItemStack itemstack, EnumMonsterType enummonstertype) {
+        c.a = 0.0F;
+        c.b = enummonstertype;
+        a((EnchantmentModifier) c, itemstack);
+        return c.a;
+    }
+
+    public static void a(EntityLiving entityliving, Entity entity) {
+        d.b = entity;
+        d.a = entityliving;
+        a((EnchantmentModifier) d, entityliving.getEquipment());
+        if (entity instanceof EntityHuman) {
+            a((EnchantmentModifier) d, entityliving.be());
+        }
+    }
+
+    public static void b(EntityLiving entityliving, Entity entity) {
+        e.a = entityliving;
+        e.b = entity;
+        a((EnchantmentModifier) e, entityliving.getEquipment());
+        if (entityliving instanceof EntityHuman) {
+            a((EnchantmentModifier) e, entityliving.be());
+        }
+    }
+
+    public static int getKnockbackEnchantmentLevel(EntityLiving entityliving, EntityLiving entityliving1) {
+        return getEnchantmentLevel(Enchantment.KNOCKBACK.id, entityliving.be());
+    }
+
+    public static int getFireAspectEnchantmentLevel(EntityLiving entityliving) {
+        return getEnchantmentLevel(Enchantment.FIRE_ASPECT.id, entityliving.be());
+    }
+
+    public static int getOxygenEnchantmentLevel(EntityLiving entityliving) {
+        return getEnchantmentLevel(Enchantment.OXYGEN.id, entityliving.getEquipment());
+    }
+
+    public static int getDigSpeedEnchantmentLevel(EntityLiving entityliving) {
+        return getEnchantmentLevel(Enchantment.DIG_SPEED.id, entityliving.be());
+    }
+
+    public static boolean hasSilkTouchEnchantment(EntityLiving entityliving) {
+        return getEnchantmentLevel(Enchantment.SILK_TOUCH.id, entityliving.be()) > 0;
+    }
+
+    public static int getBonusBlockLootEnchantmentLevel(EntityLiving entityliving) {
+        return getEnchantmentLevel(Enchantment.LOOT_BONUS_BLOCKS.id, entityliving.be());
+    }
+
+    public static int getLuckEnchantmentLevel(EntityLiving entityliving) {
+        return getEnchantmentLevel(Enchantment.LUCK.id, entityliving.be());
+    }
+
+    public static int getLureEnchantmentLevel(EntityLiving entityliving) {
+        return getEnchantmentLevel(Enchantment.LURE.id, entityliving.be());
+    }
+
+    public static int getBonusMonsterLootEnchantmentLevel(EntityLiving entityliving) {
+        return getEnchantmentLevel(Enchantment.LOOT_BONUS_MOBS.id, entityliving.be());
+    }
+
+    public static boolean hasWaterWorkerEnchantment(EntityLiving entityliving) {
+        return getEnchantmentLevel(Enchantment.WATER_WORKER.id, entityliving.getEquipment()) > 0;
+    }
+
+    public static ItemStack a(Enchantment enchantment, EntityLiving entityliving) {
+        ItemStack[] aitemstack = entityliving.getEquipment();
+        int i = aitemstack.length;
+
+        for (int j = 0; j < i; ++j) {
+            ItemStack itemstack = aitemstack[j];
+
+            if (itemstack != null && getEnchantmentLevel(enchantment.id, itemstack) > 0) {
+                return itemstack;
+            }
+        }
+
+        return null;
+    }
+
+    public static int a(Random random, int i, int j, ItemStack itemstack) {
+        Item item = itemstack.getItem();
+        int k = item.c();
+
+        if (k <= 0) {
+            return 0;
+        } else {
+            if (j > 15) {
+                j = 15;
+            }
+
+            int l = random.nextInt(8) + 1 + (j >> 1) + random.nextInt(j + 1);
+
+            return i == 0 ? Math.max(l / 3, 1) : (i == 1 ? l * 2 / 3 + 1 : Math.max(l, j * 2));
+        }
+    }
+
+    public static ItemStack a(Random random, ItemStack itemstack, int i) {
+        List list = b(random, itemstack, i);
+        boolean flag = itemstack.getItem() == Items.BOOK;
+
+        if (flag) {
+            itemstack.setItem(Items.ENCHANTED_BOOK);
+        }
+
+        if (list != null) {
+            Iterator iterator = list.iterator();
+
+            while (iterator.hasNext()) {
+                EnchantmentInstance enchantmentinstance = (EnchantmentInstance) iterator.next();
+
+                if (flag) {
+                    Items.ENCHANTED_BOOK.a(itemstack, enchantmentinstance);
+                } else {
+                    itemstack.addEnchantment(enchantmentinstance.enchantment, enchantmentinstance.level);
+                }
+            }
+        }
+
+        return itemstack;
+    }
+
+    public static List b(Random random, ItemStack itemstack, int i) {
+        Item item = itemstack.getItem();
+        int j = item.c();
+
+        if (j <= 0) {
+            return null;
+        } else {
+            j /= 2;
+            j = 1 + random.nextInt((j >> 1) + 1) + random.nextInt((j >> 1) + 1);
+            int k = j + i;
+            float f = (random.nextFloat() + random.nextFloat() - 1.0F) * 0.15F;
+            int l = (int) ((float) k * (1.0F + f) + 0.5F);
+
+            if (l < 1) {
+                l = 1;
+            }
+
+            ArrayList arraylist = null;
+            Map map = b(l, itemstack);
+
+            if (map != null && !map.isEmpty()) {
+                EnchantmentInstance enchantmentinstance = (EnchantmentInstance) WeightedRandom.a(random, map.values());
+
+                if (enchantmentinstance != null) {
+                    arraylist = new ArrayList();
+                    arraylist.add(enchantmentinstance);
+
+                    for (int i1 = l; random.nextInt(50) <= i1; i1 >>= 1) {
+                        Iterator iterator = map.keySet().iterator();
+
+                        while (iterator.hasNext()) {
+                            Integer integer = (Integer) iterator.next();
+                            boolean flag = true;
+                            Iterator iterator1 = arraylist.iterator();
+
+                            while (true) {
+                                if (iterator1.hasNext()) {
+                                    EnchantmentInstance enchantmentinstance1 = (EnchantmentInstance) iterator1.next();
+
+                                    if (enchantmentinstance1.enchantment.a(Enchantment.byId[integer.intValue()])) {
+                                        continue;
+                                    }
+
+                                    flag = false;
+                                }
+
+                                if (!flag) {
+                                    iterator.remove();
+                                }
+                                break;
+                            }
+                        }
+
+                        if (!map.isEmpty()) {
+                            EnchantmentInstance enchantmentinstance2 = (EnchantmentInstance) WeightedRandom.a(random, map.values());
+
+                            arraylist.add(enchantmentinstance2);
+                        }
+                    }
+                }
+            }
+
+            return arraylist;
+        }
+    }
+
+    public static Map b(int i, ItemStack itemstack) {
+        Item item = itemstack.getItem();
+        HashMap hashmap = null;
+        boolean flag = itemstack.getItem() == Items.BOOK;
+        Enchantment[] aenchantment = Enchantment.byId;
+        int j = aenchantment.length;
+
+        for (int k = 0; k < j; ++k) {
+            Enchantment enchantment = aenchantment[k];
+
+            if (enchantment != null && (enchantment.slot.canEnchant(item) || flag)) {
+                for (int l = enchantment.getStartLevel(); l <= enchantment.getMaxLevel(); ++l) {
+                    if (i >= enchantment.a(l) && i <= enchantment.b(l)) {
+                        if (hashmap == null) {
+                            hashmap = new HashMap();
+                        }
+
+                        hashmap.put(Integer.valueOf(enchantment.id), new EnchantmentInstance(enchantment, l));
+                    }
+                }
+            }
+        }
+
+        return hashmap;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/EnchantmentModifierArthropods.java b/src/main/java/net/minecraft/server/EnchantmentModifierArthropods.java
new file mode 100644
index 0000000..c8e11db
--- /dev/null
+++ b/src/main/java/net/minecraft/server/EnchantmentModifierArthropods.java
@@ -0,0 +1,17 @@
+package net.minecraft.server;
+
+final class EnchantmentModifierArthropods implements EnchantmentModifier {
+
+    public EntityLiving a;
+    public Entity b;
+
+    private EnchantmentModifierArthropods() {}
+
+    public void a(Enchantment enchantment, int i) {
+        enchantment.a(this.a, this.b, i);
+    }
+
+    EnchantmentModifierArthropods(EmptyClass emptyclass) {
+        this();
+    }
+}
diff --git a/src/main/java/net/minecraft/server/EnchantmentModifierDamage.java b/src/main/java/net/minecraft/server/EnchantmentModifierDamage.java
new file mode 100644
index 0000000..8610c7a
--- /dev/null
+++ b/src/main/java/net/minecraft/server/EnchantmentModifierDamage.java
@@ -0,0 +1,17 @@
+package net.minecraft.server;
+
+final class EnchantmentModifierDamage implements EnchantmentModifier {
+
+    public float a;
+    public EnumMonsterType b;
+
+    private EnchantmentModifierDamage() {}
+
+    public void a(Enchantment enchantment, int i) {
+        this.a += enchantment.a(i, this.b);
+    }
+
+    EnchantmentModifierDamage(EmptyClass emptyclass) {
+        this();
+    }
+}
diff --git a/src/main/java/net/minecraft/server/EnchantmentModifierProtection.java b/src/main/java/net/minecraft/server/EnchantmentModifierProtection.java
new file mode 100644
index 0000000..8c03320
--- /dev/null
+++ b/src/main/java/net/minecraft/server/EnchantmentModifierProtection.java
@@ -0,0 +1,17 @@
+package net.minecraft.server;
+
+final class EnchantmentModifierProtection implements EnchantmentModifier {
+
+    public int a;
+    public DamageSource b;
+
+    private EnchantmentModifierProtection() {}
+
+    public void a(Enchantment enchantment, int i) {
+        this.a += enchantment.a(i, this.b);
+    }
+
+    EnchantmentModifierProtection(EmptyClass emptyclass) {
+        this();
+    }
+}
diff --git a/src/main/java/net/minecraft/server/EnchantmentModifierThorns.java b/src/main/java/net/minecraft/server/EnchantmentModifierThorns.java
new file mode 100644
index 0000000..41993e0
--- /dev/null
+++ b/src/main/java/net/minecraft/server/EnchantmentModifierThorns.java
@@ -0,0 +1,17 @@
+package net.minecraft.server;
+
+final class EnchantmentModifierThorns implements EnchantmentModifier {
+
+    public EntityLiving a;
+    public Entity b;
+
+    private EnchantmentModifierThorns() {}
+
+    public void a(Enchantment enchantment, int i) {
+        enchantment.b(this.a, this.b, i);
+    }
+
+    EnchantmentModifierThorns(EmptyClass emptyclass) {
+        this();
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Entity.java b/src/main/java/net/minecraft/server/Entity.java
index 09c9c8e..dea5e19 100644
--- a/src/main/java/net/minecraft/server/Entity.java
+++ b/src/main/java/net/minecraft/server/Entity.java
@@ -15,6 +15,7 @@ import org.bukkit.entity.Hanging;
 import org.bukkit.entity.LivingEntity;
 import org.bukkit.entity.Painting;
 import org.bukkit.entity.Vehicle;
+import org.spigotmc.CustomTimingsHandler; // Spigot
 import org.bukkit.event.entity.EntityCombustByEntityEvent;
 import org.bukkit.event.hanging.HangingBreakByEntityEvent;
 import org.bukkit.event.painting.PaintingBreakByEntityEvent;
@@ -89,7 +90,7 @@ public abstract class Entity {
     public int ticksLived;
     public int maxFireTicks;
     public int fireTicks; // CraftBukkit - private -> public
-    protected boolean inWater;
+    public boolean inWater; // Spigot - protected -> public
     public int noDamageTicks;
     private boolean justCreated;
     protected boolean fireProof;
@@ -113,6 +114,15 @@ public abstract class Entity {
     public boolean valid; // CraftBukkit
     public org.bukkit.projectiles.ProjectileSource projectileSource; // CraftBukkit - For projectiles only
 
+    // Spigot start
+    public CustomTimingsHandler tickTimer = org.bukkit.craftbukkit.SpigotTimings.getEntityTimings(this); // Spigot
+    public final byte activationType = org.spigotmc.ActivationRange.initializeEntityActivationType(this);
+    public final boolean defaultActivationState;
+    public long activatedTick = 0;
+    public boolean fromMobSpawner;
+    public void inactiveTick() { }
+    // Spigot end
+
     public int getId() {
         return this.id;
     }
@@ -132,13 +142,18 @@ public abstract class Entity {
         this.random = new Random();
         this.maxFireTicks = 1;
         this.justCreated = true;
-        this.uniqueID = UUID.randomUUID();
+        this.uniqueID = new UUID(random.nextLong(), random.nextLong()); // Spigot
         this.as = EnumEntitySize.SIZE_2;
         this.world = world;
         this.setPosition(0.0D, 0.0D, 0.0D);
         if (world != null) {
             this.dimension = world.worldProvider.dimension;
+            // Spigot start
+            this.defaultActivationState = org.spigotmc.ActivationRange.initializeEntityActivationState(this, world.spigotConfig);
+        } else {
+            this.defaultActivationState = false;
         }
+        // Spigot end
 
         this.datawatcher = new DataWatcher(this);
         this.datawatcher.a(0, Byte.valueOf((byte) 0));
@@ -204,7 +219,7 @@ public abstract class Entity {
         if ((f == Float.POSITIVE_INFINITY) || (f == Float.NEGATIVE_INFINITY)) {
             if (this instanceof EntityPlayer) {
                 this.world.getServer().getLogger().warning(((CraftPlayer) this.getBukkitEntity()).getName() + " was caught trying to crash the server with an invalid yaw");
-                ((CraftPlayer) this.getBukkitEntity()).kickPlayer("Nope");
+                ((CraftPlayer) this.getBukkitEntity()).kickPlayer("Infinite yaw (Hacking?)"); //Spigot "Nope" -> Descriptive reason
             }
             f = 0;
         }
@@ -217,7 +232,7 @@ public abstract class Entity {
         if ((f1 == Float.POSITIVE_INFINITY) || (f1 == Float.NEGATIVE_INFINITY)) {
             if (this instanceof EntityPlayer) {
                 this.world.getServer().getLogger().warning(((CraftPlayer) this.getBukkitEntity()).getName() + " was caught trying to crash the server with an invalid pitch");
-                ((CraftPlayer) this.getBukkitEntity()).kickPlayer("Nope");
+                ((CraftPlayer) this.getBukkitEntity()).kickPlayer("Infinite pitch (Hacking?)"); //Spigot "Nope" -> Descriptive reason
             }
             f1 = 0;
         }
@@ -416,6 +431,7 @@ public abstract class Entity {
             return;
         }
         // CraftBukkit end
+        org.bukkit.craftbukkit.SpigotTimings.entityMoveTimer.startTiming(); // Spigot
         if (this.X) {
             this.boundingBox.d(d0, d1, d2);
             this.locX = (this.boundingBox.a + this.boundingBox.d) / 2.0D;
@@ -724,6 +740,7 @@ public abstract class Entity {
 
             this.world.methodProfiler.b();
         }
+        org.bukkit.craftbukkit.SpigotTimings.entityMoveTimer.stopTiming(); // Spigot
     }
 
     protected String H() {
@@ -995,6 +1012,7 @@ public abstract class Entity {
 
     public void b_(EntityHuman entityhuman) {}
 
+    int numCollisions = 0; // Spigot
     public void collide(Entity entity) {
         if (entity.passenger != this && entity.vehicle != this) {
             double d0 = entity.locX - this.locX;
@@ -1107,6 +1125,7 @@ public abstract class Entity {
             nbttagcompound.setLong("WorldUUIDLeast", this.world.getDataManager().getUUID().getLeastSignificantBits());
             nbttagcompound.setLong("WorldUUIDMost", this.world.getDataManager().getUUID().getMostSignificantBits());
             nbttagcompound.setInt("Bukkit.updateLevel", CURRENT_LEVEL);
+            nbttagcompound.setInt("Spigot.ticksLived", this.ticksLived);
             // CraftBukkit end
             this.b(nbttagcompound);
             if (this.vehicle != null) {
@@ -1175,6 +1194,8 @@ public abstract class Entity {
             if (this instanceof EntityLiving) {
                 EntityLiving entity = (EntityLiving) this;
 
+                this.ticksLived = nbttagcompound.getInt("Spigot.ticksLived");
+
                 // Reset the persistence for tamed animals
                 if (entity instanceof EntityTameableAnimal && !isLevelAtLeast(nbttagcompound, 2) && !nbttagcompound.getBoolean("PersistenceRequired")) {
                     EntityInsentient entityinsentient = (EntityInsentient) entity;
@@ -1385,7 +1406,7 @@ public abstract class Entity {
 
     public void ac() {
         if (this.passenger != null) {
-            this.passenger.setPosition(this.locX, this.locY + this.ad() + this.passenger.ad(), this.locZ);
+            this.passenger.setPosition(this.locX, this.locY + this.ae() + this.passenger.ad(), this.locZ); // Spigot
         }
     }
 
@@ -1434,6 +1455,7 @@ public abstract class Entity {
                     }
                 }
                 // CraftBukkit end
+                pluginManager.callEvent( new org.spigotmc.event.entity.EntityDismountEvent( this.getBukkitEntity(), this.vehicle.getBukkitEntity() ) ); // Spigot
 
                 this.setPositionRotation(this.vehicle.locX, this.vehicle.boundingBox.b + (double) this.vehicle.length, this.vehicle.locZ, this.yaw, this.pitch);
                 this.vehicle.passenger = null;
@@ -1469,6 +1491,17 @@ public abstract class Entity {
                 }
             }
             // CraftBukkit end
+            // Spigot Start
+            if ( entity.world.isChunkLoaded( (int) entity.locX >> 4, (int) entity.locZ >> 4 ) )
+            {
+                org.spigotmc.event.entity.EntityMountEvent event = new org.spigotmc.event.entity.EntityMountEvent( this.getBukkitEntity(), entity.getBukkitEntity() );
+                pluginManager.callEvent( event );
+                if ( event.isCancelled() )
+                {
+                    return;
+                }
+            }
+            // Spigot End
 
             if (this.vehicle != null) {
                 this.vehicle.passenger = null;
diff --git a/src/main/java/net/minecraft/server/EntityAgeable.java b/src/main/java/net/minecraft/server/EntityAgeable.java
index 36ed831..af73b81 100644
--- a/src/main/java/net/minecraft/server/EntityAgeable.java
+++ b/src/main/java/net/minecraft/server/EntityAgeable.java
@@ -6,6 +6,31 @@ public abstract class EntityAgeable extends EntityCreature {
     private float bq;
     public boolean ageLocked = false; // CraftBukkit
 
+    // Spigot start
+    @Override
+    public void inactiveTick()
+    {
+        super.inactiveTick();
+        if ( this.world.isStatic || this.ageLocked )
+        { // CraftBukkit
+            this.a( this.isBaby() );
+        } else
+        {
+            int i = this.getAge();
+
+            if ( i < 0 )
+            {
+                ++i;
+                this.setAge( i );
+            } else if ( i > 0 )
+            {
+                --i;
+                this.setAge( i );
+            }
+        }
+    }
+    // Spigot end
+
     public EntityAgeable(World world) {
         super(world);
     }
@@ -48,11 +73,11 @@ public abstract class EntityAgeable extends EntityCreature {
 
     protected void c() {
         super.c();
-        this.datawatcher.a(12, new Integer(0));
+        this.datawatcher.a(12, new org.spigotmc.ProtocolData.IntByte(0, (byte) 0)); // Spigot - protocol patch
     }
 
     public int getAge() {
-        return this.datawatcher.getInt(12);
+        return this.datawatcher.getIntByte(12).value; // Spigot - protocol patch
     }
 
     public void a(int i) {
@@ -67,7 +92,7 @@ public abstract class EntityAgeable extends EntityCreature {
     }
 
     public void setAge(int i) {
-        this.datawatcher.watch(12, Integer.valueOf(i));
+        this.datawatcher.watch(12, new org.spigotmc.ProtocolData.IntByte(i, (byte) ( i < 0 ? -1 : (i >= 6000 ? 1 : 0)))); // Spigot - protocol patch
         this.a(this.isBaby());
     }
 
diff --git a/src/main/java/net/minecraft/server/EntityAnimal.java b/src/main/java/net/minecraft/server/EntityAnimal.java
new file mode 100644
index 0000000..b9fb8fc
--- /dev/null
+++ b/src/main/java/net/minecraft/server/EntityAnimal.java
@@ -0,0 +1,271 @@
+package net.minecraft.server;
+
+import java.util.List;
+
+public abstract class EntityAnimal extends EntityAgeable implements IAnimal {
+
+    private int love;
+    private int bq;
+    private EntityHuman br;
+
+    public EntityAnimal(World world) {
+        super(world);
+    }
+
+    protected void bp() {
+        if (this.getAge() != 0) {
+            this.love = 0;
+        }
+
+        super.bp();
+    }
+
+    public void e() {
+        super.e();
+        if (this.getAge() != 0) {
+            this.love = 0;
+        }
+
+        if (this.love > 0) {
+            --this.love;
+            String s = "heart";
+
+            if (this.love % 10 == 0) {
+                double d0 = this.random.nextGaussian() * 0.02D;
+                double d1 = this.random.nextGaussian() * 0.02D;
+                double d2 = this.random.nextGaussian() * 0.02D;
+
+                this.world.addParticle(s, this.locX + (double) (this.random.nextFloat() * this.width * 2.0F) - (double) this.width, this.locY + 0.5D + (double) (this.random.nextFloat() * this.length), this.locZ + (double) (this.random.nextFloat() * this.width * 2.0F) - (double) this.width, d0, d1, d2);
+            }
+        } else {
+            this.bq = 0;
+        }
+    }
+
+    protected void a(Entity entity, float f) {
+        if (entity instanceof EntityHuman) {
+            if (f < 3.0F) {
+                double d0 = entity.locX - this.locX;
+                double d1 = entity.locZ - this.locZ;
+
+                this.yaw = (float) (Math.atan2(d1, d0) * 180.0D / 3.1415927410125732D) - 90.0F;
+                this.bn = true;
+            }
+
+            EntityHuman entityhuman = (EntityHuman) entity;
+
+            if (entityhuman.bF() == null || !this.c(entityhuman.bF())) {
+                this.target = null;
+            }
+        } else if (entity instanceof EntityAnimal) {
+            EntityAnimal entityanimal = (EntityAnimal) entity;
+
+            if (this.getAge() > 0 && entityanimal.getAge() < 0) {
+                if ((double) f < 2.5D) {
+                    this.bn = true;
+                }
+            } else if (this.love > 0 && entityanimal.love > 0) {
+                if (entityanimal.target == null) {
+                    entityanimal.target = this;
+                }
+
+                if (entityanimal.target == this && (double) f < 3.5D) {
+                    ++entityanimal.love;
+                    ++this.love;
+                    ++this.bq;
+                    if (this.bq % 4 == 0) {
+                        this.world.addParticle("heart", this.locX + (double) (this.random.nextFloat() * this.width * 2.0F) - (double) this.width, this.locY + 0.5D + (double) (this.random.nextFloat() * this.length), this.locZ + (double) (this.random.nextFloat() * this.width * 2.0F) - (double) this.width, 0.0D, 0.0D, 0.0D);
+                    }
+
+                    if (this.bq == 60) {
+                        this.b((EntityAnimal) entity);
+                    }
+                } else {
+                    this.bq = 0;
+                }
+            } else {
+                this.bq = 0;
+                this.target = null;
+            }
+        }
+    }
+
+    private void b(EntityAnimal entityanimal) {
+        EntityAgeable entityageable = this.createChild(entityanimal);
+
+        if (entityageable != null) {
+            if (this.br == null && entityanimal.cd() != null) {
+                this.br = entityanimal.cd();
+            }
+
+            if (this.br != null) {
+                this.br.a(StatisticList.x);
+                if (this instanceof EntityCow) {
+                    this.br.a((Statistic) AchievementList.H);
+                }
+            }
+
+            this.setAge(6000);
+            entityanimal.setAge(6000);
+            this.love = 0;
+            this.bq = 0;
+            this.target = null;
+            entityanimal.target = null;
+            entityanimal.bq = 0;
+            entityanimal.love = 0;
+            entityageable.setAge(-24000);
+            entityageable.setPositionRotation(this.locX, this.locY, this.locZ, this.yaw, this.pitch);
+
+            for (int i = 0; i < 7; ++i) {
+                double d0 = this.random.nextGaussian() * 0.02D;
+                double d1 = this.random.nextGaussian() * 0.02D;
+                double d2 = this.random.nextGaussian() * 0.02D;
+
+                this.world.addParticle("heart", this.locX + (double) (this.random.nextFloat() * this.width * 2.0F) - (double) this.width, this.locY + 0.5D + (double) (this.random.nextFloat() * this.length), this.locZ + (double) (this.random.nextFloat() * this.width * 2.0F) - (double) this.width, d0, d1, d2);
+            }
+
+            this.world.addEntity(entityageable);
+        }
+    }
+
+    public boolean damageEntity(DamageSource damagesource, float f) {
+        if (this.isInvulnerable()) {
+            return false;
+        } else {
+            this.bo = 60;
+            if (!this.bk()) {
+                AttributeInstance attributeinstance = this.getAttributeInstance(GenericAttributes.d);
+
+                if (attributeinstance.a(h) == null) {
+                    attributeinstance.a(i);
+                }
+            }
+
+            this.target = null;
+            this.love = 0;
+            return super.damageEntity(damagesource, f);
+        }
+    }
+
+    public float a(int i, int j, int k) {
+        return this.world.getType(i, j - 1, k) == Blocks.GRASS ? 10.0F : this.world.n(i, j, k) - 0.5F;
+    }
+
+    public void b(NBTTagCompound nbttagcompound) {
+        super.b(nbttagcompound);
+        nbttagcompound.setInt("InLove", this.love);
+    }
+
+    public void a(NBTTagCompound nbttagcompound) {
+        super.a(nbttagcompound);
+        this.love = nbttagcompound.getInt("InLove");
+    }
+
+    protected Entity findTarget() {
+        if (this.bo > 0) {
+            return null;
+        } else {
+            float f = 8.0F;
+            List list;
+            int i;
+            EntityAnimal entityanimal;
+
+            if (this.love > 0) {
+                list = this.world.a(this.getClass(), this.boundingBox.grow((double) f, (double) f, (double) f));
+
+                for (i = 0; i < list.size(); ++i) {
+                    entityanimal = (EntityAnimal) list.get(i);
+                    if (entityanimal != this && entityanimal.love > 0) {
+                        return entityanimal;
+                    }
+                }
+            } else if (this.getAge() == 0) {
+                list = this.world.a(EntityHuman.class, this.boundingBox.grow((double) f, (double) f, (double) f));
+
+                for (i = 0; i < list.size(); ++i) {
+                    EntityHuman entityhuman = (EntityHuman) list.get(i);
+
+                    if (entityhuman.bF() != null && this.c(entityhuman.bF())) {
+                        return entityhuman;
+                    }
+                }
+            } else if (this.getAge() > 0) {
+                list = this.world.a(this.getClass(), this.boundingBox.grow((double) f, (double) f, (double) f));
+
+                for (i = 0; i < list.size(); ++i) {
+                    entityanimal = (EntityAnimal) list.get(i);
+                    if (entityanimal != this && entityanimal.getAge() < 0) {
+                        return entityanimal;
+                    }
+                }
+            }
+
+            return null;
+        }
+    }
+
+    public boolean canSpawn() {
+        int i = MathHelper.floor(this.locX);
+        int j = MathHelper.floor(this.boundingBox.b);
+        int k = MathHelper.floor(this.locZ);
+
+        return this.world.getType(i, j - 1, k) == Blocks.GRASS && this.world.j(i, j, k) > 8 && super.canSpawn();
+    }
+
+    public int q() {
+        return 120;
+    }
+
+    protected boolean isTypeNotPersistent() {
+        return false;
+    }
+
+    protected int getExpValue(EntityHuman entityhuman) {
+        return 1 + this.world.random.nextInt(3);
+    }
+
+    public boolean c(ItemStack itemstack) {
+        return itemstack.getItem() == Items.WHEAT;
+    }
+
+    public boolean a(EntityHuman entityhuman) {
+        ItemStack itemstack = entityhuman.inventory.getItemInHand();
+
+        if (itemstack != null && this.c(itemstack) && this.getAge() == 0 && this.love <= 0) {
+            if (!entityhuman.abilities.canInstantlyBuild) {
+                --itemstack.count;
+                if (itemstack.count <= 0) {
+                    entityhuman.inventory.setItem(entityhuman.inventory.itemInHandIndex, (ItemStack) null);
+                }
+            }
+
+            this.f(entityhuman);
+            return true;
+        } else {
+            return super.a(entityhuman);
+        }
+    }
+
+    public void f(EntityHuman entityhuman) {
+        this.love = 600;
+        this.br = entityhuman;
+        this.target = null;
+        this.world.broadcastEntityEffect(this, (byte) 18);
+    }
+
+    public EntityHuman cd() {
+        return this.br;
+    }
+
+    public boolean ce() {
+        return this.love > 0;
+    }
+
+    public void cf() {
+        this.love = 0;
+    }
+
+    public boolean mate(EntityAnimal entityanimal) {
+        return entityanimal == this ? false : (entityanimal.getClass() != this.getClass() ? false : this.ce() && entityanimal.ce());
+    }
+}
diff --git a/src/main/java/net/minecraft/server/EntityArrow.java b/src/main/java/net/minecraft/server/EntityArrow.java
index 88b0751..de8dda7 100644
--- a/src/main/java/net/minecraft/server/EntityArrow.java
+++ b/src/main/java/net/minecraft/server/EntityArrow.java
@@ -15,7 +15,7 @@ public class EntityArrow extends Entity implements IProjectile {
     private int f = -1;
     private Block g;
     private int h;
-    private boolean inGround;
+    public boolean inGround = false; // Spigot - private -> public
     public int fromPlayer;
     public int shake;
     public Entity shooter;
@@ -24,6 +24,18 @@ public class EntityArrow extends Entity implements IProjectile {
     private double damage = 2.0D;
     public int knockbackStrength; // CraftBukkit - private -> public
 
+    // Spigot Start
+    @Override
+    public void inactiveTick()
+    {
+        if ( this.inGround )
+        {
+            this.at += 19; // Despawn counter. First int after shooter
+        }
+        super.inactiveTick();
+    }
+    // Spigot End
+
     public EntityArrow(World world) {
         super(world);
         this.j = 10.0D;
@@ -144,7 +156,7 @@ public class EntityArrow extends Entity implements IProjectile {
 
             if (block == this.g && i == this.h) {
                 ++this.at;
-                if (this.at == 1200) {
+                if (this.at >= world.spigotConfig.arrowDespawnRate) { // First int after shooter
                     this.die();
                 }
             } else {
diff --git a/src/main/java/net/minecraft/server/EntityBoat.java b/src/main/java/net/minecraft/server/EntityBoat.java
index 8a3ea63..c9f2b13 100644
--- a/src/main/java/net/minecraft/server/EntityBoat.java
+++ b/src/main/java/net/minecraft/server/EntityBoat.java
@@ -147,7 +147,7 @@ public class EntityBoat extends Entity {
         return !this.dead;
     }
 
-        public void h() {
+    public void h() {
         // CraftBukkit start
         double prevX = this.locX;
         double prevY = this.locY;
diff --git a/src/main/java/net/minecraft/server/EntityEnderDragon.java b/src/main/java/net/minecraft/server/EntityEnderDragon.java
index 78023c4..5d761aa 100644
--- a/src/main/java/net/minecraft/server/EntityEnderDragon.java
+++ b/src/main/java/net/minecraft/server/EntityEnderDragon.java
@@ -551,6 +551,7 @@ public class EntityEnderDragon extends EntityInsentient implements IComplex, IMo
                     double deltaX = this.locX - player.locX;
                     double deltaZ = this.locZ - player.locZ;
                     double distanceSquared = deltaX * deltaX + deltaZ * deltaZ;
+                    if ( world.spigotConfig.dragonDeathSoundRadius > 0 && distanceSquared > world.spigotConfig.dragonDeathSoundRadius * world.spigotConfig.dragonDeathSoundRadius ) continue; // Spigot
                     if (distanceSquared > viewDistance * viewDistance) {
                         double deltaLength = Math.sqrt(distanceSquared);
                         double relativeX = player.locX + (deltaX / deltaLength) * viewDistance;
diff --git a/src/main/java/net/minecraft/server/EntityEnderman.java b/src/main/java/net/minecraft/server/EntityEnderman.java
index fa6670b..87afc9c 100644
--- a/src/main/java/net/minecraft/server/EntityEnderman.java
+++ b/src/main/java/net/minecraft/server/EntityEnderman.java
@@ -7,6 +7,7 @@ import org.bukkit.Location;
 import org.bukkit.craftbukkit.event.CraftEventFactory;
 import org.bukkit.event.entity.EntityTeleportEvent;
 // CraftBukkit end
+import org.spigotmc.ProtocolData; // Spigot - protocol patch
 
 public class EntityEnderman extends EntityMonster {
 
@@ -33,7 +34,7 @@ public class EntityEnderman extends EntityMonster {
 
     protected void c() {
         super.c();
-        this.datawatcher.a(16, new Byte((byte) 0));
+        this.datawatcher.a( 16, new ProtocolData.ByteShort( (short) 0 ) ); // Spigot - protocol patch, handle metadata change
         this.datawatcher.a(17, new Byte((byte) 0));
         this.datawatcher.a(18, new Byte((byte) 0));
     }
@@ -315,11 +316,11 @@ public class EntityEnderman extends EntityMonster {
     }
 
     public void setCarried(Block block) {
-        this.datawatcher.watch(16, Byte.valueOf((byte) (Block.getId(block) & 255)));
+        this.datawatcher.watch( 16, new ProtocolData.ByteShort( (short) Block.getId( block ) ) ); // Spigot - protocol patch, handle metadata change
     }
 
     public Block getCarried() {
-        return Block.getById(this.datawatcher.getByte(16));
+        return Block.getById(this.datawatcher.getShort( 16 )); // Spigot - protocol patch, handle metadata change
     }
 
     public void setCarriedData(int i) {
diff --git a/src/main/java/net/minecraft/server/EntityFallingBlock.java b/src/main/java/net/minecraft/server/EntityFallingBlock.java
index 5576f15..df602bd 100644
--- a/src/main/java/net/minecraft/server/EntityFallingBlock.java
+++ b/src/main/java/net/minecraft/server/EntityFallingBlock.java
@@ -83,6 +83,7 @@ public class EntityFallingBlock extends Entity {
                     }
 
                     this.world.setAir(i, j, k);
+                    world.spigotConfig.antiXrayInstance.updateNearbyBlocks(world, i, j, k); // Spigot
                 }
 
                 if (this.onGround) {
@@ -98,6 +99,7 @@ public class EntityFallingBlock extends Entity {
                             }
                             this.world.setTypeAndData(i, j, k, this.id, this.data, 3);
                             // CraftBukkit end
+                            world.spigotConfig.antiXrayInstance.updateNearbyBlocks(world, i, j, k); // Spigot
 
                             if (this.id instanceof BlockFalling) {
                                 ((BlockFalling) this.id).a(this.world, i, j, k, this.data);
diff --git a/src/main/java/net/minecraft/server/EntityFireball.java b/src/main/java/net/minecraft/server/EntityFireball.java
index 02d90aa..663714d 100644
--- a/src/main/java/net/minecraft/server/EntityFireball.java
+++ b/src/main/java/net/minecraft/server/EntityFireball.java
@@ -199,6 +199,8 @@ public abstract class EntityFireball extends Entity {
         nbttagcompound.setByte("inGround", (byte) (this.i ? 1 : 0));
         // CraftBukkit - Fix direction being mismapped to invalid variables
         nbttagcompound.set("power", this.a(new double[] { this.dirX, this.dirY, this.dirZ}));
+        // Spigot - Support vanilla's direction tag
+        nbttagcompound.set("direction", this.a(new double[] { this.motX, this.motY, this.motZ}));
     }
 
     public void a(NBTTagCompound nbttagcompound) {
@@ -215,6 +217,13 @@ public abstract class EntityFireball extends Entity {
             this.dirY = nbttaglist.d(1);
             this.dirZ = nbttaglist.d(2);
             // CraftBukkit end
+        } else if (nbttagcompound.hasKeyOfType("direction", 9)) { // Spigot - Support vanilla's direction tag
+            NBTTagList nbttaglist = nbttagcompound.getList("direction", 6);
+
+            this.motX = nbttaglist.d(0);
+            this.motY = nbttaglist.d(1);
+            this.motZ = nbttaglist.d(2);
+
         } else {
             this.die();
         }
diff --git a/src/main/java/net/minecraft/server/EntityFireworks.java b/src/main/java/net/minecraft/server/EntityFireworks.java
index 759d46c..b977cf7 100644
--- a/src/main/java/net/minecraft/server/EntityFireworks.java
+++ b/src/main/java/net/minecraft/server/EntityFireworks.java
@@ -5,6 +5,15 @@ public class EntityFireworks extends Entity {
     private int ticksFlown;
     public int expectedLifespan; // CraftBukkit - private -> public
 
+    // Spigot Start
+    @Override
+    public void inactiveTick()
+    {
+        this.ticksFlown += 19;
+        super.inactiveTick();
+    }
+    // Spigot End
+
     public EntityFireworks(World world) {
         super(world);
         this.a(0.25F, 0.25F);
diff --git a/src/main/java/net/minecraft/server/EntityHanging.java b/src/main/java/net/minecraft/server/EntityHanging.java
index eec465b..106a15b 100644
--- a/src/main/java/net/minecraft/server/EntityHanging.java
+++ b/src/main/java/net/minecraft/server/EntityHanging.java
@@ -102,7 +102,7 @@ public abstract class EntityHanging extends Entity {
         this.lastX = this.locX;
         this.lastY = this.locY;
         this.lastZ = this.locZ;
-        if (this.e++ == 100 && !this.world.isStatic) {
+        if (this.e++ == this.world.spigotConfig.hangingTickFrequency && !this.world.isStatic) { // Spigot - 100 -> this.world.spigotConfig.hangingTickFrequency
             this.e = 0;
             if (!this.dead && !this.survives()) {
                 // CraftBukkit start - fire break events
diff --git a/src/main/java/net/minecraft/server/EntityHorse.java b/src/main/java/net/minecraft/server/EntityHorse.java
index d167c00..e9f6236 100644
--- a/src/main/java/net/minecraft/server/EntityHorse.java
+++ b/src/main/java/net/minecraft/server/EntityHorse.java
@@ -993,6 +993,14 @@ public class EntityHorse extends EntityAnimal implements IInventoryListener {
         if (nbttagcompound.hasKeyOfType("OwnerUUID", 8)) {
             this.setOwnerUUID(nbttagcompound.getString("OwnerUUID"));
         }
+        // Spigot start
+        else if (nbttagcompound.hasKey("OwnerName")) {
+            String owner = nbttagcompound.getString("OwnerName");
+            if (owner != null && !owner.isEmpty()) {
+                this.setOwnerUUID(NameReferencingFileConverter.a(owner));
+            }
+        }
+        // Spigot end
         // CraftBukkit start
         if (nbttagcompound.hasKey("Bukkit.MaxDomestication")) {
             this.maxDomestication = nbttagcompound.getInt("Bukkit.MaxDomestication");
diff --git a/src/main/java/net/minecraft/server/EntityHuman.java b/src/main/java/net/minecraft/server/EntityHuman.java
index 331dbac..5bb7295 100644
--- a/src/main/java/net/minecraft/server/EntityHuman.java
+++ b/src/main/java/net/minecraft/server/EntityHuman.java
@@ -19,6 +19,7 @@ import org.bukkit.event.player.PlayerBedLeaveEvent;
 import org.bukkit.event.player.PlayerDropItemEvent;
 import org.bukkit.event.player.PlayerItemConsumeEvent;
 // CraftBukkit end
+import org.spigotmc.ProtocolData; // Spigot - protocol patch
 
 public abstract class EntityHuman extends EntityLiving implements ICommandListener {
 
@@ -89,9 +90,10 @@ public abstract class EntityHuman extends EntityLiving implements ICommandListen
 
     protected void c() {
         super.c();
-        this.datawatcher.a(16, Byte.valueOf((byte) 0));
+        this.datawatcher.a( 16, new ProtocolData.DualByte( (byte) 0, (byte) 0 ) ); // Spigot - protocol patch, handle metadata usage change (show cape -> collisions)
         this.datawatcher.a(17, Float.valueOf(0.0F));
         this.datawatcher.a(18, Integer.valueOf(0));
+        this.datawatcher.a( 10, new ProtocolData.HiddenByte( (byte) 0 ) ); // Spigot - protocol patch, handle new metadata value
     }
 
     public boolean by() {
@@ -277,6 +279,10 @@ public abstract class EntityHuman extends EntityLiving implements ICommandListen
                 // Update client
                 if (this instanceof EntityPlayer) {
                     ((EntityPlayer) this).playerConnection.sendPacket(new PacketPlayOutSetSlot((byte) 0, activeContainer.getSlot((IInventory) this.inventory, this.inventory.itemInHandIndex).index, this.f));
+                    // Spigot Start
+                    ((EntityPlayer) this).getBukkitEntity().updateInventory();
+                    ((EntityPlayer) this).getBukkitEntity().updateScaledHealth();
+                    // Spigot End
                 }
                 return;
             }
@@ -323,6 +329,7 @@ public abstract class EntityHuman extends EntityLiving implements ICommandListen
     public void setPassengerOf(Entity entity) {
         // CraftBukkit end
         if (this.vehicle != null && entity == null) {
+            world.getServer().getPluginManager().callEvent( new org.spigotmc.event.entity.EntityDismountEvent( this.getBukkitEntity(), this.vehicle.getBukkitEntity() ) ); // Spigot
             // CraftBukkit start - use parent method instead to correctly fire VehicleExitEvent
             Entity originalVehicle = this.vehicle;
             // First statement moved down, second statement handled in parent method.
@@ -429,7 +436,7 @@ public abstract class EntityHuman extends EntityLiving implements ICommandListen
 
             List list = this.world.getEntities(this, axisalignedbb);
 
-            if (list != null) {
+            if (list != null && this.S()) { // Spigot: Add this.S() condition (second !this.isDead near bottom of EntityLiving)
                 for (int i = 0; i < list.size(); ++i) {
                     Entity entity = (Entity) list.get(i);
 
@@ -1001,7 +1008,7 @@ public abstract class EntityHuman extends EntityLiving implements ICommandListen
                             }
                         }
 
-                        this.applyExhaustion(0.3F);
+                        this.applyExhaustion(world.spigotConfig.combatExhaustion); // Spigot - Change to use configurable value
                     } else if (flag1) {
                         entity.extinguish();
                     }
@@ -1219,15 +1226,23 @@ public abstract class EntityHuman extends EntityLiving implements ICommandListen
         return this.sleeping && this.sleepTicks >= 100;
     }
 
-    protected void b(int i, boolean flag) {
-        byte b0 = this.datawatcher.getByte(16);
-
+    // Spigot start - protocol patch, handle metadata usage change (show cape -> collisions)
+    protected void b(int i, boolean flag, int version) {
+        ProtocolData.DualByte db = this.datawatcher.getDualByte( 16 );
+        byte b0 = version >= 16 ? db.value2 : db.value;
         if (flag) {
-            this.datawatcher.watch(16, Byte.valueOf((byte) (b0 | 1 << i)));
+            b0 = (byte) ( b0 | 1 << i );
+        } else {
+            b0 = (byte) (b0 & ~(1 << i));
+        }
+        if (version >= 16) {
+            db.value2 = b0;
         } else {
-            this.datawatcher.watch(16, Byte.valueOf((byte) (b0 & ~(1 << i))));
+            db.value = b0;
         }
+        this.datawatcher.watch(16, db);
     }
+    // Spigot end
 
     public void b(IChatBaseComponent ichatbasecomponent) {}
 
@@ -1261,9 +1276,9 @@ public abstract class EntityHuman extends EntityLiving implements ICommandListen
         super.bj();
         this.a(StatisticList.r, 1);
         if (this.isSprinting()) {
-            this.applyExhaustion(0.8F);
+            this.applyExhaustion(world.spigotConfig.sprintExhaustion); // Spigot - Change to use configurable value
         } else {
-            this.applyExhaustion(0.2F);
+            this.applyExhaustion(world.spigotConfig.walkExhaustion); // Spigot - Change to use configurable value
         }
     }
 
diff --git a/src/main/java/net/minecraft/server/EntityInsentient.java b/src/main/java/net/minecraft/server/EntityInsentient.java
index a812656..617f7d4 100644
--- a/src/main/java/net/minecraft/server/EntityInsentient.java
+++ b/src/main/java/net/minecraft/server/EntityInsentient.java
@@ -93,6 +93,10 @@ public abstract class EntityInsentient extends EntityLiving {
         super.c();
         this.datawatcher.a(11, Byte.valueOf((byte) 0));
         this.datawatcher.a(10, "");
+        // Spigot start - protocol patch
+        this.datawatcher.a(3, Byte.valueOf((byte) 0));
+        this.datawatcher.a(2, "");
+        // Spigot end
     }
 
     public int q() {
@@ -400,6 +404,12 @@ public abstract class EntityInsentient extends EntityLiving {
         this.world.methodProfiler.a("checkDespawn");
         this.w();
         this.world.methodProfiler.b();
+        // Spigot Start
+        if ( this.fromMobSpawner )
+        {
+            return;
+        }
+        // Spigot End
         this.world.methodProfiler.a("sensing");
         this.bq.a();
         this.world.methodProfiler.b();
@@ -727,6 +737,7 @@ public abstract class EntityInsentient extends EntityLiving {
 
     public void setCustomName(String s) {
         this.datawatcher.watch(10, s);
+        this.datawatcher.watch(2, s); // Spigot - protocol patch
     }
 
     public String getCustomName() {
@@ -739,6 +750,7 @@ public abstract class EntityInsentient extends EntityLiving {
 
     public void setCustomNameVisible(boolean flag) {
         this.datawatcher.watch(11, Byte.valueOf((byte) (flag ? 1 : 0)));
+        this.datawatcher.watch(3, Byte.valueOf((byte) (flag ? 1 : 0))); // Spigot - protocol patch
     }
 
     public boolean getCustomNameVisible() {
diff --git a/src/main/java/net/minecraft/server/EntityItem.java b/src/main/java/net/minecraft/server/EntityItem.java
index 394bfbf..a61e91a 100644
--- a/src/main/java/net/minecraft/server/EntityItem.java
+++ b/src/main/java/net/minecraft/server/EntityItem.java
@@ -102,9 +102,30 @@ public class EntityItem extends Entity {
             if (this.onGround) {
                 this.motY *= -0.5D;
             }
+            // Spigot start - Make the hopper(s) below this item active.
+            // Called each tick on each item entity.
+            if (this.world.spigotConfig.altHopperTicking) {
+                int xi = MathHelper.floor(this.boundingBox.a);
+                int yi = MathHelper.floor(this.boundingBox.b) - 1;
+                int zi = MathHelper.floor(this.boundingBox.c);
+                int xf = MathHelper.floor(this.boundingBox.d);
+                int yf = MathHelper.floor(this.boundingBox.e) - 1;
+                int zf = MathHelper.floor(this.boundingBox.f);
+                for (int a = xi; a <= xf; a++) {
+                    for (int c = zi; c <= zf; c++) {
+                        for (int b = yi; b <= yf; b++) {
+                            TileEntity tileEntity = this.world.getTileEntity(a, b, c);
+                            if (tileEntity instanceof TileEntityHopper) {
+                                ((TileEntityHopper) tileEntity).makeTick();
+                            }
+                        }
+                    }
+                }
+            }
+            // Spigot end
 
             // ++this.age; // CraftBukkit - Moved up
-            if (!this.world.isStatic && this.age >= 6000) {
+            if (!this.world.isStatic && this.age >= world.spigotConfig.itemDespawnRate) { // Spigot
                 // CraftBukkit start - fire ItemDespawnEvent
                 if (org.bukkit.craftbukkit.event.CraftEventFactory.callItemDespawnEvent(this).isCancelled()) {
                     this.age = 0;
@@ -117,7 +138,10 @@ public class EntityItem extends Entity {
     }
 
     private void k() {
-        Iterator iterator = this.world.a(EntityItem.class, this.boundingBox.grow(0.5D, 0.0D, 0.5D)).iterator();
+        // Spigot start
+        double radius = world.spigotConfig.itemMerge;
+        Iterator iterator = this.world.a(EntityItem.class, this.boundingBox.grow(radius, radius, radius)).iterator();
+        // Spigot end
 
         while (iterator.hasNext()) {
             EntityItem entityitem = (EntityItem) iterator.next();
@@ -148,11 +172,13 @@ public class EntityItem extends Entity {
             } else if (itemstack1.count + itemstack.count > itemstack1.getMaxStackSize()) {
                 return false;
             } else {
-                itemstack1.count += itemstack.count;
-                entityitem.pickupDelay = Math.max(entityitem.pickupDelay, this.pickupDelay);
-                entityitem.age = Math.min(entityitem.age, this.age);
-                entityitem.setItemStack(itemstack1);
-                this.die();
+                // Spigot start
+                itemstack.count += itemstack1.count;
+                this.pickupDelay = Math.max(entityitem.pickupDelay, this.pickupDelay);
+                this.age = Math.min(entityitem.age, this.age);
+                this.setItemStack(itemstack);
+                entityitem.die();
+                // Spigot end
                 return true;
             }
         } else {
@@ -315,7 +341,7 @@ public class EntityItem extends Entity {
     public ItemStack getItemStack() {
         ItemStack itemstack = this.getDataWatcher().getItemStack(10);
 
-        return itemstack == null ? new ItemStack(Blocks.STONE) : itemstack; 
+        return itemstack == null ? new ItemStack(Blocks.STONE) : itemstack;
     }
 
     public void setItemStack(ItemStack itemstack) {
diff --git a/src/main/java/net/minecraft/server/EntityItemFrame.java b/src/main/java/net/minecraft/server/EntityItemFrame.java
index d1d73f9..5109b5d 100644
--- a/src/main/java/net/minecraft/server/EntityItemFrame.java
+++ b/src/main/java/net/minecraft/server/EntityItemFrame.java
@@ -16,6 +16,10 @@ public class EntityItemFrame extends EntityHanging {
     protected void c() {
         this.getDataWatcher().add(2, 5);
         this.getDataWatcher().a(3, Byte.valueOf((byte) 0));
+        // Spigot start - protocol patch
+        this.getDataWatcher().add(8, 5);
+        this.getDataWatcher().a(9, Byte.valueOf((byte) 0));
+        // Spigot end
     }
 
     public boolean damageEntity(DamageSource damagesource, float f) {
@@ -99,6 +103,10 @@ public class EntityItemFrame extends EntityHanging {
 
         this.getDataWatcher().watch(2, itemstack);
         this.getDataWatcher().update(2);
+        // Spigot start - protocol patch
+        this.getDataWatcher().watch(8, itemstack);
+        this.getDataWatcher().update(8);
+        // Spigot end
     }
 
     public int getRotation() {
@@ -107,6 +115,7 @@ public class EntityItemFrame extends EntityHanging {
 
     public void setRotation(int i) {
         this.getDataWatcher().watch(3, Byte.valueOf((byte) (i % 4)));
+        this.getDataWatcher().watch(9, Byte.valueOf((byte) ((i % 4) * 2))); // Spigot - protocol patch
     }
 
     public void b(NBTTagCompound nbttagcompound) {
diff --git a/src/main/java/net/minecraft/server/EntityLightning.java b/src/main/java/net/minecraft/server/EntityLightning.java
index 66402a0..0671659 100644
--- a/src/main/java/net/minecraft/server/EntityLightning.java
+++ b/src/main/java/net/minecraft/server/EntityLightning.java
@@ -13,6 +13,8 @@ public class EntityLightning extends EntityWeather {
     // CraftBukkit start
     public boolean isEffect = false;
 
+    public boolean isSilent = false; // Spigot
+    
     public EntityLightning(World world, double d0, double d1, double d2) {
         this(world, d0, d1, d2, false);
     }
@@ -60,9 +62,17 @@ public class EntityLightning extends EntityWeather {
         }
     }
 
+    // Spigot start
+    public EntityLightning(World world, double d0, double d1, double d2, boolean isEffect, boolean isSilent)
+    {
+        this( world, d0, d1, d2, isEffect );
+        this.isSilent = isSilent;
+    }
+    // Spigot end
+
     public void h() {
         super.h();
-        if (this.lifeTicks == 2) {
+        if (!isSilent && this.lifeTicks == 2) { // Spigot
             // CraftBukkit start - Use relative location for far away sounds
             //this.world.makeSound(this.locX, this.locY, this.locZ, "ambient.weather.thunder", 10000.0F, 0.8F + this.random.nextFloat() * 0.2F);
             float pitch = 0.8F + this.random.nextFloat() * 0.2F;
diff --git a/src/main/java/net/minecraft/server/EntityLiving.java b/src/main/java/net/minecraft/server/EntityLiving.java
index 0c63b2c..546b952 100644
--- a/src/main/java/net/minecraft/server/EntityLiving.java
+++ b/src/main/java/net/minecraft/server/EntityLiving.java
@@ -16,6 +16,8 @@ import org.bukkit.event.entity.EntityDamageEvent.DamageModifier;
 import org.bukkit.event.entity.EntityRegainHealthEvent;
 // CraftBukkit end
 
+import org.bukkit.craftbukkit.SpigotTimings; // Spigot
+
 public abstract class EntityLiving extends Entity {
 
     private static final UUID b = UUID.fromString("662A6B8D-DA3E-4C1C-8813-96EA6097278D");
@@ -82,6 +84,13 @@ public abstract class EntityLiving extends Entity {
     public int maxAirTicks = 300;
     ArrayList<org.bukkit.inventory.ItemStack> drops = null;
     // CraftBukkit end
+    // Spigot start
+    public void inactiveTick()
+    {
+        super.inactiveTick();
+        ++this.aU; // Above all the floats
+    }
+    // Spigot end
 
     public EntityLiving(World world) {
         super(world);
@@ -1357,6 +1366,7 @@ public abstract class EntityLiving extends Entity {
     }
 
     public void h() {
+        SpigotTimings.timerEntityBaseTick.startTiming(); // Spigot
         super.h();
         if (!this.world.isStatic) {
             int i = this.aZ();
@@ -1395,7 +1405,9 @@ public abstract class EntityLiving extends Entity {
             }
         }
 
+        SpigotTimings.timerEntityBaseTick.stopTiming(); // Spigot
         this.e();
+        SpigotTimings.timerEntityTickRest.startTiming(); // Spigot
         double d0 = this.locX - this.lastX;
         double d1 = this.locZ - this.lastZ;
         float f = (float) (d0 * d0 + d1 * d1);
@@ -1460,6 +1472,7 @@ public abstract class EntityLiving extends Entity {
 
         this.world.methodProfiler.b();
         this.aX += f2;
+        SpigotTimings.timerEntityTickRest.stopTiming(); // Spigot
     }
 
     protected float f(float f, float f1) {
@@ -1524,6 +1537,7 @@ public abstract class EntityLiving extends Entity {
         }
 
         this.world.methodProfiler.a("ai");
+        SpigotTimings.timerEntityAI.startTiming(); // Spigot
         if (this.bh()) {
             this.bc = false;
             this.bd = 0.0F;
@@ -1541,6 +1555,7 @@ public abstract class EntityLiving extends Entity {
                 this.aO = this.yaw;
             }
         }
+        SpigotTimings.timerEntityAI.stopTiming(); // Spigot
 
         this.world.methodProfiler.b();
         this.world.methodProfiler.a("jump");
@@ -1562,11 +1577,15 @@ public abstract class EntityLiving extends Entity {
         this.bd *= 0.98F;
         this.be *= 0.98F;
         this.bf *= 0.9F;
+        SpigotTimings.timerEntityAIMove.startTiming(); // Spigot
         this.e(this.bd, this.be);
+        SpigotTimings.timerEntityAIMove.stopTiming(); // Spigot
         this.world.methodProfiler.b();
         this.world.methodProfiler.a("push");
         if (!this.world.isStatic) {
+            SpigotTimings.timerEntityAICollision.startTiming(); // Spigot
             this.bo();
+            SpigotTimings.timerEntityAICollision.stopTiming(); // Spigot
         }
 
         this.world.methodProfiler.b();
@@ -1577,8 +1596,10 @@ public abstract class EntityLiving extends Entity {
     protected void bo() {
         List list = this.world.getEntities(this, this.boundingBox.grow(0.20000000298023224D, 0.0D, 0.20000000298023224D));
 
-        if (list != null && !list.isEmpty()) {
+        if (this.R() && list != null && !list.isEmpty()) { // Spigot: Add this.R() condition
+            numCollisions -= world.spigotConfig.maxCollisionsPerEntity; // Spigot
             for (int i = 0; i < list.size(); ++i) {
+                if (numCollisions > world.spigotConfig.maxCollisionsPerEntity) { break; } // Spigot
                 Entity entity = (Entity) list.get(i);
 
                 // TODO better check now?
@@ -1589,9 +1610,12 @@ public abstract class EntityLiving extends Entity {
                 // CraftBukkit end
 
                 if (entity.S()) {
+                    entity.numCollisions++; // Spigot
+                    numCollisions++; // Spigot
                     this.o(entity);
                 }
             }
+            numCollisions = 0; // Spigot
         }
     }
 
diff --git a/src/main/java/net/minecraft/server/EntityMinecartAbstract.java b/src/main/java/net/minecraft/server/EntityMinecartAbstract.java
index f1ccd3a..0710fcc 100644
--- a/src/main/java/net/minecraft/server/EntityMinecartAbstract.java
+++ b/src/main/java/net/minecraft/server/EntityMinecartAbstract.java
@@ -74,7 +74,7 @@ public abstract class EntityMinecartAbstract extends Entity {
         this.datawatcher.a(17, new Integer(0));
         this.datawatcher.a(18, new Integer(1));
         this.datawatcher.a(19, new Float(0.0F));
-        this.datawatcher.a(20, new Integer(0));
+        this.datawatcher.a(20, new org.spigotmc.ProtocolData.DualInt(0, 0)); // Spigot - protocol patch
         this.datawatcher.a(21, new Integer(6));
         this.datawatcher.a(22, Byte.valueOf((byte) 0));
     }
@@ -342,6 +342,27 @@ public abstract class EntityMinecartAbstract extends Entity {
 
                 this.passenger = null;
             }
+            // Spigot start - Make hoppers around this container minecart active.
+            // Called each tick on each minecart.
+            if (this.world.spigotConfig.altHopperTicking && this instanceof EntityMinecartContainer) {
+                int xi = MathHelper.floor(this.boundingBox.a) - 1;
+                int yi = MathHelper.floor(this.boundingBox.b) - 1;
+                int zi = MathHelper.floor(this.boundingBox.c) - 1;
+                int xf = MathHelper.floor(this.boundingBox.d) + 1;
+                int yf = MathHelper.floor(this.boundingBox.e) + 1;
+                int zf = MathHelper.floor(this.boundingBox.f) + 1;
+                for (int a = xi; a <= xf; a++) {
+                    for (int b = yi; b <= yf; b++) {
+                        for (int c = zi; c <= zf; c++) {
+                            TileEntity tileEntity = this.world.getTileEntity(a, b, c);
+                            if (tileEntity instanceof TileEntityHopper) {
+                                ((TileEntityHopper) tileEntity).makeTick();
+                            }
+                        }
+                    }
+                }
+            }
+            // Spigot end
         }
     }
 
@@ -820,12 +841,22 @@ public abstract class EntityMinecartAbstract extends Entity {
     }
 
     public void k(int i) {
-        this.getDataWatcher().watch(20, Integer.valueOf(i & '\uffff' | this.p() << 16));
+        // Spigot start - protocol patch
+        org.spigotmc.ProtocolData.DualInt val = datawatcher.getDualInt(20);
+        val.value = Integer.valueOf(i & '\uffff' | this.p() << 16);
+        val.value2 = Integer.valueOf(i & '\uffff' | this.p() << 12);
+        this.getDataWatcher().watch(20, val);
+        // Spigot end
         this.a(true);
     }
 
     public void l(int i) {
-        this.getDataWatcher().watch(20, Integer.valueOf(Block.getId(this.n()) & '\uffff' | i << 16));
+        // Spigot start - protocol patch
+        org.spigotmc.ProtocolData.DualInt val = datawatcher.getDualInt(20);
+        val.value =  Integer.valueOf(Block.getId(this.n()) & '\uffff' | i << 16);
+        val.value2 =  Integer.valueOf(Block.getId(this.n()) & '\uffff' | i << 12);
+        this.getDataWatcher().watch(20, val);
+        // Spigot end
         this.a(true);
     }
 
diff --git a/src/main/java/net/minecraft/server/EntityMinecartContainer.java b/src/main/java/net/minecraft/server/EntityMinecartContainer.java
index 13b75ff..bf8e745 100644
--- a/src/main/java/net/minecraft/server/EntityMinecartContainer.java
+++ b/src/main/java/net/minecraft/server/EntityMinecartContainer.java
@@ -149,6 +149,12 @@ public abstract class EntityMinecartContainer extends EntityMinecartAbstract imp
     }
 
     public void b(int i) {
+        // Spigot Start
+        for ( HumanEntity human : new java.util.ArrayList<HumanEntity>( transaction ) )
+        {
+            human.closeInventory();
+        }
+        // Spigot End
         this.b = false;
         super.b(i);
     }
diff --git a/src/main/java/net/minecraft/server/EntityOcelot.java b/src/main/java/net/minecraft/server/EntityOcelot.java
index aba3748..8abbcdf 100644
--- a/src/main/java/net/minecraft/server/EntityOcelot.java
+++ b/src/main/java/net/minecraft/server/EntityOcelot.java
@@ -2,6 +2,7 @@ package net.minecraft.server;
 
 public class EntityOcelot extends EntityTameableAnimal {
 
+    public boolean spawnBonus = true; // Spigot
     private PathfinderGoalTempt bq;
 
     public EntityOcelot(World world) {
@@ -27,6 +28,31 @@ public class EntityOcelot extends EntityTameableAnimal {
         this.datawatcher.a(18, Byte.valueOf((byte) 0));
     }
 
+    // Spigot start - When this ocelot begins standing, chests below this ocelot must be
+    // updated as if its contents have changed. We update chests if this ocelot is sitting
+    // knowing that it may be dead, gone, or standing after this method returns.
+    // Called each tick on each ocelot.
+    @Override
+    public void h() {
+        if (this.world.spigotConfig.altHopperTicking && this.isSitting()) {
+            int xi = MathHelper.floor(this.boundingBox.a);
+            int yi = MathHelper.floor(this.boundingBox.b) - 1;
+            int zi = MathHelper.floor(this.boundingBox.c);
+            int xf = MathHelper.floor(this.boundingBox.d);
+            int yf = MathHelper.floor(this.boundingBox.e) - 1;
+            int zf = MathHelper.floor(this.boundingBox.f);
+            for (int a = xi; a <= xf; a++) {
+                for (int c = zi; c <= zf; c++) {
+                    for (int b = yi; b <= yf; b++) {
+                        this.world.updateChestAndHoppers(a, b, c);
+                    }
+                }
+            }
+        }
+        super.h();
+    }
+    // Spigot end
+
     public void bp() {
         if (this.getControllerMove().a()) {
             double d0 = this.getControllerMove().b();
@@ -213,7 +239,7 @@ public class EntityOcelot extends EntityTameableAnimal {
 
     public GroupDataEntity prepare(GroupDataEntity groupdataentity) {
         groupdataentity = super.prepare(groupdataentity);
-        if (this.world.random.nextInt(7) == 0) {
+        if (spawnBonus && this.world.random.nextInt(7) == 0) { // Spigot
             for (int i = 0; i < 2; ++i) {
                 EntityOcelot entityocelot = new EntityOcelot(this.world);
 
diff --git a/src/main/java/net/minecraft/server/EntityPlayer.java b/src/main/java/net/minecraft/server/EntityPlayer.java
index 84673b4..6e80242 100644
--- a/src/main/java/net/minecraft/server/EntityPlayer.java
+++ b/src/main/java/net/minecraft/server/EntityPlayer.java
@@ -26,11 +26,12 @@ import org.bukkit.craftbukkit.inventory.CraftItemStack;
 import org.bukkit.event.inventory.InventoryType;
 import org.bukkit.event.player.PlayerTeleportEvent.TeleportCause;
 // CraftBukkit end
+import org.spigotmc.ProtocolData; // Spigot - protocol patch
 
 public class EntityPlayer extends EntityHuman implements ICrafting {
 
     private static final Logger bL = LogManager.getLogger();
-    private String locale = "en_US";
+    public String locale = "en_US"; // Spigot
     public PlayerConnection playerConnection;
     public final MinecraftServer server;
     public final PlayerInteractManager playerInteractManager;
@@ -62,7 +63,23 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
     public boolean keepLevel = false;
     public double maxHealthCache;
     public boolean joining = true;
+    public int lastPing = -1; // Spigot
     // CraftBukkit end
+    // Spigot start
+    public boolean collidesWithEntities = true;
+
+    @Override
+    public boolean R()
+    {
+        return this.collidesWithEntities && super.R(); // (first !this.isDead near bottom of EntityLiving)
+    }
+
+    @Override
+    public boolean S()
+    {
+        return this.collidesWithEntities && super.S(); // (second !this.isDead near bottom of EntityLiving)
+    }
+    // Spigot end
 
     public EntityPlayer(MinecraftServer minecraftserver, WorldServer worldserver, GameProfile gameprofile, PlayerInteractManager playerinteractmanager) {
         super(worldserver, gameprofile);
@@ -199,7 +216,7 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
 
             Chunk chunk;
 
-            while (iterator1.hasNext() && arraylist.size() < PacketPlayOutMapChunkBulk.c()) {
+            while (iterator1.hasNext() && arraylist.size() < this.world.spigotConfig.maxBulkChunk) { // Spigot
                 ChunkCoordIntPair chunkcoordintpair = (ChunkCoordIntPair) iterator1.next();
 
                 if (chunkcoordintpair != null) {
@@ -217,7 +234,7 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
             }
 
             if (!arraylist.isEmpty()) {
-                this.playerConnection.sendPacket(new PacketPlayOutMapChunkBulk(arraylist));
+                this.playerConnection.sendPacket(new PacketPlayOutMapChunkBulk(arraylist, this.playerConnection.networkManager.getVersion())); // Spigot - protocol patch
                 Iterator iterator2 = arraylist1.iterator();
 
                 while (iterator2.hasNext()) {
@@ -578,7 +595,7 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
         // CraftBukkit end
 
         this.nextContainerCounter();
-        this.playerConnection.sendPacket(new PacketPlayOutOpenWindow(this.containerCounter, 1, "Crafting", 9, true));
+        this.playerConnection.sendPacket(new PacketPlayOutOpenWindow(this.containerCounter, 1, "Crafting", 0, true)); // Spigot - protocol patch
         this.activeContainer = container; // CraftBukkit - Use container we passed to event
         this.activeContainer.windowId = this.containerCounter;
         this.activeContainer.addSlotListener(this);
@@ -593,7 +610,7 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
         // CraftBukkit end
 
         this.nextContainerCounter();
-        this.playerConnection.sendPacket(new PacketPlayOutOpenWindow(this.containerCounter, 4, s == null ? "" : s, 9, s != null));
+        this.playerConnection.sendPacket(new PacketPlayOutOpenWindow(this.containerCounter, 4, s == null ? "" : s, 0, s != null)); // Spigot - protocol patch
         this.activeContainer = container; // CraftBukkit - Use container we passed to event
         this.activeContainer.windowId = this.containerCounter;
         this.activeContainer.addSlotListener(this);
@@ -608,7 +625,7 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
         // CraftBukkit end
 
         this.nextContainerCounter();
-        this.playerConnection.sendPacket(new PacketPlayOutOpenWindow(this.containerCounter, 8, "Repairing", 9, true));
+        this.playerConnection.sendPacket(new PacketPlayOutOpenWindow(this.containerCounter, 8, "Repairing", 0, true)); // Spigot - protocol patch
         this.activeContainer = container; // CraftBukkit - Use container we passed to event
         this.activeContainer.windowId = this.containerCounter;
         this.activeContainer.addSlotListener(this);
@@ -748,7 +765,7 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
         MerchantRecipeList merchantrecipelist = imerchant.getOffers(this);
 
         if (merchantrecipelist != null) {
-            PacketDataSerializer packetdataserializer = new PacketDataSerializer(Unpooled.buffer());
+            PacketDataSerializer packetdataserializer = new PacketDataSerializer(Unpooled.buffer(), playerConnection.networkManager.getVersion()); // Spigot
 
             try {
                 packetdataserializer.writeInt(this.containerCounter);
@@ -805,6 +822,22 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
     }
 
     public void setContainerData(Container container, int i, int j) {
+        // Spigot start - protocol patch
+        if ( container instanceof ContainerFurnace && playerConnection.networkManager.getVersion() >= 47 )
+        {
+            switch ( i ) {
+                case 0:
+                    i = 2;
+                    this.playerConnection.sendPacket(new PacketPlayOutWindowData(container.windowId, 3, 200));
+                    break;
+                case 1:
+                    i = 0;
+                    break;
+                case 2:
+                    i = 1;
+            }
+        }
+        // Spigot end
         this.playerConnection.sendPacket(new PacketPlayOutWindowData(container.windowId, i, j));
     }
 
@@ -988,7 +1021,16 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
             this.server.a(packetplayinsettings.g());
         }
 
-        this.b(1, !packetplayinsettings.h());
+        // Spigot start - protocol patch, handle metadata usage change (show cape -> collisions)
+        if (packetplayinsettings.version < 16)
+        {
+            this.b( 1, !packetplayinsettings.h(), packetplayinsettings.version );
+        } else
+        {
+            this.b( 1, false, packetplayinsettings.version );
+            datawatcher.watch( 10, new ProtocolData.HiddenByte( (byte) packetplayinsettings.flags ) );
+        }
+        // Spigot end
     }
 
     public EnumChatVisibility getChatFlags() {
@@ -997,6 +1039,12 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
 
     public void setResourcePack(String s) {
         this.playerConnection.sendPacket(new PacketPlayOutCustomPayload("MC|RPack", s.getBytes(Charsets.UTF_8)));
+        // Spigot start - protocol patch
+        if ( playerConnection.networkManager.getVersion() >= 36 )
+        {
+            playerConnection.sendPacket( new org.spigotmc.ProtocolInjector.PacketPlayResourcePackSend( s, "thinkislazy" ) );
+        }
+        // Spigot end
     }
 
     public ChunkCoordinates getChunkCoordinates() {
diff --git a/src/main/java/net/minecraft/server/EntityTNTPrimed.java b/src/main/java/net/minecraft/server/EntityTNTPrimed.java
index 13cbc79..2214660 100644
--- a/src/main/java/net/minecraft/server/EntityTNTPrimed.java
+++ b/src/main/java/net/minecraft/server/EntityTNTPrimed.java
@@ -42,6 +42,7 @@ public class EntityTNTPrimed extends Entity {
     }
 
     public void h() {
+        if (world.spigotConfig.currentPrimedTnt++ > world.spigotConfig.maxTntTicksPerTick) { return; } // Spigot
         this.lastX = this.locX;
         this.lastY = this.locY;
         this.lastZ = this.locZ;
diff --git a/src/main/java/net/minecraft/server/EntityTracker.java b/src/main/java/net/minecraft/server/EntityTracker.java
index 1af0e67..c0766d6 100644
--- a/src/main/java/net/minecraft/server/EntityTracker.java
+++ b/src/main/java/net/minecraft/server/EntityTracker.java
@@ -91,6 +91,8 @@ public class EntityTracker {
     }
 
     public void addEntity(Entity entity, int i, int j, boolean flag) {
+        org.spigotmc.AsyncCatcher.catchOp( "entity track"); // Spigot
+        i = org.spigotmc.TrackingRange.getEntityTrackingRange(entity, i); // Spigot
         if (i > this.e) {
             i = this.e;
         }
@@ -125,6 +127,7 @@ public class EntityTracker {
     }
 
     public void untrackEntity(Entity entity) {
+        org.spigotmc.AsyncCatcher.catchOp( "entity untrack"); // Spigot
         if (entity instanceof EntityPlayer) {
             EntityPlayer entityplayer = (EntityPlayer) entity;
             Iterator iterator = this.c.iterator();
diff --git a/src/main/java/net/minecraft/server/EntityTrackerEntry.java b/src/main/java/net/minecraft/server/EntityTrackerEntry.java
index 0cf9ad5..46c4fb8 100644
--- a/src/main/java/net/minecraft/server/EntityTrackerEntry.java
+++ b/src/main/java/net/minecraft/server/EntityTrackerEntry.java
@@ -134,11 +134,11 @@ public class EntityTrackerEntry {
                 if (this.m > 0 || this.tracker instanceof EntityArrow) {
                     if (j1 >= -128 && j1 < 128 && k1 >= -128 && k1 < 128 && l1 >= -128 && l1 < 128 && this.v <= 400 && !this.x) {
                         if (flag && flag1) {
-                            object = new PacketPlayOutRelEntityMoveLook(this.tracker.getId(), (byte) j1, (byte) k1, (byte) l1, (byte) l, (byte) i1);
+                            object = new PacketPlayOutRelEntityMoveLook(this.tracker.getId(), (byte) j1, (byte) k1, (byte) l1, (byte) l, (byte) i1, tracker.onGround); // Spigot - protocol patch
                         } else if (flag) {
-                            object = new PacketPlayOutRelEntityMove(this.tracker.getId(), (byte) j1, (byte) k1, (byte) l1);
+                            object = new PacketPlayOutRelEntityMove(this.tracker.getId(), (byte) j1, (byte) k1, (byte) l1, tracker.onGround); // Spigot - protocol patch
                         } else if (flag1) {
-                            object = new PacketPlayOutEntityLook(this.tracker.getId(), (byte) l, (byte) i1);
+                            object = new PacketPlayOutEntityLook(this.tracker.getId(), (byte) l, (byte) i1, tracker.onGround); // Spigot - protocol patch
                         }
                     } else {
                         this.v = 0;
@@ -147,7 +147,7 @@ public class EntityTrackerEntry {
                             this.scanPlayers(new java.util.ArrayList(this.trackedPlayers));
                         }
                         // CraftBukkit end
-                        object = new PacketPlayOutEntityTeleport(this.tracker.getId(), i, j, k, (byte) l, (byte) i1);
+                        object = new PacketPlayOutEntityTeleport(this.tracker.getId(), i, j, k, (byte) l, (byte) i1, tracker.onGround); // Spigot - protocol patch
                     }
                 }
 
@@ -191,7 +191,7 @@ public class EntityTrackerEntry {
                 boolean flag2 = Math.abs(i - this.yRot) >= 4 || Math.abs(j - this.xRot) >= 4;
 
                 if (flag2) {
-                    this.broadcast(new PacketPlayOutEntityLook(this.tracker.getId(), (byte) i, (byte) j));
+                    this.broadcast(new PacketPlayOutEntityLook(this.tracker.getId(), (byte) i, (byte) j, tracker.onGround)); // Spigot - protocol patch
                     this.yRot = i;
                     this.xRot = j;
                 }
@@ -299,6 +299,7 @@ public class EntityTrackerEntry {
     }
 
     public void updatePlayer(EntityPlayer entityplayer) {
+        org.spigotmc.AsyncCatcher.catchOp( "player tracker update"); // Spigot
         if (entityplayer != this.tracker) {
             double d0 = entityplayer.locX - (double) (this.xLoc / 32);
             double d1 = entityplayer.locZ - (double) (this.zLoc / 32);
@@ -319,6 +320,13 @@ public class EntityTrackerEntry {
                     this.trackedPlayers.add(entityplayer);
                     Packet packet = this.c();
 
+                    // Spigot start - protocol patch
+                    if ( tracker instanceof EntityPlayer )
+                    {
+                        entityplayer.playerConnection.sendPacket( PacketPlayOutPlayerInfo.addPlayer( (EntityPlayer) tracker ) );
+                    }
+                    // Spigot end
+
                     entityplayer.playerConnection.sendPacket(packet);
                     if (!this.tracker.getDataWatcher().d()) {
                         entityplayer.playerConnection.sendPacket(new PacketPlayOutEntityMetadata(this.tracker.getId(), this.tracker.getDataWatcher(), true));
@@ -515,6 +523,7 @@ public class EntityTrackerEntry {
     }
 
     public void clear(EntityPlayer entityplayer) {
+        org.spigotmc.AsyncCatcher.catchOp( "player tracker clear"); // Spigot
         if (this.trackedPlayers.contains(entityplayer)) {
             this.trackedPlayers.remove(entityplayer);
             entityplayer.d(this.tracker);
diff --git a/src/main/java/net/minecraft/server/EntityWither.java b/src/main/java/net/minecraft/server/EntityWither.java
index 75b3ca3..434616d 100644
--- a/src/main/java/net/minecraft/server/EntityWither.java
+++ b/src/main/java/net/minecraft/server/EntityWither.java
@@ -180,6 +180,7 @@ public class EntityWither extends EntityMonster implements IRangedEntity {
                     double deltaX = this.locX - player.locX;
                     double deltaZ = this.locZ - player.locZ;
                     double distanceSquared = deltaX * deltaX + deltaZ * deltaZ;
+                    if ( world.spigotConfig.witherSpawnSoundRadius > 0 && distanceSquared > world.spigotConfig.witherSpawnSoundRadius * world.spigotConfig.witherSpawnSoundRadius ) continue; // Spigot
                     if (distanceSquared > viewDistance * viewDistance) {
                         double deltaLength = Math.sqrt(distanceSquared);
                         double relativeX = player.locX + (deltaX / deltaLength) * viewDistance;
diff --git a/src/main/java/net/minecraft/server/EntityWitherSkull.java b/src/main/java/net/minecraft/server/EntityWitherSkull.java
index b797f8a..144ed17 100644
--- a/src/main/java/net/minecraft/server/EntityWitherSkull.java
+++ b/src/main/java/net/minecraft/server/EntityWitherSkull.java
@@ -35,15 +35,19 @@ public class EntityWitherSkull extends EntityFireball {
     protected void a(MovingObjectPosition movingobjectposition) {
         if (!this.world.isStatic) {
             if (movingobjectposition.entity != null) {
+                // Spigot start
+                boolean didDamage = false;         	
                 if (this.shooter != null) {
-                    if (movingobjectposition.entity.damageEntity(DamageSource.mobAttack(this.shooter), 8.0F) && !movingobjectposition.entity.isAlive()) {
+                    didDamage = movingobjectposition.entity.damageEntity(DamageSource.mobAttack(this.shooter), 8.0F);
+                    if (didDamage && !movingobjectposition.entity.isAlive()) {
                         this.shooter.heal(5.0F, org.bukkit.event.entity.EntityRegainHealthEvent.RegainReason.WITHER); // CraftBukkit
                     }
                 } else {
-                    movingobjectposition.entity.damageEntity(DamageSource.MAGIC, 5.0F);
+                    didDamage = movingobjectposition.entity.damageEntity(DamageSource.MAGIC, 5.0F);
                 }
 
-                if (movingobjectposition.entity instanceof EntityLiving) {
+                if (didDamage && movingobjectposition.entity instanceof EntityLiving) {
+                // Spigot end
                     byte b0 = 0;
 
                     if (this.world.difficulty == EnumDifficulty.NORMAL) {
diff --git a/src/main/java/net/minecraft/server/EntityZombie.java b/src/main/java/net/minecraft/server/EntityZombie.java
index 7d8cb93..f732579 100644
--- a/src/main/java/net/minecraft/server/EntityZombie.java
+++ b/src/main/java/net/minecraft/server/EntityZombie.java
@@ -30,7 +30,7 @@ public class EntityZombie extends EntityMonster {
         this.getNavigation().b(true);
         this.goalSelector.a(0, new PathfinderGoalFloat(this));
         this.goalSelector.a(2, new PathfinderGoalMeleeAttack(this, EntityHuman.class, 1.0D, false));
-        this.goalSelector.a(4, new PathfinderGoalMeleeAttack(this, EntityVillager.class, 1.0D, true));
+        if ( world.spigotConfig.zombieAggressiveTowardsVillager ) { this.goalSelector.a(4, new PathfinderGoalMeleeAttack(this, EntityVillager.class, 1.0D, true)); } // Spigot
         this.goalSelector.a(5, new PathfinderGoalMoveTowardsRestriction(this, 1.0D));
         this.goalSelector.a(6, new PathfinderGoalMoveThroughVillage(this, 1.0D, false));
         this.goalSelector.a(7, new PathfinderGoalRandomStroll(this, 1.0D));
@@ -38,7 +38,7 @@ public class EntityZombie extends EntityMonster {
         this.goalSelector.a(8, new PathfinderGoalRandomLookaround(this));
         this.targetSelector.a(1, new PathfinderGoalHurtByTarget(this, true));
         this.targetSelector.a(2, new PathfinderGoalNearestAttackableTarget(this, EntityHuman.class, 0, true));
-        this.targetSelector.a(2, new PathfinderGoalNearestAttackableTarget(this, EntityVillager.class, 0, false));
+        if ( world.spigotConfig.zombieAggressiveTowardsVillager ) { this.targetSelector.a(2, new PathfinderGoalNearestAttackableTarget(this, EntityVillager.class, 0, false)); } // Spigot
         this.a(0.6F, 1.8F);
     }
 
diff --git a/src/main/java/net/minecraft/server/Explosion.java b/src/main/java/net/minecraft/server/Explosion.java
index 56fa999..d876a63 100644
--- a/src/main/java/net/minecraft/server/Explosion.java
+++ b/src/main/java/net/minecraft/server/Explosion.java
@@ -130,9 +130,9 @@ public class Explosion {
                     // CraftBukkit start
                     CraftEventFactory.entityDamage = source;
                     if (!entity.damageEntity(DamageSource.explosion(this), (float) ((int) ((d10 * d10 + d10) / 2.0D * 8.0D * (double) this.size + 1.0D)))) {
-                        CraftEventFactory.entityDamage = null;
-                        continue;
+
                     }
+                    CraftEventFactory.entityDamage = null;
                     // CraftBukkit end
                     double d11 = EnchantmentProtection.a(entity, d10);
 
@@ -203,6 +203,7 @@ public class Explosion {
                 j = chunkposition.y;
                 k = chunkposition.z;
                 block = this.world.getType(i, j, k);
+                world.spigotConfig.antiXrayInstance.updateNearbyBlocks(world, i, j, k); // Spigot
                 if (flag) {
                     double d0 = (double) ((float) i + this.world.random.nextFloat());
                     double d1 = (double) ((float) j + this.world.random.nextFloat());
diff --git a/src/main/java/net/minecraft/server/FoodMetaData.java b/src/main/java/net/minecraft/server/FoodMetaData.java
index 4169231..4a7f1e5 100644
--- a/src/main/java/net/minecraft/server/FoodMetaData.java
+++ b/src/main/java/net/minecraft/server/FoodMetaData.java
@@ -65,7 +65,7 @@ public class FoodMetaData {
             if (this.foodTickTimer >= 80) {
                 // CraftBukkit - added RegainReason
                 entityhuman.heal(1.0F, org.bukkit.event.entity.EntityRegainHealthEvent.RegainReason.SATIATED);
-                this.a(3.0F);
+                this.a(entityhuman.world.spigotConfig.regenExhaustion); // Spigot - Change to use configurable value
                 this.foodTickTimer = 0;
             }
         } else if (this.foodLevel <= 0) {
diff --git a/src/main/java/net/minecraft/server/GameProfileBanEntry.java b/src/main/java/net/minecraft/server/GameProfileBanEntry.java
new file mode 100644
index 0000000..7a7bf83
--- /dev/null
+++ b/src/main/java/net/minecraft/server/GameProfileBanEntry.java
@@ -0,0 +1,57 @@
+package net.minecraft.server;
+
+import java.util.Date;
+import java.util.UUID;
+
+import net.minecraft.util.com.google.gson.JsonObject;
+import net.minecraft.util.com.mojang.authlib.GameProfile;
+
+public class GameProfileBanEntry extends ExpirableListEntry {
+
+    public GameProfileBanEntry(GameProfile gameprofile) {
+        this(gameprofile, (Date) null, (String) null, (Date) null, (String) null);
+    }
+
+    public GameProfileBanEntry(GameProfile gameprofile, Date date, String s, Date date1, String s1) {
+        super(gameprofile, date, s, date1, s1); // Spigot
+    }
+
+    public GameProfileBanEntry(JsonObject jsonobject) {
+        super(b(jsonobject), jsonobject);
+    }
+
+    protected void a(JsonObject jsonobject) {
+        if (this.getKey() != null) {
+            jsonobject.addProperty("uuid", ((GameProfile) this.getKey()).getId() == null ? "" : ((GameProfile) this.getKey()).getId().toString());
+            jsonobject.addProperty("name", ((GameProfile) this.getKey()).getName());
+            super.a(jsonobject);
+        }
+    }
+
+    private static GameProfile b(JsonObject jsonobject) {
+        // Spigot start
+        // this whole method has to be reworked to account for the fact Bukkit only accepts UUID bans and gives no way for usernames to be stored!
+        UUID uuid = null;
+        String name = null;
+        if (jsonobject.has("uuid")) {
+            String s = jsonobject.get("uuid").getAsString();
+
+            try {
+                uuid = UUID.fromString(s);
+            } catch (Throwable throwable) {
+            }
+
+        }
+        if ( jsonobject.has("name"))
+        {
+            name = jsonobject.get("name").getAsString();
+        }
+        if ( uuid != null || name != null )
+        {
+            return new GameProfile( uuid, name );
+        } else {
+            return null;
+        }
+        // Spigot End
+    }
+}
diff --git a/src/main/java/net/minecraft/server/GenericAttributes.java b/src/main/java/net/minecraft/server/GenericAttributes.java
new file mode 100644
index 0000000..7ad88f5
--- /dev/null
+++ b/src/main/java/net/minecraft/server/GenericAttributes.java
@@ -0,0 +1,107 @@
+package net.minecraft.server;
+
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.UUID;
+
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+public class GenericAttributes {
+
+    private static final Logger f = LogManager.getLogger();
+    // Spigot Start
+    public static final IAttribute maxHealth = (new AttributeRanged("generic.maxHealth", 20.0D, 0.1D, org.spigotmc.SpigotConfig.maxHealth)).a("Max Health").a(true); // Spigot
+    public static final IAttribute b = (new AttributeRanged("generic.followRange", 32.0D, 0.0D, 2048.0D)).a("Follow Range");
+    public static final IAttribute c = (new AttributeRanged("generic.knockbackResistance", 0.0D, 0.0D, 1.0D)).a("Knockback Resistance");
+    public static final IAttribute d = (new AttributeRanged("generic.movementSpeed", 0.699999988079071D, 0.0D, org.spigotmc.SpigotConfig.movementSpeed)).a("Movement Speed").a(true);
+    public static final IAttribute e = new AttributeRanged("generic.attackDamage", 2.0D, 0.0D, org.spigotmc.SpigotConfig.attackDamage);
+    // Spigot End
+
+    public static NBTTagList a(AttributeMapBase attributemapbase) {
+        NBTTagList nbttaglist = new NBTTagList();
+        Iterator iterator = attributemapbase.a().iterator();
+
+        while (iterator.hasNext()) {
+            AttributeInstance attributeinstance = (AttributeInstance) iterator.next();
+
+            nbttaglist.add(a(attributeinstance));
+        }
+
+        return nbttaglist;
+    }
+
+    private static NBTTagCompound a(AttributeInstance attributeinstance) {
+        NBTTagCompound nbttagcompound = new NBTTagCompound();
+        IAttribute iattribute = attributeinstance.getAttribute();
+
+        nbttagcompound.setString("Name", iattribute.getName());
+        nbttagcompound.setDouble("Base", attributeinstance.b());
+        Collection collection = attributeinstance.c();
+
+        if (collection != null && !collection.isEmpty()) {
+            NBTTagList nbttaglist = new NBTTagList();
+            Iterator iterator = collection.iterator();
+
+            while (iterator.hasNext()) {
+                AttributeModifier attributemodifier = (AttributeModifier) iterator.next();
+
+                if (attributemodifier.e()) {
+                    nbttaglist.add(a(attributemodifier));
+                }
+            }
+
+            nbttagcompound.set("Modifiers", nbttaglist);
+        }
+
+        return nbttagcompound;
+    }
+
+    private static NBTTagCompound a(AttributeModifier attributemodifier) {
+        NBTTagCompound nbttagcompound = new NBTTagCompound();
+
+        nbttagcompound.setString("Name", attributemodifier.b());
+        nbttagcompound.setDouble("Amount", attributemodifier.d());
+        nbttagcompound.setInt("Operation", attributemodifier.c());
+        nbttagcompound.setLong("UUIDMost", attributemodifier.a().getMostSignificantBits());
+        nbttagcompound.setLong("UUIDLeast", attributemodifier.a().getLeastSignificantBits());
+        return nbttagcompound;
+    }
+
+    public static void a(AttributeMapBase attributemapbase, NBTTagList nbttaglist) {
+        for (int i = 0; i < nbttaglist.size(); ++i) {
+            NBTTagCompound nbttagcompound = nbttaglist.get(i);
+            AttributeInstance attributeinstance = attributemapbase.a(nbttagcompound.getString("Name"));
+
+            if (attributeinstance != null) {
+                a(attributeinstance, nbttagcompound);
+            } else {
+                f.warn("Ignoring unknown attribute \'" + nbttagcompound.getString("Name") + "\'");
+            }
+        }
+    }
+
+    private static void a(AttributeInstance attributeinstance, NBTTagCompound nbttagcompound) {
+        attributeinstance.setValue(nbttagcompound.getDouble("Base"));
+        if (nbttagcompound.hasKeyOfType("Modifiers", 9)) {
+            NBTTagList nbttaglist = nbttagcompound.getList("Modifiers", 10);
+
+            for (int i = 0; i < nbttaglist.size(); ++i) {
+                AttributeModifier attributemodifier = a(nbttaglist.get(i));
+                AttributeModifier attributemodifier1 = attributeinstance.a(attributemodifier.a());
+
+                if (attributemodifier1 != null) {
+                    attributeinstance.b(attributemodifier1);
+                }
+
+                attributeinstance.a(attributemodifier);
+            }
+        }
+    }
+
+    public static AttributeModifier a(NBTTagCompound nbttagcompound) {
+        UUID uuid = new UUID(nbttagcompound.getLong("UUIDMost"), nbttagcompound.getLong("UUIDLeast"));
+
+        return new AttributeModifier(uuid, nbttagcompound.getString("Name"), nbttagcompound.getDouble("Amount"), nbttagcompound.getInt("Operation"));
+    }
+}
diff --git a/src/main/java/net/minecraft/server/HandshakeListener.java b/src/main/java/net/minecraft/server/HandshakeListener.java
index 52bc69b..7566110 100644
--- a/src/main/java/net/minecraft/server/HandshakeListener.java
+++ b/src/main/java/net/minecraft/server/HandshakeListener.java
@@ -1,14 +1,17 @@
 package net.minecraft.server;
 
+import net.minecraft.util.com.mojang.authlib.properties.Property; // Spigot
 import net.minecraft.util.io.netty.util.concurrent.GenericFutureListener;
 
 // CraftBukkit start
 import java.net.InetAddress;
 import java.util.HashMap;
+import net.minecraft.util.com.mojang.util.UUIDTypeAdapter;
 // CraftBukkit end
 
 public class HandshakeListener implements PacketHandshakingInListener {
 
+    private static final com.google.gson.Gson gson = new com.google.gson.Gson(); // Spigot
     // CraftBukkit start - add fields
     private static final HashMap<InetAddress, Long> throttleTracker = new HashMap<InetAddress, Long>();
     private static int throttleCounter = 0;
@@ -23,6 +26,12 @@ public class HandshakeListener implements PacketHandshakingInListener {
     }
 
     public void a(PacketHandshakingInSetProtocol packethandshakinginsetprotocol) {
+        // Spigot start
+        if ( NetworkManager.SUPPORTED_VERSIONS.contains( packethandshakinginsetprotocol.d() ) )
+        {
+            NetworkManager.a( this.b ).attr( NetworkManager.protocolVersion ).set( packethandshakinginsetprotocol.d() );
+        }
+        // Spigot end
         switch (ProtocolOrdinalWrapper.a[packethandshakinginsetprotocol.c().ordinal()]) {
         case 1:
             this.b.a(EnumProtocol.LOGIN);
@@ -63,16 +72,36 @@ public class HandshakeListener implements PacketHandshakingInListener {
             }
             // CraftBukkit end
 
-            if (packethandshakinginsetprotocol.d() > 5) {
-                chatcomponenttext = new ChatComponentText("Outdated server! I\'m still on 1.7.10");
+            if (packethandshakinginsetprotocol.d() > 5 && packethandshakinginsetprotocol.d() != 47) { // Spigot
+                chatcomponenttext = new ChatComponentText( java.text.MessageFormat.format( org.spigotmc.SpigotConfig.outdatedServerMessage, "1.7.10" ) ); // Spigot
                 this.b.handle(new PacketLoginOutDisconnect(chatcomponenttext), new GenericFutureListener[0]);
                 this.b.close(chatcomponenttext);
-            } else if (packethandshakinginsetprotocol.d() < 5) {
-                chatcomponenttext = new ChatComponentText("Outdated client! Please use 1.7.10");
+            } else if (packethandshakinginsetprotocol.d() < 4) {
+                chatcomponenttext = new ChatComponentText( java.text.MessageFormat.format( org.spigotmc.SpigotConfig.outdatedClientMessage, "1.7.10" ) ); // Spigot
                 this.b.handle(new PacketLoginOutDisconnect(chatcomponenttext), new GenericFutureListener[0]);
                 this.b.close(chatcomponenttext);
             } else {
                 this.b.a((PacketListener) (new LoginListener(this.a, this.b)));
+                // Spigot Start
+                if (org.spigotmc.SpigotConfig.bungee) {
+                    String[] split = packethandshakinginsetprotocol.b.split("\00");
+                    if ( split.length == 3 || split.length == 4 ) {
+                        packethandshakinginsetprotocol.b = split[0];
+                        b.n = new java.net.InetSocketAddress(split[1], ((java.net.InetSocketAddress) b.getSocketAddress()).getPort());
+                        b.spoofedUUID = UUIDTypeAdapter.fromString( split[2] );
+                    } else
+                    {
+                        chatcomponenttext = new ChatComponentText("If you wish to use IP forwarding, please enable it in your BungeeCord config as well!");
+                        this.b.handle(new PacketLoginOutDisconnect(chatcomponenttext), new GenericFutureListener[0]);
+                        this.b.close(chatcomponenttext);
+                        return;
+                    }
+                    if ( split.length == 4 )
+                    {
+                        b.spoofedProfile = gson.fromJson(split[3], Property[].class);
+                    }
+                }
+                // Spigot End
                 ((LoginListener) this.b.getPacketListener()).hostname = packethandshakinginsetprotocol.b + ":" + packethandshakinginsetprotocol.c; // CraftBukkit - set hostname
             }
             break;
diff --git a/src/main/java/net/minecraft/server/IRecipe.java b/src/main/java/net/minecraft/server/IRecipe.java
index bb28c12..c0836e4 100644
--- a/src/main/java/net/minecraft/server/IRecipe.java
+++ b/src/main/java/net/minecraft/server/IRecipe.java
@@ -11,4 +11,6 @@ public interface IRecipe {
     ItemStack b();
 
     org.bukkit.inventory.Recipe toBukkitRecipe(); // CraftBukkit
+
+    java.util.List<ItemStack> getIngredients(); // Spigot
 }
diff --git a/src/main/java/net/minecraft/server/IntCache.java b/src/main/java/net/minecraft/server/IntCache.java
new file mode 100644
index 0000000..47e06df
--- /dev/null
+++ b/src/main/java/net/minecraft/server/IntCache.java
@@ -0,0 +1,63 @@
+package net.minecraft.server;
+
+import java.util.ArrayList;
+import java.util.List;
+
+public class IntCache {
+
+    private static int a = 256;
+    private static List b = new ArrayList();
+    private static List c = new ArrayList();
+    private static List d = new ArrayList();
+    private static List e = new ArrayList();
+
+    public static synchronized int[] a(int i) {
+        int[] aint;
+
+        if (i <= 256) {
+            if (b.isEmpty()) {
+                aint = new int[256];
+                if (c.size() < org.spigotmc.SpigotConfig.intCacheLimit) c.add(aint);
+                return aint;
+            } else {
+                aint = (int[]) b.remove(b.size() - 1);
+                if (c.size() < org.spigotmc.SpigotConfig.intCacheLimit) c.add(aint);
+                return aint;
+            }
+        } else if (i > a) {
+            a = i;
+            d.clear();
+            e.clear();
+            aint = new int[a];
+            if (e.size() < org.spigotmc.SpigotConfig.intCacheLimit) e.add(aint);
+            return aint;
+        } else if (d.isEmpty()) {
+            aint = new int[a];
+            if (e.size() < org.spigotmc.SpigotConfig.intCacheLimit) e.add(aint);
+            return aint;
+        } else {
+            aint = (int[]) d.remove(d.size() - 1);
+            if (e.size() < org.spigotmc.SpigotConfig.intCacheLimit) e.add(aint);
+            return aint;
+        }
+    }
+
+    public static synchronized void a() {
+        if (!d.isEmpty()) {
+            d.remove(d.size() - 1);
+        }
+
+        if (!b.isEmpty()) {
+            b.remove(b.size() - 1);
+        }
+
+        d.addAll(e);
+        b.addAll(c);
+        e.clear();
+        c.clear();
+    }
+
+    public static synchronized String b() {
+        return "cache: " + d.size() + ", tcache: " + b.size() + ", allocated: " + e.size() + ", tallocated: " + c.size();
+    }
+}
diff --git a/src/main/java/net/minecraft/server/ItemFishingRod.java b/src/main/java/net/minecraft/server/ItemFishingRod.java
index 2f34151..9ededf3 100644
--- a/src/main/java/net/minecraft/server/ItemFishingRod.java
+++ b/src/main/java/net/minecraft/server/ItemFishingRod.java
@@ -23,6 +23,7 @@ public class ItemFishingRod extends Item {
             world.getServer().getPluginManager().callEvent(playerFishEvent);
 
             if (playerFishEvent.isCancelled()) {
+                entityhuman.hookedFish = null;
                 return itemstack;
             }
             // CraftBukkit end
diff --git a/src/main/java/net/minecraft/server/ItemSkull.java b/src/main/java/net/minecraft/server/ItemSkull.java
new file mode 100644
index 0000000..3deacc6
--- /dev/null
+++ b/src/main/java/net/minecraft/server/ItemSkull.java
@@ -0,0 +1,117 @@
+package net.minecraft.server;
+
+import java.util.UUID;
+
+import net.minecraft.util.com.mojang.authlib.GameProfile;
+
+public class ItemSkull extends Item {
+
+    private static final String[] b = new String[] { "skeleton", "wither", "zombie", "char", "creeper"};
+    public static final String[] a = new String[] { "skeleton", "wither", "zombie", "steve", "creeper"};
+
+    public ItemSkull() {
+        this.a(CreativeModeTab.c);
+        this.setMaxDurability(0);
+        this.a(true);
+    }
+
+    public boolean interactWith(ItemStack itemstack, EntityHuman entityhuman, World world, int i, int j, int k, int l, float f, float f1, float f2) {
+        if (l == 0) {
+            return false;
+        } else if (!world.getType(i, j, k).getMaterial().isBuildable()) {
+            return false;
+        } else {
+            if (l == 1) {
+                ++j;
+            }
+
+            if (l == 2) {
+                --k;
+            }
+
+            if (l == 3) {
+                ++k;
+            }
+
+            if (l == 4) {
+                --i;
+            }
+
+            if (l == 5) {
+                ++i;
+            }
+
+            if (!world.isStatic) {
+                // Spigot Start
+                if ( !Blocks.SKULL.canPlace( world, i, j, k ) )
+                {
+                    return false;
+                }
+                // Spigot End
+                world.setTypeAndData(i, j, k, Blocks.SKULL, l, 2);
+                int i1 = 0;
+
+                if (l == 1) {
+                    i1 = MathHelper.floor((double) (entityhuman.yaw * 16.0F / 360.0F) + 0.5D) & 15;
+                }
+
+                TileEntity tileentity = world.getTileEntity(i, j, k);
+
+                if (tileentity != null && tileentity instanceof TileEntitySkull) {
+                    if (itemstack.getData() == 3) {
+                        GameProfile gameprofile = null;
+
+                        if (itemstack.hasTag()) {
+                            NBTTagCompound nbttagcompound = itemstack.getTag();
+
+                            if (nbttagcompound.hasKeyOfType("SkullOwner", 10)) {
+                                gameprofile = GameProfileSerializer.deserialize(nbttagcompound.getCompound("SkullOwner"));
+                            } else if (nbttagcompound.hasKeyOfType("SkullOwner", 8) && nbttagcompound.getString("SkullOwner").length() > 0) {
+                                gameprofile = new GameProfile((UUID) null, nbttagcompound.getString("SkullOwner"));
+                            }
+                        }
+
+                        ((TileEntitySkull) tileentity).setGameProfile(gameprofile);
+                    } else {
+                        ((TileEntitySkull) tileentity).setSkullType(itemstack.getData());
+                    }
+
+                    ((TileEntitySkull) tileentity).setRotation(i1);
+                    ((BlockSkull) Blocks.SKULL).a(world, i, j, k, (TileEntitySkull) tileentity);
+                }
+
+                --itemstack.count;
+            }
+
+            return true;
+        }
+    }
+
+    public int filterData(int i) {
+        return i;
+    }
+
+    public String a(ItemStack itemstack) {
+        int i = itemstack.getData();
+
+        if (i < 0 || i >= b.length) {
+            i = 0;
+        }
+
+        return super.getName() + "." + b[i];
+    }
+
+    public String n(ItemStack itemstack) {
+        if (itemstack.getData() == 3 && itemstack.hasTag()) {
+            if (itemstack.getTag().hasKeyOfType("SkullOwner", 10)) {
+                return LocaleI18n.get("item.skull.player.name", new Object[] { GameProfileSerializer.deserialize(itemstack.getTag().getCompound("SkullOwner")).getName()});
+            }
+
+            if (itemstack.getTag().hasKeyOfType("SkullOwner", 8)) {
+                return LocaleI18n.get("item.skull.player.name", new Object[] { itemstack.getTag().getString("SkullOwner")});
+            }
+        }
+
+        return super.n(itemstack);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/ItemStack.java b/src/main/java/net/minecraft/server/ItemStack.java
index c9d74d3..ee82aba 100644
--- a/src/main/java/net/minecraft/server/ItemStack.java
+++ b/src/main/java/net/minecraft/server/ItemStack.java
@@ -216,9 +216,61 @@ public final class ItemStack {
         if (nbttagcompound.hasKeyOfType("tag", 10)) {
             // CraftBukkit - make defensive copy as this data may be coming from the save thread
             this.tag = (NBTTagCompound) nbttagcompound.getCompound("tag").clone();
+            validateSkullSkin(); // Spigot
         }
     }
 
+    // Spigot start - make sure the tag is given the full gameprofile if it's a skull (async lookup)
+    public void validateSkullSkin()
+    {
+        if ( this.item == Items.SKULL && this.getData() == 3 )
+        {
+            String owner;
+            if ( this.tag.hasKeyOfType( "SkullOwner", 8 ) )
+            {
+                owner = this.tag.getString( "SkullOwner" );
+            } else if ( this.tag.hasKeyOfType( "SkullOwner", 10 ) )
+            {
+                net.minecraft.util.com.mojang.authlib.GameProfile profile = GameProfileSerializer.deserialize( this.tag.getCompound( "SkullOwner" ) );
+                if ( profile == null || !profile.getProperties().isEmpty() )
+                {
+                    return;
+                } else
+                {
+                    owner = profile.getName();
+                }
+            } else
+            {
+                return;
+            }
+
+            final String finalOwner = owner;
+            TileEntitySkull.executor.execute( new Runnable()
+            {
+                @Override
+                public void run()
+                {
+
+                    final net.minecraft.util.com.mojang.authlib.GameProfile profile = TileEntitySkull.skinCache.getUnchecked( finalOwner.toLowerCase() );
+                    if ( profile != null )
+                    {
+                        MinecraftServer.getServer().processQueue.add( new Runnable()
+                        {
+                            @Override
+                            public void run()
+                            {
+                                NBTTagCompound nbtProfile = new NBTTagCompound();
+                                GameProfileSerializer.serialize( nbtProfile, profile );
+                                ItemStack.this.tag.set( "SkullOwner", nbtProfile );
+                            }
+                        } );
+                    }
+                }
+            } );
+        }
+    }
+    // Spigot end
+    
     public int getMaxStackSize() {
         return this.getItem().getMaxStackSize();
     }
@@ -228,7 +280,13 @@ public final class ItemStack {
     }
 
     public boolean g() {
-        return this.item.getMaxDurability() <= 0 ? false : !this.hasTag() || !this.getTag().getBoolean("Unbreakable");
+        // Spigot Start
+        if ( this.item.getMaxDurability() <= 0 )
+        {
+            return false;
+        }
+        return ( !hasTag() ) || ( !getTag().getBoolean( "Unbreakable" ) );
+        // Spigot End
     }
 
     public boolean usesData() {
@@ -279,7 +337,13 @@ public final class ItemStack {
         return this.item.getMaxDurability();
     }
 
+    // Spigot start
     public boolean isDamaged(int i, Random random) {
+        return isDamaged(i, random, null);
+    }
+
+    public boolean isDamaged(int i, Random random, EntityLiving entityliving) {
+        // Spigot end
         if (!this.g()) {
             return false;
         } else {
@@ -294,7 +358,16 @@ public final class ItemStack {
                 }
 
                 i -= k;
-                if (i <= 0) {
+                // Spigot start
+                if (entityliving instanceof EntityPlayer) {
+                    org.bukkit.craftbukkit.inventory.CraftItemStack item = org.bukkit.craftbukkit.inventory.CraftItemStack.asCraftMirror(this);
+                    org.bukkit.event.player.PlayerItemDamageEvent event = new org.bukkit.event.player.PlayerItemDamageEvent((org.bukkit.entity.Player) entityliving.getBukkitEntity(), item, i);
+                    org.bukkit.Bukkit.getServer().getPluginManager().callEvent(event);
+                    if (event.isCancelled()) return false;
+                    i = event.getDamage();
+                }
+                // Spigot end
+                if (i <= 0 ) {
                     return false;
                 }
             }
@@ -307,7 +380,7 @@ public final class ItemStack {
     public void damage(int i, EntityLiving entityliving) {
         if (!(entityliving instanceof EntityHuman) || !((EntityHuman) entityliving).abilities.canInstantlyBuild) {
             if (this.g()) {
-                if (this.isDamaged(i, entityliving.aI())) {
+                if (this.isDamaged(i, entityliving.aI(), entityliving)) { // Spigot
                     entityliving.a(this);
                     --this.count;
                     if (entityliving instanceof EntityHuman) {
@@ -436,6 +509,7 @@ public final class ItemStack {
 
     public void setTag(NBTTagCompound nbttagcompound) {
         this.tag = nbttagcompound;
+        validateSkullSkin(); // Spigot
     }
 
     public String getName() {
diff --git a/src/main/java/net/minecraft/server/ItemWorldMap.java b/src/main/java/net/minecraft/server/ItemWorldMap.java
index c08ccca..881fd4b 100644
--- a/src/main/java/net/minecraft/server/ItemWorldMap.java
+++ b/src/main/java/net/minecraft/server/ItemWorldMap.java
@@ -199,7 +199,7 @@ public class ItemWorldMap extends ItemWorldMapBase {
     public Packet c(ItemStack itemstack, World world, EntityHuman entityhuman) {
         byte[] abyte = this.getSavedMap(itemstack, world).getUpdatePacket(itemstack, world, entityhuman);
 
-        return abyte == null ? null : new PacketPlayOutMap(itemstack.getData(), abyte);
+        return abyte == null ? null : new PacketPlayOutMap(itemstack.getData(), abyte, this.getSavedMap(itemstack, world).scale); // Spigot - protocol patch
     }
 
     public void d(ItemStack itemstack, World world, EntityHuman entityhuman) {
diff --git a/src/main/java/net/minecraft/server/JsonList.java b/src/main/java/net/minecraft/server/JsonList.java
index 9d1cb33..71ae29e 100644
--- a/src/main/java/net/minecraft/server/JsonList.java
+++ b/src/main/java/net/minecraft/server/JsonList.java
@@ -146,6 +146,17 @@ public class JsonList {
         try {
             bufferedreader = Files.newReader(this.c, Charsets.UTF_8);
             collection = (Collection) this.b.fromJson(bufferedreader, f);
+        // Spigot Start
+        } catch ( java.io.FileNotFoundException ex )
+        {
+            org.bukkit.Bukkit.getLogger().log( java.util.logging.Level.INFO, "Unable to find file {0}, creating it.", this.c );
+        } catch ( net.minecraft.util.com.google.gson.JsonSyntaxException ex )
+        {
+            org.bukkit.Bukkit.getLogger().log( java.util.logging.Level.WARNING, "Unable to read file {0}, backing it up to {0}.backup and creating new copy.", this.c );
+            File backup = new File( this.c + ".backup" );
+            this.c.renameTo( backup );
+            this.c.delete();
+        // Spigot End
         } finally {
             IOUtils.closeQuietly(bufferedreader);
         }
diff --git a/src/main/java/net/minecraft/server/LoginListener.java b/src/main/java/net/minecraft/server/LoginListener.java
index 8f982f1..bd254de 100644
--- a/src/main/java/net/minecraft/server/LoginListener.java
+++ b/src/main/java/net/minecraft/server/LoginListener.java
@@ -9,6 +9,8 @@ import javax.crypto.SecretKey;
 
 import net.minecraft.util.com.google.common.base.Charsets;
 import net.minecraft.util.com.mojang.authlib.GameProfile;
+import net.minecraft.util.com.mojang.authlib.properties.Property;
+import net.minecraft.util.io.netty.util.concurrent.Future;
 import net.minecraft.util.io.netty.util.concurrent.GenericFutureListener;
 import net.minecraft.util.org.apache.commons.lang3.Validate;
 import org.apache.logging.log4j.LogManager;
@@ -59,10 +61,38 @@ public class LoginListener implements PacketLoginInListener {
         }
     }
 
+    // Spigot start
+    public void initUUID()
+    {
+        UUID uuid;
+        if ( networkManager.spoofedUUID != null )
+        {
+            uuid = networkManager.spoofedUUID;
+        } else
+        {
+            uuid = UUID.nameUUIDFromBytes( ( "OfflinePlayer:" + this.i.getName() ).getBytes( Charsets.UTF_8 ) );
+        }
+
+        this.i = new GameProfile( uuid, this.i.getName() );
+
+        if (networkManager.spoofedProfile != null)
+        {
+            for ( Property property : networkManager.spoofedProfile )
+            {
+                this.i.getProperties().put( property.getName(), property );
+            }
+        }
+    }
+    // Spigot end
+
     public void c() {
+        // Spigot start - Moved to initUUID
+        /*
         if (!this.i.isComplete()) {
             this.i = this.a(this.i);
         }
+        */
+        // Spigot end
 
         // CraftBukkit start - fire PlayerLoginEvent
         EntityPlayer s = this.server.getPlayerList().attemptLogin(this, this.i, this.hostname);
@@ -72,6 +102,19 @@ public class LoginListener implements PacketLoginInListener {
             // CraftBukkit end
         } else {
             this.g = EnumProtocolState.e;
+            // Spigot start
+            if ( networkManager.getVersion() >= 27 )
+            {
+                this.networkManager.handle( new org.spigotmc.ProtocolInjector.PacketLoginCompression( 256 ), new GenericFutureListener()
+                {
+                    @Override
+                    public void operationComplete(Future future) throws Exception
+                    {
+                        networkManager.enableCompression();
+                    }
+                } );
+            }
+            // Spigot end
             this.networkManager.handle(new PacketLoginOutSuccess(this.i), new GenericFutureListener[0]);
             this.server.getPlayerList().a(this.networkManager, this.server.getPlayerList().processLogin(this.i, s)); // CraftBukkit - add player reference
         }
@@ -97,7 +140,7 @@ public class LoginListener implements PacketLoginInListener {
             this.g = EnumProtocolState.KEY;
             this.networkManager.handle(new PacketLoginOutEncryptionBegin(this.j, this.server.K().getPublic(), this.e), new GenericFutureListener[0]);
         } else {
-            this.g = EnumProtocolState.READY_TO_ACCEPT;
+            (new ThreadPlayerLookupUUID(this, "User Authenticator #" + b.incrementAndGet())).start(); // Spigot
         }
     }
 
diff --git a/src/main/java/net/minecraft/server/MerchantRecipe.java b/src/main/java/net/minecraft/server/MerchantRecipe.java
new file mode 100644
index 0000000..aa6bbf6
--- /dev/null
+++ b/src/main/java/net/minecraft/server/MerchantRecipe.java
@@ -0,0 +1,101 @@
+package net.minecraft.server;
+
+public class MerchantRecipe {
+
+    private ItemStack buyingItem1;
+    private ItemStack buyingItem2;
+    private ItemStack sellingItem;
+    public int uses; // Spigot - protocol patch
+    public int maxUses; // Spigot - protocol patch
+
+    public MerchantRecipe(NBTTagCompound nbttagcompound) {
+        this.a(nbttagcompound);
+    }
+
+    public MerchantRecipe(ItemStack itemstack, ItemStack itemstack1, ItemStack itemstack2) {
+        this.buyingItem1 = itemstack;
+        this.buyingItem2 = itemstack1;
+        this.sellingItem = itemstack2;
+        this.maxUses = 7;
+    }
+
+    public MerchantRecipe(ItemStack itemstack, ItemStack itemstack1) {
+        this(itemstack, (ItemStack) null, itemstack1);
+    }
+
+    public MerchantRecipe(ItemStack itemstack, Item item) {
+        this(itemstack, new ItemStack(item));
+    }
+
+    public ItemStack getBuyItem1() {
+        return this.buyingItem1;
+    }
+
+    public ItemStack getBuyItem2() {
+        return this.buyingItem2;
+    }
+
+    public boolean hasSecondItem() {
+        return this.buyingItem2 != null;
+    }
+
+    public ItemStack getBuyItem3() {
+        return this.sellingItem;
+    }
+
+    public boolean a(MerchantRecipe merchantrecipe) {
+        return this.buyingItem1.getItem() == merchantrecipe.buyingItem1.getItem() && this.sellingItem.getItem() == merchantrecipe.sellingItem.getItem() ? this.buyingItem2 == null && merchantrecipe.buyingItem2 == null || this.buyingItem2 != null && merchantrecipe.buyingItem2 != null && this.buyingItem2.getItem() == merchantrecipe.buyingItem2.getItem() : false;
+    }
+
+    public boolean b(MerchantRecipe merchantrecipe) {
+        return this.a(merchantrecipe) && (this.buyingItem1.count < merchantrecipe.buyingItem1.count || this.buyingItem2 != null && this.buyingItem2.count < merchantrecipe.buyingItem2.count);
+    }
+
+    public void f() {
+        ++this.uses;
+    }
+
+    public void a(int i) {
+        this.maxUses += i;
+    }
+
+    public boolean g() {
+        return this.uses >= this.maxUses;
+    }
+
+    public void a(NBTTagCompound nbttagcompound) {
+        NBTTagCompound nbttagcompound1 = nbttagcompound.getCompound("buy");
+
+        this.buyingItem1 = ItemStack.createStack(nbttagcompound1);
+        NBTTagCompound nbttagcompound2 = nbttagcompound.getCompound("sell");
+
+        this.sellingItem = ItemStack.createStack(nbttagcompound2);
+        if (nbttagcompound.hasKeyOfType("buyB", 10)) {
+            this.buyingItem2 = ItemStack.createStack(nbttagcompound.getCompound("buyB"));
+        }
+
+        if (nbttagcompound.hasKeyOfType("uses", 99)) {
+            this.uses = nbttagcompound.getInt("uses");
+        }
+
+        if (nbttagcompound.hasKeyOfType("maxUses", 99)) {
+            this.maxUses = nbttagcompound.getInt("maxUses");
+        } else {
+            this.maxUses = 7;
+        }
+    }
+
+    public NBTTagCompound i() {
+        NBTTagCompound nbttagcompound = new NBTTagCompound();
+
+        nbttagcompound.set("buy", this.buyingItem1.save(new NBTTagCompound()));
+        nbttagcompound.set("sell", this.sellingItem.save(new NBTTagCompound()));
+        if (this.buyingItem2 != null) {
+            nbttagcompound.set("buyB", this.buyingItem2.save(new NBTTagCompound()));
+        }
+
+        nbttagcompound.setInt("uses", this.uses);
+        nbttagcompound.setInt("maxUses", this.maxUses);
+        return nbttagcompound;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/MerchantRecipeList.java b/src/main/java/net/minecraft/server/MerchantRecipeList.java
new file mode 100644
index 0000000..6ddbf7a
--- /dev/null
+++ b/src/main/java/net/minecraft/server/MerchantRecipeList.java
@@ -0,0 +1,96 @@
+package net.minecraft.server;
+
+import java.util.ArrayList;
+
+public class MerchantRecipeList extends ArrayList {
+
+    public MerchantRecipeList() {}
+
+    public MerchantRecipeList(NBTTagCompound nbttagcompound) {
+        this.a(nbttagcompound);
+    }
+
+    public MerchantRecipe a(ItemStack itemstack, ItemStack itemstack1, int i) {
+        if (i > 0 && i < this.size()) {
+            MerchantRecipe merchantrecipe = (MerchantRecipe) this.get(i);
+
+            return itemstack.getItem() == merchantrecipe.getBuyItem1().getItem() && (itemstack1 == null && !merchantrecipe.hasSecondItem() || merchantrecipe.hasSecondItem() && itemstack1 != null && merchantrecipe.getBuyItem2().getItem() == itemstack1.getItem()) && itemstack.count >= merchantrecipe.getBuyItem1().count && (!merchantrecipe.hasSecondItem() || itemstack1.count >= merchantrecipe.getBuyItem2().count) ? merchantrecipe : null;
+        } else {
+            for (int j = 0; j < this.size(); ++j) {
+                MerchantRecipe merchantrecipe1 = (MerchantRecipe) this.get(j);
+
+                if (itemstack.getItem() == merchantrecipe1.getBuyItem1().getItem() && itemstack.count >= merchantrecipe1.getBuyItem1().count && (!merchantrecipe1.hasSecondItem() && itemstack1 == null || merchantrecipe1.hasSecondItem() && itemstack1 != null && merchantrecipe1.getBuyItem2().getItem() == itemstack1.getItem() && itemstack1.count >= merchantrecipe1.getBuyItem2().count)) {
+                    return merchantrecipe1;
+                }
+            }
+
+            return null;
+        }
+    }
+
+    public void a(MerchantRecipe merchantrecipe) {
+        for (int i = 0; i < this.size(); ++i) {
+            MerchantRecipe merchantrecipe1 = (MerchantRecipe) this.get(i);
+
+            if (merchantrecipe.a(merchantrecipe1)) {
+                if (merchantrecipe.b(merchantrecipe1)) {
+                    this.set(i, merchantrecipe);
+                }
+
+                return;
+            }
+        }
+
+        this.add(merchantrecipe);
+    }
+
+    public void a(PacketDataSerializer packetdataserializer) {
+        packetdataserializer.writeByte((byte) (this.size() & 255));
+
+        for (int i = 0; i < this.size(); ++i) {
+            MerchantRecipe merchantrecipe = (MerchantRecipe) this.get(i);
+
+            packetdataserializer.a(merchantrecipe.getBuyItem1());
+            packetdataserializer.a(merchantrecipe.getBuyItem3());
+            ItemStack itemstack = merchantrecipe.getBuyItem2();
+
+            packetdataserializer.writeBoolean(itemstack != null);
+            if (itemstack != null) {
+                packetdataserializer.a(itemstack);
+            }
+
+            packetdataserializer.writeBoolean(merchantrecipe.g());
+            // Spigot start - protocol patch
+            if ( packetdataserializer.version >= 28 )
+            {
+                packetdataserializer.writeInt( merchantrecipe.uses );
+                packetdataserializer.writeInt( merchantrecipe.maxUses );
+            }
+            // Spigot end
+        }
+    }
+
+    public void a(NBTTagCompound nbttagcompound) {
+        NBTTagList nbttaglist = nbttagcompound.getList("Recipes", 10);
+
+        for (int i = 0; i < nbttaglist.size(); ++i) {
+            NBTTagCompound nbttagcompound1 = nbttaglist.get(i);
+
+            this.add(new MerchantRecipe(nbttagcompound1));
+        }
+    }
+
+    public NBTTagCompound a() {
+        NBTTagCompound nbttagcompound = new NBTTagCompound();
+        NBTTagList nbttaglist = new NBTTagList();
+
+        for (int i = 0; i < this.size(); ++i) {
+            MerchantRecipe merchantrecipe = (MerchantRecipe) this.get(i);
+
+            nbttaglist.add(merchantrecipe.i());
+        }
+
+        nbttagcompound.set("Recipes", nbttaglist);
+        return nbttagcompound;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index e65cbfa..8c3950a 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -37,6 +37,7 @@ import jline.console.ConsoleReader;
 import joptsimple.OptionSet;
 
 import org.bukkit.World.Environment;
+import org.bukkit.craftbukkit.SpigotTimings; // Spigot
 import org.bukkit.craftbukkit.util.Waitable;
 import org.bukkit.event.server.RemoteServerCommandEvent;
 import org.bukkit.event.world.WorldSaveEvent;
@@ -53,7 +54,7 @@ public abstract class MinecraftServer implements ICommandListener, Runnable, IMo
     private final List n = new ArrayList();
     private final ICommandHandler o;
     public final MethodProfiler methodProfiler = new MethodProfiler();
-    private final ServerConnection p;
+    private ServerConnection p; // Spigot
     private final ServerPing q = new ServerPing();
     private final Random r = new Random();
     private String serverIp;
@@ -106,13 +107,20 @@ public abstract class MinecraftServer implements ICommandListener, Runnable, IMo
     public java.util.Queue<Runnable> processQueue = new java.util.concurrent.ConcurrentLinkedQueue<Runnable>();
     public int autosavePeriod;
     // CraftBukkit end
+    // Spigot start
+    private static final int TPS = 20;
+    private static final int TICK_TIME = 1000000000 / TPS;
+    private static final int SAMPLE_INTERVAL = 100;
+    public final double[] recentTps = new double[ 3 ];
+    // Spigot end
 
     public MinecraftServer(OptionSet options, Proxy proxy) { // CraftBukkit - signature file -> OptionSet
+        net.minecraft.util.io.netty.util.ResourceLeakDetector.setEnabled( false ); // Spigot - disable
         this.X = new UserCache(this, a);
         j = this;
         this.d = proxy;
         // this.universe = file1; // CraftBukkit
-        this.p = new ServerConnection(this);
+        // this.p = new ServerConnection(this); // Spigot
         this.o = new CommandDispatcher();
         // this.convertable = new WorldLoaderServer(file1); // CraftBukkit - moved to DedicatedServer.init
         this.T = new YggdrasilAuthenticationService(proxy, UUID.randomUUID().toString());
@@ -412,6 +420,13 @@ public abstract class MinecraftServer implements ICommandListener, Runnable, IMo
             if (this.l.d()) {
                 this.l.e();
             }
+            // Spigot start
+            if( org.spigotmc.SpigotConfig.saveUserCacheOnStopOnly )
+            {
+                i.info("Saving usercache.json");
+                this.X.c();
+            }
+            //Spigot end
         }
     }
 
@@ -431,6 +446,13 @@ public abstract class MinecraftServer implements ICommandListener, Runnable, IMo
         this.isRunning = false;
     }
 
+    // Spigot Start
+    private static double calcTps(double avg, double exp, double tps)
+    {
+        return ( avg * exp ) + ( tps * ( 1 - exp ) );
+    }
+    // Spigot End
+ 
     public void run() {
         try {
             if (this.init()) {
@@ -441,43 +463,45 @@ public abstract class MinecraftServer implements ICommandListener, Runnable, IMo
                 this.q.setServerInfo(new ServerPingServerData("1.7.10", 5));
                 this.a(this.q);
 
+                // Spigot start
+                Arrays.fill( recentTps, 20 );
+                long lastTick = System.nanoTime(), catchupTime = 0, curTime, wait, tickSection = lastTick;
                 while (this.isRunning) {
-                    long k = ar();
-                    long l = k - i;
-
-                    if (l > 2000L && i - this.P >= 15000L) {
-                        if (this.server.getWarnOnOverload()) // CraftBukkit - Added option to suppress warning messages
-                        MinecraftServer.i.warn("Can\'t keep up! Did the system time change, or is the server overloaded? Running {}ms behind, skipping {} tick(s)", new Object[] { Long.valueOf(l), Long.valueOf(l / 50L)});
-                        l = 2000L;
-                        this.P = i;
-                    }
-
-                    if (l < 0L) {
-                        MinecraftServer.i.warn("Time ran backwards! Did the system time change?");
-                        l = 0L;
+                    curTime = System.nanoTime();
+                    wait = TICK_TIME - (curTime - lastTick) - catchupTime;
+                    if (wait > 0) {
+                        Thread.sleep(wait / 1000000);
+                        catchupTime = 0;
+                        continue;
+                    } else {
+                        catchupTime = Math.min(1000000000, Math.abs(wait));
                     }
 
-                    j += l;
-                    i = k;
-                    if (this.worlds.get(0).everyoneDeeplySleeping()) { // CraftBukkit
-                        this.u();
-                        j = 0L;
-                    } else {
-                        while (j > 50L) {
-                            MinecraftServer.currentTick = (int) (System.currentTimeMillis() / 50); // CraftBukkit
-                            j -= 50L;
-                            this.u();
-                        }
+                    if ( MinecraftServer.currentTick++ % SAMPLE_INTERVAL == 0 )
+                    {
+                        double currentTps = 1E9 / ( curTime - tickSection ) * SAMPLE_INTERVAL;
+                        recentTps[0] = calcTps( recentTps[0], 0.92, currentTps ); // 1/exp(5sec/1min)
+                        recentTps[1] = calcTps( recentTps[1], 0.9835, currentTps ); // 1/exp(5sec/5min)
+                        recentTps[2] = calcTps( recentTps[2], 0.9945, currentTps ); // 1/exp(5sec/15min)
+                        tickSection = curTime;
                     }
+                    lastTick = curTime;
 
-                    Thread.sleep(Math.max(1L,  50L - j));
+                    this.u();
                     this.O = true;
                 }
+                // Spigot end
             } else {
                 this.a((CrashReport) null);
             }
         } catch (Throwable throwable) {
             i.error("Encountered an unexpected exception", throwable);
+            // Spigot Start
+            if ( throwable.getCause() != null )
+            {
+                i.error( "\tCause of unexpected exception was", throwable.getCause() );
+            }
+            // Spigot End
             CrashReport crashreport = null;
 
             if (throwable instanceof ReportedException) {
@@ -497,6 +521,7 @@ public abstract class MinecraftServer implements ICommandListener, Runnable, IMo
             this.a(crashreport);
         } finally {
             try {
+                org.spigotmc.WatchdogThread.doStop();
                 this.stop();
                 this.isStopped = true;
             } catch (Throwable throwable1) {
@@ -545,6 +570,7 @@ public abstract class MinecraftServer implements ICommandListener, Runnable, IMo
     protected void t() {}
 
     protected void u() throws ExceptionWorldConflict { // CraftBukkit - added throws
+        SpigotTimings.serverTickTimer.startTiming(); // Spigot
         long i = System.nanoTime();
 
         ++this.ticks;
@@ -571,41 +597,62 @@ public abstract class MinecraftServer implements ICommandListener, Runnable, IMo
         }
 
         if ((this.autosavePeriod > 0) && ((this.ticks % this.autosavePeriod) == 0)) { // CraftBukkit
+            SpigotTimings.worldSaveTimer.startTiming(); // Spigot
             this.methodProfiler.a("save");
             this.u.savePlayers();
-            this.saveChunks(true);
+            // Spigot Start
+            // We replace this with saving each individual world as this.saveChunks(...) is broken,
+            // and causes the main thread to sleep for random amounts of time depending on chunk activity
+            server.playerCommandState = true;
+            for (World world : worlds) {
+                world.getWorld().save();
+            }
+            server.playerCommandState = false;
+            // this.saveChunks(true);
+            // Spigot End
             this.methodProfiler.b();
+            SpigotTimings.worldSaveTimer.stopTiming(); // Spigot
         }
 
         this.methodProfiler.a("tallying");
         this.g[this.ticks % 100] = System.nanoTime() - i;
         this.methodProfiler.b();
         this.methodProfiler.a("snooper");
-        if (!this.l.d() && this.ticks > 100) {
+        if (getSnooperEnabled() && !this.l.d() && this.ticks > 100) { // Spigot
             this.l.a();
         }
 
-        if (this.ticks % 6000 == 0) {
+        if (getSnooperEnabled() && this.ticks % 6000 == 0) { // Spigot
             this.l.b();
         }
 
         this.methodProfiler.b();
         this.methodProfiler.b();
+        org.spigotmc.WatchdogThread.tick(); // Spigot
+        SpigotTimings.serverTickTimer.stopTiming(); // Spigot
+        org.spigotmc.CustomTimingsHandler.tick(); // Spigot
     }
 
     public void v() {
         this.methodProfiler.a("levels");
 
+        SpigotTimings.schedulerTimer.startTiming(); // Spigot
         // CraftBukkit start
         this.server.getScheduler().mainThreadHeartbeat(this.ticks);
+        SpigotTimings.schedulerTimer.stopTiming(); // Spigot
 
         // Run tasks that are waiting on processing
+        SpigotTimings.processQueueTimer.startTiming(); // Spigot
         while (!processQueue.isEmpty()) {
             processQueue.remove().run();
         }
+        SpigotTimings.processQueueTimer.stopTiming(); // Spigot
 
+        SpigotTimings.chunkIOTickTimer.startTiming(); // Spigot
         org.bukkit.craftbukkit.chunkio.ChunkIOExecutor.tick();
+        SpigotTimings.chunkIOTickTimer.stopTiming(); // Spigot
 
+        SpigotTimings.timeUpdateTimer.startTiming(); // Spigot
         // Send time updates to everyone, it will get the right time from the world the player is in.
         if (this.ticks % 20 == 0) {
             for (int i = 0; i < this.getPlayerList().players.size(); ++i) {
@@ -613,6 +660,7 @@ public abstract class MinecraftServer implements ICommandListener, Runnable, IMo
                 entityplayer.playerConnection.sendPacket(new PacketPlayOutUpdateTime(entityplayer.world.getTime(), entityplayer.getPlayerTime(), entityplayer.world.getGameRules().getBoolean("doDaylightCycle"))); // Add support for per player time
             }
         }
+        SpigotTimings.timeUpdateTimer.stopTiming(); // Spigot
 
         int i;
 
@@ -638,24 +686,42 @@ public abstract class MinecraftServer implements ICommandListener, Runnable, IMo
                 CrashReport crashreport;
 
                 try {
+                    worldserver.timings.doTick.startTiming(); // Spigot
                     worldserver.doTick();
+                    worldserver.timings.doTick.stopTiming(); // Spigot
                 } catch (Throwable throwable) {
+                    // Spigot Start
+                    try {
                     crashreport = CrashReport.a(throwable, "Exception ticking world");
+                    } catch (Throwable t){
+                        throw new RuntimeException("Error generating crash report", t);
+                    }
+                    // Spigot End
                     worldserver.a(crashreport);
                     throw new ReportedException(crashreport);
                 }
 
                 try {
+                    worldserver.timings.tickEntities.startTiming(); // Spigot
                     worldserver.tickEntities();
+                    worldserver.timings.tickEntities.stopTiming(); // Spigot
                 } catch (Throwable throwable1) {
+                    // Spigot Start
+                    try {
                     crashreport = CrashReport.a(throwable1, "Exception ticking world entities");
+                    } catch (Throwable t){
+                        throw new RuntimeException("Error generating crash report", t);
+                    }
+                    // Spigot End
                     worldserver.a(crashreport);
                     throw new ReportedException(crashreport);
                 }
 
                 this.methodProfiler.b();
                 this.methodProfiler.a("tracker");
+                worldserver.timings.tracker.startTiming(); // Spigot
                 worldserver.getTracker().updatePlayers();
+                worldserver.timings.tracker.stopTiming(); // Spigot
                 this.methodProfiler.b();
                 this.methodProfiler.b();
             // } // CraftBukkit
@@ -664,14 +730,20 @@ public abstract class MinecraftServer implements ICommandListener, Runnable, IMo
         }
 
         this.methodProfiler.c("connection");
+        SpigotTimings.connectionTimer.startTiming(); // Spigot
         this.ai().c();
+        SpigotTimings.connectionTimer.stopTiming(); // Spigot
         this.methodProfiler.c("players");
+        SpigotTimings.playerListTimer.startTiming(); // Spigot
         this.u.tick();
+        SpigotTimings.playerListTimer.stopTiming(); // Spigot
         this.methodProfiler.c("tickables");
 
+        SpigotTimings.tickablesTimer.startTiming(); // Spigot
         for (i = 0; i < this.n.size(); ++i) {
             ((IUpdatePlayerListBox) this.n.get(i)).a();
         }
+        SpigotTimings.tickablesTimer.stopTiming(); // Spigot
 
         this.methodProfiler.b();
     }
@@ -686,6 +758,7 @@ public abstract class MinecraftServer implements ICommandListener, Runnable, IMo
 
     public static void main(final OptionSet options) { // CraftBukkit - replaces main(String[] astring)
         DispenserRegistry.b();
+        org.spigotmc.ProtocolInjector.inject();
 
         try {
             /* CraftBukkit start - Replace everything
@@ -915,7 +988,7 @@ public abstract class MinecraftServer implements ICommandListener, Runnable, IMo
     }
 
     public String getServerModName() {
-        return server.getName(); // CraftBukkit - cb > vanilla!
+        return "Spigot"; // Spigot - Spigot > // CraftBukkit - cb > vanilla!
     }
 
     public CrashReport b(CrashReport crashreport) {
@@ -1225,9 +1298,15 @@ public abstract class MinecraftServer implements ICommandListener, Runnable, IMo
         }
     }
 
-    public ServerConnection ai() {
+    // Spigot Start
+    public ServerConnection getServerConnection()
+    {
         return this.p;
     }
+    // Spigot End
+    public ServerConnection ai() {
+        return ( this.p ) == null ? this.p = new ServerConnection( this ) : this.p; // Spigot
+    }
 
     public boolean ak() {
         return false;
diff --git a/src/main/java/net/minecraft/server/MobSpawnerAbstract.java b/src/main/java/net/minecraft/server/MobSpawnerAbstract.java
index 93bb1ad..2276905 100644
--- a/src/main/java/net/minecraft/server/MobSpawnerAbstract.java
+++ b/src/main/java/net/minecraft/server/MobSpawnerAbstract.java
@@ -5,7 +5,11 @@ import java.util.Collection;
 import java.util.Iterator;
 import java.util.List;
 
-import org.bukkit.event.entity.CreatureSpawnEvent; // CraftBukkit
+// CraftBukkit start
+import org.bukkit.craftbukkit.event.CraftEventFactory;
+import org.bukkit.event.entity.CreatureSpawnEvent;
+import org.bukkit.event.entity.SpawnerSpawnEvent;
+// CraftBukkit end
 
 public abstract class MobSpawnerAbstract {
 
@@ -128,7 +132,18 @@ public abstract class MobSpawnerAbstract {
 
             entity.f(nbttagcompound);
             if (entity.world != null) {
-                entity.world.addEntity(entity, CreatureSpawnEvent.SpawnReason.SPAWNER); // CraftBukkit
+                // CraftBukkit start - call SpawnerSpawnEvent, abort if cancelled
+                SpawnerSpawnEvent event = CraftEventFactory.callSpawnerSpawnEvent(entity, this.b(), this.c(), this.d());
+                if (!event.isCancelled()) {
+                    entity.world.addEntity(entity, CreatureSpawnEvent.SpawnReason.SPAWNER); // CraftBukkit
+                    // Spigot Start
+                    if ( entity.world.spigotConfig.nerfSpawnerMobs )
+                    {
+                        entity.fromMobSpawner = true;
+                    }
+                    // Spigot End
+                }
+                // CraftBukkit end
             }
 
             NBTTagCompound nbttagcompound1;
@@ -152,6 +167,11 @@ public abstract class MobSpawnerAbstract {
 
                     entity2.f(nbttagcompound2);
                     entity2.setPositionRotation(entity1.locX, entity1.locY, entity1.locZ, entity1.yaw, entity1.pitch);
+                    // CraftBukkit start - call SpawnerSpawnEvent, skip if cancelled
+                    SpawnerSpawnEvent event = CraftEventFactory.callSpawnerSpawnEvent(entity2, this.b(), this.c(), this.d());
+                    if (event.isCancelled()) {
+                        continue;
+                    }
                     if (entity.world != null) {
                         entity.world.addEntity(entity2, CreatureSpawnEvent.SpawnReason.SPAWNER); // CraftBukkit
                     }
@@ -163,7 +183,18 @@ public abstract class MobSpawnerAbstract {
             }
         } else if (entity instanceof EntityLiving && entity.world != null) {
             ((EntityInsentient) entity).prepare((GroupDataEntity) null);
-            this.a().addEntity(entity, CreatureSpawnEvent.SpawnReason.SPAWNER); // CraftBukkit
+            // Spigot start - call SpawnerSpawnEvent, abort if cancelled
+            SpawnerSpawnEvent event = CraftEventFactory.callSpawnerSpawnEvent(entity, this.b(), this.c(), this.d());
+            if (!event.isCancelled()) {
+                this.a().addEntity(entity, CreatureSpawnEvent.SpawnReason.SPAWNER); // CraftBukkit
+                // Spigot Start
+                if ( entity.world.spigotConfig.nerfSpawnerMobs )
+                {
+                    entity.fromMobSpawner = true;
+                }
+                // Spigot End
+            }
+            // Spigot end
         }
 
         return entity;
diff --git a/src/main/java/net/minecraft/server/NBTBase.java b/src/main/java/net/minecraft/server/NBTBase.java
new file mode 100644
index 0000000..af13af5
--- /dev/null
+++ b/src/main/java/net/minecraft/server/NBTBase.java
@@ -0,0 +1,83 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+public abstract class NBTBase {
+
+    public static final String[] a = new String[] { "END", "BYTE", "SHORT", "INT", "LONG", "FLOAT", "DOUBLE", "BYTE[]", "STRING", "LIST", "COMPOUND", "INT[]"};
+
+    abstract void write(DataOutput dataoutput) throws IOException;
+
+    abstract void load(DataInput datainput, int i, NBTReadLimiter nbtreadlimiter) throws IOException;
+
+    public abstract String toString();
+
+    public abstract byte getTypeId();
+
+    protected NBTBase() {}
+
+    protected static NBTBase createTag(byte b0) {
+        switch (b0) {
+        case 0:
+            return new NBTTagEnd();
+
+        case 1:
+            return new NBTTagByte();
+
+        case 2:
+            return new NBTTagShort();
+
+        case 3:
+            return new NBTTagInt();
+
+        case 4:
+            return new NBTTagLong();
+
+        case 5:
+            return new NBTTagFloat();
+
+        case 6:
+            return new NBTTagDouble();
+
+        case 7:
+            return new NBTTagByteArray();
+
+        case 8:
+            return new NBTTagString();
+
+        case 9:
+            return new NBTTagList();
+
+        case 10:
+            return new NBTTagCompound();
+
+        case 11:
+            return new NBTTagIntArray();
+
+        default:
+            return null;
+        }
+    }
+
+    public abstract NBTBase clone();
+
+    public boolean equals(Object object) {
+        if (!(object instanceof NBTBase)) {
+            return false;
+        } else {
+            NBTBase nbtbase = (NBTBase) object;
+
+            return this.getTypeId() == nbtbase.getTypeId();
+        }
+    }
+
+    public int hashCode() {
+        return this.getTypeId();
+    }
+
+    protected String a_() {
+        return this.toString();
+    }
+}
diff --git a/src/main/java/net/minecraft/server/NBTCompressedStreamTools.java b/src/main/java/net/minecraft/server/NBTCompressedStreamTools.java
new file mode 100644
index 0000000..6defdf5
--- /dev/null
+++ b/src/main/java/net/minecraft/server/NBTCompressedStreamTools.java
@@ -0,0 +1,132 @@
+package net.minecraft.server;
+
+import java.io.BufferedInputStream;
+import java.io.BufferedOutputStream;
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.DataInput;
+import java.io.DataInputStream;
+import java.io.DataOutput;
+import java.io.DataOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.util.zip.GZIPInputStream;
+import java.util.zip.GZIPOutputStream;
+
+public class NBTCompressedStreamTools {
+
+    public static NBTTagCompound a(InputStream inputstream) {
+        try {
+        DataInputStream datainputstream = new DataInputStream(new BufferedInputStream(new GZIPInputStream(inputstream)));
+
+        NBTTagCompound nbttagcompound;
+
+        try {
+            nbttagcompound = a((DataInput) datainputstream, NBTReadLimiter.a);
+        } finally {
+            datainputstream.close();
+        }
+
+        return nbttagcompound;
+        } catch (IOException ex) { org.spigotmc.SneakyThrow.sneaky( ex ); } return null;
+    }
+
+    public static void a(NBTTagCompound nbttagcompound, OutputStream outputstream) {
+        try {
+        DataOutputStream dataoutputstream = new DataOutputStream(new BufferedOutputStream(new GZIPOutputStream(outputstream)));
+
+        try {
+            a(nbttagcompound, (DataOutput) dataoutputstream);
+        } finally {
+            dataoutputstream.close();
+        }
+        } catch (IOException ex) { org.spigotmc.SneakyThrow.sneaky( ex ); }
+    }
+
+    public static NBTTagCompound a(byte[] abyte, NBTReadLimiter nbtreadlimiter) {
+        try {
+        DataInputStream datainputstream = new DataInputStream(new BufferedInputStream(new org.spigotmc.LimitStream(new GZIPInputStream(new ByteArrayInputStream(abyte)), nbtreadlimiter))); // Spigot
+
+        NBTTagCompound nbttagcompound;
+
+        try {
+            nbttagcompound = a((DataInput) datainputstream, nbtreadlimiter);
+        } finally {
+            datainputstream.close();
+        }
+
+        return nbttagcompound;
+        } catch (IOException ex) { org.spigotmc.SneakyThrow.sneaky( ex ); } return null;
+    }
+
+    public static byte[] a(NBTTagCompound nbttagcompound) {
+        try {
+        ByteArrayOutputStream bytearrayoutputstream = new ByteArrayOutputStream();
+        DataOutputStream dataoutputstream = new DataOutputStream(new GZIPOutputStream(bytearrayoutputstream));
+
+        try {
+            a(nbttagcompound, (DataOutput) dataoutputstream);
+        } finally {
+            dataoutputstream.close();
+        }
+
+        return bytearrayoutputstream.toByteArray();
+        } catch (IOException ex) { org.spigotmc.SneakyThrow.sneaky( ex ); } return null;
+    }
+
+    public static NBTTagCompound a(DataInputStream datainputstream) {
+        return a((DataInput) datainputstream, NBTReadLimiter.a);
+    }
+
+    public static NBTTagCompound a(DataInput datainput, NBTReadLimiter nbtreadlimiter) {
+        try {
+        NBTBase nbtbase = a(datainput, 0, nbtreadlimiter);
+
+        if (nbtbase instanceof NBTTagCompound) {
+            return (NBTTagCompound) nbtbase;
+        } else {
+            throw new IOException("Root tag must be a named compound tag");
+        }
+        } catch (IOException ex) { org.spigotmc.SneakyThrow.sneaky( ex ); } return null;
+    }
+
+    public static void a(NBTTagCompound nbttagcompound, DataOutput dataoutput) {
+        a((NBTBase) nbttagcompound, dataoutput);
+    }
+
+    private static void a(NBTBase nbtbase, DataOutput dataoutput) {
+        try {
+        dataoutput.writeByte(nbtbase.getTypeId());
+        if (nbtbase.getTypeId() != 0) {
+            dataoutput.writeUTF("");
+            nbtbase.write(dataoutput);
+        }
+        } catch (IOException ex) { org.spigotmc.SneakyThrow.sneaky( ex ); }
+    }
+
+    private static NBTBase a(DataInput datainput, int i, NBTReadLimiter nbtreadlimiter) {
+        try {
+        byte b0 = datainput.readByte();
+
+        if (b0 == 0) {
+            return new NBTTagEnd();
+        } else {
+            datainput.readUTF();
+            NBTBase nbtbase = NBTBase.createTag(b0);
+
+            try {
+                nbtbase.load(datainput, i, nbtreadlimiter);
+                return nbtbase;
+            } catch (IOException ioexception) {
+                CrashReport crashreport = CrashReport.a(ioexception, "Loading NBT data");
+                CrashReportSystemDetails crashreportsystemdetails = crashreport.a("NBT Tag");
+
+                crashreportsystemdetails.a("Tag name", "[UNNAMED TAG]");
+                crashreportsystemdetails.a("Tag type", Byte.valueOf(b0));
+                throw new ReportedException(crashreport);
+            }
+        }
+        } catch (IOException ex) { org.spigotmc.SneakyThrow.sneaky( ex ); } return null;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/NBTTagByteArray.java b/src/main/java/net/minecraft/server/NBTTagByteArray.java
new file mode 100644
index 0000000..78a1b9a
--- /dev/null
+++ b/src/main/java/net/minecraft/server/NBTTagByteArray.java
@@ -0,0 +1,58 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+import java.util.Arrays;
+
+public class NBTTagByteArray extends NBTBase {
+
+    private byte[] data;
+
+    NBTTagByteArray() {}
+
+    public NBTTagByteArray(byte[] abyte) {
+        this.data = abyte;
+    }
+
+    void write(DataOutput dataoutput) throws IOException {
+        dataoutput.writeInt(this.data.length);
+        dataoutput.write(this.data);
+    }
+
+    void load(DataInput datainput, int i, NBTReadLimiter nbtreadlimiter) throws IOException {
+        int j = datainput.readInt();
+        com.google.common.base.Preconditions.checkArgument( j < 1 << 24);
+
+        nbtreadlimiter.a((long) (8 * j));
+        this.data = new byte[j];
+        datainput.readFully(this.data);
+    }
+
+    public byte getTypeId() {
+        return (byte) 7;
+    }
+
+    public String toString() {
+        return "[" + this.data.length + " bytes]";
+    }
+
+    public NBTBase clone() {
+        byte[] abyte = new byte[this.data.length];
+
+        System.arraycopy(this.data, 0, abyte, 0, this.data.length);
+        return new NBTTagByteArray(abyte);
+    }
+
+    public boolean equals(Object object) {
+        return super.equals(object) ? Arrays.equals(this.data, ((NBTTagByteArray) object).data) : false;
+    }
+
+    public int hashCode() {
+        return super.hashCode() ^ Arrays.hashCode(this.data);
+    }
+
+    public byte[] c() {
+        return this.data;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/NBTTagIntArray.java b/src/main/java/net/minecraft/server/NBTTagIntArray.java
new file mode 100644
index 0000000..099e16a
--- /dev/null
+++ b/src/main/java/net/minecraft/server/NBTTagIntArray.java
@@ -0,0 +1,74 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+import java.util.Arrays;
+
+public class NBTTagIntArray extends NBTBase {
+
+    private int[] data;
+
+    NBTTagIntArray() {}
+
+    public NBTTagIntArray(int[] aint) {
+        this.data = aint;
+    }
+
+    void write(DataOutput dataoutput) throws IOException {
+        dataoutput.writeInt(this.data.length);
+
+        for (int i = 0; i < this.data.length; ++i) {
+            dataoutput.writeInt(this.data[i]);
+        }
+    }
+
+    void load(DataInput datainput, int i, NBTReadLimiter nbtreadlimiter) throws IOException {
+        int j = datainput.readInt();
+        com.google.common.base.Preconditions.checkArgument( j < 1 << 24);
+
+        nbtreadlimiter.a((long) (32 * j));
+        this.data = new int[j];
+
+        for (int k = 0; k < j; ++k) {
+            this.data[k] = datainput.readInt();
+        }
+    }
+
+    public byte getTypeId() {
+        return (byte) 11;
+    }
+
+    public String toString() {
+        String s = "[";
+        int[] aint = this.data;
+        int i = aint.length;
+
+        for (int j = 0; j < i; ++j) {
+            int k = aint[j];
+
+            s = s + k + ",";
+        }
+
+        return s + "]";
+    }
+
+    public NBTBase clone() {
+        int[] aint = new int[this.data.length];
+
+        System.arraycopy(this.data, 0, aint, 0, this.data.length);
+        return new NBTTagIntArray(aint);
+    }
+
+    public boolean equals(Object object) {
+        return super.equals(object) ? Arrays.equals(this.data, ((NBTTagIntArray) object).data) : false;
+    }
+
+    public int hashCode() {
+        return super.hashCode() ^ Arrays.hashCode(this.data);
+    }
+
+    public int[] c() {
+        return this.data;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/NBTTagList.java b/src/main/java/net/minecraft/server/NBTTagList.java
new file mode 100644
index 0000000..f80f93d
--- /dev/null
+++ b/src/main/java/net/minecraft/server/NBTTagList.java
@@ -0,0 +1,167 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+
+public class NBTTagList extends NBTBase {
+
+    private List list = new ArrayList();
+    private byte type = 0;
+
+    public NBTTagList() {}
+
+    void write(DataOutput dataoutput) {
+        if (!this.list.isEmpty()) {
+            this.type = ((NBTBase) this.list.get(0)).getTypeId();
+        } else {
+            this.type = 0;
+        }
+
+        dataoutput.writeByte(this.type);
+        dataoutput.writeInt(this.list.size());
+
+        for (int i = 0; i < this.list.size(); ++i) {
+            ((NBTBase) this.list.get(i)).write(dataoutput);
+        }
+    }
+
+    void load(DataInput datainput, int i, NBTReadLimiter nbtreadlimiter) {
+        if (i > 512) {
+            throw new RuntimeException("Tried to read NBT tag with too high complexity, depth > 512");
+        } else {
+            nbtreadlimiter.a(8L);
+            this.type = datainput.readByte();
+            int j = datainput.readInt();
+
+            this.list = new ArrayList();
+
+            for (int k = 0; k < j; ++k) {
+                NBTBase nbtbase = NBTBase.createTag(this.type);
+
+                nbtbase.load(datainput, i + 1, nbtreadlimiter);
+                this.list.add(nbtbase);
+            }
+        }
+    }
+
+    public byte getTypeId() {
+        return (byte) 9;
+    }
+
+    public String toString() {
+        String s = "[";
+        int i = 0;
+
+        for (Iterator iterator = this.list.iterator(); iterator.hasNext(); ++i) {
+            NBTBase nbtbase = (NBTBase) iterator.next();
+
+            s = s + "" + i + ':' + nbtbase + ',';
+        }
+
+        return s + "]";
+    }
+
+    public void add(NBTBase nbtbase) {
+        if (this.type == 0) {
+            this.type = nbtbase.getTypeId();
+        } else if (this.type != nbtbase.getTypeId()) {
+            System.err.println("WARNING: Adding mismatching tag types to tag list");
+            return;
+        }
+
+        this.list.add(nbtbase);
+    }
+
+    public NBTTagCompound get(int i) {
+        if (i >= 0 && i < this.list.size()) {
+            NBTBase nbtbase = (NBTBase) this.list.get(i);
+
+            return nbtbase.getTypeId() == 10 ? (NBTTagCompound) nbtbase : new NBTTagCompound();
+        } else {
+            return new NBTTagCompound();
+        }
+    }
+
+    public int[] c(int i) {
+        if (i >= 0 && i < this.list.size()) {
+            NBTBase nbtbase = (NBTBase) this.list.get(i);
+
+            return nbtbase.getTypeId() == 11 ? ((NBTTagIntArray) nbtbase).c() : new int[0];
+        } else {
+            return new int[0];
+        }
+    }
+
+    public double d(int i) {
+        if (i >= 0 && i < this.list.size()) {
+            NBTBase nbtbase = (NBTBase) this.list.get(i);
+
+            return nbtbase.getTypeId() == 6 ? ((NBTTagDouble) nbtbase).g() : 0.0D;
+        } else {
+            return 0.0D;
+        }
+    }
+
+    public float e(int i) {
+        if (i >= 0 && i < this.list.size()) {
+            NBTBase nbtbase = (NBTBase) this.list.get(i);
+
+            return nbtbase.getTypeId() == 5 ? ((NBTTagFloat) nbtbase).h() : 0.0F;
+        } else {
+            return 0.0F;
+        }
+    }
+
+    public String getString(int i) {
+        if (i >= 0 && i < this.list.size()) {
+            NBTBase nbtbase = (NBTBase) this.list.get(i);
+
+            return nbtbase.getTypeId() == 8 ? nbtbase.a_() : nbtbase.toString();
+        } else {
+            return "";
+        }
+    }
+
+    public int size() {
+        return this.list.size();
+    }
+
+    public NBTBase clone() {
+        NBTTagList nbttaglist = new NBTTagList();
+
+        nbttaglist.type = this.type;
+        Iterator iterator = this.list.iterator();
+
+        while (iterator.hasNext()) {
+            NBTBase nbtbase = (NBTBase) iterator.next();
+            NBTBase nbtbase1 = nbtbase.clone();
+
+            nbttaglist.list.add(nbtbase1);
+        }
+
+        return nbttaglist;
+    }
+
+    public boolean equals(Object object) {
+        if (super.equals(object)) {
+            NBTTagList nbttaglist = (NBTTagList) object;
+
+            if (this.type == nbttaglist.type) {
+                return this.list.equals(nbttaglist.list);
+            }
+        }
+
+        return false;
+    }
+
+    public int hashCode() {
+        return super.hashCode() ^ this.list.hashCode();
+    }
+
+    public int d() {
+        return this.type;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/NameReferencingFileConverter.java b/src/main/java/net/minecraft/server/NameReferencingFileConverter.java
index ce66cca..56fb152 100644
--- a/src/main/java/net/minecraft/server/NameReferencingFileConverter.java
+++ b/src/main/java/net/minecraft/server/NameReferencingFileConverter.java
@@ -56,7 +56,7 @@ public class NameReferencingFileConverter {
     private static void a(MinecraftServer minecraftserver, Collection collection, ProfileLookupCallback profilelookupcallback) {
         String[] astring = (String[]) Iterators.toArray(Iterators.filter(collection.iterator(), new PredicateEmptyList()), String.class);
 
-        if (minecraftserver.getOnlineMode()) {
+        if (minecraftserver.getOnlineMode() || org.spigotmc.SpigotConfig.bungee) { // Spigot: bungee = online mode, for now.
             minecraftserver.getGameProfileRepository().findProfilesByNames(astring, Agent.MINECRAFT, profilelookupcallback);
         } else {
             String[] astring1 = astring;
diff --git a/src/main/java/net/minecraft/server/NetworkManager.java b/src/main/java/net/minecraft/server/NetworkManager.java
index 1b080c7..0cae021 100644
--- a/src/main/java/net/minecraft/server/NetworkManager.java
+++ b/src/main/java/net/minecraft/server/NetworkManager.java
@@ -6,6 +6,7 @@ import javax.crypto.SecretKey;
 
 import net.minecraft.util.com.google.common.collect.Queues;
 import net.minecraft.util.com.google.common.util.concurrent.ThreadFactoryBuilder;
+import net.minecraft.util.com.mojang.authlib.properties.Property;
 import net.minecraft.util.io.netty.channel.Channel;
 import net.minecraft.util.io.netty.channel.ChannelFutureListener;
 import net.minecraft.util.io.netty.channel.ChannelHandlerContext;
@@ -21,6 +22,11 @@ import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 import org.apache.logging.log4j.Marker;
 import org.apache.logging.log4j.MarkerManager;
+// Spigot start
+import com.google.common.collect.ImmutableSet;
+import org.spigotmc.SpigotCompressor;
+import org.spigotmc.SpigotDecompressor;
+// Spigot end
 
 public class NetworkManager extends SimpleChannelInboundHandler {
 
@@ -37,11 +43,30 @@ public class NetworkManager extends SimpleChannelInboundHandler {
     private final Queue k = Queues.newConcurrentLinkedQueue();
     private final Queue l = Queues.newConcurrentLinkedQueue();
     private Channel m;
-    private SocketAddress n;
+    // Spigot Start
+    public SocketAddress n;
+    public java.util.UUID spoofedUUID;
+    public Property[] spoofedProfile;
+    public boolean preparing = true;
+    // Spigot End
     private PacketListener o;
     private EnumProtocol p;
     private IChatBaseComponent q;
     private boolean r;
+    // Spigot Start
+    public static final AttributeKey<Integer> protocolVersion = new AttributeKey<Integer>("protocol_version");
+    public static final ImmutableSet<Integer> SUPPORTED_VERSIONS = ImmutableSet.of(4, 5, 47);
+    public static final int CURRENT_VERSION = 5;
+    public static int getVersion(Channel attr)
+    {
+        Integer ver = attr.attr( protocolVersion ).get();
+        return ( ver != null ) ? ver : CURRENT_VERSION;
+    }
+    public int getVersion()
+    {
+        return getVersion( this.m );
+    }
+    // Spigot End
 
     public NetworkManager(boolean flag) {
         this.j = flag;
@@ -51,6 +76,9 @@ public class NetworkManager extends SimpleChannelInboundHandler {
         super.channelActive(channelhandlercontext);
         this.m = channelhandlercontext.channel();
         this.n = this.m.remoteAddress();
+        // Spigot Start
+        this.preparing = false;
+        // Spigot End
         this.a(EnumProtocol.HANDSHAKING);
     }
 
@@ -76,6 +104,7 @@ public class NetworkManager extends SimpleChannelInboundHandler {
         }
 
         this.close(chatmessage);
+        if (MinecraftServer.getServer().isDebugging()) throwable.printStackTrace(); // Spigot
     }
 
     protected void a(ChannelHandlerContext channelhandlercontext, Packet packet) {
@@ -168,6 +197,9 @@ public class NetworkManager extends SimpleChannelInboundHandler {
     }
 
     public void close(IChatBaseComponent ichatbasecomponent) {
+        // Spigot Start
+        this.preparing = false;
+        // Spigot End
         if (this.m.isOpen()) {
             this.m.close();
             this.q = ichatbasecomponent;
@@ -207,4 +239,25 @@ public class NetworkManager extends SimpleChannelInboundHandler {
     static Channel a(NetworkManager networkmanager) {
         return networkmanager.m;
     }
+
+    // Spigot Start
+    public SocketAddress getRawAddress()
+    {
+        return this.m.remoteAddress();
+    }
+    // Spigot End
+
+
+    // Spigot start - protocol patch
+    public void enableCompression() {
+        // Fix ProtocolLib compatibility
+        if ( m.pipeline().get("protocol_lib_decoder") != null ) {
+            m.pipeline().addBefore( "protocol_lib_decoder", "decompress", new SpigotDecompressor() );
+        } else {
+            m.pipeline().addBefore( "decoder", "decompress", new SpigotDecompressor() );
+        }
+
+        m.pipeline().addBefore( "encoder", "compress", new SpigotCompressor() );
+    }
+    // Spigot end
 }
diff --git a/src/main/java/net/minecraft/server/NextTickListEntry.java b/src/main/java/net/minecraft/server/NextTickListEntry.java
new file mode 100644
index 0000000..cbb3576
--- /dev/null
+++ b/src/main/java/net/minecraft/server/NextTickListEntry.java
@@ -0,0 +1,60 @@
+package net.minecraft.server;
+
+public class NextTickListEntry implements Comparable {
+
+    private static long f;
+    private final Block g;
+    public int a;
+    public int b;
+    public int c;
+    public long d;
+    public int e;
+    private long h;
+
+    public NextTickListEntry(int i, int j, int k, Block block) {
+        this.h = (long) (f++);
+        this.a = i;
+        this.b = j;
+        this.c = k;
+        this.g = block;
+    }
+
+    public boolean equals(Object object) {
+        if (!(object instanceof NextTickListEntry)) {
+            return false;
+        } else {
+            NextTickListEntry nextticklistentry = (NextTickListEntry) object;
+
+            return this.a == nextticklistentry.a && this.b == nextticklistentry.b && this.c == nextticklistentry.c && Block.a(this.g, nextticklistentry.g);
+        }
+    }
+
+    public int hashCode() {
+        return (this.a * 1024 * 1024 + this.c * 1024 + this.b) * 256;
+    }
+
+    public NextTickListEntry a(long i) {
+        this.d = i;
+        return this;
+    }
+
+    public void a(int i) {
+        this.e = i;
+    }
+
+    public int compareTo(NextTickListEntry nextticklistentry) {
+        return this.d < nextticklistentry.d ? -1 : (this.d > nextticklistentry.d ? 1 : (this.e != nextticklistentry.e ? this.e - nextticklistentry.e : (this.h < nextticklistentry.h ? -1 : (this.h > nextticklistentry.h ? 1 : 0))));
+    }
+
+    public String toString() {
+        return Block.getId(this.g) + ": (" + this.a + ", " + this.b + ", " + this.c + "), " + this.d + ", " + this.e + ", " + this.h;
+    }
+
+    public Block a() {
+        return this.g;
+    }
+
+    public int compareTo(Object object) {
+        return this.compareTo((NextTickListEntry) object);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/NibbleArray.java b/src/main/java/net/minecraft/server/NibbleArray.java
new file mode 100644
index 0000000..5d75a54
--- /dev/null
+++ b/src/main/java/net/minecraft/server/NibbleArray.java
@@ -0,0 +1,40 @@
+package net.minecraft.server;
+
+public class NibbleArray {
+
+    public final byte[] a;
+    private final int b;
+    private final int c;
+
+    public NibbleArray(int i, int j) {
+        this.a = new byte[i >> 1];
+        this.b = j;
+        this.c = j + 4;
+    }
+
+    public NibbleArray(byte[] abyte, int i) {
+        this.a = abyte;
+        this.b = i;
+        this.c = i + 4;
+    }
+
+    public int a(int i, int j, int k) {
+        int l = j << this.c | k << this.b | i;
+        int i1 = l >> 1;
+        int j1 = l & 1;
+
+        return j1 == 0 ? this.a[i1] & 15 : this.a[i1] >> 4 & 15;
+    }
+
+    public void a(int i, int j, int k, int l) {
+        int i1 = j << this.c | k << this.b | i;
+        int j1 = i1 >> 1;
+        int k1 = i1 & 1;
+
+        if (k1 == 0) {
+            this.a[j1] = (byte) (this.a[j1] & 240 | l & 15);
+        } else {
+            this.a[j1] = (byte) (this.a[j1] & 15 | (l & 15) << 4);
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/OldChunkLoader.java b/src/main/java/net/minecraft/server/OldChunkLoader.java
new file mode 100644
index 0000000..fcb9912
--- /dev/null
+++ b/src/main/java/net/minecraft/server/OldChunkLoader.java
@@ -0,0 +1,120 @@
+package net.minecraft.server;
+
+public class OldChunkLoader {
+
+    public static OldChunk a(NBTTagCompound nbttagcompound) {
+        int i = nbttagcompound.getInt("xPos");
+        int j = nbttagcompound.getInt("zPos");
+        OldChunk oldchunk = new OldChunk(i, j);
+
+        oldchunk.g = nbttagcompound.getByteArray("Blocks");
+        oldchunk.f = new OldNibbleArray(nbttagcompound.getByteArray("Data"), 7);
+        oldchunk.e = new OldNibbleArray(nbttagcompound.getByteArray("SkyLight"), 7);
+        oldchunk.d = new OldNibbleArray(nbttagcompound.getByteArray("BlockLight"), 7);
+        oldchunk.c = nbttagcompound.getByteArray("HeightMap");
+        oldchunk.b = nbttagcompound.getBoolean("TerrainPopulated");
+        oldchunk.h = nbttagcompound.getList("Entities", 10);
+        oldchunk.i = nbttagcompound.getList("TileEntities", 10);
+        oldchunk.j = nbttagcompound.getList("TileTicks", 10);
+
+        try {
+            oldchunk.a = nbttagcompound.getLong("LastUpdate");
+        } catch (ClassCastException classcastexception) {
+            oldchunk.a = (long) nbttagcompound.getInt("LastUpdate");
+        }
+
+        return oldchunk;
+    }
+
+    public static void a(OldChunk oldchunk, NBTTagCompound nbttagcompound, WorldChunkManager worldchunkmanager) {
+        nbttagcompound.setInt("xPos", oldchunk.k);
+        nbttagcompound.setInt("zPos", oldchunk.l);
+        nbttagcompound.setLong("LastUpdate", oldchunk.a);
+        int[] aint = new int[oldchunk.c.length];
+
+        for (int i = 0; i < oldchunk.c.length; ++i) {
+            aint[i] = oldchunk.c[i];
+        }
+
+        nbttagcompound.setIntArray("HeightMap", aint);
+        nbttagcompound.setBoolean("TerrainPopulated", oldchunk.b);
+        NBTTagList nbttaglist = new NBTTagList();
+
+        int j;
+
+        for (int k = 0; k < 8; ++k) {
+            boolean flag = true;
+
+            for (j = 0; j < 16 && flag; ++j) {
+                int l = 0;
+
+                while (l < 16 && flag) {
+                    int i1 = 0;
+
+                    while (true) {
+                        if (i1 < 16) {
+                            int j1 = j << 11 | i1 << 7 | l + (k << 4);
+                            byte b0 = oldchunk.g[j1];
+
+                            if (b0 == 0) {
+                                ++i1;
+                                continue;
+                            }
+
+                            flag = false;
+                        }
+
+                        ++l;
+                        break;
+                    }
+                }
+            }
+
+            if (!flag) {
+                byte[] abyte = new byte[4096];
+                NibbleArray nibblearray = new NibbleArray(abyte.length, 4);
+                NibbleArray nibblearray1 = new NibbleArray(abyte.length, 4);
+                NibbleArray nibblearray2 = new NibbleArray(abyte.length, 4);
+
+                for (int k1 = 0; k1 < 16; ++k1) {
+                    for (int l1 = 0; l1 < 16; ++l1) {
+                        for (int i2 = 0; i2 < 16; ++i2) {
+                            int j2 = k1 << 11 | i2 << 7 | l1 + (k << 4);
+                            byte b1 = oldchunk.g[j2];
+
+                            abyte[l1 << 8 | i2 << 4 | k1] = (byte) (b1 & 255);
+                            nibblearray.a(k1, l1, i2, oldchunk.f.a(k1, l1 + (k << 4), i2));
+                            nibblearray1.a(k1, l1, i2, oldchunk.e.a(k1, l1 + (k << 4), i2));
+                            nibblearray2.a(k1, l1, i2, oldchunk.d.a(k1, l1 + (k << 4), i2));
+                        }
+                    }
+                }
+
+                NBTTagCompound nbttagcompound1 = new NBTTagCompound();
+
+                nbttagcompound1.setByte("Y", (byte) (k & 255));
+                nbttagcompound1.setByteArray("Blocks", abyte);
+                nbttagcompound1.setByteArray("Data", nibblearray.a);
+                nbttagcompound1.setByteArray("SkyLight", nibblearray1.a);
+                nbttagcompound1.setByteArray("BlockLight", nibblearray2.a);
+                nbttaglist.add(nbttagcompound1);
+            }
+        }
+
+        nbttagcompound.set("Sections", nbttaglist);
+        byte[] abyte1 = new byte[256];
+
+        for (int k2 = 0; k2 < 16; ++k2) {
+            for (j = 0; j < 16; ++j) {
+                abyte1[j << 4 | k2] = (byte) (worldchunkmanager.getBiome(oldchunk.k << 4 | k2, oldchunk.l << 4 | j).id & 255);
+            }
+        }
+
+        nbttagcompound.setByteArray("Biomes", abyte1);
+        nbttagcompound.set("Entities", oldchunk.h);
+        nbttagcompound.set("TileEntities", oldchunk.i);
+        if (oldchunk.j != null) {
+            nbttagcompound.set("TileTicks", oldchunk.j);
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Packet.java b/src/main/java/net/minecraft/server/Packet.java
index 592ffc5..7a1e8f0 100644
--- a/src/main/java/net/minecraft/server/Packet.java
+++ b/src/main/java/net/minecraft/server/Packet.java
@@ -26,12 +26,39 @@ public abstract class Packet {
     }
 
     public static void a(ByteBuf bytebuf, byte[] abyte) {
-        bytebuf.writeShort(abyte.length);
+        // Spigot start - protocol patch
+        if (bytebuf instanceof PacketDataSerializer)
+        {
+            PacketDataSerializer packetDataSerializer = (PacketDataSerializer) bytebuf;
+            if (packetDataSerializer.version >= 20) {
+                packetDataSerializer.b( abyte.length );
+            } else {
+                bytebuf.writeShort( abyte.length );
+            }
+        } else
+        {
+            bytebuf.writeShort( abyte.length );
+        }
+        // Spigot end
         bytebuf.writeBytes(abyte);
     }
 
     public static byte[] a(ByteBuf bytebuf) throws IOException { // CraftBukkit - added throws
-        short short1 = bytebuf.readShort();
+        // Spigot start - protocol patch
+        short short1 = 0;
+        if (bytebuf instanceof PacketDataSerializer)
+        {
+            PacketDataSerializer packetDataSerializer = (PacketDataSerializer) bytebuf;
+            if (packetDataSerializer.version >= 20) {
+                short1 = (short) packetDataSerializer.a();
+            } else {
+                short1 = bytebuf.readShort();
+            }
+        } else
+        {
+            short1 = bytebuf.readShort();
+        }
+        // Spigot end
 
         if (short1 < 0) {
             throw new IOException("Key was smaller than nothing!  Weird key!");
diff --git a/src/main/java/net/minecraft/server/PacketDataSerializer.java b/src/main/java/net/minecraft/server/PacketDataSerializer.java
index 8d3cf1f..451f5fd 100644
--- a/src/main/java/net/minecraft/server/PacketDataSerializer.java
+++ b/src/main/java/net/minecraft/server/PacketDataSerializer.java
@@ -8,6 +8,7 @@ import java.nio.ByteOrder;
 import java.nio.channels.GatheringByteChannel;
 import java.nio.channels.ScatteringByteChannel;
 import java.nio.charset.Charset;
+import java.util.UUID;
 
 import net.minecraft.util.com.google.common.base.Charsets;
 import net.minecraft.util.io.netty.buffer.ByteBuf;
@@ -16,14 +17,58 @@ import net.minecraft.util.io.netty.buffer.ByteBufProcessor;
 
 import org.bukkit.craftbukkit.inventory.CraftItemStack; // CraftBukkit
 
+// Spigot start - protocol patch
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import net.minecraft.util.io.netty.buffer.Unpooled;
+import net.minecraft.util.io.netty.buffer.ByteBufInputStream;
+import net.minecraft.util.io.netty.buffer.ByteBufOutputStream;
+import org.spigotmc.SpigotComponentReverter;
+// Spigot end
+
 public class PacketDataSerializer extends ByteBuf {
 
     private final ByteBuf a;
+    // Spigot Start
+    public final int version;
+
+    public PacketDataSerializer(ByteBuf bytebuf)
+    {
+        this( bytebuf, NetworkManager.CURRENT_VERSION );
+    }
 
-    public PacketDataSerializer(ByteBuf bytebuf) {
+    public PacketDataSerializer(ByteBuf bytebuf, int version) {
         this.a = bytebuf;
+        this.version = version;
+    }
+
+    public void writePosition(int x, int y, int z) {
+        writeLong( ( ( (long) x & 0x3FFFFFFL ) << 38 )
+                | ( ( (long) y & 0xFFFL ) << 26 )
+                | ( (long) z & 0x3FFFFFFL ) );
+    }
+
+    public int readPositionX(long val)
+    {
+        return (int) ( val >> 38 );
     }
 
+    public int readPositionY(long val)
+    {
+        return (int) (val << 26 >> 52);
+    }
+
+    public int readPositionZ(long val)
+    {
+        return (int) (val << 38 >> 38);
+    }
+
+    public void writeUUID(UUID uuid) {
+        writeLong( uuid.getMostSignificantBits() );
+        writeLong( uuid.getLeastSignificantBits() );
+    }
+    // Spigot End
+
     public static int a(int i) {
         return (i & -128) == 0 ? 1 : ((i & -16384) == 0 ? 2 : ((i & -2097152) == 0 ? 3 : ((i & -268435456) == 0 ? 4 : 5)));
     }
@@ -54,43 +99,112 @@ public class PacketDataSerializer extends ByteBuf {
         this.writeByte(i);
     }
 
-    public void a(NBTTagCompound nbttagcompound) {
-        if (nbttagcompound == null) {
-            this.writeShort(-1);
-        } else {
-            byte[] abyte = NBTCompressedStreamTools.a(nbttagcompound);
-
-            this.writeShort((short) abyte.length);
-            this.writeBytes(abyte);
+    // Spigot start - protocol patch
+    public void a(NBTTagCompound nbttagcompound)
+    {
+        if ( version < 28 )
+        {
+            if ( nbttagcompound == null )
+            {
+                this.writeShort( -1 );
+            } else
+            {
+                byte[] abyte = NBTCompressedStreamTools.a( nbttagcompound );
+
+                this.writeShort( (short) abyte.length );
+                this.writeBytes( abyte );
+            }
+        } else
+        {
+            if ( nbttagcompound == null )
+            {
+                this.writeByte( 0 );
+            } else
+            {
+                ByteBufOutputStream out = new ByteBufOutputStream( Unpooled.buffer() );
+                NBTCompressedStreamTools.a( nbttagcompound, (java.io.DataOutput) new DataOutputStream( out ) );
+                writeBytes( out.buffer() );
+                out.buffer().release();
+            }
         }
     }
 
     public NBTTagCompound b() {
-        short short1 = this.readShort();
-
-        if (short1 < 0) {
-            return null;
+        if ( version < 28 )
+        {
+            short short1 = this.readShort();
+
+            if ( short1 < 0 )
+            {
+                return null;
+            } else
+            {
+                byte[] abyte = new byte[ short1 ];
+
+                this.readBytes( abyte );
+                return NBTCompressedStreamTools.a( abyte, new NBTReadLimiter( 2097152L ) );
+            }
         } else {
-            byte[] abyte = new byte[short1];
-
-            this.readBytes(abyte);
-            return NBTCompressedStreamTools.a(abyte, new NBTReadLimiter(2097152L));
+            int index = readerIndex();
+            if (readByte() == 0) {
+                return null;
+            }
+            readerIndex(index);
+            return NBTCompressedStreamTools.a( new DataInputStream( new ByteBufInputStream( a ) ) );
         }
     }
+    // Spigot end
 
     public void a(ItemStack itemstack) {
         if (itemstack == null || itemstack.getItem() == null) { // CraftBukkit - NPE fix itemstack.getItem()
             this.writeShort(-1);
         } else {
-            this.writeShort(Item.getId(itemstack.getItem()));
+            // Spigot start - protocol patch
+            if ( version >= 47 )
+            {
+                this.writeShort( org.spigotmc.SpigotDebreakifier.getItemId( Item.getId( itemstack.getItem() ) ) );
+            } else
+            {
+                this.writeShort( Item.getId( itemstack.getItem() ) );
+            }
+            // Spigot end
             this.writeByte(itemstack.count);
             this.writeShort(itemstack.getData());
             NBTTagCompound nbttagcompound = null;
 
             if (itemstack.getItem().usesDurability() || itemstack.getItem().s()) {
+                // Spigot start - filter
+                itemstack = itemstack.cloneItemStack();
+                CraftItemStack.setItemMeta(itemstack, CraftItemStack.getItemMeta(itemstack));
+                // Spigot end
                 nbttagcompound = itemstack.tag;
             }
 
+            // Spigot start - protocol patch
+            if (nbttagcompound != null && version >= 29 )
+            {
+                if ( itemstack.getItem() == Items.WRITTEN_BOOK && nbttagcompound.hasKeyOfType("pages", 9) )
+                {
+                    nbttagcompound = (NBTTagCompound) nbttagcompound.clone();
+                    NBTTagList nbttaglist = nbttagcompound.getList( "pages", 8 );
+                    NBTTagList newList = new NBTTagList();
+                    for (int i = 0; i < nbttaglist.size(); ++i)
+                    {
+                        IChatBaseComponent[] parts = org.bukkit.craftbukkit.util.CraftChatMessage.fromString( nbttaglist.getString( i ) );
+                        IChatBaseComponent root = parts[0];
+                        for ( int i1 = 1; i1 < parts.length; i1++ )
+                        {
+                            IChatBaseComponent c = parts[ i1 ];
+                            root.a( "\n" );
+                            root.addSibling( c );
+                        }
+                        newList.add( new NBTTagString( ChatSerializer.a( root ) ) );
+                    }
+                    nbttagcompound.set( "pages", newList );
+                }
+            }
+            // Spigot end
+
             this.a(nbttagcompound);
         }
     }
@@ -107,6 +221,24 @@ public class PacketDataSerializer extends ByteBuf {
             itemstack.tag = this.b();
             // CraftBukkit start
             if (itemstack.tag != null) {
+
+                // Spigot start - protocol patch
+                if ( version >= 29
+                        && itemstack.getItem() == Items.WRITTEN_BOOK
+                        && itemstack.tag.hasKeyOfType("pages", 9) )
+                {
+                    NBTTagList nbttaglist = itemstack.tag.getList( "pages", 8 );
+                    NBTTagList newList = new NBTTagList();
+                    for (int i = 0; i < nbttaglist.size(); ++i)
+                    {
+                        IChatBaseComponent s = ChatSerializer.a( nbttaglist.getString( i ) );
+                        String newString = SpigotComponentReverter.toLegacy( s );
+                        newList.add( new NBTTagString( newString ) );
+                    }
+                    itemstack.tag.set( "pages", newList );
+                }
+                // Spigot end
+
                 CraftItemStack.setItemMeta(itemstack, CraftItemStack.getItemMeta(itemstack));
             }
             // CraftBukkit end
diff --git a/src/main/java/net/minecraft/server/PacketDecoder.java b/src/main/java/net/minecraft/server/PacketDecoder.java
new file mode 100644
index 0000000..5213f1f
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PacketDecoder.java
@@ -0,0 +1,49 @@
+package net.minecraft.server;
+
+import java.io.IOException;
+import java.util.List;
+
+import net.minecraft.util.com.google.common.collect.BiMap;
+import net.minecraft.util.io.netty.buffer.ByteBuf;
+import net.minecraft.util.io.netty.channel.ChannelHandlerContext;
+import net.minecraft.util.io.netty.handler.codec.ByteToMessageDecoder;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.apache.logging.log4j.Marker;
+import org.apache.logging.log4j.MarkerManager;
+
+public class PacketDecoder extends ByteToMessageDecoder {
+
+    private static final Logger a = LogManager.getLogger();
+    private static final Marker b = MarkerManager.getMarker("PACKET_RECEIVED", NetworkManager.b);
+    private final NetworkStatistics c;
+
+    public PacketDecoder(NetworkStatistics networkstatistics) {
+        this.c = networkstatistics;
+    }
+
+    protected void decode(ChannelHandlerContext channelhandlercontext, ByteBuf bytebuf, List list) throws IOException {
+        int i = bytebuf.readableBytes();
+
+        if (i != 0) {
+            PacketDataSerializer packetdataserializer = new PacketDataSerializer( bytebuf, NetworkManager.getVersion( channelhandlercontext.channel() ) ); // Spigot
+            int j = packetdataserializer.a();
+            Packet packet = Packet.a((BiMap) channelhandlercontext.channel().attr(NetworkManager.e).get(), j);
+
+            if (packet == null) {
+                throw new IOException("Bad packet id " + j);
+            } else {
+                packet.a(packetdataserializer);
+                if (packetdataserializer.readableBytes() > 0) {
+                    throw new IOException("Packet was larger than I expected, found " + packetdataserializer.readableBytes() + " bytes extra whilst reading packet " + j);
+                } else {
+                    list.add(packet);
+                    this.c.a(j, (long) i);
+                    if (a.isDebugEnabled()) {
+                        a.debug(b, " IN: [{}:{}] {}[{}]", new Object[] { channelhandlercontext.channel().attr(NetworkManager.d).get(), Integer.valueOf(j), packet.getClass().getName(), packet.b()});
+                    }
+                }
+            }
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PacketEncoder.java b/src/main/java/net/minecraft/server/PacketEncoder.java
new file mode 100644
index 0000000..7994daa
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PacketEncoder.java
@@ -0,0 +1,45 @@
+package net.minecraft.server;
+
+import java.io.IOException;
+
+import net.minecraft.util.com.google.common.collect.BiMap;
+import net.minecraft.util.io.netty.buffer.ByteBuf;
+import net.minecraft.util.io.netty.channel.ChannelHandlerContext;
+import net.minecraft.util.io.netty.handler.codec.MessageToByteEncoder;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.apache.logging.log4j.Marker;
+import org.apache.logging.log4j.MarkerManager;
+
+public class PacketEncoder extends MessageToByteEncoder {
+
+    private static final Logger a = LogManager.getLogger();
+    private static final Marker b = MarkerManager.getMarker("PACKET_SENT", NetworkManager.b);
+    private final NetworkStatistics c;
+
+    public PacketEncoder(NetworkStatistics networkstatistics) {
+        this.c = networkstatistics;
+    }
+
+    protected void a(ChannelHandlerContext channelhandlercontext, Packet packet, ByteBuf bytebuf) throws IOException {
+        Integer integer = (Integer) ((BiMap) channelhandlercontext.channel().attr(NetworkManager.f).get()).inverse().get(packet.getClass());
+
+        if (a.isDebugEnabled()) {
+            a.debug(b, "OUT: [{}:{}] {}[{}]", new Object[] { channelhandlercontext.channel().attr(NetworkManager.d).get(), integer, packet.getClass().getName(), packet.b()});
+        }
+
+        if (integer == null) {
+            throw new IOException("Can\'t serialize unregistered packet");
+        } else {
+            PacketDataSerializer packetdataserializer = new PacketDataSerializer(bytebuf, NetworkManager.getVersion(channelhandlercontext.channel())); // Spigot
+
+            packetdataserializer.b(integer.intValue());
+            packet.b(packetdataserializer);
+            this.c.b(integer.intValue(), (long) packetdataserializer.readableBytes());
+        }
+    }
+
+    protected void encode(ChannelHandlerContext channelhandlercontext, Object object, ByteBuf bytebuf) throws IOException {
+        this.a(channelhandlercontext, (Packet) object, bytebuf);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PacketHandshakingInSetProtocol.java b/src/main/java/net/minecraft/server/PacketHandshakingInSetProtocol.java
index 16d4765..39692ee 100644
--- a/src/main/java/net/minecraft/server/PacketHandshakingInSetProtocol.java
+++ b/src/main/java/net/minecraft/server/PacketHandshakingInSetProtocol.java
@@ -13,7 +13,7 @@ public class PacketHandshakingInSetProtocol extends Packet {
 
     public void a(PacketDataSerializer packetdataserializer) throws IOException { // CraftBukkit - added throws
         this.a = packetdataserializer.a();
-        this.b = packetdataserializer.c(255);
+        this.b = packetdataserializer.c(Short.MAX_VALUE); // Spigot
         this.c = packetdataserializer.readUnsignedShort();
         this.d = EnumProtocol.a(packetdataserializer.a());
     }
diff --git a/src/main/java/net/minecraft/server/PacketLoginOutSuccess.java b/src/main/java/net/minecraft/server/PacketLoginOutSuccess.java
new file mode 100644
index 0000000..a244f00
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PacketLoginOutSuccess.java
@@ -0,0 +1,44 @@
+package net.minecraft.server;
+
+import java.io.IOException;
+import java.util.UUID;
+
+import net.minecraft.util.com.mojang.authlib.GameProfile;
+
+public class PacketLoginOutSuccess extends Packet {
+
+    private GameProfile a;
+
+    public PacketLoginOutSuccess() {}
+
+    public PacketLoginOutSuccess(GameProfile gameprofile) {
+        this.a = gameprofile;
+    }
+
+    public void a(PacketDataSerializer packetdataserializer) throws IOException {
+        String s = packetdataserializer.c(36);
+        String s1 = packetdataserializer.c(16);
+        UUID uuid = UUID.fromString(s);
+
+        this.a = new GameProfile(uuid, s1);
+    }
+
+    public void b(PacketDataSerializer packetdataserializer) throws IOException {
+        UUID uuid = this.a.getId();
+
+        packetdataserializer.a(uuid == null ? "" : ( ( packetdataserializer.version >= 5 ) ? uuid.toString() : uuid.toString().replaceAll( "-", "" ) ) );
+        packetdataserializer.a(this.a.getName());
+    }
+
+    public void a(PacketLoginOutListener packetloginoutlistener) {
+        packetloginoutlistener.a(this);
+    }
+
+    public boolean a() {
+        return true;
+    }
+
+    public void handle(PacketListener packetlistener) {
+        this.a((PacketLoginOutListener) packetlistener);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PacketPlayInArmAnimation.java b/src/main/java/net/minecraft/server/PacketPlayInArmAnimation.java
new file mode 100644
index 0000000..91d9e58
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PacketPlayInArmAnimation.java
@@ -0,0 +1,42 @@
+package net.minecraft.server;
+
+public class PacketPlayInArmAnimation extends Packet {
+
+    private int a;
+    private int b;
+
+    public PacketPlayInArmAnimation() {}
+
+    public void a(PacketDataSerializer packetdataserializer) {
+        // Spigot start - protocol patch
+        if ( packetdataserializer.version < 16 )
+        {
+            this.a = packetdataserializer.readInt();
+            this.b = packetdataserializer.readByte();
+        } else {
+            b = 1;
+        }
+        // Spigot end
+    }
+
+    public void b(PacketDataSerializer packetdataserializer) {
+        packetdataserializer.writeInt(this.a);
+        packetdataserializer.writeByte(this.b);
+    }
+
+    public void a(PacketPlayInListener packetplayinlistener) {
+        packetplayinlistener.a(this);
+    }
+
+    public String b() {
+        return String.format("id=%d, type=%d", new Object[] { Integer.valueOf(this.a), Integer.valueOf(this.b)});
+    }
+
+    public int d() {
+        return this.b;
+    }
+
+    public void handle(PacketListener packetlistener) {
+        this.a((PacketPlayInListener) packetlistener);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PacketPlayInBlockDig.java b/src/main/java/net/minecraft/server/PacketPlayInBlockDig.java
new file mode 100644
index 0000000..e85ba8c
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PacketPlayInBlockDig.java
@@ -0,0 +1,67 @@
+package net.minecraft.server;
+
+public class PacketPlayInBlockDig extends Packet {
+
+    private int a;
+    private int b;
+    private int c;
+    private int face;
+    private int e;
+
+    public PacketPlayInBlockDig() {}
+
+    public void a(PacketDataSerializer packetdataserializer) {
+        this.e = packetdataserializer.readUnsignedByte();
+        // Spigot start
+        if ( packetdataserializer.version < 16)
+        {
+            this.a = packetdataserializer.readInt();
+            this.b = packetdataserializer.readUnsignedByte();
+            this.c = packetdataserializer.readInt();
+        } else
+        {
+            long position = packetdataserializer.readLong();
+            a = packetdataserializer.readPositionX( position );
+            b = packetdataserializer.readPositionY( position );
+            c = packetdataserializer.readPositionZ( position );
+        }
+        // Spigot end
+        this.face = packetdataserializer.readUnsignedByte();
+    }
+
+    public void b(PacketDataSerializer packetdataserializer) {
+        packetdataserializer.writeByte(this.e);
+        packetdataserializer.writeInt(this.a);
+        packetdataserializer.writeByte(this.b);
+        packetdataserializer.writeInt(this.c);
+        packetdataserializer.writeByte(this.face);
+    }
+
+    public void a(PacketPlayInListener packetplayinlistener) {
+        packetplayinlistener.a(this);
+    }
+
+    public int c() {
+        return this.a;
+    }
+
+    public int d() {
+        return this.b;
+    }
+
+    public int e() {
+        return this.c;
+    }
+
+    public int f() {
+        return this.face;
+    }
+
+    public int g() {
+        return this.e;
+    }
+
+    public void handle(PacketListener packetlistener) {
+        this.a((PacketPlayInListener) packetlistener);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PacketPlayInBlockPlace.java b/src/main/java/net/minecraft/server/PacketPlayInBlockPlace.java
new file mode 100644
index 0000000..b9cea4c
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PacketPlayInBlockPlace.java
@@ -0,0 +1,88 @@
+package net.minecraft.server;
+
+public class PacketPlayInBlockPlace extends Packet {
+
+    private int a;
+    private int b;
+    private int c;
+    private int d;
+    private ItemStack e;
+    private float f;
+    private float g;
+    private float h;
+
+    public PacketPlayInBlockPlace() {}
+
+    public void a(PacketDataSerializer packetdataserializer) {
+        // Spigot start - protocol patch
+        if ( packetdataserializer.version < 16 )
+        {
+            this.a = packetdataserializer.readInt();
+            this.b = packetdataserializer.readUnsignedByte();
+            this.c = packetdataserializer.readInt();
+        } else
+        {
+            long position = packetdataserializer.readLong();
+            a = packetdataserializer.readPositionX( position );
+            b = packetdataserializer.readPositionY( position );
+            c = packetdataserializer.readPositionZ( position );
+        }
+        // Spigot end
+        this.d = packetdataserializer.readUnsignedByte();
+        this.e = packetdataserializer.c();
+        this.f = (float) packetdataserializer.readUnsignedByte() / 16.0F;
+        this.g = (float) packetdataserializer.readUnsignedByte() / 16.0F;
+        this.h = (float) packetdataserializer.readUnsignedByte() / 16.0F;
+    }
+
+    public void b(PacketDataSerializer packetdataserializer) {
+        packetdataserializer.writeInt(this.a);
+        packetdataserializer.writeByte(this.b);
+        packetdataserializer.writeInt(this.c);
+        packetdataserializer.writeByte(this.d);
+        packetdataserializer.a(this.e);
+        packetdataserializer.writeByte((int) (this.f * 16.0F));
+        packetdataserializer.writeByte((int) (this.g * 16.0F));
+        packetdataserializer.writeByte((int) (this.h * 16.0F));
+    }
+
+    public void a(PacketPlayInListener packetplayinlistener) {
+        packetplayinlistener.a(this);
+    }
+
+    public int c() {
+        return this.a;
+    }
+
+    public int d() {
+        return this.b;
+    }
+
+    public int e() {
+        return this.c;
+    }
+
+    public int getFace() {
+        return this.d;
+    }
+
+    public ItemStack getItemStack() {
+        return this.e;
+    }
+
+    public float h() {
+        return this.f;
+    }
+
+    public float i() {
+        return this.g;
+    }
+
+    public float j() {
+        return this.h;
+    }
+
+    public void handle(PacketListener packetlistener) {
+        this.a((PacketPlayInListener) packetlistener);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PacketPlayInChat.java b/src/main/java/net/minecraft/server/PacketPlayInChat.java
index 604a7af..d419f0f 100644
--- a/src/main/java/net/minecraft/server/PacketPlayInChat.java
+++ b/src/main/java/net/minecraft/server/PacketPlayInChat.java
@@ -43,7 +43,25 @@ public class PacketPlayInChat extends Packet {
     }
     // CraftBukkit end
 
-    public void handle(PacketListener packetlistener) {
+    // Spigot Start
+    private static final java.util.concurrent.ExecutorService executors = java.util.concurrent.Executors.newCachedThreadPool(
+            new com.google.common.util.concurrent.ThreadFactoryBuilder().setDaemon( true ).setNameFormat( "Async Chat Thread - #%d" ).build() );
+    public void handle(final PacketListener packetlistener)
+    {
+        if ( a() )
+        {
+            executors.submit( new Runnable()
+            {
+
+                @Override
+                public void run()
+                {
+                    PacketPlayInChat.this.a( (PacketPlayInListener) packetlistener );
+                }
+            } );
+            return;
+        }
+        // Spigot End
         this.a((PacketPlayInListener) packetlistener);
     }
 }
diff --git a/src/main/java/net/minecraft/server/PacketPlayInCustomPayload.java b/src/main/java/net/minecraft/server/PacketPlayInCustomPayload.java
index 5df99a4..54ac5b7 100644
--- a/src/main/java/net/minecraft/server/PacketPlayInCustomPayload.java
+++ b/src/main/java/net/minecraft/server/PacketPlayInCustomPayload.java
@@ -12,7 +12,15 @@ public class PacketPlayInCustomPayload extends Packet {
 
     public void a(PacketDataSerializer packetdataserializer) throws IOException { // CraftBukkit - added throws
         this.tag = packetdataserializer.c(20);
-        this.length = packetdataserializer.readShort();
+        // Spigot start - protocol patch
+        if ( packetdataserializer.version < 29 )
+        {
+            this.length = packetdataserializer.readShort();
+        } else
+        {
+            this.length = packetdataserializer.readableBytes();
+        }
+        // Spigot end
         if (this.length > 0 && this.length < 32767) {
             this.data = new byte[this.length];
             packetdataserializer.readBytes(this.data);
diff --git a/src/main/java/net/minecraft/server/PacketPlayInEntityAction.java b/src/main/java/net/minecraft/server/PacketPlayInEntityAction.java
new file mode 100644
index 0000000..5e4a377
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PacketPlayInEntityAction.java
@@ -0,0 +1,48 @@
+package net.minecraft.server;
+
+public class PacketPlayInEntityAction extends Packet {
+
+    private int a;
+    private int animation;
+    private int c;
+
+    public PacketPlayInEntityAction() {}
+
+    public void a(PacketDataSerializer packetdataserializer) {
+        // Spigot start - protocol patch
+        if ( packetdataserializer.version < 16 )
+        {
+            this.a = packetdataserializer.readInt();
+            this.animation = packetdataserializer.readByte();
+            this.c = packetdataserializer.readInt();
+        } else
+        {
+            a = packetdataserializer.a();
+            animation = packetdataserializer.readUnsignedByte() + 1;
+            c = packetdataserializer.a();
+        }
+        // Spigot end
+    }
+
+    public void b(PacketDataSerializer packetdataserializer) {
+        packetdataserializer.writeInt(this.a);
+        packetdataserializer.writeByte(this.animation);
+        packetdataserializer.writeInt(this.c);
+    }
+
+    public void a(PacketPlayInListener packetplayinlistener) {
+        packetplayinlistener.a(this);
+    }
+
+    public int d() {
+        return this.animation;
+    }
+
+    public int e() {
+        return this.c;
+    }
+
+    public void handle(PacketListener packetlistener) {
+        this.a((PacketPlayInListener) packetlistener);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PacketPlayInKeepAlive.java b/src/main/java/net/minecraft/server/PacketPlayInKeepAlive.java
new file mode 100644
index 0000000..5c88cf1
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PacketPlayInKeepAlive.java
@@ -0,0 +1,40 @@
+package net.minecraft.server;
+
+public class PacketPlayInKeepAlive extends Packet {
+
+    private int a;
+
+    public PacketPlayInKeepAlive() {}
+
+    public void a(PacketPlayInListener packetplayinlistener) {
+        packetplayinlistener.a(this);
+    }
+
+    public void a(PacketDataSerializer packetdataserializer) {
+        // Spigot start - protocol patch
+        if ( packetdataserializer.version < 16 )
+        {
+            this.a = packetdataserializer.readInt();
+        } else
+        {
+            this.a = packetdataserializer.a();
+        }
+        // Spigot end
+    }
+
+    public void b(PacketDataSerializer packetdataserializer) {
+        packetdataserializer.writeInt(this.a);
+    }
+
+    public boolean a() {
+        return true;
+    }
+
+    public int c() {
+        return this.a;
+    }
+
+    public void handle(PacketListener packetlistener) {
+        this.a((PacketPlayInListener) packetlistener);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PacketPlayInPosition.java b/src/main/java/net/minecraft/server/PacketPlayInPosition.java
new file mode 100644
index 0000000..2f3a2ec
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PacketPlayInPosition.java
@@ -0,0 +1,37 @@
+package net.minecraft.server;
+
+public class PacketPlayInPosition extends PacketPlayInFlying {
+
+    public PacketPlayInPosition() {
+        this.hasPos = true;
+    }
+
+    public void a(PacketDataSerializer packetdataserializer) {
+        this.x = packetdataserializer.readDouble();
+        // Spigot start - protocol patch
+        if (packetdataserializer.version < 16)
+        {
+            this.y = packetdataserializer.readDouble();
+            this.stance = packetdataserializer.readDouble();
+        } else
+        {
+            this.y = packetdataserializer.readDouble();
+            this.stance = y + 1.62;
+        }
+        // Spigot end
+        this.z = packetdataserializer.readDouble();
+        super.a(packetdataserializer);
+    }
+
+    public void b(PacketDataSerializer packetdataserializer) {
+        packetdataserializer.writeDouble(this.x);
+        packetdataserializer.writeDouble(this.y);
+        packetdataserializer.writeDouble(this.stance);
+        packetdataserializer.writeDouble(this.z);
+        super.b(packetdataserializer);
+    }
+
+    public void handle(PacketListener packetlistener) {
+        super.a((PacketPlayInListener) packetlistener);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PacketPlayInPositionLook.java b/src/main/java/net/minecraft/server/PacketPlayInPositionLook.java
new file mode 100644
index 0000000..0266592
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PacketPlayInPositionLook.java
@@ -0,0 +1,42 @@
+package net.minecraft.server;
+
+public class PacketPlayInPositionLook extends PacketPlayInFlying {
+
+    public PacketPlayInPositionLook() {
+        this.hasPos = true;
+        this.hasLook = true;
+    }
+
+    public void a(PacketDataSerializer packetdataserializer) {
+        this.x = packetdataserializer.readDouble();
+        // Spigot start - protocol patch
+        if (packetdataserializer.version < 16)
+        {
+            this.y = packetdataserializer.readDouble();
+            this.stance = packetdataserializer.readDouble();
+        } else
+        {
+            this.y = packetdataserializer.readDouble();
+            this.stance = y + 1.62;
+        }
+        // Spigot end
+        this.z = packetdataserializer.readDouble();
+        this.yaw = packetdataserializer.readFloat();
+        this.pitch = packetdataserializer.readFloat();
+        super.a(packetdataserializer);
+    }
+
+    public void b(PacketDataSerializer packetdataserializer) {
+        packetdataserializer.writeDouble(this.x);
+        packetdataserializer.writeDouble(this.y);
+        packetdataserializer.writeDouble(this.stance);
+        packetdataserializer.writeDouble(this.z);
+        packetdataserializer.writeFloat(this.yaw);
+        packetdataserializer.writeFloat(this.pitch);
+        super.b(packetdataserializer);
+    }
+
+    public void handle(PacketListener packetlistener) {
+        super.a((PacketPlayInListener) packetlistener);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PacketPlayInSettings.java b/src/main/java/net/minecraft/server/PacketPlayInSettings.java
new file mode 100644
index 0000000..ea51d91
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PacketPlayInSettings.java
@@ -0,0 +1,83 @@
+package net.minecraft.server;
+
+import java.io.IOException;
+
+public class PacketPlayInSettings extends Packet {
+
+    private String a;
+    private int b;
+    private EnumChatVisibility c;
+    private boolean d;
+    private EnumDifficulty e;
+    private boolean f;
+
+    // Spigot start - protocol patch
+    public int version;
+    public int flags;
+    // Spigot end
+
+    public PacketPlayInSettings() {}
+
+    public void a(PacketDataSerializer packetdataserializer) throws IOException {
+        this.a = packetdataserializer.c(7);
+        this.b = packetdataserializer.readByte();
+        this.c = EnumChatVisibility.a(packetdataserializer.readByte());
+        this.d = packetdataserializer.readBoolean();
+        // Spigot start - protocol patch
+        if ( packetdataserializer.version < 16 )
+        {
+            this.e = EnumDifficulty.getById( packetdataserializer.readByte() );
+            this.f = packetdataserializer.readBoolean();
+        } else
+        {
+            flags = packetdataserializer.readUnsignedByte();
+        }
+        version = packetdataserializer.version;
+        // Spigot end
+    }
+
+    public void b(PacketDataSerializer packetdataserializer) throws IOException {
+        packetdataserializer.a(this.a);
+        packetdataserializer.writeByte(this.b);
+        packetdataserializer.writeByte(this.c.a());
+        packetdataserializer.writeBoolean(this.d);
+        packetdataserializer.writeByte(this.e.a());
+        packetdataserializer.writeBoolean(this.f);
+    }
+
+    public void a(PacketPlayInListener packetplayinlistener) {
+        packetplayinlistener.a(this);
+    }
+
+    public String c() {
+        return this.a;
+    }
+
+    public int d() {
+        return this.b;
+    }
+
+    public EnumChatVisibility e() {
+        return this.c;
+    }
+
+    public boolean f() {
+        return this.d;
+    }
+
+    public EnumDifficulty g() {
+        return this.e;
+    }
+
+    public boolean h() {
+        return this.f;
+    }
+
+    public String b() {
+        return String.format("lang=\'%s\', view=%d, chat=%s, col=%b, difficulty=%s, cape=%b", new Object[] { this.a, Integer.valueOf(this.b), this.c, Boolean.valueOf(this.d), this.e, Boolean.valueOf(this.f)});
+    }
+
+    public void handle(PacketListener packetlistener) {
+        this.a((PacketPlayInListener) packetlistener);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PacketPlayInSteerVehicle.java b/src/main/java/net/minecraft/server/PacketPlayInSteerVehicle.java
new file mode 100644
index 0000000..c26bf77
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PacketPlayInSteerVehicle.java
@@ -0,0 +1,58 @@
+package net.minecraft.server;
+
+public class PacketPlayInSteerVehicle extends Packet {
+
+    private float a;
+    private float b;
+    private boolean c;
+    private boolean d;
+
+    public PacketPlayInSteerVehicle() {}
+
+    public void a(PacketDataSerializer packetdataserializer) {
+        this.a = packetdataserializer.readFloat();
+        this.b = packetdataserializer.readFloat();
+        // Spigot start - protocol patch
+        if ( packetdataserializer.version < 16 )
+        {
+            this.c = packetdataserializer.readBoolean();
+            this.d = packetdataserializer.readBoolean();
+        } else {
+            int flags = packetdataserializer.readUnsignedByte();
+            c = (flags & 0x1) != 0;
+            d = (flags & 0x2) != 0;
+        }
+        // Spigot end
+    }
+
+    public void b(PacketDataSerializer packetdataserializer) {
+        packetdataserializer.writeFloat(this.a);
+        packetdataserializer.writeFloat(this.b);
+        packetdataserializer.writeBoolean(this.c);
+        packetdataserializer.writeBoolean(this.d);
+    }
+
+    public void a(PacketPlayInListener packetplayinlistener) {
+        packetplayinlistener.a(this);
+    }
+
+    public float c() {
+        return this.a;
+    }
+
+    public float d() {
+        return this.b;
+    }
+
+    public boolean e() {
+        return this.c;
+    }
+
+    public boolean f() {
+        return this.d;
+    }
+
+    public void handle(PacketListener packetlistener) {
+        this.a((PacketPlayInListener) packetlistener);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PacketPlayInTabComplete.java b/src/main/java/net/minecraft/server/PacketPlayInTabComplete.java
new file mode 100644
index 0000000..5909876
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PacketPlayInTabComplete.java
@@ -0,0 +1,48 @@
+package net.minecraft.server;
+
+import net.minecraft.util.org.apache.commons.lang3.StringUtils;
+
+import java.io.IOException;
+
+public class PacketPlayInTabComplete extends Packet {
+
+    private String a;
+
+    public PacketPlayInTabComplete() {}
+
+    public PacketPlayInTabComplete(String s) {
+        this.a = s;
+    }
+
+    public void a(PacketDataSerializer packetdataserializer) throws IOException {
+        this.a = packetdataserializer.c(32767);
+        // Spigot start - protocol patch
+        if ( packetdataserializer.version >= 37 )
+        {
+            if (packetdataserializer.readBoolean()) {
+                long position = packetdataserializer.readLong();
+            }
+        }
+        // Spigot end
+    }
+
+    public void b(PacketDataSerializer packetdataserializer) throws IOException {
+        packetdataserializer.a(StringUtils.substring(this.a, 0, 32767));
+    }
+
+    public void a(PacketPlayInListener packetplayinlistener) {
+        packetplayinlistener.a(this);
+    }
+
+    public String c() {
+        return this.a;
+    }
+
+    public String b() {
+        return String.format("message=\'%s\'", new Object[] { this.a});
+    }
+
+    public void handle(PacketListener packetlistener) {
+        this.a((PacketPlayInListener) packetlistener);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PacketPlayInUpdateSign.java b/src/main/java/net/minecraft/server/PacketPlayInUpdateSign.java
new file mode 100644
index 0000000..f6cf5c8
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PacketPlayInUpdateSign.java
@@ -0,0 +1,80 @@
+package net.minecraft.server;
+
+import java.io.IOException;
+
+public class PacketPlayInUpdateSign extends Packet {
+
+    private int a;
+    private int b;
+    private int c;
+    private String[] d;
+
+    public PacketPlayInUpdateSign() {}
+
+    public void a(PacketDataSerializer packetdataserializer) throws IOException {
+        // Spigot start - protocol patch
+        if ( packetdataserializer.version < 16 )
+        {
+            this.a = packetdataserializer.readInt();
+            this.b = packetdataserializer.readShort();
+            this.c = packetdataserializer.readInt();
+        } else
+        {
+            long position = packetdataserializer.readLong();
+            a = packetdataserializer.readPositionX( position );
+            b = packetdataserializer.readPositionY( position );
+            c = packetdataserializer.readPositionZ( position );
+        }
+        // Spigot end
+        this.d = new String[4];
+
+        for (int i = 0; i < 4; ++i) {
+            // Spigot start - protocol patch
+            if ( packetdataserializer.version < 21 )
+            {
+                this.d[ i ] = packetdataserializer.c( 15 );
+            } else
+            {
+                this.d[ i ] = ChatSerializer.a( packetdataserializer.c( Short.MAX_VALUE ) ).c();
+            }
+            if (this.d[i].length() > 15) {
+                this.d[i] = this.d[i].substring( 0, 15 );
+            }
+            // Spigot end
+        }
+    }
+
+    public void b(PacketDataSerializer packetdataserializer) throws IOException {
+        packetdataserializer.writeInt(this.a);
+        packetdataserializer.writeShort(this.b);
+        packetdataserializer.writeInt(this.c);
+
+        for (int i = 0; i < 4; ++i) {
+            packetdataserializer.a(this.d[i]);
+        }
+    }
+
+    public void a(PacketPlayInListener packetplayinlistener) {
+        packetplayinlistener.a(this);
+    }
+
+    public int c() {
+        return this.a;
+    }
+
+    public int d() {
+        return this.b;
+    }
+
+    public int e() {
+        return this.c;
+    }
+
+    public String[] f() {
+        return this.d;
+    }
+
+    public void handle(PacketListener packetlistener) {
+        this.a((PacketPlayInListener) packetlistener);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PacketPlayInUseEntity.java b/src/main/java/net/minecraft/server/PacketPlayInUseEntity.java
new file mode 100644
index 0000000..3f12453
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PacketPlayInUseEntity.java
@@ -0,0 +1,51 @@
+package net.minecraft.server;
+
+public class PacketPlayInUseEntity extends Packet {
+
+    private int a;
+    private EnumEntityUseAction action;
+
+    public PacketPlayInUseEntity() {}
+
+    public void a(PacketDataSerializer packetdataserializer) {
+        // Spigot start
+        if ( packetdataserializer.version < 16 )
+        {
+            this.a = packetdataserializer.readInt();
+            this.action = EnumEntityUseAction.values()[packetdataserializer.readByte() % EnumEntityUseAction.values().length];
+        } else {
+            this.a = packetdataserializer.a();
+            int val = packetdataserializer.a();
+            if ( val == 2 ) {
+                packetdataserializer.readFloat();
+                packetdataserializer.readFloat();
+                packetdataserializer.readFloat();
+            } else
+            {
+                this.action = EnumEntityUseAction.values()[ val % EnumEntityUseAction.values().length ];
+            }
+        }
+        // Spigot end
+    }
+
+    public void b(PacketDataSerializer packetdataserializer) {
+        packetdataserializer.writeInt(this.a);
+        packetdataserializer.writeByte(this.action.ordinal());
+    }
+
+    public void a(PacketPlayInListener packetplayinlistener) {
+        packetplayinlistener.a(this);
+    }
+
+    public Entity a(World world) {
+        return world.getEntity(this.a);
+    }
+
+    public EnumEntityUseAction c() {
+        return this.action;
+    }
+
+    public void handle(PacketListener packetlistener) {
+        this.a((PacketPlayInListener) packetlistener);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PacketPlayInWindowClick.java b/src/main/java/net/minecraft/server/PacketPlayInWindowClick.java
new file mode 100644
index 0000000..87daa8e
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PacketPlayInWindowClick.java
@@ -0,0 +1,67 @@
+package net.minecraft.server;
+
+public class PacketPlayInWindowClick extends Packet {
+
+    private int a;
+    public int slot; // Spigot
+    private int button;
+    private short d;
+    private ItemStack item;
+    private int shift;
+
+    public PacketPlayInWindowClick() {}
+
+    public void a(PacketPlayInListener packetplayinlistener) {
+        packetplayinlistener.a(this);
+    }
+
+    public void a(PacketDataSerializer packetdataserializer) {
+        this.a = packetdataserializer.readByte();
+        this.slot = packetdataserializer.readShort();
+        this.button = packetdataserializer.readByte();
+        this.d = packetdataserializer.readShort();
+        this.shift = packetdataserializer.readByte();
+        this.item = packetdataserializer.c();
+    }
+
+    public void b(PacketDataSerializer packetdataserializer) {
+        packetdataserializer.writeByte(this.a);
+        packetdataserializer.writeShort(this.slot);
+        packetdataserializer.writeByte(this.button);
+        packetdataserializer.writeShort(this.d);
+        packetdataserializer.writeByte(this.shift);
+        packetdataserializer.a(this.item);
+    }
+
+    public String b() {
+        return this.item != null ? String.format("id=%d, slot=%d, button=%d, type=%d, itemid=%d, itemcount=%d, itemaux=%d", new Object[] { Integer.valueOf(this.a), Integer.valueOf(this.slot), Integer.valueOf(this.button), Integer.valueOf(this.shift), Integer.valueOf(Item.getId(this.item.getItem())), Integer.valueOf(this.item.count), Integer.valueOf(this.item.getData())}) : String.format("id=%d, slot=%d, button=%d, type=%d, itemid=-1", new Object[] { Integer.valueOf(this.a), Integer.valueOf(this.slot), Integer.valueOf(this.button), Integer.valueOf(this.shift)});
+    }
+
+    public int c() {
+        return this.a;
+    }
+
+    public int d() {
+        return this.slot;
+    }
+
+    public int e() {
+        return this.button;
+    }
+
+    public short f() {
+        return this.d;
+    }
+
+    public ItemStack g() {
+        return this.item;
+    }
+
+    public int h() {
+        return this.shift;
+    }
+
+    public void handle(PacketListener packetlistener) {
+        this.a((PacketPlayInListener) packetlistener);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PacketPlayOutBed.java b/src/main/java/net/minecraft/server/PacketPlayOutBed.java
new file mode 100644
index 0000000..b361f38
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PacketPlayOutBed.java
@@ -0,0 +1,49 @@
+package net.minecraft.server;
+
+public class PacketPlayOutBed extends Packet {
+
+    private int a;
+    private int b;
+    private int c;
+    private int d;
+
+    public PacketPlayOutBed() {}
+
+    public PacketPlayOutBed(EntityHuman entityhuman, int i, int j, int k) {
+        this.b = i;
+        this.c = j;
+        this.d = k;
+        this.a = entityhuman.getId();
+    }
+
+    public void a(PacketDataSerializer packetdataserializer) {
+        this.a = packetdataserializer.readInt();
+        this.b = packetdataserializer.readInt();
+        this.c = packetdataserializer.readByte();
+        this.d = packetdataserializer.readInt();
+    }
+
+    public void b(PacketDataSerializer packetdataserializer) {
+        // Spigot start - protocol patch
+        if ( packetdataserializer.version < 16 )
+        {
+            packetdataserializer.writeInt( this.a );
+            packetdataserializer.writeInt( this.b );
+            packetdataserializer.writeByte( this.c );
+            packetdataserializer.writeInt( this.d );
+        } else
+        {
+            packetdataserializer.b( a );
+            packetdataserializer.writePosition( b, c, d );
+        }
+        // Spigot end
+    }
+
+    public void a(PacketPlayOutListener packetplayoutlistener) {
+        packetplayoutlistener.a(this);
+    }
+
+    public void handle(PacketListener packetlistener) {
+        this.a((PacketPlayOutListener) packetlistener);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PacketPlayOutBlockAction.java b/src/main/java/net/minecraft/server/PacketPlayOutBlockAction.java
new file mode 100644
index 0000000..959d052
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PacketPlayOutBlockAction.java
@@ -0,0 +1,56 @@
+package net.minecraft.server;
+
+public class PacketPlayOutBlockAction extends Packet {
+
+    private int a;
+    private int b;
+    private int c;
+    private int d;
+    private int e;
+    private Block f;
+
+    public PacketPlayOutBlockAction() {}
+
+    public PacketPlayOutBlockAction(int i, int j, int k, Block block, int l, int i1) {
+        this.a = i;
+        this.b = j;
+        this.c = k;
+        this.d = l;
+        this.e = i1;
+        this.f = block;
+    }
+
+    public void a(PacketDataSerializer packetdataserializer) {
+        this.a = packetdataserializer.readInt();
+        this.b = packetdataserializer.readShort();
+        this.c = packetdataserializer.readInt();
+        this.d = packetdataserializer.readUnsignedByte();
+        this.e = packetdataserializer.readUnsignedByte();
+        this.f = Block.getById(packetdataserializer.a() & 4095);
+    }
+
+    public void b(PacketDataSerializer packetdataserializer) {
+        // Spigot start
+        if ( packetdataserializer.version < 16 )
+        {
+            packetdataserializer.writeInt( this.a );
+            packetdataserializer.writeShort( this.b );
+            packetdataserializer.writeInt( this.c );
+        } else
+        {
+            packetdataserializer.writePosition( a, b, c );
+        }
+        // Spigot end
+        packetdataserializer.writeByte(this.d);
+        packetdataserializer.writeByte(this.e);
+        packetdataserializer.b(Block.getId(this.f) & 4095);
+    }
+
+    public void a(PacketPlayOutListener packetplayoutlistener) {
+        packetplayoutlistener.a(this);
+    }
+
+    public void handle(PacketListener packetlistener) {
+        this.a((PacketPlayOutListener) packetlistener);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PacketPlayOutBlockBreakAnimation.java b/src/main/java/net/minecraft/server/PacketPlayOutBlockBreakAnimation.java
new file mode 100644
index 0000000..1d70129
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PacketPlayOutBlockBreakAnimation.java
@@ -0,0 +1,52 @@
+package net.minecraft.server;
+
+public class PacketPlayOutBlockBreakAnimation extends Packet {
+
+    private int a;
+    private int b;
+    private int c;
+    private int d;
+    private int e;
+
+    public PacketPlayOutBlockBreakAnimation() {}
+
+    public PacketPlayOutBlockBreakAnimation(int i, int j, int k, int l, int i1) {
+        this.a = i;
+        this.b = j;
+        this.c = k;
+        this.d = l;
+        this.e = i1;
+    }
+
+    public void a(PacketDataSerializer packetdataserializer) {
+        this.a = packetdataserializer.a();
+        this.b = packetdataserializer.readInt();
+        this.c = packetdataserializer.readInt();
+        this.d = packetdataserializer.readInt();
+        this.e = packetdataserializer.readUnsignedByte();
+    }
+
+    public void b(PacketDataSerializer packetdataserializer) {
+        packetdataserializer.b(this.a);
+        // Spigot start - protocol patch
+        if ( packetdataserializer.version < 16 )
+        {
+            packetdataserializer.writeInt( this.b );
+            packetdataserializer.writeInt( this.c );
+            packetdataserializer.writeInt( this.d );
+        } else
+        {
+            packetdataserializer.writePosition( b, c, d );
+        }
+        // Spigot end
+        packetdataserializer.writeByte(this.e);
+    }
+
+    public void a(PacketPlayOutListener packetplayoutlistener) {
+        packetplayoutlistener.a(this);
+    }
+
+    public void handle(PacketListener packetlistener) {
+        this.a((PacketPlayOutListener) packetlistener);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PacketPlayOutBlockChange.java b/src/main/java/net/minecraft/server/PacketPlayOutBlockChange.java
index 4c622e2..dfa68b0 100644
--- a/src/main/java/net/minecraft/server/PacketPlayOutBlockChange.java
+++ b/src/main/java/net/minecraft/server/PacketPlayOutBlockChange.java
@@ -27,11 +27,22 @@ public class PacketPlayOutBlockChange extends Packet {
     }
 
     public void b(PacketDataSerializer packetdataserializer) {
-        packetdataserializer.writeInt(this.a);
-        packetdataserializer.writeByte(this.b);
-        packetdataserializer.writeInt(this.c);
-        packetdataserializer.b(Block.getId(this.block));
-        packetdataserializer.writeByte(this.data);
+        // Spigot start - protocol patch
+        if ( packetdataserializer.version < 25 )
+        {
+            packetdataserializer.writeInt( this.a );
+            packetdataserializer.writeByte( this.b );
+            packetdataserializer.writeInt( this.c );
+            packetdataserializer.b( Block.getId( this.block ) );
+            packetdataserializer.writeByte(this.data);
+        } else
+        {
+            packetdataserializer.writePosition( a, b, c );
+            int id = Block.getId( this.block );
+            data = org.spigotmc.SpigotDebreakifier.getCorrectedData( id, data );
+            packetdataserializer.b( (id << 4) | this.data );
+        }
+        // Spigot end
     }
 
     public void a(PacketPlayOutListener packetplayoutlistener) {
diff --git a/src/main/java/net/minecraft/server/PacketPlayOutChat.java b/src/main/java/net/minecraft/server/PacketPlayOutChat.java
new file mode 100644
index 0000000..fdbdcc6
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PacketPlayOutChat.java
@@ -0,0 +1,53 @@
+package net.minecraft.server;
+
+import java.io.IOException;
+
+public class PacketPlayOutChat extends Packet {
+
+    private IChatBaseComponent a;
+    private boolean b;
+
+    public PacketPlayOutChat() {
+        this.b = true;
+    }
+
+    public PacketPlayOutChat(IChatBaseComponent ichatbasecomponent) {
+        this(ichatbasecomponent, true);
+    }
+
+    public PacketPlayOutChat(IChatBaseComponent ichatbasecomponent, boolean flag) {
+        this.b = true;
+        this.a = ichatbasecomponent;
+        this.b = flag;
+    }
+
+    public void a(PacketDataSerializer packetdataserializer) throws IOException {
+        this.a = ChatSerializer.a(packetdataserializer.c(32767));
+    }
+
+    public void b(PacketDataSerializer packetdataserializer) throws IOException {
+        packetdataserializer.a(ChatSerializer.a(this.a));
+        // Spigot start - protocol patch
+        if ( packetdataserializer.version >= 16 )
+        {
+            packetdataserializer.writeByte(0);
+        }
+        // Spigot end
+    }
+
+    public void a(PacketPlayOutListener packetplayoutlistener) {
+        packetplayoutlistener.a(this);
+    }
+
+    public String b() {
+        return String.format("message=\'%s\'", new Object[] { this.a});
+    }
+
+    public boolean d() {
+        return this.b;
+    }
+
+    public void handle(PacketListener packetlistener) {
+        this.a((PacketPlayOutListener) packetlistener);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PacketPlayOutCollect.java b/src/main/java/net/minecraft/server/PacketPlayOutCollect.java
new file mode 100644
index 0000000..8eff9e5
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PacketPlayOutCollect.java
@@ -0,0 +1,41 @@
+package net.minecraft.server;
+
+public class PacketPlayOutCollect extends Packet {
+
+    private int a;
+    private int b;
+
+    public PacketPlayOutCollect() {}
+
+    public PacketPlayOutCollect(int i, int j) {
+        this.a = i;
+        this.b = j;
+    }
+
+    public void a(PacketDataSerializer packetdataserializer) {
+        this.a = packetdataserializer.readInt();
+        this.b = packetdataserializer.readInt();
+    }
+
+    public void b(PacketDataSerializer packetdataserializer) {
+        // Spigot start - protocol patch
+        if ( packetdataserializer.version < 16 )
+        {
+            packetdataserializer.writeInt( this.a );
+            packetdataserializer.writeInt( this.b );
+        } else
+        {
+            packetdataserializer.b( this.a );
+            packetdataserializer.b( this.b );
+        }
+        // Spigot end
+    }
+
+    public void a(PacketPlayOutListener packetplayoutlistener) {
+        packetplayoutlistener.a(this);
+    }
+
+    public void handle(PacketListener packetlistener) {
+        this.a((PacketPlayOutListener) packetlistener);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PacketPlayOutCustomPayload.java b/src/main/java/net/minecraft/server/PacketPlayOutCustomPayload.java
new file mode 100644
index 0000000..e6d9165
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PacketPlayOutCustomPayload.java
@@ -0,0 +1,59 @@
+package net.minecraft.server;
+
+import net.minecraft.util.io.netty.buffer.ByteBuf;
+
+import java.io.IOException;
+
+public class PacketPlayOutCustomPayload extends Packet {
+
+    private String tag;
+    private byte[] data;
+
+    public PacketPlayOutCustomPayload() {}
+
+    public PacketPlayOutCustomPayload(String s, ByteBuf bytebuf) {
+        this(s, bytebuf.array());
+    }
+
+    public PacketPlayOutCustomPayload(String s, byte[] abyte) {
+        this.tag = s;
+        this.data = abyte;
+        if (abyte.length >= 1048576) {
+            throw new IllegalArgumentException("Payload may not be larger than 1048576 bytes");
+        }
+    }
+
+    public void a(PacketDataSerializer packetdataserializer) throws IOException {
+        this.tag = packetdataserializer.c(20);
+        this.data = new byte[packetdataserializer.readUnsignedShort()];
+        packetdataserializer.readBytes(this.data);
+    }
+
+    public void b(PacketDataSerializer packetdataserializer) throws IOException {
+        packetdataserializer.a(this.tag);
+        // Spigot start - protocol patch
+        if ( packetdataserializer.version < 29 )
+        {
+            packetdataserializer.writeShort( this.data.length );
+        }
+        if ( packetdataserializer.version >= 47 && tag.equals( "MC|Brand" ) )
+        {
+            packetdataserializer.a( new String( data, "UTF-8" ) );
+            return;
+        }
+        packetdataserializer.writeBytes(this.data);
+        if ( packetdataserializer.version >= 29 && tag.equals( "MC|AdvCdm" ) )
+        {
+            packetdataserializer.writeBoolean( true );
+        }
+        // Spigot end
+    }
+
+    public void a(PacketPlayOutListener packetplayoutlistener) {
+        packetplayoutlistener.a(this);
+    }
+
+    public void handle(PacketListener packetlistener) {
+        this.a((PacketPlayOutListener) packetlistener);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PacketPlayOutEntity.java b/src/main/java/net/minecraft/server/PacketPlayOutEntity.java
new file mode 100644
index 0000000..749b32d
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PacketPlayOutEntity.java
@@ -0,0 +1,50 @@
+package net.minecraft.server;
+
+public class PacketPlayOutEntity extends Packet {
+
+    protected int a;
+    protected byte b;
+    protected byte c;
+    protected byte d;
+    protected byte e;
+    protected byte f;
+    protected boolean g;
+
+    public PacketPlayOutEntity() {}
+
+    public PacketPlayOutEntity(int i) {
+        this.a = i;
+    }
+
+    public void a(PacketDataSerializer packetdataserializer) {
+        this.a = packetdataserializer.readInt();
+    }
+
+    public void b(PacketDataSerializer packetdataserializer) {
+        // Spigot start - protocol patch
+        if ( packetdataserializer.version < 16 )
+        {
+            packetdataserializer.writeInt( this.a );
+        } else
+        {
+            packetdataserializer.b( a );
+        }
+        // Spigot end
+    }
+
+    public void a(PacketPlayOutListener packetplayoutlistener) {
+        packetplayoutlistener.a(this);
+    }
+
+    public String b() {
+        return String.format("id=%d", new Object[] { Integer.valueOf(this.a)});
+    }
+
+    public String toString() {
+        return "Entity_" + super.toString();
+    }
+
+    public void handle(PacketListener packetlistener) {
+        this.a((PacketPlayOutListener) packetlistener);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PacketPlayOutEntityDestroy.java b/src/main/java/net/minecraft/server/PacketPlayOutEntityDestroy.java
new file mode 100644
index 0000000..bef5ae3
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PacketPlayOutEntityDestroy.java
@@ -0,0 +1,61 @@
+package net.minecraft.server;
+
+public class PacketPlayOutEntityDestroy extends Packet {
+
+    private int[] a;
+
+    public PacketPlayOutEntityDestroy() {}
+
+    public PacketPlayOutEntityDestroy(int... aint) {
+        this.a = aint;
+    }
+
+    public void a(PacketDataSerializer packetdataserializer) {
+        this.a = new int[packetdataserializer.readByte()];
+
+        for (int i = 0; i < this.a.length; ++i) {
+            this.a[i] = packetdataserializer.readInt();
+        }
+    }
+
+    public void b(PacketDataSerializer packetdataserializer) {
+        // Spigot start - protocol lib
+        if ( packetdataserializer.version < 16 )
+        {
+            packetdataserializer.writeByte( this.a.length );
+
+            for ( int i = 0; i < this.a.length; ++i )
+            {
+                packetdataserializer.writeInt( this.a[ i ] );
+            }
+        } else {
+            packetdataserializer.b( a.length );
+            for ( int i : a ) {
+                packetdataserializer.b( i );
+            }
+        }
+        // Spigot end
+    }
+
+    public void a(PacketPlayOutListener packetplayoutlistener) {
+        packetplayoutlistener.a(this);
+    }
+
+    public String b() {
+        StringBuilder stringbuilder = new StringBuilder();
+
+        for (int i = 0; i < this.a.length; ++i) {
+            if (i > 0) {
+                stringbuilder.append(", ");
+            }
+
+            stringbuilder.append(this.a[i]);
+        }
+
+        return String.format("entities=%d[%s]", new Object[] { Integer.valueOf(this.a.length), stringbuilder});
+    }
+
+    public void handle(PacketListener packetlistener) {
+        this.a((PacketPlayOutListener) packetlistener);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PacketPlayOutEntityEffect.java b/src/main/java/net/minecraft/server/PacketPlayOutEntityEffect.java
new file mode 100644
index 0000000..3693850
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PacketPlayOutEntityEffect.java
@@ -0,0 +1,56 @@
+package net.minecraft.server;
+
+public class PacketPlayOutEntityEffect extends Packet {
+
+    private int a;
+    private byte b;
+    private byte c;
+    private short d;
+
+    public PacketPlayOutEntityEffect() {}
+
+    public PacketPlayOutEntityEffect(int i, MobEffect mobeffect) {
+        this.a = i;
+        this.b = (byte) (mobeffect.getEffectId() & 255);
+        this.c = (byte) (mobeffect.getAmplifier() & 255);
+        if (mobeffect.getDuration() > 32767) {
+            this.d = 32767;
+        } else {
+            this.d = (short) mobeffect.getDuration();
+        }
+    }
+
+    public void a(PacketDataSerializer packetdataserializer) {
+        this.a = packetdataserializer.readInt();
+        this.b = packetdataserializer.readByte();
+        this.c = packetdataserializer.readByte();
+        this.d = packetdataserializer.readShort();
+    }
+
+    public void b(PacketDataSerializer packetdataserializer) {
+        // Spigot start - protocol patch
+        if ( packetdataserializer.version < 16 )
+        {
+            packetdataserializer.writeInt( this.a );
+            packetdataserializer.writeByte( this.b );
+            packetdataserializer.writeByte( this.c );
+            packetdataserializer.writeShort( this.d );
+        } else
+        {
+            packetdataserializer.b( a );
+            packetdataserializer.writeByte( b );
+            packetdataserializer.writeByte( c );
+            packetdataserializer.b( d );
+            packetdataserializer.writeBoolean( false );
+        }
+        // Spigot end
+    }
+
+    public void a(PacketPlayOutListener packetplayoutlistener) {
+        packetplayoutlistener.a(this);
+    }
+
+    public void handle(PacketListener packetlistener) {
+        this.a((PacketPlayOutListener) packetlistener);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PacketPlayOutEntityEquipment.java b/src/main/java/net/minecraft/server/PacketPlayOutEntityEquipment.java
new file mode 100644
index 0000000..1ca4f08
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PacketPlayOutEntityEquipment.java
@@ -0,0 +1,47 @@
+package net.minecraft.server;
+
+public class PacketPlayOutEntityEquipment extends Packet {
+
+    private int a;
+    private int b;
+    private ItemStack c;
+
+    public PacketPlayOutEntityEquipment() {}
+
+    public PacketPlayOutEntityEquipment(int i, int j, ItemStack itemstack) {
+        this.a = i;
+        this.b = j;
+        this.c = itemstack == null ? null : itemstack.cloneItemStack();
+    }
+
+    public void a(PacketDataSerializer packetdataserializer) {
+        this.a = packetdataserializer.readInt();
+        this.b = packetdataserializer.readShort();
+        this.c = packetdataserializer.c();
+    }
+
+    public void b(PacketDataSerializer packetdataserializer) {
+        // Spigot start - protocol patch
+        if ( packetdataserializer.version < 16 )
+        {
+            packetdataserializer.writeInt(this.a);
+        } else {
+            packetdataserializer.b( this.a );
+        }
+        // Spigot end
+        packetdataserializer.writeShort(this.b);
+        packetdataserializer.a(this.c);
+    }
+
+    public void a(PacketPlayOutListener packetplayoutlistener) {
+        packetplayoutlistener.a(this);
+    }
+
+    public String b() {
+        return String.format("entity=%d, slot=%d, item=%s", new Object[] { Integer.valueOf(this.a), Integer.valueOf(this.b), this.c});
+    }
+
+    public void handle(PacketListener packetlistener) {
+        this.a((PacketPlayOutListener) packetlistener);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PacketPlayOutEntityHeadRotation.java b/src/main/java/net/minecraft/server/PacketPlayOutEntityHeadRotation.java
new file mode 100644
index 0000000..2e4abe1
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PacketPlayOutEntityHeadRotation.java
@@ -0,0 +1,44 @@
+package net.minecraft.server;
+
+public class PacketPlayOutEntityHeadRotation extends Packet {
+
+    private int a;
+    private byte b;
+
+    public PacketPlayOutEntityHeadRotation() {}
+
+    public PacketPlayOutEntityHeadRotation(Entity entity, byte b0) {
+        this.a = entity.getId();
+        this.b = b0;
+    }
+
+    public void a(PacketDataSerializer packetdataserializer) {
+        this.a = packetdataserializer.readInt();
+        this.b = packetdataserializer.readByte();
+    }
+
+    public void b(PacketDataSerializer packetdataserializer) {
+        // Spigot start - protocol patch
+        if ( packetdataserializer.version < 16 )
+        {
+            packetdataserializer.writeInt( this.a );
+        } else
+        {
+            packetdataserializer.b( a );
+        }
+        // Spigot end
+        packetdataserializer.writeByte(this.b);
+    }
+
+    public void a(PacketPlayOutListener packetplayoutlistener) {
+        packetplayoutlistener.a(this);
+    }
+
+    public String b() {
+        return String.format("id=%d, rot=%d", new Object[] { Integer.valueOf(this.a), Byte.valueOf(this.b)});
+    }
+
+    public void handle(PacketListener packetlistener) {
+        this.a((PacketPlayOutListener) packetlistener);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PacketPlayOutEntityLook.java b/src/main/java/net/minecraft/server/PacketPlayOutEntityLook.java
new file mode 100644
index 0000000..617adb3
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PacketPlayOutEntityLook.java
@@ -0,0 +1,44 @@
+package net.minecraft.server;
+
+public class PacketPlayOutEntityLook extends PacketPlayOutEntity {
+
+    private boolean onGround; // Spigot - protocol patch
+
+    public PacketPlayOutEntityLook() {
+        this.g = true;
+    }
+
+    public PacketPlayOutEntityLook(int i, byte b0, byte b1, boolean onGround) { // Spigot - protocol patch
+        super(i);
+        this.e = b0;
+        this.f = b1;
+        this.g = true;
+        this.onGround = onGround; // Spigot - protocol patch
+    }
+
+    public void a(PacketDataSerializer packetdataserializer) {
+        super.a(packetdataserializer);
+        this.e = packetdataserializer.readByte();
+        this.f = packetdataserializer.readByte();
+    }
+
+    public void b(PacketDataSerializer packetdataserializer) {
+        super.b(packetdataserializer);
+        packetdataserializer.writeByte(this.e);
+        packetdataserializer.writeByte(this.f);
+        // Spigot start - protocol patch
+        if ( packetdataserializer.version >= 22 )
+        {
+            packetdataserializer.writeBoolean( onGround );
+        }
+        // Spigot end
+    }
+
+    public String b() {
+        return super.b() + String.format(", yRot=%d, xRot=%d", new Object[] { Byte.valueOf(this.e), Byte.valueOf(this.f)});
+    }
+
+    public void handle(PacketListener packetlistener) {
+        super.a((PacketPlayOutListener) packetlistener);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PacketPlayOutEntityMetadata.java b/src/main/java/net/minecraft/server/PacketPlayOutEntityMetadata.java
new file mode 100644
index 0000000..c937f59
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PacketPlayOutEntityMetadata.java
@@ -0,0 +1,46 @@
+package net.minecraft.server;
+
+import java.util.List;
+
+public class PacketPlayOutEntityMetadata extends Packet {
+
+    private int a;
+    private List b;
+
+    public PacketPlayOutEntityMetadata() {}
+
+    public PacketPlayOutEntityMetadata(int i, DataWatcher datawatcher, boolean flag) {
+        this.a = i;
+        if (flag) {
+            this.b = datawatcher.c();
+        } else {
+            this.b = datawatcher.b();
+        }
+    }
+
+    public void a(PacketDataSerializer packetdataserializer) {
+        this.a = packetdataserializer.readInt();
+        this.b = DataWatcher.b(packetdataserializer);
+    }
+
+    public void b(PacketDataSerializer packetdataserializer) {
+        // Spigot start - protocol patch
+        if ( packetdataserializer.version < 16 )
+        {
+            packetdataserializer.writeInt( this.a );
+        } else
+        {
+            packetdataserializer.b( a );
+        }
+        DataWatcher.a(this.b, packetdataserializer, packetdataserializer.version);
+        // Spigot end
+    }
+
+    public void a(PacketPlayOutListener packetplayoutlistener) {
+        packetplayoutlistener.a(this);
+    }
+
+    public void handle(PacketListener packetlistener) {
+        this.a((PacketPlayOutListener) packetlistener);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PacketPlayOutEntityTeleport.java b/src/main/java/net/minecraft/server/PacketPlayOutEntityTeleport.java
new file mode 100644
index 0000000..87260d5
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PacketPlayOutEntityTeleport.java
@@ -0,0 +1,73 @@
+package net.minecraft.server;
+
+public class PacketPlayOutEntityTeleport extends Packet {
+
+    private int a;
+    private int b;
+    private int c;
+    private int d;
+    private byte e;
+    private byte f;
+    private boolean onGround; // Spigot - protocol patch
+
+    public PacketPlayOutEntityTeleport() {}
+
+    public PacketPlayOutEntityTeleport(Entity entity) {
+        this.a = entity.getId();
+        this.b = MathHelper.floor(entity.locX * 32.0D);
+        this.c = MathHelper.floor(entity.locY * 32.0D);
+        this.d = MathHelper.floor(entity.locZ * 32.0D);
+        this.e = (byte) ((int) (entity.yaw * 256.0F / 360.0F));
+        this.f = (byte) ((int) (entity.pitch * 256.0F / 360.0F));
+    }
+
+    public PacketPlayOutEntityTeleport(int i, int j, int k, int l, byte b0, byte b1, boolean onGround) { // Spigot - protocol patch
+        this.a = i;
+        this.b = j;
+        this.c = k;
+        this.d = l;
+        this.e = b0;
+        this.f = b1;
+        this.onGround = onGround; // Spigot - protocol patch
+    }
+
+    public void a(PacketDataSerializer packetdataserializer) {
+        this.a = packetdataserializer.readInt();
+        this.b = packetdataserializer.readInt();
+        this.c = packetdataserializer.readInt();
+        this.d = packetdataserializer.readInt();
+        this.e = packetdataserializer.readByte();
+        this.f = packetdataserializer.readByte();
+    }
+
+    public void b(PacketDataSerializer packetdataserializer) {
+        // Spigot start - protocol
+        if ( packetdataserializer.version < 16 )
+        {
+            packetdataserializer.writeInt( this.a );
+        } else
+        {
+            packetdataserializer.b( a );
+        }
+        // Spigot end
+        packetdataserializer.writeInt(this.b);
+        packetdataserializer.writeInt(this.c);
+        packetdataserializer.writeInt(this.d);
+        packetdataserializer.writeByte(this.e);
+        packetdataserializer.writeByte(this.f);
+        // Spigot start - protocol patch
+        if ( packetdataserializer.version >= 22 )
+        {
+            packetdataserializer.writeBoolean( onGround );
+        }
+        // Spigot end
+    }
+
+    public void a(PacketPlayOutListener packetplayoutlistener) {
+        packetplayoutlistener.a(this);
+    }
+
+    public void handle(PacketListener packetlistener) {
+        this.a((PacketPlayOutListener) packetlistener);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PacketPlayOutEntityVelocity.java b/src/main/java/net/minecraft/server/PacketPlayOutEntityVelocity.java
new file mode 100644
index 0000000..170f27f
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PacketPlayOutEntityVelocity.java
@@ -0,0 +1,82 @@
+package net.minecraft.server;
+
+public class PacketPlayOutEntityVelocity extends Packet {
+
+    private int a;
+    private int b;
+    private int c;
+    private int d;
+
+    public PacketPlayOutEntityVelocity() {}
+
+    public PacketPlayOutEntityVelocity(Entity entity) {
+        this(entity.getId(), entity.motX, entity.motY, entity.motZ);
+    }
+
+    public PacketPlayOutEntityVelocity(int i, double d0, double d1, double d2) {
+        this.a = i;
+        double d3 = 3.9D;
+
+        if (d0 < -d3) {
+            d0 = -d3;
+        }
+
+        if (d1 < -d3) {
+            d1 = -d3;
+        }
+
+        if (d2 < -d3) {
+            d2 = -d3;
+        }
+
+        if (d0 > d3) {
+            d0 = d3;
+        }
+
+        if (d1 > d3) {
+            d1 = d3;
+        }
+
+        if (d2 > d3) {
+            d2 = d3;
+        }
+
+        this.b = (int) (d0 * 8000.0D);
+        this.c = (int) (d1 * 8000.0D);
+        this.d = (int) (d2 * 8000.0D);
+    }
+
+    public void a(PacketDataSerializer packetdataserializer) {
+        this.a = packetdataserializer.readInt();
+        this.b = packetdataserializer.readShort();
+        this.c = packetdataserializer.readShort();
+        this.d = packetdataserializer.readShort();
+    }
+
+    public void b(PacketDataSerializer packetdataserializer) {
+        // Spigot start - protocol patch
+        if ( packetdataserializer.version < 16 )
+        {
+            packetdataserializer.writeInt( this.a );
+        } else
+        {
+            packetdataserializer.b( a );
+        }
+        // Spigot end
+        packetdataserializer.writeShort(this.b);
+        packetdataserializer.writeShort(this.c);
+        packetdataserializer.writeShort(this.d);
+    }
+
+    public void a(PacketPlayOutListener packetplayoutlistener) {
+        packetplayoutlistener.a(this);
+    }
+
+    public String b() {
+        return String.format("id=%d, x=%.2f, y=%.2f, z=%.2f", new Object[] { Integer.valueOf(this.a), Float.valueOf((float) this.b / 8000.0F), Float.valueOf((float) this.c / 8000.0F), Float.valueOf((float) this.d / 8000.0F)});
+    }
+
+    public void handle(PacketListener packetlistener) {
+        this.a((PacketPlayOutListener) packetlistener);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PacketPlayOutExperience.java b/src/main/java/net/minecraft/server/PacketPlayOutExperience.java
new file mode 100644
index 0000000..35788b2
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PacketPlayOutExperience.java
@@ -0,0 +1,45 @@
+package net.minecraft.server;
+
+public class PacketPlayOutExperience extends Packet {
+
+    private float a;
+    private int b;
+    private int c;
+
+    public PacketPlayOutExperience() {}
+
+    public PacketPlayOutExperience(float f, int i, int j) {
+        this.a = f;
+        this.b = i;
+        this.c = j;
+    }
+
+    public void a(PacketDataSerializer packetdataserializer) {
+        this.a = packetdataserializer.readFloat();
+        this.c = packetdataserializer.readShort();
+        this.b = packetdataserializer.readShort();
+    }
+
+    public void b(PacketDataSerializer packetdataserializer) {
+        packetdataserializer.writeFloat(this.a);
+        // Spigot start - protocol patch
+        if ( packetdataserializer.version < 16 )
+        {
+            packetdataserializer.writeShort( this.c );
+            packetdataserializer.writeShort( this.b );
+        } else
+        {
+            packetdataserializer.b( c );
+            packetdataserializer.b( b );
+        }
+        // Spigot end
+    }
+
+    public void a(PacketPlayOutListener packetplayoutlistener) {
+        packetplayoutlistener.a(this);
+    }
+
+    public void handle(PacketListener packetlistener) {
+        this.a((PacketPlayOutListener) packetlistener);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PacketPlayOutKeepAlive.java b/src/main/java/net/minecraft/server/PacketPlayOutKeepAlive.java
new file mode 100644
index 0000000..e9ff5ee
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PacketPlayOutKeepAlive.java
@@ -0,0 +1,40 @@
+package net.minecraft.server;
+
+public class PacketPlayOutKeepAlive extends Packet {
+
+    private int a;
+
+    public PacketPlayOutKeepAlive() {}
+
+    public PacketPlayOutKeepAlive(int i) {
+        this.a = i;
+    }
+
+    public void a(PacketPlayOutListener packetplayoutlistener) {
+        packetplayoutlistener.a(this);
+    }
+
+    public void a(PacketDataSerializer packetdataserializer) {
+        this.a = packetdataserializer.readInt();
+    }
+
+    public void b(PacketDataSerializer packetdataserializer) {
+        // Spigot start
+        if ( packetdataserializer.version >= 32 )
+        {
+            packetdataserializer.b( this.a );
+        } else
+        {
+            packetdataserializer.writeInt( this.a );
+        }
+        // Spigot end
+    }
+
+    public boolean a() {
+        return true;
+    }
+
+    public void handle(PacketListener packetlistener) {
+        this.a((PacketPlayOutListener) packetlistener);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PacketPlayOutLogin.java b/src/main/java/net/minecraft/server/PacketPlayOutLogin.java
new file mode 100644
index 0000000..9ebf9b5
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PacketPlayOutLogin.java
@@ -0,0 +1,77 @@
+package net.minecraft.server;
+
+import java.io.IOException;
+
+public class PacketPlayOutLogin extends Packet {
+
+    private int a;
+    private boolean b;
+    private EnumGamemode c;
+    private int d;
+    private EnumDifficulty e;
+    private int f;
+    private WorldType g;
+
+    public PacketPlayOutLogin() {}
+
+    public PacketPlayOutLogin(int i, EnumGamemode enumgamemode, boolean flag, int j, EnumDifficulty enumdifficulty, int k, WorldType worldtype) {
+        this.a = i;
+        this.d = j;
+        this.e = enumdifficulty;
+        this.c = enumgamemode;
+        this.f = k;
+        this.b = flag;
+        this.g = worldtype;
+    }
+
+    public void a(PacketDataSerializer packetdataserializer) throws IOException {
+        this.a = packetdataserializer.readInt();
+        short short1 = packetdataserializer.readUnsignedByte();
+
+        this.b = (short1 & 8) == 8;
+        int i = short1 & -9;
+
+        this.c = EnumGamemode.getById(i);
+        this.d = packetdataserializer.readByte();
+        this.e = EnumDifficulty.getById(packetdataserializer.readUnsignedByte());
+        this.f = packetdataserializer.readUnsignedByte();
+        this.g = WorldType.getType(packetdataserializer.c(16));
+        if (this.g == null) {
+            this.g = WorldType.NORMAL;
+        }
+    }
+
+    public void b(PacketDataSerializer packetdataserializer) throws IOException {
+        packetdataserializer.writeInt(this.a);
+        int i = this.c.getId();
+
+        if (this.b) {
+            i |= 8;
+        }
+
+        packetdataserializer.writeByte(i);
+        packetdataserializer.writeByte(this.d);
+        packetdataserializer.writeByte(this.e.a());
+        packetdataserializer.writeByte(this.f);
+        packetdataserializer.a(this.g.name());
+
+        // Spigot start - protocol patch
+        if ( packetdataserializer.version >= 29 )
+        {
+            packetdataserializer.writeBoolean( false );
+        }
+        // Spigot end
+    }
+
+    public void a(PacketPlayOutListener packetplayoutlistener) {
+        packetplayoutlistener.a(this);
+    }
+
+    public String b() {
+        return String.format("eid=%d, gameType=%d, hardcore=%b, dimension=%d, difficulty=%s, maxplayers=%d", new Object[] { Integer.valueOf(this.a), Integer.valueOf(this.c.getId()), Boolean.valueOf(this.b), Integer.valueOf(this.d), this.e, Integer.valueOf(this.f)});
+    }
+
+    public void handle(PacketListener packetlistener) {
+        this.a((PacketPlayOutListener) packetlistener);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PacketPlayOutMap.java b/src/main/java/net/minecraft/server/PacketPlayOutMap.java
new file mode 100644
index 0000000..b45a9ce
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PacketPlayOutMap.java
@@ -0,0 +1,71 @@
+package net.minecraft.server;
+
+import java.util.Arrays;
+
+public class PacketPlayOutMap extends Packet {
+
+    private int a;
+    private byte[] b;
+    private byte scale; // Spigot - protocol patch
+
+    public PacketPlayOutMap() {}
+
+    // Spigot start - protocol patch
+    public PacketPlayOutMap(int i, byte[] abyte, byte scale) {
+        this.scale = scale;
+    // Spigot end
+        this.a = i;
+        this.b = abyte;
+    }
+
+    public void a(PacketDataSerializer packetdataserializer) {
+        this.a = packetdataserializer.a();
+        this.b = new byte[packetdataserializer.readUnsignedShort()];
+        packetdataserializer.readBytes(this.b);
+    }
+
+    public void b(PacketDataSerializer packetdataserializer) {
+        packetdataserializer.b(this.a);
+        if ( packetdataserializer.version < 27 )
+        {
+            packetdataserializer.writeShort( this.b.length );
+            packetdataserializer.writeBytes( this.b );
+        } else {
+            packetdataserializer.writeByte( scale );
+            if (b[0] == 1) {
+                int count = (b.length - 1) / 3;
+                packetdataserializer.b( count );
+                for (int i = 0; i < count; i++) {
+                    packetdataserializer.writeByte( b[1 + i * 3] );
+                    packetdataserializer.writeByte( b[2 + i * 3] );
+                    packetdataserializer.writeByte( b[3 + i * 3] );
+                }
+            } else {
+                packetdataserializer.b( 0 );
+            }
+
+            if (b[0] == 0) {
+                packetdataserializer.writeByte( 1 );
+                int rows = (b.length - 3);
+                packetdataserializer.writeByte( rows );
+                packetdataserializer.writeByte( b[1] );
+                packetdataserializer.writeByte( b[2] );
+                a( packetdataserializer, Arrays.copyOfRange(b, 3, b.length) );
+            } else {
+                packetdataserializer.writeByte( 0 );
+            }
+        }
+    }
+
+    public void a(PacketPlayOutListener packetplayoutlistener) {
+        packetplayoutlistener.a(this);
+    }
+
+    public String b() {
+        return String.format("id=%d, length=%d", new Object[] { Integer.valueOf(this.a), Integer.valueOf(this.b.length)});
+    }
+
+    public void handle(PacketListener packetlistener) {
+        this.a((PacketPlayOutListener) packetlistener);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PacketPlayOutMapChunk.java b/src/main/java/net/minecraft/server/PacketPlayOutMapChunk.java
new file mode 100644
index 0000000..fcd126b
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PacketPlayOutMapChunk.java
@@ -0,0 +1,245 @@
+package net.minecraft.server;
+
+import java.io.IOException;
+import java.util.zip.DataFormatException;
+import java.util.zip.Deflater;
+import java.util.zip.Inflater;
+
+public class PacketPlayOutMapChunk extends Packet {
+
+    private int a;
+    private int b;
+    private int c;
+    private int d;
+    private byte[] e;
+    private byte[] f;
+    private boolean g;
+    private int h;
+    private static byte[] i = new byte[196864];
+
+    private Chunk chunk; // Spigot
+    private int mask; // Spigot
+
+    public PacketPlayOutMapChunk() {}
+
+    // Spigot start - protocol patch
+    public PacketPlayOutMapChunk(Chunk chunk, boolean flag, int i, int version) {
+        this.chunk = chunk;
+        this.mask = i;
+        this.a = chunk.locX;
+        this.b = chunk.locZ;
+        this.g = flag;
+        ChunkMap chunkmap = a(chunk, flag, i, version);
+
+        this.d = chunkmap.c;
+        this.c = chunkmap.b;
+
+        this.f = chunkmap.a;
+    }
+
+    public static int c() {
+        return 196864;
+    }
+
+    public void a(PacketDataSerializer packetdataserializer) throws IOException {
+        this.a = packetdataserializer.readInt();
+        this.b = packetdataserializer.readInt();
+        this.g = packetdataserializer.readBoolean();
+        this.c = packetdataserializer.readShort();
+        this.d = packetdataserializer.readShort();
+        this.h = packetdataserializer.readInt();
+        if (i.length < this.h) {
+            i = new byte[this.h];
+        }
+
+        packetdataserializer.readBytes(i, 0, this.h);
+        int i = 0;
+
+        int j;
+
+        for (j = 0; j < 16; ++j) {
+            i += this.c >> j & 1;
+        }
+
+        j = 12288 * i;
+        if (this.g) {
+            j += 256;
+        }
+
+        this.f = new byte[j];
+        Inflater inflater = new Inflater();
+
+        inflater.setInput(PacketPlayOutMapChunk.i, 0, this.h);
+
+        try {
+            inflater.inflate(this.f);
+        } catch (DataFormatException dataformatexception) {
+            throw new IOException("Bad compressed data format");
+        } finally {
+            inflater.end();
+        }
+    }
+
+    public void b(PacketDataSerializer packetdataserializer) {
+        packetdataserializer.writeInt(this.a);
+        packetdataserializer.writeInt(this.b);
+        packetdataserializer.writeBoolean(this.g);
+        packetdataserializer.writeShort((short) (this.c & '\uffff'));
+        // Spigot start - protocol patch
+        if ( packetdataserializer.version < 27 )
+        {
+            chunk.world.spigotConfig.antiXrayInstance.obfuscate(chunk.locX, chunk.locZ, mask, this.f, chunk.world, false); // Spigot
+            Deflater deflater = new Deflater(4); // Spigot
+            try {
+                deflater.setInput(this.f, 0, this.f.length);
+                deflater.finish();
+                this.e = new byte[this.f.length];
+                this.h = deflater.deflate(this.e);
+            } finally {
+                deflater.end();
+            }
+            packetdataserializer.writeShort( (short) ( this.d & '\uffff' ) );
+            packetdataserializer.writeInt( this.h );
+            packetdataserializer.writeBytes( this.e, 0, this.h );
+        } else
+        {
+            chunk.world.spigotConfig.antiXrayInstance.obfuscate(chunk.locX, chunk.locZ, mask, this.f, chunk.world, true); // Spigot
+            a( packetdataserializer, this.f );
+        }
+        // Spigot end - protocol patch
+    }
+
+    public void a(PacketPlayOutListener packetplayoutlistener) {
+        packetplayoutlistener.a(this);
+    }
+
+    public String b() {
+        return String.format("x=%d, z=%d, full=%b, sects=%d, add=%d, size=%d", new Object[] { Integer.valueOf(this.a), Integer.valueOf(this.b), Boolean.valueOf(this.g), Integer.valueOf(this.c), Integer.valueOf(this.d), Integer.valueOf(this.h)});
+    }
+
+    // Spigot start - protocol patch
+    public static ChunkMap a(Chunk chunk, boolean flag, int i, int version) {
+        int j = 0;
+        ChunkSection[] achunksection = chunk.getSections();
+        int k = 0;
+        ChunkMap chunkmap = new ChunkMap();
+        byte[] abyte = PacketPlayOutMapChunk.i;
+
+        if (flag) {
+            chunk.q = true;
+        }
+
+        int l;
+
+        for (l = 0; l < achunksection.length; ++l) {
+            if (achunksection[l] != null && (!flag || !achunksection[l].isEmpty()) && (i & 1 << l) != 0) {
+                chunkmap.b |= 1 << l;
+                if (achunksection[l].getExtendedIdArray() != null) {
+                    chunkmap.c |= 1 << l;
+                    ++k;
+                }
+            }
+        }
+
+        if ( version < 24 )
+        {
+            for ( l = 0; l < achunksection.length; ++l )
+            {
+                if ( achunksection[ l ] != null && ( !flag || !achunksection[ l ].isEmpty() ) && ( i & 1 << l ) != 0 )
+                {
+                    byte[] abyte1 = achunksection[ l ].getIdArray();
+
+                    System.arraycopy( abyte1, 0, abyte, j, abyte1.length );
+                    j += abyte1.length;
+                }
+            }
+        } else {
+            for ( l = 0; l < achunksection.length; ++l )
+            {
+                if ( achunksection[ l ] != null && ( !flag || !achunksection[ l ].isEmpty() ) && ( i & 1 << l ) != 0 )
+                {
+                    byte[] abyte1 = achunksection[ l ].getIdArray();
+                    NibbleArray nibblearray = achunksection[ l ].getDataArray();
+                    for ( int ind = 0; ind < abyte1.length; ind++ )
+                    {
+                        int id = abyte1[ ind ] & 0xFF;
+                        int px = ind & 0xF;
+                        int py = ( ind >> 8 ) & 0xF;
+                        int pz = ( ind >> 4 ) & 0xF;
+                        int data = nibblearray.a( px, py, pz );
+                        if ( id == 90 && data == 0 )
+                        {
+                            Blocks.PORTAL.updateShape( chunk.world, ( chunk.locX << 4 ) + px, ( l << 4 ) + py, ( chunk.locZ << 4 ) + pz );
+                        } else
+                        {
+                            data = org.spigotmc.SpigotDebreakifier.getCorrectedData( id, data );
+                        }
+                        char val = (char) ( id << 4 | data );
+                        abyte[ j++ ] = (byte) ( val & 0xFF );
+                        abyte[ j++ ] = (byte) ( ( val >> 8 ) & 0xFF );
+                    }
+                }
+            }
+        }
+
+        NibbleArray nibblearray;
+
+        if ( version < 24 )
+        {
+            for ( l = 0; l < achunksection.length; ++l )
+            {
+                if ( achunksection[ l ] != null && ( !flag || !achunksection[ l ].isEmpty() ) && ( i & 1 << l ) != 0 )
+                {
+                    nibblearray = achunksection[ l ].getDataArray();
+                    System.arraycopy(nibblearray.a, 0, abyte, j, nibblearray.a.length);
+                    j += nibblearray.a.length;
+                }
+            }
+        }
+
+        for (l = 0; l < achunksection.length; ++l) {
+            if (achunksection[l] != null && (!flag || !achunksection[l].isEmpty()) && (i & 1 << l) != 0) {
+                nibblearray = achunksection[l].getEmittedLightArray();
+                System.arraycopy(nibblearray.a, 0, abyte, j, nibblearray.a.length);
+                j += nibblearray.a.length;
+            }
+        }
+
+        if (!chunk.world.worldProvider.g) {
+            for (l = 0; l < achunksection.length; ++l) {
+                if (achunksection[l] != null && (!flag || !achunksection[l].isEmpty()) && (i & 1 << l) != 0) {
+                    nibblearray = achunksection[l].getSkyLightArray();
+                    System.arraycopy(nibblearray.a, 0, abyte, j, nibblearray.a.length);
+                    j += nibblearray.a.length;
+                }
+            }
+        }
+
+        if (k > 0 && version < 24) {
+            for (l = 0; l < achunksection.length; ++l) {
+                if (achunksection[l] != null && (!flag || !achunksection[l].isEmpty()) && achunksection[l].getExtendedIdArray() != null && (i & 1 << l) != 0) {
+                    nibblearray = achunksection[l].getExtendedIdArray();
+                    System.arraycopy(nibblearray.a, 0, abyte, j, nibblearray.a.length);
+                    j += nibblearray.a.length;
+                }
+            }
+        }
+
+        if (flag) {
+            byte[] abyte2 = chunk.m();
+
+            System.arraycopy(abyte2, 0, abyte, j, abyte2.length);
+            j += abyte2.length;
+        }
+
+        chunkmap.a = new byte[j];
+        System.arraycopy(abyte, 0, chunkmap.a, 0, j);
+        return chunkmap;
+    }
+    // Spigot end - protocol patch
+
+    @Override
+    public void handle(PacketListener packetlistener) {
+        this.a((PacketPlayOutListener) packetlistener);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PacketPlayOutMapChunkBulk.java b/src/main/java/net/minecraft/server/PacketPlayOutMapChunkBulk.java
index 3eac231..b9db43c 100644
--- a/src/main/java/net/minecraft/server/PacketPlayOutMapChunkBulk.java
+++ b/src/main/java/net/minecraft/server/PacketPlayOutMapChunkBulk.java
@@ -22,14 +22,15 @@ public class PacketPlayOutMapChunkBulk extends Packet {
         @Override
         protected Deflater initialValue() {
             // Don't use higher compression level, slows things down too much
-            return new Deflater(6);
+            return new Deflater(4); // Spigot 6 -> 4
         }
     };
     // CraftBukkit end
+    private World world; // Spigot
 
     public PacketPlayOutMapChunkBulk() {}
 
-    public PacketPlayOutMapChunkBulk(List list) {
+    public PacketPlayOutMapChunkBulk(List list, int version) {
         int i = list.size();
 
         this.a = new int[i];
@@ -42,8 +43,11 @@ public class PacketPlayOutMapChunkBulk extends Packet {
 
         for (int k = 0; k < i; ++k) {
             Chunk chunk = (Chunk) list.get(k);
-            ChunkMap chunkmap = PacketPlayOutMapChunk.a(chunk, true, '\uffff');
+            ChunkMap chunkmap = PacketPlayOutMapChunk.a(chunk, true, '\uffff', version);
 
+            // Spigot start
+            world = chunk.world;
+            /*
             if (buildBuffer.length < j + chunkmap.a.length) {
                 byte[] abyte = new byte[j + chunkmap.a.length];
 
@@ -52,6 +56,8 @@ public class PacketPlayOutMapChunkBulk extends Packet {
             }
 
             System.arraycopy(chunkmap.a, 0, buildBuffer, j, chunkmap.a.length);
+            */
+            // Spigot end
             j += chunkmap.a.length;
             this.a[k] = chunk.locX;
             this.b[k] = chunk.locZ;
@@ -79,6 +85,22 @@ public class PacketPlayOutMapChunkBulk extends Packet {
         if (this.buffer != null) {
             return;
         }
+        // Spigot start
+        int finalBufferSize = 0;
+        // Obfuscate all sections
+        for (int i = 0; i < a.length; i++) {
+            world.spigotConfig.antiXrayInstance.obfuscate(a[i], b[i], c[i], inflatedBuffers[i], world, false);
+            finalBufferSize += inflatedBuffers[i].length;
+        }
+
+        // Now it's time to efficiently copy the chunk to the build buffer
+        buildBuffer = new byte[finalBufferSize];
+        int bufferLocation = 0;
+        for (int i = 0; i < a.length; i++) {
+            System.arraycopy(inflatedBuffers[i], 0, buildBuffer, bufferLocation, inflatedBuffers[i].length);
+            bufferLocation += inflatedBuffers[i].length;
+        }
+        // Spigot end
 
         Deflater deflater = localDeflater.get();
         deflater.reset();
@@ -152,17 +174,34 @@ public class PacketPlayOutMapChunkBulk extends Packet {
     }
 
     public void b(PacketDataSerializer packetdataserializer) throws IOException { // CraftBukkit - throws IOException
-        compress(); // CraftBukkit
-        packetdataserializer.writeShort(this.a.length);
-        packetdataserializer.writeInt(this.size);
-        packetdataserializer.writeBoolean(this.h);
-        packetdataserializer.writeBytes(this.buffer, 0, this.size);
-
-        for (int i = 0; i < this.a.length; ++i) {
-            packetdataserializer.writeInt(this.a[i]);
-            packetdataserializer.writeInt(this.b[i]);
-            packetdataserializer.writeShort((short) (this.c[i] & '\uffff'));
-            packetdataserializer.writeShort((short) (this.d[i] & '\uffff'));
+        if ( packetdataserializer.version < 27 )
+        {
+            compress(); // CraftBukkit
+            packetdataserializer.writeShort( this.a.length );
+            packetdataserializer.writeInt( this.size );
+            packetdataserializer.writeBoolean( this.h );
+            packetdataserializer.writeBytes( this.buffer, 0, this.size );
+
+            for (int i = 0; i < this.a.length; ++i) {
+                packetdataserializer.writeInt(this.a[i]);
+                packetdataserializer.writeInt(this.b[i]);
+                packetdataserializer.writeShort((short) (this.c[i] & '\uffff'));
+                packetdataserializer.writeShort( (short) ( this.d[i] & '\uffff' ) );
+            }
+        } else
+        {
+            packetdataserializer.writeBoolean( this.h );
+            packetdataserializer.b( this.a.length );
+
+            for (int i = 0; i < this.a.length; ++i) {
+                packetdataserializer.writeInt(this.a[i]);
+                packetdataserializer.writeInt(this.b[i]);
+                packetdataserializer.writeShort((short) (this.c[i] & '\uffff'));
+            }
+            for (int i = 0; i < this.a.length; ++i) {
+                world.spigotConfig.antiXrayInstance.obfuscate(a[i], b[i], c[i], inflatedBuffers[i], world, true);
+                packetdataserializer.writeBytes( inflatedBuffers[i] );
+            }
         }
     }
 
diff --git a/src/main/java/net/minecraft/server/PacketPlayOutMultiBlockChange.java b/src/main/java/net/minecraft/server/PacketPlayOutMultiBlockChange.java
new file mode 100644
index 0000000..1e86a8f
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PacketPlayOutMultiBlockChange.java
@@ -0,0 +1,115 @@
+package net.minecraft.server;
+
+import java.io.ByteArrayOutputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+public class PacketPlayOutMultiBlockChange extends Packet {
+
+    private static final Logger a = LogManager.getLogger();
+    private ChunkCoordIntPair b;
+    private byte[] c;
+    private int d;
+    // Spigot start - protocol patch
+    private short[] ashort;
+    private int[] blocks;
+    private Chunk chunk;
+    // Spigot end
+
+    public PacketPlayOutMultiBlockChange() {}
+
+    public PacketPlayOutMultiBlockChange(int i, short[] ashort, Chunk chunk) {
+        // Spigot start
+        this.ashort = ashort;
+        this.chunk = chunk;
+        // Spigot end
+        this.b = new ChunkCoordIntPair(chunk.locX, chunk.locZ);
+        this.d = i;
+        int j = 4 * i;
+
+        try
+        {
+            ByteArrayOutputStream bytearrayoutputstream = new ByteArrayOutputStream( j );
+            DataOutputStream dataoutputstream = new DataOutputStream( bytearrayoutputstream );
+
+            // Spigot start
+            blocks = new int[i];
+            for (int k = 0; k < i; ++k) {
+                int l = ashort[k] >> 12 & 15;
+                int i1 = ashort[k] >> 8 & 15;
+                int j1 = ashort[k] & 255;
+
+                dataoutputstream.writeShort(ashort[k]);
+                int blockId = Block.getId( chunk.getType( l, j1, i1 ) );
+                int data = chunk.getData( l, j1, i1 );
+                data = org.spigotmc.SpigotDebreakifier.getCorrectedData( blockId, data );
+                int id = ( blockId & 4095 ) << 4 | data & 15;
+                dataoutputstream.writeShort((short) id);
+                blocks[k] = id;
+            }
+            // Spigot end
+
+            this.c = bytearrayoutputstream.toByteArray();
+            if (this.c.length != j) {
+                throw new RuntimeException("Expected length " + j + " doesn\'t match received length " + this.c.length);
+            }
+        } catch (IOException ioexception) {
+            a.error("Couldn\'t create bulk block update packet", ioexception);
+            this.c = null;
+        }
+    }
+
+    public void a(PacketDataSerializer packetdataserializer) {
+        this.b = new ChunkCoordIntPair(packetdataserializer.readInt(), packetdataserializer.readInt());
+        this.d = packetdataserializer.readShort() & '\uffff';
+        int i = packetdataserializer.readInt();
+
+        if (i > 0) {
+            this.c = new byte[i];
+            packetdataserializer.readBytes(this.c);
+        }
+    }
+
+    public void b(PacketDataSerializer packetdataserializer) {
+        // Spigot start - protocol patch
+        if (packetdataserializer.version < 25)
+        {
+            packetdataserializer.writeInt( this.b.x );
+            packetdataserializer.writeInt( this.b.z );
+            packetdataserializer.writeShort( (short) this.d );
+            if ( this.c != null )
+            {
+                packetdataserializer.writeInt( this.c.length );
+                packetdataserializer.writeBytes( this.c );
+            } else
+            {
+                packetdataserializer.writeInt( 0 );
+            }
+        } else {
+            packetdataserializer.writeInt( this.b.x );
+            packetdataserializer.writeInt( this.b.z );
+            packetdataserializer.b( this.d );
+            for ( int i = 0; i < d; i++ )
+            {
+                packetdataserializer.writeShort( ashort[ i ] );
+                packetdataserializer.b( blocks[ i ] );
+            }
+        }
+        // Spigot end
+    }
+
+    public void a(PacketPlayOutListener packetplayoutlistener) {
+        packetplayoutlistener.a(this);
+    }
+
+    public String b() {
+        return String.format("xc=%d, zc=%d, count=%d", new Object[] { Integer.valueOf(this.b.x), Integer.valueOf(this.b.z), Integer.valueOf(this.d)});
+    }
+
+    public void handle(PacketListener packetlistener) {
+        this.a((PacketPlayOutListener) packetlistener);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PacketPlayOutNamedEntitySpawn.java b/src/main/java/net/minecraft/server/PacketPlayOutNamedEntitySpawn.java
index 0023f18..80857c9 100644
--- a/src/main/java/net/minecraft/server/PacketPlayOutNamedEntitySpawn.java
+++ b/src/main/java/net/minecraft/server/PacketPlayOutNamedEntitySpawn.java
@@ -64,10 +64,13 @@ public class PacketPlayOutNamedEntitySpawn extends Packet {
 
     public void b(PacketDataSerializer packetdataserializer) throws IOException { // CraftBukkit - added throws
         packetdataserializer.b(this.a);
-        UUID uuid = this.b.getId();
 
-        packetdataserializer.a(uuid == null ? "" : uuid.toString());
+        UUID uuid = this.b.getId();
+        // Spigot start - protocol patch
+        if (packetdataserializer.version < 20) {
+        packetdataserializer.a( uuid == null ? "" : ( ( packetdataserializer.version >= 5 ) ? uuid.toString() : uuid.toString().replaceAll( "-", "" ) ) ); // Spigot
         packetdataserializer.a(this.b.getName().length() > 16 ? this.b.getName().substring(0, 16) : this.b.getName()); // CraftBukkit - Limit name length to 16 characters
+        if (packetdataserializer.version >= 5 ) { // Spigot
         packetdataserializer.b(this.b.getProperties().size());
         Iterator iterator = this.b.getProperties().values().iterator();
 
@@ -78,13 +81,26 @@ public class PacketPlayOutNamedEntitySpawn extends Packet {
             packetdataserializer.a(property.getValue());
             packetdataserializer.a(property.getSignature());
         }
+        }
+        } else
+        {
+            packetdataserializer.writeUUID( uuid );
+        }
+        // Spigot end
 
         packetdataserializer.writeInt(this.c);
         packetdataserializer.writeInt(this.d);
         packetdataserializer.writeInt(this.e);
         packetdataserializer.writeByte(this.f);
         packetdataserializer.writeByte(this.g);
-        packetdataserializer.writeShort(this.h);
+        // Spigot start - protocol patch
+        if ( packetdataserializer.version >= 47 )
+        {
+            packetdataserializer.writeShort( org.spigotmc.SpigotDebreakifier.getItemId( this.h ) );
+        } else
+        {
+            packetdataserializer.writeShort( this.h );
+        }
         this.i.a(packetdataserializer);
     }
 
diff --git a/src/main/java/net/minecraft/server/PacketPlayOutOpenSignEditor.java b/src/main/java/net/minecraft/server/PacketPlayOutOpenSignEditor.java
new file mode 100644
index 0000000..052da02
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PacketPlayOutOpenSignEditor.java
@@ -0,0 +1,44 @@
+package net.minecraft.server;
+
+public class PacketPlayOutOpenSignEditor extends Packet {
+
+    private int a;
+    private int b;
+    private int c;
+
+    public PacketPlayOutOpenSignEditor() {}
+
+    public PacketPlayOutOpenSignEditor(int i, int j, int k) {
+        this.a = i;
+        this.b = j;
+        this.c = k;
+    }
+
+    public void a(PacketPlayOutListener packetplayoutlistener) {
+        packetplayoutlistener.a(this);
+    }
+
+    public void a(PacketDataSerializer packetdataserializer) {
+        this.a = packetdataserializer.readInt();
+        this.b = packetdataserializer.readInt();
+        this.c = packetdataserializer.readInt();
+    }
+
+    public void b(PacketDataSerializer packetdataserializer) {
+        // Spigot start - protocol patch
+        if ( packetdataserializer.version < 16 )
+        {
+            packetdataserializer.writeInt( this.a );
+            packetdataserializer.writeInt( this.b );
+            packetdataserializer.writeInt( this.c );
+        } else
+        {
+            packetdataserializer.writePosition( a, b, c );
+        }
+        // Spigot end
+    }
+
+    public void handle(PacketListener packetlistener) {
+        this.a((PacketPlayOutListener) packetlistener);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PacketPlayOutOpenWindow.java b/src/main/java/net/minecraft/server/PacketPlayOutOpenWindow.java
new file mode 100644
index 0000000..8e9ea33
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PacketPlayOutOpenWindow.java
@@ -0,0 +1,114 @@
+package net.minecraft.server;
+
+import org.bukkit.craftbukkit.util.CraftChatMessage;
+
+import java.io.IOException;
+
+public class PacketPlayOutOpenWindow extends Packet {
+
+    private int a;
+    private int b;
+    private String c;
+    private int d;
+    private boolean e;
+    private int f;
+
+    public PacketPlayOutOpenWindow() {}
+
+    public PacketPlayOutOpenWindow(int i, int j, String s, int k, boolean flag) {
+        if (s.length() > 32) s = s.substring( 0, 32 ); // Spigot - Cap window name to prevent client disconnects
+        this.a = i;
+        this.b = j;
+        this.c = s;
+        this.d = k;
+        this.e = flag;
+    }
+
+    public PacketPlayOutOpenWindow(int i, int j, String s, int k, boolean flag, int l) {
+        this(i, j, s, k, flag);
+        this.f = l;
+    }
+
+    public void a(PacketPlayOutListener packetplayoutlistener) {
+        packetplayoutlistener.a(this);
+    }
+
+    public void a(PacketDataSerializer packetdataserializer) throws IOException {
+        this.a = packetdataserializer.readUnsignedByte();
+        this.b = packetdataserializer.readUnsignedByte();
+        this.c = packetdataserializer.c(32);
+        this.d = packetdataserializer.readUnsignedByte();
+        this.e = packetdataserializer.readBoolean();
+        if (this.b == 11) {
+            this.f = packetdataserializer.readInt();
+        }
+    }
+
+    public void b(PacketDataSerializer packetdataserializer) throws IOException {
+        if ( packetdataserializer.version < 16 )
+        {
+            packetdataserializer.writeByte( this.a );
+            packetdataserializer.writeByte( this.b );
+            packetdataserializer.a( this.c );
+            packetdataserializer.writeByte( this.d );
+            packetdataserializer.writeBoolean( this.e );
+            if ( this.b == 11 )
+            {
+                packetdataserializer.writeInt( this.f );
+            }
+        } else
+        {
+            packetdataserializer.writeByte( a );
+            packetdataserializer.a( getInventoryString( b ) );
+            if ( e )
+            {
+                packetdataserializer.a( ChatSerializer.a( CraftChatMessage.fromString( c )[ 0 ] ) );
+            } else
+            {
+                packetdataserializer.a( ChatSerializer.a( new ChatMessage( c ) ) );
+            }
+            packetdataserializer.writeByte( d );
+            if ( this.b == 11 )
+            {
+                packetdataserializer.writeInt( this.f );
+            }
+        }
+    }
+
+    // Spigot start - protocol patch
+    private String getInventoryString(int b)
+    {
+        switch ( b ) {
+            case 0:
+                return "minecraft:chest";
+            case 1:
+                return "minecraft:crafting_table";
+            case 2:
+                return "minecraft:furnace";
+            case 3:
+                return "minecraft:dispenser";
+            case 4:
+                return "minecraft:enchanting_table";
+            case 5:
+                return "minecraft:brewing_stand";
+            case 6:
+                return "minecraft:villager";
+            case 7:
+                return "minecraft:beacon";
+            case 8:
+                return "minecraft:anvil";
+            case 9:
+                return "minecraft:hopper";
+            case 10:
+                return "minecraft:dropper";
+            case 11:
+                return "EntityHorse";
+        }
+        throw new IllegalArgumentException( "Unknown type " + b );
+    }
+    // Spigot end
+
+    public void handle(PacketListener packetlistener) {
+        this.a((PacketPlayOutListener) packetlistener);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PacketPlayOutPlayerInfo.java b/src/main/java/net/minecraft/server/PacketPlayOutPlayerInfo.java
new file mode 100644
index 0000000..adb8e8f
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PacketPlayOutPlayerInfo.java
@@ -0,0 +1,146 @@
+package net.minecraft.server;
+
+import java.io.IOException;
+// Spigot start - protocol patch
+import net.minecraft.util.com.mojang.authlib.GameProfile;
+import net.minecraft.util.com.mojang.authlib.properties.Property;
+import net.minecraft.util.com.mojang.authlib.properties.PropertyMap;
+import org.bukkit.craftbukkit.util.CraftChatMessage;
+
+public class PacketPlayOutPlayerInfo extends Packet {
+
+    private static final int ADD_PLAYER = 0;
+    private static final int UPDATE_GAMEMODE = 1;
+    private static final int UPDATE_LATENCY = 2;
+    private static final int UPDATE_DISPLAY_NAME = 3;
+    private static final int REMOVE_PLAYER = 4;
+
+    private int action;
+    // private int length; We don't batch (yet)
+    private GameProfile player;
+
+    private int gamemode;
+    private int ping;
+    private String username;
+
+    public PacketPlayOutPlayerInfo() {}
+
+    /* removed to force breaking
+    public PacketPlayOutPlayerInfo(String s, boolean flag, int i) {
+        this.a = s;
+        this.b = flag;
+        this.c = i;
+    }
+    */
+
+    public static PacketPlayOutPlayerInfo addPlayer(EntityPlayer player) {
+        PacketPlayOutPlayerInfo packet = new PacketPlayOutPlayerInfo();
+        packet.action = ADD_PLAYER;
+        packet.username = player.listName;
+        packet.player = player.getProfile();
+        packet.ping = player.ping;
+        packet.gamemode = player.playerInteractManager.getGameMode().getId();
+        return packet;
+    }
+
+    public static PacketPlayOutPlayerInfo updatePing(EntityPlayer player) {
+        PacketPlayOutPlayerInfo packet = new PacketPlayOutPlayerInfo();
+        packet.action = UPDATE_LATENCY;
+        packet.username = player.listName;
+        packet.player = player.getProfile();
+        packet.ping = player.ping;
+        return packet;
+    }
+
+    public static PacketPlayOutPlayerInfo updateGamemode(EntityPlayer player) {
+        PacketPlayOutPlayerInfo packet = new PacketPlayOutPlayerInfo();
+        packet.action = UPDATE_GAMEMODE;
+        packet.username = player.listName;
+        packet.player = player.getProfile();
+        packet.gamemode = player.playerInteractManager.getGameMode().getId();
+        return packet;
+    }
+
+    public static PacketPlayOutPlayerInfo updateDisplayName(EntityPlayer player) {
+        PacketPlayOutPlayerInfo packet = new PacketPlayOutPlayerInfo();
+        packet.action = UPDATE_DISPLAY_NAME;
+        packet.username = player.listName;
+        packet.player = player.getProfile();
+        return packet;
+    }
+
+    public static PacketPlayOutPlayerInfo removePlayer(EntityPlayer player) {
+        PacketPlayOutPlayerInfo packet = new PacketPlayOutPlayerInfo();
+        packet.action = REMOVE_PLAYER;
+        packet.username = player.listName;
+        packet.player = player.getProfile();
+        return packet;
+    }
+
+    public void a(PacketDataSerializer packetdataserializer) throws IOException {
+        // Not needed
+    }
+
+    public void b(PacketDataSerializer packetdataserializer) throws IOException {
+        if ( packetdataserializer.version >= 20 )
+        {
+            packetdataserializer.b( action );
+            packetdataserializer.b( 1 );
+            packetdataserializer.writeUUID( player.getId() );
+            switch ( action )
+            {
+                case ADD_PLAYER:
+                    packetdataserializer.a( player.getName() );
+                    PropertyMap properties = player.getProperties();
+                    packetdataserializer.b( properties.size() );
+                    for ( Property property : properties.values() )
+                    {
+                        packetdataserializer.a( property.getName() );
+                        packetdataserializer.a( property.getValue() );
+                        packetdataserializer.writeBoolean( property.hasSignature() );
+                        if ( property.hasSignature() )
+                        {
+                            packetdataserializer.a( property.getSignature() );
+                        }
+                    }
+                    packetdataserializer.b( gamemode );
+                    packetdataserializer.b( ping );
+                    packetdataserializer.writeBoolean( username != null );
+                    if ( username != null )
+                    {
+                        packetdataserializer.a( ChatSerializer.a( CraftChatMessage.fromString( username )[0] ) );
+                    }
+                    break;
+                case UPDATE_GAMEMODE:
+                    packetdataserializer.b( gamemode );
+                    break;
+                case UPDATE_LATENCY:
+                    packetdataserializer.b( ping );
+                    break;
+                case UPDATE_DISPLAY_NAME:
+                    packetdataserializer.writeBoolean( username != null );
+                    if ( username != null )
+                    {
+                        packetdataserializer.a( ChatSerializer.a( CraftChatMessage.fromString( username )[0] ) );
+                    }
+                    break;
+                case REMOVE_PLAYER:
+                    break;
+
+            }
+        } else {
+            packetdataserializer.a( username );
+            packetdataserializer.writeBoolean( action != REMOVE_PLAYER );
+            packetdataserializer.writeShort( ping );
+        }
+    }
+
+    public void a(PacketPlayOutListener packetplayoutlistener) {
+        packetplayoutlistener.a(this);
+    }
+
+    public void handle(PacketListener packetlistener) {
+        this.a((PacketPlayOutListener) packetlistener);
+    }
+}
+// Spigot end
\ No newline at end of file
diff --git a/src/main/java/net/minecraft/server/PacketPlayOutPosition.java b/src/main/java/net/minecraft/server/PacketPlayOutPosition.java
new file mode 100644
index 0000000..b3c0ccf
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PacketPlayOutPosition.java
@@ -0,0 +1,56 @@
+package net.minecraft.server;
+
+public class PacketPlayOutPosition extends Packet {
+
+    private double a;
+    private double b;
+    private double c;
+    private float d;
+    private float e;
+    private boolean f;
+
+    public PacketPlayOutPosition() {}
+
+    public PacketPlayOutPosition(double d0, double d1, double d2, float f, float f1, boolean flag) {
+        this.a = d0;
+        this.b = d1;
+        this.c = d2;
+        this.d = f;
+        this.e = f1;
+        this.f = flag;
+    }
+
+    public void a(PacketDataSerializer packetdataserializer) {
+        this.a = packetdataserializer.readDouble();
+        this.b = packetdataserializer.readDouble();
+        this.c = packetdataserializer.readDouble();
+        this.d = packetdataserializer.readFloat();
+        this.e = packetdataserializer.readFloat();
+        this.f = packetdataserializer.readBoolean();
+    }
+
+    public void b(PacketDataSerializer packetdataserializer) {
+        // Spigot start - protocol patch
+        packetdataserializer.writeDouble(this.a);
+        packetdataserializer.writeDouble(this.b - (packetdataserializer.version >= 16 ? 1.62 : 0));
+        packetdataserializer.writeDouble(this.c);
+        packetdataserializer.writeFloat(this.d);
+        packetdataserializer.writeFloat(this.e);
+        if ( packetdataserializer.version < 16 )
+        {
+            packetdataserializer.writeBoolean( this.f );
+        } else
+        {
+            packetdataserializer.writeByte( 0 );
+        }
+        // Spigot end
+    }
+
+    public void a(PacketPlayOutListener packetplayoutlistener) {
+        packetplayoutlistener.a(this);
+    }
+
+    public void handle(PacketListener packetlistener) {
+        this.a((PacketPlayOutListener) packetlistener);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PacketPlayOutRelEntityMove.java b/src/main/java/net/minecraft/server/PacketPlayOutRelEntityMove.java
new file mode 100644
index 0000000..37e5a38
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PacketPlayOutRelEntityMove.java
@@ -0,0 +1,44 @@
+package net.minecraft.server;
+
+public class PacketPlayOutRelEntityMove extends PacketPlayOutEntity {
+
+    private boolean onGround; // Spigot - protocol patch
+
+    public PacketPlayOutRelEntityMove() {}
+
+    public PacketPlayOutRelEntityMove(int i, byte b0, byte b1, byte b2, boolean onGround) { // Spigot - protocol patch
+        super(i);
+        this.b = b0;
+        this.c = b1;
+        this.d = b2;
+        this.onGround = onGround; // Spigot - protocol patch
+    }
+
+    public void a(PacketDataSerializer packetdataserializer) {
+        super.a(packetdataserializer);
+        this.b = packetdataserializer.readByte();
+        this.c = packetdataserializer.readByte();
+        this.d = packetdataserializer.readByte();
+    }
+
+    public void b(PacketDataSerializer packetdataserializer) {
+        super.b(packetdataserializer);
+        packetdataserializer.writeByte(this.b);
+        packetdataserializer.writeByte(this.c);
+        packetdataserializer.writeByte(this.d);
+        // Spigot start - protocol patch
+        if ( packetdataserializer.version >= 22 )
+        {
+            packetdataserializer.writeBoolean( onGround );
+        }
+        // Spigot end
+    }
+
+    public String b() {
+        return super.b() + String.format(", xa=%d, ya=%d, za=%d", new Object[] { Byte.valueOf(this.b), Byte.valueOf(this.c), Byte.valueOf(this.d)});
+    }
+
+    public void handle(PacketListener packetlistener) {
+        super.a((PacketPlayOutListener) packetlistener);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PacketPlayOutRelEntityMoveLook.java b/src/main/java/net/minecraft/server/PacketPlayOutRelEntityMoveLook.java
new file mode 100644
index 0000000..2ad234b
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PacketPlayOutRelEntityMoveLook.java
@@ -0,0 +1,53 @@
+package net.minecraft.server;
+
+public class PacketPlayOutRelEntityMoveLook extends PacketPlayOutEntity {
+
+    private boolean onGround; // Spigot - protocol patch
+
+    public PacketPlayOutRelEntityMoveLook() {
+        this.g = true;
+    }
+
+    public PacketPlayOutRelEntityMoveLook(int i, byte b0, byte b1, byte b2, byte b3, byte b4, boolean onGround) { // Spigot - protocol patch
+        super(i);
+        this.b = b0;
+        this.c = b1;
+        this.d = b2;
+        this.e = b3;
+        this.f = b4;
+        this.g = true;
+        this.onGround = onGround; // Spigot - protocol patch
+    }
+
+    public void a(PacketDataSerializer packetdataserializer) {
+        super.a(packetdataserializer);
+        this.b = packetdataserializer.readByte();
+        this.c = packetdataserializer.readByte();
+        this.d = packetdataserializer.readByte();
+        this.e = packetdataserializer.readByte();
+        this.f = packetdataserializer.readByte();
+    }
+
+    public void b(PacketDataSerializer packetdataserializer) {
+        super.b(packetdataserializer);
+        packetdataserializer.writeByte(this.b);
+        packetdataserializer.writeByte(this.c);
+        packetdataserializer.writeByte(this.d);
+        packetdataserializer.writeByte(this.e);
+        packetdataserializer.writeByte(this.f);
+        // Spigot start - protocol patch
+        if ( packetdataserializer.version >= 22 )
+        {
+            packetdataserializer.writeBoolean( onGround );
+        }
+        // Spigot end
+    }
+
+    public String b() {
+        return super.b() + String.format(", xa=%d, ya=%d, za=%d, yRot=%d, xRot=%d", new Object[] { Byte.valueOf(this.b), Byte.valueOf(this.c), Byte.valueOf(this.d), Byte.valueOf(this.e), Byte.valueOf(this.f)});
+    }
+
+    public void handle(PacketListener packetlistener) {
+        super.a((PacketPlayOutListener) packetlistener);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PacketPlayOutRemoveEntityEffect.java b/src/main/java/net/minecraft/server/PacketPlayOutRemoveEntityEffect.java
new file mode 100644
index 0000000..f2c38c5
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PacketPlayOutRemoveEntityEffect.java
@@ -0,0 +1,39 @@
+package net.minecraft.server;
+
+public class PacketPlayOutRemoveEntityEffect extends Packet {
+
+    private int a;
+    private int b;
+
+    public PacketPlayOutRemoveEntityEffect() {}
+
+    public PacketPlayOutRemoveEntityEffect(int i, MobEffect mobeffect) {
+        this.a = i;
+        this.b = mobeffect.getEffectId();
+    }
+
+    public void a(PacketDataSerializer packetdataserializer) {
+        this.a = packetdataserializer.readInt();
+        this.b = packetdataserializer.readUnsignedByte();
+    }
+
+    public void b(PacketDataSerializer packetdataserializer) {
+        // Spigot start - protocol patch
+        if ( packetdataserializer.version < 16 )
+        {
+            packetdataserializer.writeInt( this.a );
+        } else {
+            packetdataserializer.b( a );
+        }
+        // Spigot end
+        packetdataserializer.writeByte(this.b);
+    }
+
+    public void a(PacketPlayOutListener packetplayoutlistener) {
+        packetplayoutlistener.a(this);
+    }
+
+    public void handle(PacketListener packetlistener) {
+        this.a((PacketPlayOutListener) packetlistener);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PacketPlayOutScoreboardObjective.java b/src/main/java/net/minecraft/server/PacketPlayOutScoreboardObjective.java
new file mode 100644
index 0000000..700e94e
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PacketPlayOutScoreboardObjective.java
@@ -0,0 +1,51 @@
+package net.minecraft.server;
+
+import java.io.IOException;
+
+public class PacketPlayOutScoreboardObjective extends Packet {
+
+    private String a;
+    private String b;
+    private int c;
+
+    public PacketPlayOutScoreboardObjective() {}
+
+    public PacketPlayOutScoreboardObjective(ScoreboardObjective scoreboardobjective, int i) {
+        this.a = scoreboardobjective.getName();
+        this.b = scoreboardobjective.getDisplayName();
+        this.c = i;
+    }
+
+    public void a(PacketDataSerializer packetdataserializer) throws IOException {
+        this.a = packetdataserializer.c(16);
+        this.b = packetdataserializer.c(32);
+        this.c = packetdataserializer.readByte();
+    }
+
+    public void b(PacketDataSerializer packetdataserializer) throws IOException {
+        // Spigot start - protocol patch
+        if ( packetdataserializer.version < 16 )
+        {
+            packetdataserializer.a( this.a );
+            packetdataserializer.a( this.b );
+            packetdataserializer.writeByte( this.c );
+        } else
+        {
+            packetdataserializer.a( a );
+            packetdataserializer.writeByte( c );
+            if ( c == 0 || c == 2 ) {
+                packetdataserializer.a( b );
+                packetdataserializer.a( "integer" );
+            }
+        }
+        // Spigot end
+    }
+
+    public void a(PacketPlayOutListener packetplayoutlistener) {
+        packetplayoutlistener.a(this);
+    }
+
+    public void handle(PacketListener packetlistener) {
+        this.a((PacketPlayOutListener) packetlistener);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PacketPlayOutScoreboardScore.java b/src/main/java/net/minecraft/server/PacketPlayOutScoreboardScore.java
new file mode 100644
index 0000000..446e308
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PacketPlayOutScoreboardScore.java
@@ -0,0 +1,66 @@
+package net.minecraft.server;
+
+import java.io.IOException;
+
+public class PacketPlayOutScoreboardScore extends Packet {
+
+    private String a = "";
+    private String b = "";
+    private int c;
+    private int d;
+
+    public PacketPlayOutScoreboardScore() {}
+
+    public PacketPlayOutScoreboardScore(ScoreboardScore scoreboardscore, int i) {
+        this.a = scoreboardscore.getPlayerName();
+        this.b = scoreboardscore.getObjective().getName();
+        this.c = scoreboardscore.getScore();
+        this.d = i;
+    }
+
+    public PacketPlayOutScoreboardScore(String s) {
+        this.a = s;
+        this.b = "";
+        this.c = 0;
+        this.d = 1;
+    }
+
+    public void a(PacketDataSerializer packetdataserializer) throws IOException {
+        this.a = packetdataserializer.c(16);
+        this.d = packetdataserializer.readByte();
+        if (this.d != 1) {
+            this.b = packetdataserializer.c(16);
+            this.c = packetdataserializer.readInt();
+        }
+    }
+
+    public void b(PacketDataSerializer packetdataserializer) throws IOException {
+        packetdataserializer.a( this.a );
+        packetdataserializer.writeByte( this.d );
+        // Spigot start - protocol patch
+        if ( packetdataserializer.version < 16 )
+        {
+            if ( this.d != 1 )
+            {
+                packetdataserializer.a( this.b );
+                packetdataserializer.writeInt( this.c );
+            }
+        } else
+        {
+            packetdataserializer.a( this.b );
+            if ( this.d != 1 )
+            {
+                packetdataserializer.b( c );
+            }
+        }
+        // Spigot end
+    }
+
+    public void a(PacketPlayOutListener packetplayoutlistener) {
+        packetplayoutlistener.a(this);
+    }
+
+    public void handle(PacketListener packetlistener) {
+        this.a((PacketPlayOutListener) packetlistener);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PacketPlayOutScoreboardTeam.java b/src/main/java/net/minecraft/server/PacketPlayOutScoreboardTeam.java
new file mode 100644
index 0000000..abba46c
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PacketPlayOutScoreboardTeam.java
@@ -0,0 +1,110 @@
+package net.minecraft.server;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Iterator;
+
+public class PacketPlayOutScoreboardTeam extends Packet {
+
+    private String a = "";
+    private String b = "";
+    private String c = "";
+    private String d = "";
+    private Collection e = new ArrayList();
+    private int f;
+    private int g;
+
+    public PacketPlayOutScoreboardTeam() {}
+
+    public PacketPlayOutScoreboardTeam(ScoreboardTeam scoreboardteam, int i) {
+        this.a = scoreboardteam.getName();
+        this.f = i;
+        if (i == 0 || i == 2) {
+            this.b = scoreboardteam.getDisplayName();
+            this.c = scoreboardteam.getPrefix();
+            this.d = scoreboardteam.getSuffix();
+            this.g = scoreboardteam.packOptionData();
+        }
+
+        if (i == 0) {
+            this.e.addAll(scoreboardteam.getPlayerNameSet());
+        }
+    }
+
+    public PacketPlayOutScoreboardTeam(ScoreboardTeam scoreboardteam, Collection collection, int i) {
+        if (i != 3 && i != 4) {
+            throw new IllegalArgumentException("Method must be join or leave for player constructor");
+        } else if (collection != null && !collection.isEmpty()) {
+            this.f = i;
+            this.a = scoreboardteam.getName();
+            this.e.addAll(collection);
+        } else {
+            throw new IllegalArgumentException("Players cannot be null/empty");
+        }
+    }
+
+    public void a(PacketDataSerializer packetdataserializer) throws IOException {
+        this.a = packetdataserializer.c(16);
+        this.f = packetdataserializer.readByte();
+        if (this.f == 0 || this.f == 2) {
+            this.b = packetdataserializer.c(32);
+            this.c = packetdataserializer.c(16);
+            this.d = packetdataserializer.c(16);
+            this.g = packetdataserializer.readByte();
+        }
+
+        if (this.f == 0 || this.f == 3 || this.f == 4) {
+            short short1 = packetdataserializer.readShort();
+
+            for (int i = 0; i < short1; ++i) {
+                this.e.add(packetdataserializer.c(40));
+            }
+        }
+    }
+
+    public void b(PacketDataSerializer packetdataserializer) throws IOException {
+        packetdataserializer.a(this.a);
+        packetdataserializer.writeByte(this.f);
+        if (this.f == 0 || this.f == 2) {
+            packetdataserializer.a(this.b);
+            packetdataserializer.a(this.c);
+            packetdataserializer.a(this.d);
+            packetdataserializer.writeByte(this.g);
+            // Spigot start - protocol patch
+            if ( packetdataserializer.version >= 16 )
+            {
+                packetdataserializer.a( "always" );
+                packetdataserializer.writeByte( EnumChatFormat.WHITE.ordinal() );
+            }
+            // Spigot end
+        }
+
+        if (this.f == 0 || this.f == 3 || this.f == 4) {
+            // Spigot start - protocol patch
+            if ( packetdataserializer.version < 16 )
+            {
+                packetdataserializer.writeShort( this.e.size() );
+            } else
+            {
+                packetdataserializer.b( e.size() );
+            }
+            // Spigot end
+            Iterator iterator = this.e.iterator();
+
+            while (iterator.hasNext()) {
+                String s = (String) iterator.next();
+
+                packetdataserializer.a(s);
+            }
+        }
+    }
+
+    public void a(PacketPlayOutListener packetplayoutlistener) {
+        packetplayoutlistener.a(this);
+    }
+
+    public void handle(PacketListener packetlistener) {
+        this.a((PacketPlayOutListener) packetlistener);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PacketPlayOutSetSlot.java b/src/main/java/net/minecraft/server/PacketPlayOutSetSlot.java
new file mode 100644
index 0000000..8893b61
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PacketPlayOutSetSlot.java
@@ -0,0 +1,36 @@
+package net.minecraft.server;
+
+public class PacketPlayOutSetSlot extends Packet {
+
+    public int a; // Spigot
+    public int b; // Spigot
+    private ItemStack c;
+
+    public PacketPlayOutSetSlot() {}
+
+    public PacketPlayOutSetSlot(int i, int j, ItemStack itemstack) {
+        this.a = i;
+        this.b = j;
+        this.c = itemstack == null ? null : itemstack.cloneItemStack();
+    }
+
+    public void a(PacketPlayOutListener packetplayoutlistener) {
+        packetplayoutlistener.a(this);
+    }
+
+    public void a(PacketDataSerializer packetdataserializer) {
+        this.a = packetdataserializer.readByte();
+        this.b = packetdataserializer.readShort();
+        this.c = packetdataserializer.c();
+    }
+
+    public void b(PacketDataSerializer packetdataserializer) {
+        packetdataserializer.writeByte(this.a);
+        packetdataserializer.writeShort(this.b);
+        packetdataserializer.a(this.c);
+    }
+
+    public void handle(PacketListener packetlistener) {
+        this.a((PacketPlayOutListener) packetlistener);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PacketPlayOutSpawnEntity.java b/src/main/java/net/minecraft/server/PacketPlayOutSpawnEntity.java
new file mode 100644
index 0000000..dcf1204
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PacketPlayOutSpawnEntity.java
@@ -0,0 +1,168 @@
+package net.minecraft.server;
+
+public class PacketPlayOutSpawnEntity extends Packet {
+
+    private int a;
+    private int b;
+    private int c;
+    private int d;
+    private int e;
+    private int f;
+    private int g;
+    private int h;
+    private int i;
+    private int j;
+    private int k;
+
+    public PacketPlayOutSpawnEntity() {}
+
+    public PacketPlayOutSpawnEntity(Entity entity, int i) {
+        this(entity, i, 0);
+    }
+
+    public PacketPlayOutSpawnEntity(Entity entity, int i, int j) {
+        this.a = entity.getId();
+        this.b = MathHelper.floor(entity.locX * 32.0D);
+        this.c = MathHelper.floor(entity.locY * 32.0D);
+        this.d = MathHelper.floor(entity.locZ * 32.0D);
+        this.h = MathHelper.d(entity.pitch * 256.0F / 360.0F);
+        this.i = MathHelper.d(entity.yaw * 256.0F / 360.0F);
+        this.j = i;
+        this.k = j;
+        if (j > 0) {
+            double d0 = entity.motX;
+            double d1 = entity.motY;
+            double d2 = entity.motZ;
+            double d3 = 3.9D;
+
+            if (d0 < -d3) {
+                d0 = -d3;
+            }
+
+            if (d1 < -d3) {
+                d1 = -d3;
+            }
+
+            if (d2 < -d3) {
+                d2 = -d3;
+            }
+
+            if (d0 > d3) {
+                d0 = d3;
+            }
+
+            if (d1 > d3) {
+                d1 = d3;
+            }
+
+            if (d2 > d3) {
+                d2 = d3;
+            }
+
+            this.e = (int) (d0 * 8000.0D);
+            this.f = (int) (d1 * 8000.0D);
+            this.g = (int) (d2 * 8000.0D);
+        }
+    }
+
+    public void a(PacketDataSerializer packetdataserializer) {
+        this.a = packetdataserializer.a();
+        this.j = packetdataserializer.readByte();
+        this.b = packetdataserializer.readInt();
+        this.c = packetdataserializer.readInt();
+        this.d = packetdataserializer.readInt();
+        this.h = packetdataserializer.readByte();
+        this.i = packetdataserializer.readByte();
+        this.k = packetdataserializer.readInt();
+        if (this.k > 0) {
+            this.e = packetdataserializer.readShort();
+            this.f = packetdataserializer.readShort();
+            this.g = packetdataserializer.readShort();
+        }
+    }
+
+    public void b(PacketDataSerializer packetdataserializer) {
+        packetdataserializer.b(this.a);
+        packetdataserializer.writeByte(this.j);
+        // Spigot start - protocol patch
+        if ( j == 71 && packetdataserializer.version >= 28 )
+        {
+            // North: 0   256
+            // West:  64  192
+            // South: 128 128
+            // East:  192 320
+            switch ( k ) {
+                case 0:
+                    d += 32;
+                    i = 0;
+                    break;
+                case 1:
+                    b -= 32;
+                    i = 64;
+                    break;
+                case 2:
+                    d -= 32;
+                    i = 128;
+                    break;
+                case 3:
+                    b += 32;
+                    i = 192;
+                    break;
+            }
+        }
+        if ( j == 70 && packetdataserializer.version >= 36 )
+        {
+            int id = k & 0xFFFF;
+            int data = k >> 16;
+            k = id | ( data << 12 );
+        }
+        // Spigot end
+        packetdataserializer.writeInt(this.b);
+        packetdataserializer.writeInt(this.c);
+        packetdataserializer.writeInt(this.d);
+        packetdataserializer.writeByte(this.h);
+        packetdataserializer.writeByte(this.i);
+        packetdataserializer.writeInt(this.k);
+        if (this.k > 0) {
+            packetdataserializer.writeShort(this.e);
+            packetdataserializer.writeShort(this.f);
+            packetdataserializer.writeShort(this.g);
+        }
+    }
+
+    public void a(PacketPlayOutListener packetplayoutlistener) {
+        packetplayoutlistener.a(this);
+    }
+
+    public String b() {
+        return String.format("id=%d, type=%d, x=%.2f, y=%.2f, z=%.2f", new Object[] { Integer.valueOf(this.a), Integer.valueOf(this.j), Float.valueOf((float) this.b / 32.0F), Float.valueOf((float) this.c / 32.0F), Float.valueOf((float) this.d / 32.0F)});
+    }
+
+    public void a(int i) {
+        this.b = i;
+    }
+
+    public void b(int i) {
+        this.c = i;
+    }
+
+    public void c(int i) {
+        this.d = i;
+    }
+
+    public void d(int i) {
+        this.e = i;
+    }
+
+    public void e(int i) {
+        this.f = i;
+    }
+
+    public void f(int i) {
+        this.g = i;
+    }
+
+    public void handle(PacketListener packetlistener) {
+        this.a((PacketPlayOutListener) packetlistener);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PacketPlayOutSpawnEntityLiving.java b/src/main/java/net/minecraft/server/PacketPlayOutSpawnEntityLiving.java
new file mode 100644
index 0000000..98b4d97
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PacketPlayOutSpawnEntityLiving.java
@@ -0,0 +1,108 @@
+package net.minecraft.server;
+
+import java.util.List;
+
+public class PacketPlayOutSpawnEntityLiving extends Packet {
+
+    private int a;
+    private int b;
+    private int c;
+    private int d;
+    private int e;
+    private int f;
+    private int g;
+    private int h;
+    private byte i;
+    private byte j;
+    private byte k;
+    private DataWatcher l;
+    private List m;
+
+    public PacketPlayOutSpawnEntityLiving() {}
+
+    public PacketPlayOutSpawnEntityLiving(EntityLiving entityliving) {
+        this.a = entityliving.getId();
+        this.b = (byte) EntityTypes.a(entityliving);
+        this.c = entityliving.as.a(entityliving.locX);
+        this.d = MathHelper.floor(entityliving.locY * 32.0D);
+        this.e = entityliving.as.a(entityliving.locZ);
+        this.i = (byte) ((int) (entityliving.yaw * 256.0F / 360.0F));
+        this.j = (byte) ((int) (entityliving.pitch * 256.0F / 360.0F));
+        this.k = (byte) ((int) (entityliving.aO * 256.0F / 360.0F));
+        double d0 = 3.9D;
+        double d1 = entityliving.motX;
+        double d2 = entityliving.motY;
+        double d3 = entityliving.motZ;
+
+        if (d1 < -d0) {
+            d1 = -d0;
+        }
+
+        if (d2 < -d0) {
+            d2 = -d0;
+        }
+
+        if (d3 < -d0) {
+            d3 = -d0;
+        }
+
+        if (d1 > d0) {
+            d1 = d0;
+        }
+
+        if (d2 > d0) {
+            d2 = d0;
+        }
+
+        if (d3 > d0) {
+            d3 = d0;
+        }
+
+        this.f = (int) (d1 * 8000.0D);
+        this.g = (int) (d2 * 8000.0D);
+        this.h = (int) (d3 * 8000.0D);
+        this.l = entityliving.getDataWatcher();
+    }
+
+    public void a(PacketDataSerializer packetdataserializer) {
+        this.a = packetdataserializer.a();
+        this.b = packetdataserializer.readByte() & 255;
+        this.c = packetdataserializer.readInt();
+        this.d = packetdataserializer.readInt();
+        this.e = packetdataserializer.readInt();
+        this.i = packetdataserializer.readByte();
+        this.j = packetdataserializer.readByte();
+        this.k = packetdataserializer.readByte();
+        this.f = packetdataserializer.readShort();
+        this.g = packetdataserializer.readShort();
+        this.h = packetdataserializer.readShort();
+        this.m = DataWatcher.b(packetdataserializer);
+    }
+
+    public void b(PacketDataSerializer packetdataserializer) {
+        packetdataserializer.b(this.a);
+        packetdataserializer.writeByte(this.b & 255);
+        packetdataserializer.writeInt(this.c);
+        packetdataserializer.writeInt(this.d);
+        packetdataserializer.writeInt(this.e);
+        packetdataserializer.writeByte(this.i);
+        packetdataserializer.writeByte(this.j);
+        packetdataserializer.writeByte(this.k);
+        packetdataserializer.writeShort(this.f);
+        packetdataserializer.writeShort(this.g);
+        packetdataserializer.writeShort(this.h);
+        this.l.a(packetdataserializer, packetdataserializer.version); // Spigot
+    }
+
+    public void a(PacketPlayOutListener packetplayoutlistener) {
+        packetplayoutlistener.a(this);
+    }
+
+    public String b() {
+        return String.format("id=%d, type=%d, x=%.2f, y=%.2f, z=%.2f, xd=%.2f, yd=%.2f, zd=%.2f", new Object[] { Integer.valueOf(this.a), Integer.valueOf(this.b), Float.valueOf((float) this.c / 32.0F), Float.valueOf((float) this.d / 32.0F), Float.valueOf((float) this.e / 32.0F), Float.valueOf((float) this.f / 8000.0F), Float.valueOf((float) this.g / 8000.0F), Float.valueOf((float) this.h / 8000.0F)});
+    }
+
+    public void handle(PacketListener packetlistener) {
+        this.a((PacketPlayOutListener) packetlistener);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PacketPlayOutSpawnEntityPainting.java b/src/main/java/net/minecraft/server/PacketPlayOutSpawnEntityPainting.java
new file mode 100644
index 0000000..47efb16
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PacketPlayOutSpawnEntityPainting.java
@@ -0,0 +1,84 @@
+package net.minecraft.server;
+
+import java.io.IOException;
+
+public class PacketPlayOutSpawnEntityPainting extends Packet {
+
+    private int a;
+    private int b;
+    private int c;
+    private int d;
+    private int e;
+    private String f;
+
+    public PacketPlayOutSpawnEntityPainting() {}
+
+    public PacketPlayOutSpawnEntityPainting(EntityPainting entitypainting) {
+        this.a = entitypainting.getId();
+        this.b = entitypainting.x;
+        this.c = entitypainting.y;
+        this.d = entitypainting.z;
+        this.e = entitypainting.direction;
+        this.f = entitypainting.art.B;
+    }
+
+    public void a(PacketDataSerializer packetdataserializer) throws IOException {
+        this.a = packetdataserializer.a();
+        this.f = packetdataserializer.c(EnumArt.A);
+        this.b = packetdataserializer.readInt();
+        this.c = packetdataserializer.readInt();
+        this.d = packetdataserializer.readInt();
+        this.e = packetdataserializer.readInt();
+    }
+
+    public void b(PacketDataSerializer packetdataserializer) throws IOException {
+        packetdataserializer.b(this.a);
+        packetdataserializer.a(this.f);
+        // Spigot start - protocol patch
+        if ( packetdataserializer.version >= 28 )
+        {
+            // North: 0   256
+            // West:  64  192
+            // South: 128 128
+            // East:  192 320
+            switch ( e ) {
+                case 0:
+                    d += 1;
+                    break;
+                case 1:
+                    b -= 1;
+                    break;
+                case 2:
+                    d -= 1;
+                    break;
+                case 3:
+                    b += 1;
+                    break;
+            }
+        }
+        if ( packetdataserializer.version < 16 )
+        {
+            packetdataserializer.writeInt( this.b );
+            packetdataserializer.writeInt( this.c );
+            packetdataserializer.writeInt( this.d );
+            packetdataserializer.writeInt( this.e );
+        } else
+        {
+            packetdataserializer.writePosition( b, c, d );
+            packetdataserializer.writeByte( e );
+        }
+        // Spigot end
+    }
+
+    public void a(PacketPlayOutListener packetplayoutlistener) {
+        packetplayoutlistener.a(this);
+    }
+
+    public String b() {
+        return String.format("id=%d, type=%s, x=%d, y=%d, z=%d", new Object[] { Integer.valueOf(this.a), this.f, Integer.valueOf(this.b), Integer.valueOf(this.c), Integer.valueOf(this.d)});
+    }
+
+    public void handle(PacketListener packetlistener) {
+        this.a((PacketPlayOutListener) packetlistener);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PacketPlayOutSpawnPosition.java b/src/main/java/net/minecraft/server/PacketPlayOutSpawnPosition.java
index 92e4036..191d213 100644
--- a/src/main/java/net/minecraft/server/PacketPlayOutSpawnPosition.java
+++ b/src/main/java/net/minecraft/server/PacketPlayOutSpawnPosition.java
@@ -21,9 +21,16 @@ public class PacketPlayOutSpawnPosition extends Packet {
     }
 
     public void b(PacketDataSerializer packetdataserializer) {
-        packetdataserializer.writeInt(this.x);
-        packetdataserializer.writeInt(this.y);
-        packetdataserializer.writeInt(this.z);
+        if ( packetdataserializer.version < 16 )
+        {
+            packetdataserializer.writeInt( this.x );
+            packetdataserializer.writeInt( this.y );
+            packetdataserializer.writeInt( this.z );
+
+        } else
+        {
+            packetdataserializer.writePosition( x, y, z );
+        }
     }
 
     public void a(PacketPlayOutListener packetplayoutlistener) {
diff --git a/src/main/java/net/minecraft/server/PacketPlayOutTileEntityData.java b/src/main/java/net/minecraft/server/PacketPlayOutTileEntityData.java
new file mode 100644
index 0000000..ed54ddd
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PacketPlayOutTileEntityData.java
@@ -0,0 +1,52 @@
+package net.minecraft.server;
+
+public class PacketPlayOutTileEntityData extends Packet {
+
+    private int a;
+    private int b;
+    private int c;
+    private int d;
+    private NBTTagCompound e;
+
+    public PacketPlayOutTileEntityData() {}
+
+    public PacketPlayOutTileEntityData(int i, int j, int k, int l, NBTTagCompound nbttagcompound) {
+        this.a = i;
+        this.b = j;
+        this.c = k;
+        this.d = l;
+        this.e = nbttagcompound;
+    }
+
+    public void a(PacketDataSerializer packetdataserializer) {
+        this.a = packetdataserializer.readInt();
+        this.b = packetdataserializer.readShort();
+        this.c = packetdataserializer.readInt();
+        this.d = packetdataserializer.readUnsignedByte();
+        this.e = packetdataserializer.b();
+    }
+
+    public void b(PacketDataSerializer packetdataserializer) {
+        // Spigot start - protocol patch
+        if ( packetdataserializer.version < 16 )
+        {
+            packetdataserializer.writeInt( this.a );
+            packetdataserializer.writeShort( this.b );
+            packetdataserializer.writeInt( this.c );
+        } else
+        {
+            packetdataserializer.writePosition( a, b, c );
+        }
+        // Spigot end
+        packetdataserializer.writeByte((byte) this.d);
+        packetdataserializer.a(this.e);
+    }
+
+    public void a(PacketPlayOutListener packetplayoutlistener) {
+        packetplayoutlistener.a(this);
+    }
+
+    public void handle(PacketListener packetlistener) {
+        this.a((PacketPlayOutListener) packetlistener);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PacketPlayOutUpdateAttributes.java b/src/main/java/net/minecraft/server/PacketPlayOutUpdateAttributes.java
new file mode 100644
index 0000000..0c38297
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PacketPlayOutUpdateAttributes.java
@@ -0,0 +1,94 @@
+package net.minecraft.server;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.List;
+import java.util.UUID;
+
+public class PacketPlayOutUpdateAttributes extends Packet {
+
+    private int a;
+    private final List b = new ArrayList();
+
+    public PacketPlayOutUpdateAttributes() {}
+
+    public PacketPlayOutUpdateAttributes(int i, Collection collection) {
+        this.a = i;
+        Iterator iterator = collection.iterator();
+
+        while (iterator.hasNext()) {
+            AttributeInstance attributeinstance = (AttributeInstance) iterator.next();
+
+            this.b.add(new AttributeSnapshot(this, attributeinstance.getAttribute().getName(), attributeinstance.b(), attributeinstance.c()));
+        }
+    }
+
+    public void a(PacketDataSerializer packetdataserializer) throws IOException {
+        this.a = packetdataserializer.readInt();
+        int i = packetdataserializer.readInt();
+
+        for (int j = 0; j < i; ++j) {
+            String s = packetdataserializer.c(64);
+            double d0 = packetdataserializer.readDouble();
+            ArrayList arraylist = new ArrayList();
+            short short1 = packetdataserializer.readShort();
+
+            for (int k = 0; k < short1; ++k) {
+                UUID uuid = new UUID(packetdataserializer.readLong(), packetdataserializer.readLong());
+
+                arraylist.add(new AttributeModifier(uuid, "Unknown synced attribute modifier", packetdataserializer.readDouble(), packetdataserializer.readByte()));
+            }
+
+            this.b.add(new AttributeSnapshot(this, s, d0, arraylist));
+        }
+    }
+
+    public void b(PacketDataSerializer packetdataserializer) throws IOException {
+        // Spigot start - protocol patch
+        if ( packetdataserializer.version < 16)
+        {
+            packetdataserializer.writeInt( this.a );
+        } else
+        {
+            packetdataserializer.b( a );
+        }
+        // Spigot end
+        packetdataserializer.writeInt(this.b.size());
+        Iterator iterator = this.b.iterator();
+
+        while (iterator.hasNext()) {
+            AttributeSnapshot attributesnapshot = (AttributeSnapshot) iterator.next();
+
+            packetdataserializer.a(attributesnapshot.a());
+            packetdataserializer.writeDouble(attributesnapshot.b());
+            // Spigot start - protocol patch
+            if ( packetdataserializer.version < 16 )
+            {
+                packetdataserializer.writeShort( attributesnapshot.c().size() );
+            } else {
+                packetdataserializer.b( attributesnapshot.c().size() );
+            }
+            // Spigot end
+            Iterator iterator1 = attributesnapshot.c().iterator();
+
+            while (iterator1.hasNext()) {
+                AttributeModifier attributemodifier = (AttributeModifier) iterator1.next();
+
+                packetdataserializer.writeLong(attributemodifier.a().getMostSignificantBits());
+                packetdataserializer.writeLong(attributemodifier.a().getLeastSignificantBits());
+                packetdataserializer.writeDouble(attributemodifier.d());
+                packetdataserializer.writeByte(attributemodifier.c());
+            }
+        }
+    }
+
+    public void a(PacketPlayOutListener packetplayoutlistener) {
+        packetplayoutlistener.a(this);
+    }
+
+    public void handle(PacketListener packetlistener) {
+        this.a((PacketPlayOutListener) packetlistener);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PacketPlayOutUpdateHealth.java b/src/main/java/net/minecraft/server/PacketPlayOutUpdateHealth.java
new file mode 100644
index 0000000..37ede05
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PacketPlayOutUpdateHealth.java
@@ -0,0 +1,44 @@
+package net.minecraft.server;
+
+public class PacketPlayOutUpdateHealth extends Packet {
+
+    private float a;
+    private int b;
+    private float c;
+
+    public PacketPlayOutUpdateHealth() {}
+
+    public PacketPlayOutUpdateHealth(float f, int i, float f1) {
+        this.a = f;
+        this.b = i;
+        this.c = f1;
+    }
+
+    public void a(PacketDataSerializer packetdataserializer) {
+        this.a = packetdataserializer.readFloat();
+        this.b = packetdataserializer.readShort();
+        this.c = packetdataserializer.readFloat();
+    }
+
+    public void b(PacketDataSerializer packetdataserializer) {
+        packetdataserializer.writeFloat(this.a);
+        // Spigot start - protocol patch
+        if ( packetdataserializer.version < 16 )
+        {
+            packetdataserializer.writeShort( this.b );
+        } else
+        {
+            packetdataserializer.b( this.b );
+        }
+        // Spigot end
+        packetdataserializer.writeFloat(this.c);
+    }
+
+    public void a(PacketPlayOutListener packetplayoutlistener) {
+        packetplayoutlistener.a(this);
+    }
+
+    public void handle(PacketListener packetlistener) {
+        this.a((PacketPlayOutListener) packetlistener);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PacketPlayOutUpdateSign.java b/src/main/java/net/minecraft/server/PacketPlayOutUpdateSign.java
new file mode 100644
index 0000000..e68fc18
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PacketPlayOutUpdateSign.java
@@ -0,0 +1,66 @@
+package net.minecraft.server;
+
+import java.io.IOException;
+
+import org.bukkit.craftbukkit.util.CraftChatMessage; // Spigot - protocol patch
+
+public class PacketPlayOutUpdateSign extends Packet {
+
+    private int x;
+    private int y;
+    private int z;
+    private String[] lines;
+
+    public PacketPlayOutUpdateSign() {}
+
+    public PacketPlayOutUpdateSign(int i, int j, int k, String[] astring) {
+        this.x = i;
+        this.y = j;
+        this.z = k;
+        this.lines = new String[] { astring[0], astring[1], astring[2], astring[3]};
+    }
+
+    public void a(PacketDataSerializer packetdataserializer) throws IOException {
+        this.x = packetdataserializer.readInt();
+        this.y = packetdataserializer.readShort();
+        this.z = packetdataserializer.readInt();
+        this.lines = new String[4];
+
+        for (int i = 0; i < 4; ++i) {
+            this.lines[i] = packetdataserializer.c(15);
+        }
+    }
+
+    public void b(PacketDataSerializer packetdataserializer) throws IOException {
+        // Spigot start - protocol patch
+        if ( packetdataserializer.version < 16 )
+        {
+            packetdataserializer.writeInt( this.x );
+            packetdataserializer.writeShort( this.y );
+            packetdataserializer.writeInt( this.z );
+        } else
+        {
+            packetdataserializer.writePosition( x, y, z );
+        }
+
+        for (int i = 0; i < 4; ++i) {
+            if ( packetdataserializer.version < 21 )
+            {
+                packetdataserializer.a( this.lines[ i ] );
+            } else
+            {
+                String line = ChatSerializer.a( CraftChatMessage.fromString( this.lines[ i ] )[ 0 ] );
+                packetdataserializer.a( line );
+            }
+        }
+        // Spigot end
+    }
+
+    public void a(PacketPlayOutListener packetplayoutlistener) {
+        packetplayoutlistener.a(this);
+    }
+
+    public void handle(PacketListener packetlistener) {
+        this.a((PacketPlayOutListener) packetlistener);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PacketPlayOutWindowItems.java b/src/main/java/net/minecraft/server/PacketPlayOutWindowItems.java
new file mode 100644
index 0000000..2a96e2d
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PacketPlayOutWindowItems.java
@@ -0,0 +1,54 @@
+package net.minecraft.server;
+
+import java.util.List;
+
+public class PacketPlayOutWindowItems extends Packet {
+
+    public int a; // Spigot
+    public ItemStack[] b; // Spigot
+
+    public PacketPlayOutWindowItems() {}
+
+    public PacketPlayOutWindowItems(int i, List list) {
+        this.a = i;
+        this.b = new ItemStack[list.size()];
+
+        for (int j = 0; j < this.b.length; ++j) {
+            ItemStack itemstack = (ItemStack) list.get(j);
+
+            this.b[j] = itemstack == null ? null : itemstack.cloneItemStack();
+        }
+    }
+
+    public void a(PacketDataSerializer packetdataserializer) {
+        this.a = packetdataserializer.readUnsignedByte();
+        short short1 = packetdataserializer.readShort();
+
+        this.b = new ItemStack[short1];
+
+        for (int i = 0; i < short1; ++i) {
+            this.b[i] = packetdataserializer.c();
+        }
+    }
+
+    public void b(PacketDataSerializer packetdataserializer) {
+        packetdataserializer.writeByte(this.a);
+        packetdataserializer.writeShort(this.b.length);
+        ItemStack[] aitemstack = this.b;
+        int i = aitemstack.length;
+
+        for (int j = 0; j < i; ++j) {
+            ItemStack itemstack = aitemstack[j];
+
+            packetdataserializer.a(itemstack);
+        }
+    }
+
+    public void a(PacketPlayOutListener packetplayoutlistener) {
+        packetplayoutlistener.a(this);
+    }
+
+    public void handle(PacketListener packetlistener) {
+        this.a((PacketPlayOutListener) packetlistener);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PacketPlayOutWorldEvent.java b/src/main/java/net/minecraft/server/PacketPlayOutWorldEvent.java
new file mode 100644
index 0000000..a9577b8
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PacketPlayOutWorldEvent.java
@@ -0,0 +1,56 @@
+package net.minecraft.server;
+
+public class PacketPlayOutWorldEvent extends Packet {
+
+    private int a;
+    private int b;
+    private int c;
+    private int d;
+    private int e;
+    private boolean f;
+
+    public PacketPlayOutWorldEvent() {}
+
+    public PacketPlayOutWorldEvent(int i, int j, int k, int l, int i1, boolean flag) {
+        this.a = i;
+        this.c = j;
+        this.d = k;
+        this.e = l;
+        this.b = i1;
+        this.f = flag;
+    }
+
+    public void a(PacketDataSerializer packetdataserializer) {
+        this.a = packetdataserializer.readInt();
+        this.c = packetdataserializer.readInt();
+        this.d = packetdataserializer.readByte() & 255;
+        this.e = packetdataserializer.readInt();
+        this.b = packetdataserializer.readInt();
+        this.f = packetdataserializer.readBoolean();
+    }
+
+    public void b(PacketDataSerializer packetdataserializer) {
+        packetdataserializer.writeInt(this.a);
+        // Spigot start - protocol patch
+        if ( packetdataserializer.version < 16 )
+        {
+            packetdataserializer.writeInt( this.c );
+            packetdataserializer.writeByte( this.d & 255 );
+            packetdataserializer.writeInt( this.e );
+        } else
+        {
+            packetdataserializer.writePosition( c, d, e );
+        }
+        // Spigot end
+        packetdataserializer.writeInt(this.b);
+        packetdataserializer.writeBoolean(this.f);
+    }
+
+    public void a(PacketPlayOutListener packetplayoutlistener) {
+        packetplayoutlistener.a(this);
+    }
+
+    public void handle(PacketListener packetlistener) {
+        this.a((PacketPlayOutListener) packetlistener);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PacketPlayOutWorldParticles.java b/src/main/java/net/minecraft/server/PacketPlayOutWorldParticles.java
new file mode 100644
index 0000000..07b564f
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PacketPlayOutWorldParticles.java
@@ -0,0 +1,174 @@
+package net.minecraft.server;
+
+import java.io.IOException;
+import java.util.HashMap; // Spigot
+
+public class PacketPlayOutWorldParticles extends Packet {
+
+    private String a;
+    private float b;
+    private float c;
+    private float d;
+    private float e;
+    private float f;
+    private float g;
+    private float h;
+    private int i;
+
+    public PacketPlayOutWorldParticles() {}
+
+    public PacketPlayOutWorldParticles(String s, float f, float f1, float f2, float f3, float f4, float f5, float f6, int i) {
+        this.a = s;
+        this.b = f;
+        this.c = f1;
+        this.d = f2;
+        this.e = f3;
+        this.f = f4;
+        this.g = f5;
+        this.h = f6;
+        this.i = i;
+    }
+
+    public void a(PacketDataSerializer packetdataserializer) throws IOException {
+        this.a = packetdataserializer.c(64);
+        this.b = packetdataserializer.readFloat();
+        this.c = packetdataserializer.readFloat();
+        this.d = packetdataserializer.readFloat();
+        this.e = packetdataserializer.readFloat();
+        this.f = packetdataserializer.readFloat();
+        this.g = packetdataserializer.readFloat();
+        this.h = packetdataserializer.readFloat();
+        this.i = packetdataserializer.readInt();
+    }
+
+    // Spigot start - protocol patch
+    public void b(PacketDataSerializer packetdataserializer) throws IOException {
+        String[] parts = this.a.split( "_" );
+        Particle particle = Particle.find( parts[ 0 ] );
+        if (particle == null) particle = Particle.CRIT;
+        if ( packetdataserializer.version < 17 )
+        {
+            packetdataserializer.a( this.a );
+        } else
+        {
+            packetdataserializer.writeInt( particle.ordinal() );
+            packetdataserializer.writeBoolean( false );
+        }
+        packetdataserializer.writeFloat(this.b);
+        packetdataserializer.writeFloat(this.c);
+        packetdataserializer.writeFloat(this.d);
+        packetdataserializer.writeFloat(this.e);
+        packetdataserializer.writeFloat(this.f);
+        packetdataserializer.writeFloat(this.g);
+        packetdataserializer.writeFloat(this.h);
+        packetdataserializer.writeInt(this.i);
+        if ( packetdataserializer.version >= 17 )
+        {
+            for ( int i = 0; i < particle.extra; i++ )
+            {
+                int toWrite = 0;
+                if ( parts.length - 1 > i )
+                {
+                    try
+                    {
+                        toWrite = Integer.parseInt( parts[i + 1] );
+                        if ( particle.extra == 1 && parts.length == 3 )
+                        {
+                            i++;
+                            toWrite = toWrite | (Integer.parseInt( parts[i + 1] ) << 12);
+                        }
+                    } catch ( NumberFormatException e )
+                    {
+
+                    }
+                }
+                packetdataserializer.b( toWrite );
+            }
+        }
+    }
+    // Spigot end
+
+    public void a(PacketPlayOutListener packetplayoutlistener) {
+        packetplayoutlistener.a(this);
+    }
+
+    public void handle(PacketListener packetlistener) {
+        this.a((PacketPlayOutListener) packetlistener);
+    }
+
+    // Spigot start - protocol patch
+    private enum Particle
+    {
+        EXPLOSION_NORMAL( "explode" ),
+        EXPLOSION_LARGE( "largeexplode" ),
+        EXPLOSION_HUGE( "hugeexplosion" ),
+        FIREWORKS_SPARK( "fireworksSpark" ),
+        WATER_BUBBLE( "bubble" ),
+        WATER_SPLASH( "splash" ),
+        WATER_WAKE( "wake" ),
+        SUSPENDED( "suspended" ),
+        SUSPENDED_DEPTH( "depthsuspend" ),
+        CRIT( "crit" ),
+        CRIT_MAGIC( "magicCrit" ),
+        SMOKE_NORMAL( "smoke" ),
+        SMOKE_LARGE( "largesmoke" ),
+        SPELL( "spell" ),
+        SPELL_INSTANT( "instantSpell" ),
+        SPELL_MOB( "mobSpell" ),
+        SPELL_MOB_AMBIENT( "mobSpellAmbient" ),
+        SPELL_WITCH( "witchMagic" ),
+        DRIP_WATER( "dripWater" ),
+        DRIP_LAVA( "dripLava" ),
+        VILLAGER_ANGRY( "angryVillager" ),
+        VILLAGER_HAPPY( "happyVillager" ),
+        TOWN_AURA( "townaura" ),
+        NOTE( "note" ),
+        PORTAL( "portal" ),
+        ENCHANTMENT_TABLE( "enchantmenttable" ),
+        FLAME( "flame" ),
+        LAVA( "lava" ),
+        FOOTSTEP( "footstep" ),
+        CLOUD( "cloud" ),
+        REDSTONE( "reddust" ),
+        SNOWBALL( "snowballpoof" ),
+        SNOW_SHOVEL( "snowshovel" ),
+        SLIME( "slime" ),
+        HEART( "heart" ),
+        BARRIER( "barrier" ),
+        ICON_CRACK( "iconcrack", 2 ),
+        BLOCK_CRACK( "blockcrack", 1 ),
+        BLOCK_DUST( "blockdust", 1 ),
+        WATER_DROP( "droplet" ),
+        ITEM_TAKE( "take" ),
+        MOB_APPEARANCE( "mobappearance" );
+
+        public final String name;
+        public final int extra;
+        private final static HashMap<String, Particle> particleMap = new HashMap<String, Particle>();
+
+        Particle(String name)
+        {
+            this( name, 0 );
+        }
+
+        Particle(String name, int extra)
+        {
+            this.name = name;
+            this.extra = extra;
+        }
+
+        public static Particle find(String part)
+        {
+            return particleMap.get( part );
+        }
+
+        static
+        {
+            for ( Particle particle : values() )
+            {
+                particleMap.put( particle.name, particle );
+            }
+        }
+    }
+    // Spigot end
+}
diff --git a/src/main/java/net/minecraft/server/PacketStatusListener.java b/src/main/java/net/minecraft/server/PacketStatusListener.java
index cd06305..f1571f1 100644
--- a/src/main/java/net/minecraft/server/PacketStatusListener.java
+++ b/src/main/java/net/minecraft/server/PacketStatusListener.java
@@ -110,13 +110,20 @@ public class PacketStatusListener implements PacketStatusInListener {
         }
 
         ServerPingPlayerSample playerSample = new ServerPingPlayerSample(event.getMaxPlayers(), profiles.size());
+        // Spigot Start
+        if ( !profiles.isEmpty() )
+        {
+            java.util.Collections.shuffle( profiles ); // This sucks, its inefficient but we have no simple way of doing it differently
+            profiles = profiles.subList( 0, Math.min( profiles.size(), org.spigotmc.SpigotConfig.playerSample ) ); // Cap the sample to n (or less) displayed players, ie: Vanilla behaviour
+        }
+        // Spigot End
         playerSample.a(profiles.toArray(new GameProfile[profiles.size()]));
 
         ServerPing ping = new ServerPing();
         ping.setFavicon(event.icon.value);
         ping.setMOTD(new ChatComponentText(event.getMotd()));
         ping.setPlayerSample(playerSample);
-        ping.setServerInfo(new ServerPingServerData(minecraftServer.getServerModName() + " " + minecraftServer.getVersion(), 5)); // TODO: Update when protocol changes
+        ping.setServerInfo(new ServerPingServerData(minecraftServer.getServerModName() + " " + minecraftServer.getVersion(), networkManager.getVersion())); // TODO: Update when protocol changes
 
         this.networkManager.handle(new PacketStatusOutServerInfo(ping), new GenericFutureListener[0]);
         // CraftBukkit end
diff --git a/src/main/java/net/minecraft/server/PathfinderGoalNearestAttackableTarget.java b/src/main/java/net/minecraft/server/PathfinderGoalNearestAttackableTarget.java
new file mode 100644
index 0000000..a9e106c
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PathfinderGoalNearestAttackableTarget.java
@@ -0,0 +1,52 @@
+package net.minecraft.server;
+
+import java.util.Collections;
+import java.util.List;
+
+public class PathfinderGoalNearestAttackableTarget extends PathfinderGoalTarget {
+
+    private final Class a;
+    private final int b;
+    private final DistanceComparator e;
+    private final IEntitySelector f;
+    private EntityLiving g;
+
+    public PathfinderGoalNearestAttackableTarget(EntityCreature entitycreature, Class oclass, int i, boolean flag) {
+        this(entitycreature, oclass, i, flag, false);
+    }
+
+    public PathfinderGoalNearestAttackableTarget(EntityCreature entitycreature, Class oclass, int i, boolean flag, boolean flag1) {
+        this(entitycreature, oclass, i, flag, flag1, (IEntitySelector) null);
+    }
+
+    public PathfinderGoalNearestAttackableTarget(EntityCreature entitycreature, Class oclass, int i, boolean flag, boolean flag1, IEntitySelector ientityselector) {
+        super(entitycreature, flag, flag1);
+        this.a = oclass;
+        this.b = i;
+        this.e = new DistanceComparator(entitycreature);
+        this.a(1);
+        this.f = new EntitySelectorNearestAttackableTarget(this, ientityselector);
+    }
+
+    public boolean a() {
+        if (this.b > 0 && this.c.aI().nextInt(this.b) != 0) {
+            return false;
+        } else {
+            double d0 = this.f();
+            List list = this.c.world.a(this.a, this.c.boundingBox.grow(d0, 4.0D, d0), this.f);
+
+            Collections.sort(list, this.e);
+            if (list.isEmpty()) {
+                return false;
+            } else {
+                this.g = (EntityLiving) list.get(0);
+                return true;
+            }
+        }
+    }
+
+    public void c() {
+        this.c.setGoalTarget(this.g);
+        super.c();
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PersistentCollection.java b/src/main/java/net/minecraft/server/PersistentCollection.java
new file mode 100644
index 0000000..e9469a5
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PersistentCollection.java
@@ -0,0 +1,185 @@
+package net.minecraft.server;
+
+import java.io.DataInputStream;
+import java.io.DataOutput;
+import java.io.DataOutputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+
+public class PersistentCollection {
+
+    private IDataManager a;
+    private Map b = new HashMap();
+    public List c = new ArrayList(); // Spigot
+    private Map d = new HashMap();
+
+    public PersistentCollection(IDataManager idatamanager) {
+        this.a = idatamanager;
+        this.b();
+    }
+
+    public PersistentBase get(Class oclass, String s) {
+        PersistentBase persistentbase = (PersistentBase) this.b.get(s);
+
+        if (persistentbase != null) {
+            return persistentbase;
+        } else {
+            if (this.a != null) {
+                try {
+                    File file1 = this.a.getDataFile(s);
+
+                    if (file1 != null && file1.exists()) {
+                        try {
+                            persistentbase = (PersistentBase) oclass.getConstructor(new Class[] { String.class}).newInstance(new Object[] { s});
+                        } catch (Exception exception) {
+                            throw new RuntimeException("Failed to instantiate " + oclass.toString(), exception);
+                        }
+
+                        FileInputStream fileinputstream = new FileInputStream(file1);
+                        NBTTagCompound nbttagcompound = NBTCompressedStreamTools.a((InputStream) fileinputstream);
+
+                        fileinputstream.close();
+                        persistentbase.a(nbttagcompound.getCompound("data"));
+                    }
+                } catch (Exception exception1) {
+                    exception1.printStackTrace();
+                }
+            }
+
+            if (persistentbase != null) {
+                this.b.put(s, persistentbase);
+                this.c.add(persistentbase);
+            }
+
+            return persistentbase;
+        }
+    }
+
+    public void a(String s, PersistentBase persistentbase) {
+        if (persistentbase == null) {
+            throw new RuntimeException("Can\'t set null data");
+        } else {
+            if (this.b.containsKey(s)) {
+                this.c.remove(this.b.remove(s));
+            }
+
+            this.b.put(s, persistentbase);
+            this.c.add(persistentbase);
+        }
+    }
+
+    public void a() {
+        for (int i = 0; i < this.c.size(); ++i) {
+            PersistentBase persistentbase = (PersistentBase) this.c.get(i);
+
+            if (persistentbase.d()) {
+                this.a(persistentbase);
+                persistentbase.a(false);
+            }
+        }
+    }
+
+    private void a(PersistentBase persistentbase) {
+        if (this.a != null) {
+            try {
+                File file1 = this.a.getDataFile(persistentbase.id);
+
+                if (file1 != null) {
+                    NBTTagCompound nbttagcompound = new NBTTagCompound();
+
+                    persistentbase.b(nbttagcompound);
+                    NBTTagCompound nbttagcompound1 = new NBTTagCompound();
+
+                    nbttagcompound1.set("data", nbttagcompound);
+                    FileOutputStream fileoutputstream = new FileOutputStream(file1);
+
+                    NBTCompressedStreamTools.a(nbttagcompound1, (OutputStream) fileoutputstream);
+                    fileoutputstream.close();
+                }
+            } catch (Exception exception) {
+                exception.printStackTrace();
+            }
+        }
+    }
+
+    private void b() {
+        try {
+            this.d.clear();
+            if (this.a == null) {
+                return;
+            }
+
+            File file1 = this.a.getDataFile("idcounts");
+
+            if (file1 != null && file1.exists()) {
+                DataInputStream datainputstream = new DataInputStream(new FileInputStream(file1));
+                NBTTagCompound nbttagcompound = NBTCompressedStreamTools.a(datainputstream);
+
+                datainputstream.close();
+                Iterator iterator = nbttagcompound.c().iterator();
+
+                while (iterator.hasNext()) {
+                    String s = (String) iterator.next();
+                    NBTBase nbtbase = nbttagcompound.get(s);
+
+                    if (nbtbase instanceof NBTTagShort) {
+                        NBTTagShort nbttagshort = (NBTTagShort) nbtbase;
+                        short short1 = nbttagshort.e();
+
+                        this.d.put(s, Short.valueOf(short1));
+                    }
+                }
+            }
+        } catch (Exception exception) {
+            exception.printStackTrace();
+        }
+    }
+
+    public int a(String s) {
+        Short oshort = (Short) this.d.get(s);
+
+        if (oshort == null) {
+            oshort = Short.valueOf((short) 0);
+        } else {
+            oshort = Short.valueOf((short) (oshort.shortValue() + 1));
+        }
+
+        this.d.put(s, oshort);
+        if (this.a == null) {
+            return oshort.shortValue();
+        } else {
+            try {
+                File file1 = this.a.getDataFile("idcounts");
+
+                if (file1 != null) {
+                    NBTTagCompound nbttagcompound = new NBTTagCompound();
+                    Iterator iterator = this.d.keySet().iterator();
+
+                    while (iterator.hasNext()) {
+                        String s1 = (String) iterator.next();
+                        short short1 = ((Short) this.d.get(s1)).shortValue();
+
+                        nbttagcompound.setShort(s1, short1);
+                    }
+
+                    DataOutputStream dataoutputstream = new DataOutputStream(new FileOutputStream(file1));
+
+                    NBTCompressedStreamTools.a(nbttagcompound, (DataOutput) dataoutputstream);
+                    dataoutputstream.close();
+                }
+            } catch (Exception exception) {
+                exception.printStackTrace();
+            }
+
+            return oshort.shortValue();
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PlayerChunk.java b/src/main/java/net/minecraft/server/PlayerChunk.java
index f5afcb7..07b9d35 100644
--- a/src/main/java/net/minecraft/server/PlayerChunk.java
+++ b/src/main/java/net/minecraft/server/PlayerChunk.java
@@ -85,7 +85,7 @@ class PlayerChunk {
             Chunk chunk = PlayerChunkMap.a(this.playerChunkMap).getChunkAt(this.location.x, this.location.z);
 
             if (chunk.isReady()) {
-                entityplayer.playerConnection.sendPacket(new PacketPlayOutMapChunk(chunk, true, 0));
+                entityplayer.playerConnection.sendPacket(new PacketPlayOutMapChunk(chunk, true, 0, entityplayer.playerConnection.networkManager.getVersion())); // Spigot - protocol patch
             }
 
             this.players.remove(entityplayer); // CraftBukkit
@@ -164,8 +164,21 @@ class PlayerChunk {
                 if (this.dirtyCount == 64) {
                     i = this.location.x * 16;
                     j = this.location.z * 16;
-                    this.sendAll(new PacketPlayOutMapChunk(PlayerChunkMap.a(this.playerChunkMap).getChunkAt(this.location.x, this.location.z), (this.f == 0xFFFF), this.f)); // CraftBukkit - send everything (including biome) if all sections flagged
+                    // Spigot start - protocol patch
+                    //this.sendAll(new PacketPlayOutMapChunk(PlayerChunkMap.a(this.playerChunkMap).getChunkAt(this.location.x, this.location.z), (this.f == 0xFFFF), this.f)); // CraftBukkit - send everything (including biome) if all sections flagged
 
+                    Chunk chunk = PlayerChunkMap.a( this.playerChunkMap ).getChunkAt( this.location.x, this.location.z );
+                    for (int idx = 0; idx < this.b.size(); ++idx) {
+                        EntityPlayer entityplayer = (EntityPlayer) this.b.get(idx);
+
+                        if (!entityplayer.chunkCoordIntPairQueue.contains(this.location)) {
+                            entityplayer.playerConnection.sendPacket(
+                                    new PacketPlayOutMapChunk( chunk, (this.f == 0xFFFF), this.f, entityplayer.playerConnection.networkManager.getVersion())
+                            );
+                        }
+                    }
+
+                    // Spigot end - protocol patch
                     for (k = 0; k < 16; ++k) {
                         if ((this.f & 1 << k) != 0) {
                             l = k << 4;
diff --git a/src/main/java/net/minecraft/server/PlayerChunkMap.java b/src/main/java/net/minecraft/server/PlayerChunkMap.java
index ae53635..6f60cac 100644
--- a/src/main/java/net/minecraft/server/PlayerChunkMap.java
+++ b/src/main/java/net/minecraft/server/PlayerChunkMap.java
@@ -26,9 +26,9 @@ public class PlayerChunkMap {
     private final int[][] i = new int[][] { { 1, 0}, { 0, 1}, { -1, 0}, { 0, -1}};
     private boolean wasNotEmpty; // CraftBukkit - add field
 
-    public PlayerChunkMap(WorldServer worldserver) {
+    public PlayerChunkMap(WorldServer worldserver, int viewDistance /* Spigot */) {
         this.world = worldserver;
-        this.a(worldserver.getMinecraftServer().getPlayerList().s());
+        this.a(viewDistance); // Spigot
     }
 
     public WorldServer a() {
@@ -250,7 +250,7 @@ public class PlayerChunkMap {
                     this.a(pair.x, pair.z, true).a(entityplayer);
                 }
 
-                if (i1 > 1 || i1 < -1 || j1 > 1 || j1 < -1) {
+                if (j1 > 1 || j1 < -1 || k1 > 1 || k1 < -1) { // Spigot - missed diff
                     Collections.sort(entityplayer.chunkCoordIntPairQueue, new ChunkCoordComparator(entityplayer));
                 }
                 // CraftBukkit end
diff --git a/src/main/java/net/minecraft/server/PlayerConnection.java b/src/main/java/net/minecraft/server/PlayerConnection.java
index 3a98439..10faa8c 100644
--- a/src/main/java/net/minecraft/server/PlayerConnection.java
+++ b/src/main/java/net/minecraft/server/PlayerConnection.java
@@ -106,6 +106,7 @@ public class PlayerConnection implements PacketPlayInListener {
     private float lastPitch = Float.MAX_VALUE;
     private float lastYaw = Float.MAX_VALUE;
     private boolean justTeleported = false;
+    private boolean hasMoved; // Spigot
 
     // For the PacketPlayOutBlockPlace hack :(
     Long lastPacket;
@@ -184,7 +185,7 @@ public class PlayerConnection implements PacketPlayInListener {
         // CraftBukkit start - Check for NaN
         if (Double.isNaN(packetplayinflying.x) || Double.isNaN(packetplayinflying.y) || Double.isNaN(packetplayinflying.z) || Double.isNaN(packetplayinflying.stance)) {
             c.warn(player.getName() + " was caught trying to crash the server with an invalid position.");
-            getPlayer().kickPlayer("Nope!");
+            getPlayer().kickPlayer("NaN in position (Hacking?)"); //Spigot "Nope" -> Descriptive reason
             return;
         }
         // CraftBukkit end
@@ -203,6 +204,18 @@ public class PlayerConnection implements PacketPlayInListener {
 
             // CraftBukkit start - fire PlayerMoveEvent
             Player player = this.getPlayer();
+            // Spigot Start
+            if ( !hasMoved )
+            {
+                Location curPos = player.getLocation();
+                lastPosX = curPos.getX();
+                lastPosY = curPos.getY();
+                lastPosZ = curPos.getZ();
+                lastYaw = curPos.getYaw();
+                lastPitch = curPos.getPitch();
+                hasMoved = true;
+            }
+            // Spigot End
             Location from = new Location(player.getWorld(), lastPosX, lastPosY, lastPosZ, lastYaw, lastPitch); // Get the Players previous Event location.
             Location to = player.getLocation().clone(); // Start off the To location as the Players current location.
 
@@ -231,7 +244,7 @@ public class PlayerConnection implements PacketPlayInListener {
                 this.lastPitch = to.getPitch();
 
                 // Skip the first time we do this
-                if (from.getX() != Double.MAX_VALUE) {
+                if (true) { // Spigot - don't skip any move events
                     PlayerMoveEvent event = new PlayerMoveEvent(player, from, to);
                     this.server.getPluginManager().callEvent(event);
 
@@ -358,7 +371,8 @@ public class PlayerConnection implements PacketPlayInListener {
                 // CraftBukkit end
                 double d10 = d7 * d7 + d8 * d8 + d9 * d9;
 
-                if (d10 > 100.0D && this.checkMovement && (!this.minecraftServer.N() || !this.minecraftServer.M().equals(this.player.getName()))) { // CraftBukkit - Added this.checkMovement condition to solve this check being triggered by teleports
+                // Spigot: make "moved too quickly" limit configurable
+                if (d10 > org.spigotmc.SpigotConfig.movedTooQuicklyThreshold && this.checkMovement && (!this.minecraftServer.N() || !this.minecraftServer.M().equals(this.player.getName()))) { // CraftBukkit - Added this.checkMovement condition to solve this check being triggered by teleports
                     c.warn(this.player.getName() + " moved too quickly! " + d4 + "," + d5 + "," + d6 + " (" + d7 + ", " + d8 + ", " + d9 + ")");
                     this.a(this.y, this.z, this.q, this.player.yaw, this.player.pitch);
                     return;
@@ -386,7 +400,8 @@ public class PlayerConnection implements PacketPlayInListener {
                 d10 = d4 * d4 + d5 * d5 + d6 * d6;
                 boolean flag1 = false;
 
-                if (d10 > 0.0625D && !this.player.isSleeping() && !this.player.playerInteractManager.isCreative()) {
+                // Spigot: make "moved wrongly" limit configurable
+                if (d10 > org.spigotmc.SpigotConfig.movedWronglyThreshold && !this.player.isSleeping() && !this.player.playerInteractManager.isCreative()) {
                     flag1 = true;
                     c.warn(this.player.getName() + " moved wrongly!");
                 }
@@ -560,7 +575,20 @@ public class PlayerConnection implements PacketPlayInListener {
         }
     }
 
+    // Spigot start - limit place/interactions
+    private long lastPlace = -1;
+    private int packets = 0;
+
     public void a(PacketPlayInBlockPlace packetplayinblockplace) {
+        boolean throttled = false;
+        if (lastPlace != -1 && packetplayinblockplace.timestamp - lastPlace < 30 && packets++ >= 4) {
+            throttled = true;
+        } else if ( packetplayinblockplace.timestamp - lastPlace >= 30 || lastPlace == -1 )
+        {
+            lastPlace = packetplayinblockplace.timestamp;
+            packets = 0;
+        }
+    // Spigot end
         WorldServer worldserver = this.minecraftServer.getWorldServer(this.player.dimension);
 
         // CraftBukkit start
@@ -603,10 +631,14 @@ public class PlayerConnection implements PacketPlayInListener {
 
             // CraftBukkit start
             int itemstackAmount = itemstack.count;
+            // Spigot start - skip the event if throttled
+            if (!throttled) {
             org.bukkit.event.player.PlayerInteractEvent event = CraftEventFactory.callPlayerInteractEvent(this.player, Action.RIGHT_CLICK_AIR, itemstack);
             if (event.useItemInHand() != Event.Result.DENY) {
                 this.player.playerInteractManager.useItem(this.player, this.player.world, itemstack);
             }
+            }
+            // Spigot end
 
             // CraftBukkit - notch decrements the counter by 1 in the above method with food,
             // snowballs and so forth, but he does it in a place that doesn't cause the
@@ -627,7 +659,7 @@ public class PlayerConnection implements PacketPlayInListener {
                 return;
             }
 
-            if (!this.player.playerInteractManager.interact(this.player, worldserver, itemstack, i, j, k, l, packetplayinblockplace.h(), packetplayinblockplace.i(), packetplayinblockplace.j())) {
+            if (throttled || !this.player.playerInteractManager.interact(this.player, worldserver, itemstack, i, j, k, l, packetplayinblockplace.h(), packetplayinblockplace.i(), packetplayinblockplace.j())) { // Spigot - skip the event if throttled
                 always = true; // force PacketPlayOutSetSlot to be sent to client to update ItemStack count
             }
             // CraftBukkit end
@@ -715,6 +747,36 @@ public class PlayerConnection implements PacketPlayInListener {
     }
 
     public void sendPacket(Packet packet) {
+        // Spigot start - protocol patch
+        if ( NetworkManager.a( networkManager ).attr( NetworkManager.protocolVersion ).get() >= 17 )
+        {
+            if ( packet instanceof PacketPlayOutWindowItems )
+            {
+                PacketPlayOutWindowItems items = (PacketPlayOutWindowItems) packet;
+                if ( player.activeContainer instanceof ContainerEnchantTable
+                        && player.activeContainer.windowId == items.a )
+                {
+                    ItemStack[] old = items.b;
+                    items.b = new ItemStack[ old.length + 1 ];
+                    items.b[ 0 ] = old[ 0 ];
+                    System.arraycopy( old, 1, items.b, 2, old.length - 1 );
+                    items.b[ 1 ] = new ItemStack( Items.INK_SACK, 3, 4 );
+
+                }
+            } else if ( packet instanceof PacketPlayOutSetSlot )
+            {
+                PacketPlayOutSetSlot items = (PacketPlayOutSetSlot) packet;
+                if ( player.activeContainer instanceof ContainerEnchantTable
+                        && player.activeContainer.windowId == items.a )
+                {
+                    if ( items.b >= 1 )
+                    {
+                        items.b++;
+                    }
+                }
+            }
+        }
+        // Spigot end
         if (packet instanceof PacketPlayOutChat) {
             PacketPlayOutChat packetplayoutchat = (PacketPlayOutChat) packet;
             EnumChatVisibility enumchatvisibility = this.player.getChatFlags();
@@ -766,7 +828,7 @@ public class PlayerConnection implements PacketPlayInListener {
             this.player.v();
         } else {
             c.warn(this.player.getName() + " tried to set an invalid carried item");
-            this.disconnect("Nope!"); // CraftBukkit
+            this.disconnect("Invalid hotbar selection (Hacking?)"); // CraftBukkit //Spigot "Nope" -> Descriptive reason
         }
     }
 
@@ -822,7 +884,18 @@ public class PlayerConnection implements PacketPlayInListener {
             } else if (s.isEmpty()) {
                 c.warn(this.player.getName() + " tried to send an empty message");
             } else if (getPlayer().isConversing()) {
-                getPlayer().acceptConversationInput(s);
+                // Spigot start
+                final String message = s;
+                this.minecraftServer.processQueue.add( new Waitable()
+                {
+                    @Override
+                    protected Object evaluate()
+                    {
+                        getPlayer().acceptConversationInput( message );
+                        return null;
+                    }
+                } );
+                // Spigot end
             } else if (this.player.getChatFlags() == EnumChatVisibility.SYSTEM) { // Re-add "Command Only" flag check
                 ChatMessage chatmessage = new ChatMessage("chat.cannotSend", new Object[0]);
 
@@ -837,9 +910,19 @@ public class PlayerConnection implements PacketPlayInListener {
                 this.minecraftServer.getPlayerList().sendMessage(chatmessage1, false);
             }
 
+            // Spigot - spam exclusions
+            boolean counted = true;
+            for ( String exclude : org.spigotmc.SpigotConfig.spamExclusions )
+            {
+                if ( exclude != null && s.startsWith( exclude ) )
+                {
+                    counted = false;
+                    break;
+                }
+            }
             // CraftBukkit start - replaced with thread safe throttle
             // this.chatThrottle += 20;
-            if (chatSpamField.addAndGet(this, 20) > 200 && !this.minecraftServer.getPlayerList().isOp(this.player.getProfile())) {
+            if (counted && chatSpamField.addAndGet(this, 20) > 200 && !this.minecraftServer.getPlayerList().isOp(this.player.getProfile())) {
                 if (packetplayinchat.a()) {
                     Waitable waitable = new Waitable() {
                         @Override
@@ -941,8 +1024,10 @@ public class PlayerConnection implements PacketPlayInListener {
     // CraftBukkit end
 
     private void handleCommand(String s) {
+        org.bukkit.craftbukkit.SpigotTimings.playerCommandTimer.startTiming(); // Spigot
+
         // CraftBukkit start - whole method
-        this.c.info(this.player.getName() + " issued server command: " + s);
+        if ( org.spigotmc.SpigotConfig.logCommands ) this.c.info(this.player.getName() + " issued server command: " + s);
 
         CraftPlayer player = this.getPlayer();
 
@@ -950,18 +1035,22 @@ public class PlayerConnection implements PacketPlayInListener {
         this.server.getPluginManager().callEvent(event);
 
         if (event.isCancelled()) {
+            org.bukkit.craftbukkit.SpigotTimings.playerCommandTimer.stopTiming(); // Spigot
             return;
         }
 
         try {
             if (this.server.dispatchCommand(event.getPlayer(), event.getMessage().substring(1))) {
+                org.bukkit.craftbukkit.SpigotTimings.playerCommandTimer.stopTiming(); // Spigot
                 return;
             }
         } catch (org.bukkit.command.CommandException ex) {
             player.sendMessage(org.bukkit.ChatColor.RED + "An internal error occurred while attempting to perform this command");
             java.util.logging.Logger.getLogger(PlayerConnection.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
+            org.bukkit.craftbukkit.SpigotTimings.playerCommandTimer.stopTiming(); // Spigot
             return;
         }
+        org.bukkit.craftbukkit.SpigotTimings.playerCommandTimer.stopTiming(); // Spigot
         //this.minecraftServer.getCommandHandler().a(this.player, s);
         // CraftBukkit end
     }
@@ -985,7 +1074,7 @@ public class PlayerConnection implements PacketPlayInListener {
             float f6 = MathHelper.sin(-f1 * 0.017453292F);
             float f7 = f4 * f5;
             float f8 = f3 * f5;
-            double d3 = 5.0D;
+            double d3 = player.playerInteractManager.getGameMode() == EnumGamemode.CREATIVE ? 5.0D : 4.5D; // Spigot
             Vec3D vec3d1 = vec3d.add((double) f7 * d3, (double) f6 * d3, (double) f8 * d3);
             MovingObjectPosition movingobjectposition = this.player.world.rayTrace(vec3d, vec3d1, false);
 
@@ -1049,9 +1138,17 @@ public class PlayerConnection implements PacketPlayInListener {
     }
 
     public void a(PacketPlayInUseEntity packetplayinuseentity) {
+        if ( packetplayinuseentity.c() == null ) return; // Spigot - protocol patch
         if (this.player.dead) return; // CraftBukkit
         WorldServer worldserver = this.minecraftServer.getWorldServer(this.player.dimension);
         Entity entity = packetplayinuseentity.a((World) worldserver);
+        // Spigot Start
+        if ( entity == player )
+        {
+            disconnect( "Cannot interact with self!" );
+            return;
+        }
+        // Spigot End
 
         this.player.v();
         if (entity != null) {
@@ -1171,6 +1268,21 @@ public class PlayerConnection implements PacketPlayInListener {
             }
 
             InventoryView inventory = this.player.activeContainer.getBukkitView();
+            // Spigot start - protocol patch
+            if ( NetworkManager.a( networkManager ).attr( NetworkManager.protocolVersion ).get() >= 17 )
+            {
+                if ( player.activeContainer instanceof ContainerEnchantTable )
+                {
+                    if ( packetplayinwindowclick.slot == 1 )
+                    {
+                        return;
+                    } else if ( packetplayinwindowclick.slot > 1 )
+                    {
+                        packetplayinwindowclick.slot--;
+                    }
+                }
+            }
+            // Spigot end
             SlotType type = CraftInventoryView.getSlotType(inventory, packetplayinwindowclick.d());
 
             InventoryClickEvent event = null;
@@ -1463,7 +1575,7 @@ public class PlayerConnection implements PacketPlayInListener {
             ItemStack itemstack = packetplayinsetcreativeslot.getItemStack();
             boolean flag1 = packetplayinsetcreativeslot.c() >= 1 && packetplayinsetcreativeslot.c() < 36 + PlayerInventory.getHotbarSize();
             // CraftBukkit - Add invalidItems check
-            boolean flag2 = itemstack == null || itemstack.getItem() != null && !invalidItems.contains(Item.getId(itemstack.getItem()));
+            boolean flag2 = itemstack == null || itemstack.getItem() != null && (!invalidItems.contains(Item.getId(itemstack.getItem())) || !org.spigotmc.SpigotConfig.filterCreativeItems); // Spigot
             boolean flag3 = itemstack == null || itemstack.getData() >= 0 && itemstack.count <= 64 && itemstack.count > 0;
 
             // CraftBukkit start - Call click event
@@ -1521,7 +1633,20 @@ public class PlayerConnection implements PacketPlayInListener {
                 if (entityitem != null) {
                     entityitem.e();
                 }
+            // Spigot start - protocol patch
+            } else
+            {
+                if ( flag1 )
+                {
+                    player.playerConnection.sendPacket(
+                            new PacketPlayOutSetSlot( 0,
+                                    packetplayinsetcreativeslot.c(),
+                                    player.defaultContainer.getSlot( packetplayinsetcreativeslot.c() ).getItem()
+                            )
+                    );
+                }
             }
+            // Spigot end
         }
     }
 
@@ -1558,6 +1683,7 @@ public class PlayerConnection implements PacketPlayInListener {
 
             for (j = 0; j < 4; ++j) {
                 boolean flag = true;
+                packetplayinupdatesign.f()[j] = packetplayinupdatesign.f()[j].replaceAll( "\uF700", "" ).replaceAll( "\uF701", "" ); // Spigot - Mac OSX sends weird chars
 
                 if (packetplayinupdatesign.f()[j].length() > 15) {
                     flag = false;
@@ -1654,7 +1780,7 @@ public class PlayerConnection implements PacketPlayInListener {
         // CraftBukkit end
 
         if ("MC|BEdit".equals(packetplayincustompayload.c())) {
-            packetdataserializer = new PacketDataSerializer(Unpooled.wrappedBuffer(packetplayincustompayload.e()));
+            packetdataserializer = new PacketDataSerializer(Unpooled.wrappedBuffer(packetplayincustompayload.e()), networkManager.getVersion()); // Spigot - protocol patch
 
             try {
                 itemstack = packetdataserializer.c();
@@ -1686,7 +1812,7 @@ public class PlayerConnection implements PacketPlayInListener {
 
             return;
         } else if ("MC|BSign".equals(packetplayincustompayload.c())) {
-            packetdataserializer = new PacketDataSerializer(Unpooled.wrappedBuffer(packetplayincustompayload.e()));
+            packetdataserializer = new PacketDataSerializer(Unpooled.wrappedBuffer(packetplayincustompayload.e()), networkManager.getVersion()); // Spigot - protocol patch
 
             try {
                 itemstack = packetdataserializer.c();
@@ -1701,7 +1827,7 @@ public class PlayerConnection implements PacketPlayInListener {
                     }
 
                     if (itemstack.getItem() == Items.WRITTEN_BOOK && itemstack1.getItem() == Items.BOOK_AND_QUILL) {
-                        CraftEventFactory.handleEditBookEvent(player, itemstack); // CraftBukkit
+                        CraftEventFactory.handleEditBookEvent(player, itemstack); // CraftBukkit
                     }
 
                     return;
@@ -1848,7 +1974,7 @@ public class PlayerConnection implements PacketPlayInListener {
     }
 
     // CraftBukkit start - Add "isDisconnected" method
-    public final boolean isDisconnected() {
+    public boolean isDisconnected() {
         return !this.player.joining && !NetworkManager.a(this.networkManager).config().isAutoRead();
     }
     // CraftBukkit end
diff --git a/src/main/java/net/minecraft/server/PlayerInteractManager.java b/src/main/java/net/minecraft/server/PlayerInteractManager.java
index 7607155..036be30 100644
--- a/src/main/java/net/minecraft/server/PlayerInteractManager.java
+++ b/src/main/java/net/minecraft/server/PlayerInteractManager.java
@@ -173,6 +173,7 @@ public class PlayerInteractManager {
                     this.o = i1;
                 }
             }
+            world.spigotConfig.antiXrayInstance.updateNearbyBlocks(world, i, j, k); // Spigot
         }
     }
 
@@ -327,6 +328,13 @@ public class PlayerInteractManager {
         int j = itemstack.getData();
         ItemStack itemstack1 = itemstack.a(world, entityhuman);
 
+        // Spigot start - protocol patch
+        if ( itemstack1 != null && itemstack1.getItem() == Items.WRITTEN_BOOK )
+        {
+            player.playerConnection.sendPacket( new PacketPlayOutCustomPayload( "MC|BOpen", new byte[0] ) );
+        }
+        // Spigot end
+
         if (itemstack1 == itemstack && (itemstack1 == null || itemstack1.count == i && itemstack1.n() <= 0 && itemstack1.getData() == j)) {
             return false;
         } else {
diff --git a/src/main/java/net/minecraft/server/PlayerList.java b/src/main/java/net/minecraft/server/PlayerList.java
index e6012fb..0359cb3 100644
--- a/src/main/java/net/minecraft/server/PlayerList.java
+++ b/src/main/java/net/minecraft/server/PlayerList.java
@@ -36,6 +36,7 @@ import org.bukkit.event.player.PlayerQuitEvent;
 import org.bukkit.event.player.PlayerRespawnEvent;
 import org.bukkit.event.player.PlayerTeleportEvent.TeleportCause;
 import org.bukkit.util.Vector;
+import org.spigotmc.event.player.PlayerSpawnLocationEvent;
 // CraftBukkit end
 
 public abstract class PlayerList {
@@ -99,6 +100,19 @@ public abstract class PlayerList {
             s1 = networkmanager.getSocketAddress().toString();
         }
 
+        // Spigot start - spawn location event
+        Player bukkitPlayer = entityplayer.getBukkitEntity();
+        PlayerSpawnLocationEvent ev = new PlayerSpawnLocationEvent(bukkitPlayer, bukkitPlayer.getLocation());
+        Bukkit.getPluginManager().callEvent(ev);
+
+        Location loc = ev.getSpawnLocation();
+        WorldServer world = ((CraftWorld) loc.getWorld()).getHandle();
+
+        entityplayer.spawnIn(world);
+        entityplayer.setPosition(loc.getX(), loc.getY(), loc.getZ());
+        entityplayer.b(loc.getYaw(), loc.getPitch()); // should be setYawAndPitch
+        // Spigot end
+
         // CraftBukkit - Moved message to after join
         // g.info(entityplayer.getName() + "[" + s1 + "] logged in with entity id " + entityplayer.getId() + " at (" + entityplayer.locX + ", " + entityplayer.locY + ", " + entityplayer.locZ + ")");
         WorldServer worldserver = this.server.getWorldServer(entityplayer.dimension);
@@ -270,7 +284,7 @@ public abstract class PlayerList {
         // CraftBukkit end
 
         // CraftBukkit start - sendAll above replaced with this loop
-        PacketPlayOutPlayerInfo packet = new PacketPlayOutPlayerInfo(entityplayer.listName, true, 1000);
+        PacketPlayOutPlayerInfo packet = PacketPlayOutPlayerInfo.addPlayer( entityplayer ); // Spigot - protocol patch
         for (int i = 0; i < this.players.size(); ++i) {
             EntityPlayer entityplayer1 = (EntityPlayer) this.players.get(i);
 
@@ -288,7 +302,7 @@ public abstract class PlayerList {
                 continue;
             }
             // .name -> .listName
-            entityplayer.playerConnection.sendPacket(new PacketPlayOutPlayerInfo(entityplayer1.listName, true, entityplayer1.ping));
+            entityplayer.playerConnection.sendPacket(PacketPlayOutPlayerInfo.addPlayer( entityplayer1 )); // Spigot - protocol patch
             // CraftBukkit end
         }
     }
@@ -324,7 +338,7 @@ public abstract class PlayerList {
 
         // CraftBukkit start - .name -> .listName, replace sendAll with loop
         // this.sendAll(new PacketPlayOutPlayerInfo(entityplayer.getName(), false, 9999));
-        PacketPlayOutPlayerInfo packet = new PacketPlayOutPlayerInfo(entityplayer.listName, false, 9999);
+        PacketPlayOutPlayerInfo packet = PacketPlayOutPlayerInfo.removePlayer( entityplayer ); // Spigot - protocol patch
         for (int i = 0; i < this.players.size(); ++i) {
             EntityPlayer entityplayer1 = (EntityPlayer) this.players.get(i);
 
@@ -350,7 +364,7 @@ public abstract class PlayerList {
 
         EntityPlayer entity = new EntityPlayer(this.server, this.server.getWorldServer(0), gameprofile, new PlayerInteractManager(this.server.getWorldServer(0)));
         Player player = entity.getBukkitEntity();
-        PlayerLoginEvent event = new PlayerLoginEvent(player, hostname, ((java.net.InetSocketAddress) socketaddress).getAddress());
+        PlayerLoginEvent event = new PlayerLoginEvent(player, hostname, ((java.net.InetSocketAddress) socketaddress).getAddress(), ((java.net.InetSocketAddress) loginlistener.networkManager.getRawAddress()).getAddress());
         String s;
 
         if (this.j.isBanned(gameprofile) && !this.j.get(gameprofile).hasExpired()) {
@@ -362,11 +376,11 @@ public abstract class PlayerList {
             }
 
             // return s;
-            event.disallow(PlayerLoginEvent.Result.KICK_BANNED, s);
+            if (!gameprofilebanentry.hasExpired()) event.disallow(PlayerLoginEvent.Result.KICK_BANNED, s); // Spigot
         } else if (!this.isWhitelisted(gameprofile)) {
             // return "You are not white-listed on this server!";
-            event.disallow(PlayerLoginEvent.Result.KICK_WHITELIST, "You are not white-listed on this server!");
-        } else if (this.k.isBanned(socketaddress) && !this.k.get(gameprofile).hasExpired()) {
+            event.disallow(PlayerLoginEvent.Result.KICK_WHITELIST, org.spigotmc.SpigotConfig.whitelistMessage); // Spigot
+        } else if (this.k.isBanned(socketaddress) && !this.k.get(socketaddress).hasExpired()) { // Spigot
             IpBanEntry ipbanentry = this.k.get(socketaddress);
 
             s = "Your IP address is banned from this server!\nReason: " + ipbanentry.getReason();
@@ -379,7 +393,7 @@ public abstract class PlayerList {
         } else {
             // return this.players.size() >= this.maxPlayers ? "The server is full!" : null;
             if (this.players.size() >= this.maxPlayers) {
-                event.disallow(PlayerLoginEvent.Result.KICK_FULL, "The server is full!");
+                event.disallow(PlayerLoginEvent.Result.KICK_FULL, org.spigotmc.SpigotConfig.serverFullMessage); // Spigot
             }
         }
 
@@ -492,6 +506,11 @@ public abstract class PlayerList {
             Player respawnPlayer = this.cserver.getPlayer(entityplayer1);
             PlayerRespawnEvent respawnEvent = new PlayerRespawnEvent(respawnPlayer, location, isBedSpawn);
             this.cserver.getPluginManager().callEvent(respawnEvent);
+            // Spigot Start
+            if (entityplayer.playerConnection.isDisconnected()) {
+                return entityplayer;
+            }
+            // Spigot End
 
             location = respawnEvent.getRespawnLocation();
             entityplayer.reset();
@@ -788,6 +807,8 @@ public abstract class PlayerList {
         // CraftBukkit end
     }
 
+    private int currentPing = 0;
+
     public void tick() {
         if (++this.t > 600) {
             this.t = 0;
@@ -800,6 +821,30 @@ public abstract class PlayerList {
             this.sendAll(new PacketPlayOutPlayerInfo(entityplayer.getName(), true, entityplayer.ping));
         }
         // CraftBukkit end */
+        // Spigot start
+        try
+        {
+            if ( !players.isEmpty() )
+            {
+                currentPing = ( currentPing + 1 ) % this.players.size();
+                EntityPlayer player = (EntityPlayer) this.players.get( currentPing );
+                if ( player.lastPing == -1 || Math.abs( player.ping - player.lastPing ) > 20 )
+                {
+                    Packet packet = PacketPlayOutPlayerInfo.updatePing( player ); // Spigot - protocol patch
+                    for ( EntityPlayer splayer : (List<EntityPlayer>) this.players )
+                    {
+                        if ( splayer.getBukkitEntity().canSee( player.getBukkitEntity() ) )
+                        {
+                            splayer.playerConnection.sendPacket( packet );
+                        }
+                    }
+                    player.lastPing = player.ping;
+                }
+            }
+        } catch ( Exception e ) {
+            // Better safe than sorry :)
+        }
+        // Spigot end
     }
 
     public void sendAll(Packet packet) {
@@ -1152,8 +1197,15 @@ public abstract class PlayerList {
     }
 
     public void u() {
-        for (int i = 0; i < this.players.size(); ++i) {
-            ((EntityPlayer) this.players.get(i)).playerConnection.disconnect(this.server.server.getShutdownMessage()); // CraftBukkit - add custom shutdown message
+        while (!this.players.isEmpty()) {
+            // Spigot start
+            EntityPlayer p = (EntityPlayer) this.players.get( 0 );
+            p.playerConnection.disconnect( this.server.server.getShutdownMessage() );
+            if ( ( !this.players.isEmpty() ) && ( this.players.get( 0 ) == p ) )
+            {
+                this.players.remove( 0 ); // Prevent shutdown hang if already disconnected
+            }
+            // Spigot end
         }
     }
 
diff --git a/src/main/java/net/minecraft/server/PlayerSelector.java b/src/main/java/net/minecraft/server/PlayerSelector.java
index 819a133..14d44f0 100644
--- a/src/main/java/net/minecraft/server/PlayerSelector.java
+++ b/src/main/java/net/minecraft/server/PlayerSelector.java
@@ -1,6 +1,10 @@
 package net.minecraft.server;
 
-import java.util.*;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
diff --git a/src/main/java/net/minecraft/server/PropertyManager.java b/src/main/java/net/minecraft/server/PropertyManager.java
index c6cd6fb..fefa221 100644
--- a/src/main/java/net/minecraft/server/PropertyManager.java
+++ b/src/main/java/net/minecraft/server/PropertyManager.java
@@ -52,7 +52,7 @@ public class PropertyManager {
     }
 
     private <T> T getOverride(String name, T value) {
-        if ((this.options != null) && (this.options.has(name))) {
+        if ((this.options != null) && (this.options.has(name)) && !name.equals( "online-mode")) { // Spigot
             return (T) this.options.valueOf(name);
         }
 
diff --git a/src/main/java/net/minecraft/server/RegionFileCache.java b/src/main/java/net/minecraft/server/RegionFileCache.java
new file mode 100644
index 0000000..829f4a3
--- /dev/null
+++ b/src/main/java/net/minecraft/server/RegionFileCache.java
@@ -0,0 +1,67 @@
+package net.minecraft.server;
+
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.File;
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Map;
+
+public class RegionFileCache {
+
+    public static final Map a = new HashMap(); // CraftBukkit - private -> public
+
+    public static synchronized RegionFile a(File file1, int i, int j) {
+        File file2 = new File(file1, "region");
+        File file3 = new File(file2, "r." + (i >> 5) + "." + (j >> 5) + ".mca");
+        RegionFile regionfile = (RegionFile) a.get(file3);
+
+        if (regionfile != null) {
+            return regionfile;
+        } else {
+            if (!file2.exists()) {
+                file2.mkdirs();
+            }
+
+            if (a.size() >= 256) {
+                a();
+            }
+
+            RegionFile regionfile1 = new RegionFile(file3);
+
+            a.put(file3, regionfile1);
+            return regionfile1;
+        }
+    }
+
+    public static synchronized void a() {
+        Iterator iterator = a.values().iterator();
+
+        while (iterator.hasNext()) {
+            RegionFile regionfile = (RegionFile) iterator.next();
+
+            try {
+                if (regionfile != null) {
+                    regionfile.c();
+                }
+            } catch (IOException ioexception) {
+                ioexception.printStackTrace();
+            }
+        }
+
+        a.clear();
+    }
+
+    public static DataInputStream c(File file1, int i, int j) {
+        RegionFile regionfile = a(file1, i, j);
+
+        return regionfile.a(i & 31, j & 31);
+    }
+
+    public static DataOutputStream d(File file1, int i, int j) {
+        RegionFile regionfile = a(file1, i, j);
+
+        return regionfile.b(i & 31, j & 31);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/RemoteControlListener.java b/src/main/java/net/minecraft/server/RemoteControlListener.java
new file mode 100644
index 0000000..f655b24
--- /dev/null
+++ b/src/main/java/net/minecraft/server/RemoteControlListener.java
@@ -0,0 +1,107 @@
+package net.minecraft.server;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.ServerSocket;
+import java.net.Socket;
+import java.net.SocketTimeoutException;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Map.Entry;
+
+public class RemoteControlListener extends RemoteConnectionThread {
+
+    private int h;
+    private int i;
+    private String j;
+    private ServerSocket k;
+    private String l;
+    private Map m;
+
+    public RemoteControlListener(IMinecraftServer iminecraftserver) {
+        super(iminecraftserver, "RCON Listener");
+        this.h = iminecraftserver.a("rcon.port", 0);
+        this.l = iminecraftserver.a("rcon.password", "");
+        this.j = iminecraftserver.y();
+        this.i = iminecraftserver.z();
+        if (0 == this.h) {
+            this.h = this.i + 10;
+            this.info("Setting default rcon port to " + this.h);
+            iminecraftserver.a("rcon.port", Integer.valueOf(this.h));
+            if (0 == this.l.length()) {
+                iminecraftserver.a("rcon.password", "");
+            }
+
+            iminecraftserver.a();
+        }
+
+        if (0 == this.j.length()) {
+            this.j = "0.0.0.0";
+        }
+
+        this.f();
+        this.k = null;
+    }
+
+    private void f() {
+        this.m = new HashMap();
+    }
+
+    private void g() {
+        Iterator iterator = this.m.entrySet().iterator();
+
+        while (iterator.hasNext()) {
+            Entry entry = (Entry) iterator.next();
+
+            if (!((RemoteControlSession) entry.getValue()).c()) {
+                iterator.remove();
+            }
+        }
+    }
+
+    public void run() {
+        this.info("RCON running on " + this.j + ":" + this.h);
+
+        try {
+            while (this.running) {
+                try {
+                    Socket socket = this.k.accept();
+
+                    socket.setSoTimeout(500);
+                    RemoteControlSession remotecontrolsession = new RemoteControlSession(this.server, socket);
+
+                    remotecontrolsession.a();
+                    this.m.put(socket.getRemoteSocketAddress(), remotecontrolsession);
+                    this.g();
+                } catch (SocketTimeoutException sockettimeoutexception) {
+                    this.g();
+                } catch (IOException ioexception) {
+                    if (this.running) {
+                        this.info("IO: " + ioexception.getMessage());
+                    }
+                }
+            }
+        } finally {
+            this.b(this.k);
+        }
+    }
+
+    public void a() {
+        if (0 == this.l.length()) {
+            this.warning("No rcon password set in \'" + this.server.b() + "\', rcon disabled!");
+        } else if (0 < this.h && '\uffff' >= this.h) {
+            if (!this.running) {
+                try {
+                    this.k = new ServerSocket(this.h, 0, InetAddress.getByName(this.j));
+                    this.k.setSoTimeout(500);
+                    super.a();
+                } catch (IOException ioexception) {
+                    this.warning("Unable to initialise rcon on " + this.j + ":" + this.h + " : " + ioexception.getMessage());
+                }
+            }
+        } else {
+            this.warning("Invalid rcon port " + this.h + " found in \'" + this.server.b() + "\', rcon disabled!");
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/ServerConnection.java b/src/main/java/net/minecraft/server/ServerConnection.java
new file mode 100644
index 0000000..981e22c
--- /dev/null
+++ b/src/main/java/net/minecraft/server/ServerConnection.java
@@ -0,0 +1,113 @@
+package net.minecraft.server;
+
+import java.net.InetAddress;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Iterator;
+import java.util.List;
+import java.util.concurrent.Callable;
+
+import net.minecraft.util.com.google.common.util.concurrent.ThreadFactoryBuilder;
+import net.minecraft.util.io.netty.bootstrap.ServerBootstrap;
+import net.minecraft.util.io.netty.channel.ChannelFuture;
+import net.minecraft.util.io.netty.channel.nio.NioEventLoopGroup;
+import net.minecraft.util.io.netty.channel.socket.nio.NioServerSocketChannel;
+import net.minecraft.util.io.netty.util.concurrent.GenericFutureListener;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+public class ServerConnection {
+
+    private static final Logger b = LogManager.getLogger();
+    private static final NioEventLoopGroup c = new NioEventLoopGroup(0, (new ThreadFactoryBuilder()).setNameFormat("Netty IO #%d").setDaemon(true).build());
+    private final MinecraftServer d;
+    public volatile boolean a;
+    private final List e = Collections.synchronizedList(new ArrayList());
+    private final List f = Collections.synchronizedList(new ArrayList());
+
+    public ServerConnection(MinecraftServer minecraftserver) {
+        this.d = minecraftserver;
+        this.a = true;
+    }
+
+    public void a(InetAddress inetaddress, int i) {
+        List list = this.e;
+
+        synchronized (this.e) {
+            this.e.add(((ServerBootstrap) ((ServerBootstrap) (new ServerBootstrap()).channel(NioServerSocketChannel.class)).childHandler(new ServerConnectionChannel(this)).group(c).localAddress(inetaddress, i)).bind().syncUninterruptibly());
+        }
+    }
+
+    public void b() {
+        this.a = false;
+        Iterator iterator = this.e.iterator();
+
+        while (iterator.hasNext()) {
+            ChannelFuture channelfuture = (ChannelFuture) iterator.next();
+
+            channelfuture.channel().close().syncUninterruptibly();
+        }
+    }
+
+    public void c() {
+        List list = this.f;
+
+        synchronized (this.f) {
+            // Spigot Start
+            // This prevents players from 'gaming' the server, and strategically relogging to increase their position in the tick order
+            if ( org.spigotmc.SpigotConfig.playerShuffle > 0 && MinecraftServer.currentTick % org.spigotmc.SpigotConfig.playerShuffle == 0 )
+            {
+                Collections.shuffle( this.f );
+            }
+            // Spigot End
+            Iterator iterator = this.f.iterator();
+
+            while (iterator.hasNext()) {
+                NetworkManager networkmanager = (NetworkManager) iterator.next();
+
+                if (!networkmanager.isConnected()) {
+                    // Spigot Start
+                    // Fix a race condition where a NetworkManager could be unregistered just before connection.
+                    if (networkmanager.preparing) continue;
+                    // Spigot End
+                    iterator.remove();
+                    if (networkmanager.f() != null) {
+                        networkmanager.getPacketListener().a(networkmanager.f());
+                    } else if (networkmanager.getPacketListener() != null) {
+                        networkmanager.getPacketListener().a(new ChatComponentText("Disconnected"));
+                    }
+                } else {
+                    try {
+                        networkmanager.a();
+                    } catch (Exception exception) {
+                        if (networkmanager.c()) {
+                            CrashReport crashreport = CrashReport.a(exception, "Ticking memory connection");
+                            CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Ticking connection");
+
+                            crashreportsystemdetails.a("Connection", (Callable) (new CrashReportServerConnection(this, networkmanager)));
+                            throw new ReportedException(crashreport);
+                        }
+
+                        b.warn("Failed to handle packet for " + networkmanager.getSocketAddress(), exception);
+                        ChatComponentText chatcomponenttext = new ChatComponentText("Internal server error");
+
+                        networkmanager.handle(new PacketPlayOutKickDisconnect(chatcomponenttext), new GenericFutureListener[] { new ServerConnectionFuture(this, networkmanager, chatcomponenttext)});
+                        networkmanager.g();
+                    }
+                }
+            }
+        }
+    }
+
+    public MinecraftServer d() {
+        return this.d;
+    }
+
+    static List a(ServerConnection serverconnection) {
+        return serverconnection.f;
+    }
+
+    static MinecraftServer b(ServerConnection serverconnection) {
+        return serverconnection.d;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/ServerConnectionChannel.java b/src/main/java/net/minecraft/server/ServerConnectionChannel.java
new file mode 100644
index 0000000..d7d93a0
--- /dev/null
+++ b/src/main/java/net/minecraft/server/ServerConnectionChannel.java
@@ -0,0 +1,37 @@
+package net.minecraft.server;
+
+import net.minecraft.util.io.netty.channel.Channel;
+import net.minecraft.util.io.netty.channel.ChannelException;
+import net.minecraft.util.io.netty.channel.ChannelInitializer;
+import net.minecraft.util.io.netty.channel.ChannelOption;
+import net.minecraft.util.io.netty.handler.timeout.ReadTimeoutHandler;
+
+class ServerConnectionChannel extends ChannelInitializer {
+
+    final ServerConnection a;
+
+    ServerConnectionChannel(ServerConnection serverconnection) {
+        this.a = serverconnection;
+    }
+
+    protected void initChannel(Channel channel) {
+        try {
+            channel.config().setOption(ChannelOption.IP_TOS, Integer.valueOf(24));
+        } catch (ChannelException channelexception) {
+            ;
+        }
+
+        try {
+            channel.config().setOption(ChannelOption.TCP_NODELAY, Boolean.valueOf(false));
+        } catch (ChannelException channelexception1) {
+            ;
+        }
+
+        channel.pipeline().addLast("timeout", new ReadTimeoutHandler(30)).addLast("legacy_query", new LegacyPingHandler(this.a)).addLast("splitter", new PacketSplitter()).addLast("decoder", new PacketDecoder(NetworkManager.h)).addLast("prepender", new PacketPrepender()).addLast("encoder", new PacketEncoder(NetworkManager.h));
+        NetworkManager networkmanager = new NetworkManager(false);
+
+        ServerConnection.a(this.a).add(networkmanager);
+        channel.pipeline().addLast("packet_handler", networkmanager);
+        networkmanager.a((PacketListener) (new HandshakeListener(ServerConnection.b(this.a), networkmanager)));
+    }
+}
diff --git a/src/main/java/net/minecraft/server/ServerStatisticManager.java b/src/main/java/net/minecraft/server/ServerStatisticManager.java
new file mode 100644
index 0000000..cea31ae
--- /dev/null
+++ b/src/main/java/net/minecraft/server/ServerStatisticManager.java
@@ -0,0 +1,212 @@
+package net.minecraft.server;
+
+import java.io.File;
+import java.io.IOException;
+import java.lang.reflect.Constructor;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Set;
+import java.util.Map.Entry;
+
+import net.minecraft.util.com.google.common.collect.Maps;
+import net.minecraft.util.com.google.common.collect.Sets;
+import net.minecraft.util.com.google.gson.JsonElement;
+import net.minecraft.util.com.google.gson.JsonObject;
+import net.minecraft.util.com.google.gson.JsonParseException;
+import net.minecraft.util.com.google.gson.JsonParser;
+import net.minecraft.util.org.apache.commons.io.FileUtils;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+public class ServerStatisticManager extends StatisticManager {
+
+    private static final Logger b = LogManager.getLogger();
+    private final MinecraftServer c;
+    private final File d;
+    private final Set e = Sets.newHashSet();
+    private int f = -300;
+    private boolean g = false;
+
+    public ServerStatisticManager(MinecraftServer minecraftserver, File file1) {
+        this.c = minecraftserver;
+        this.d = file1;
+        // Spigot start
+        for ( String name : org.spigotmc.SpigotConfig.forcedStats.keySet() )
+        {
+            StatisticWrapper wrapper = new StatisticWrapper();
+            wrapper.a( org.spigotmc.SpigotConfig.forcedStats.get( name ) );
+            a.put( StatisticList.getStatistic( name ), wrapper );
+        }
+        // Spigot end
+    }
+
+    public void a() {
+        if (this.d.isFile()) {
+            try {
+                this.a.clear();
+                this.a.putAll(this.a(FileUtils.readFileToString(this.d)));
+            } catch (IOException ioexception) {
+                b.error("Couldn\'t read statistics file " + this.d, ioexception);
+            } catch (JsonParseException jsonparseexception) {
+                b.error("Couldn\'t parse statistics file " + this.d, jsonparseexception);
+            }
+        }
+    }
+
+    public void b() {
+        if ( org.spigotmc.SpigotConfig.disableStatSaving ) return; // Spigot
+        try {
+            FileUtils.writeStringToFile(this.d, a(this.a));
+        } catch (IOException ioexception) {
+            b.error("Couldn\'t save stats", ioexception);
+        }
+    }
+
+    public void setStatistic(EntityHuman entityhuman, Statistic statistic, int i) {
+        if ( org.spigotmc.SpigotConfig.disableStatSaving ) return; // Spigot
+        int j = statistic.d() ? this.getStatisticValue(statistic) : 0;
+
+        super.setStatistic(entityhuman, statistic, i);
+        this.e.add(statistic);
+        if (statistic.d() && j == 0 && i > 0) {
+            this.g = true;
+            if (this.c.at()) {
+                this.c.getPlayerList().sendMessage(new ChatMessage("chat.type.achievement", new Object[] { entityhuman.getScoreboardDisplayName(), statistic.j()}));
+            }
+        }
+    }
+
+    public Set c() {
+        HashSet hashset = Sets.newHashSet(this.e);
+
+        this.e.clear();
+        this.g = false;
+        return hashset;
+    }
+
+    public Map a(String s) {
+        JsonElement jsonelement = (new JsonParser()).parse(s);
+
+        if (!jsonelement.isJsonObject()) {
+            return Maps.newHashMap();
+        } else {
+            JsonObject jsonobject = jsonelement.getAsJsonObject();
+            HashMap hashmap = Maps.newHashMap();
+            Iterator iterator = jsonobject.entrySet().iterator();
+
+            while (iterator.hasNext()) {
+                Entry entry = (Entry) iterator.next();
+                Statistic statistic = StatisticList.getStatistic((String) entry.getKey());
+
+                if (statistic != null) {
+                    StatisticWrapper statisticwrapper = new StatisticWrapper();
+
+                    if (((JsonElement) entry.getValue()).isJsonPrimitive() && ((JsonElement) entry.getValue()).getAsJsonPrimitive().isNumber()) {
+                        statisticwrapper.a(((JsonElement) entry.getValue()).getAsInt());
+                    } else if (((JsonElement) entry.getValue()).isJsonObject()) {
+                        JsonObject jsonobject1 = ((JsonElement) entry.getValue()).getAsJsonObject();
+
+                        if (jsonobject1.has("value") && jsonobject1.get("value").isJsonPrimitive() && jsonobject1.get("value").getAsJsonPrimitive().isNumber()) {
+                            statisticwrapper.a(jsonobject1.getAsJsonPrimitive("value").getAsInt());
+                        }
+
+                        if (jsonobject1.has("progress") && statistic.l() != null) {
+                            try {
+                                Constructor constructor = statistic.l().getConstructor(new Class[0]);
+                                IJsonStatistic ijsonstatistic = (IJsonStatistic) constructor.newInstance(new Object[0]);
+
+                                ijsonstatistic.a(jsonobject1.get("progress"));
+                                statisticwrapper.a(ijsonstatistic);
+                            } catch (Throwable throwable) {
+                                b.warn("Invalid statistic progress in " + this.d, throwable);
+                            }
+                        }
+                    }
+
+                    hashmap.put(statistic, statisticwrapper);
+                } else {
+                    b.warn("Invalid statistic in " + this.d + ": Don\'t know what " + (String) entry.getKey() + " is");
+                }
+            }
+
+            return hashmap;
+        }
+    }
+
+    public static String a(Map map) {
+        JsonObject jsonobject = new JsonObject();
+        Iterator iterator = map.entrySet().iterator();
+
+        while (iterator.hasNext()) {
+            Entry entry = (Entry) iterator.next();
+
+            if (((StatisticWrapper) entry.getValue()).b() != null) {
+                JsonObject jsonobject1 = new JsonObject();
+
+                jsonobject1.addProperty("value", Integer.valueOf(((StatisticWrapper) entry.getValue()).a()));
+
+                try {
+                    jsonobject1.add("progress", ((StatisticWrapper) entry.getValue()).b().a());
+                } catch (Throwable throwable) {
+                    b.warn("Couldn\'t save statistic " + ((Statistic) entry.getKey()).e() + ": error serializing progress", throwable);
+                }
+
+                jsonobject.add(((Statistic) entry.getKey()).name, jsonobject1);
+            } else {
+                jsonobject.addProperty(((Statistic) entry.getKey()).name, Integer.valueOf(((StatisticWrapper) entry.getValue()).a()));
+            }
+        }
+
+        return jsonobject.toString();
+    }
+
+    public void d() {
+        Iterator iterator = this.a.keySet().iterator();
+
+        while (iterator.hasNext()) {
+            Statistic statistic = (Statistic) iterator.next();
+
+            this.e.add(statistic);
+        }
+    }
+
+    public void a(EntityPlayer entityplayer) {
+        int i = this.c.al();
+        HashMap hashmap = Maps.newHashMap();
+
+        if (this.g || i - this.f > 300) {
+            this.f = i;
+            Iterator iterator = this.c().iterator();
+
+            while (iterator.hasNext()) {
+                Statistic statistic = (Statistic) iterator.next();
+
+                hashmap.put(statistic, Integer.valueOf(this.getStatisticValue(statistic)));
+            }
+        }
+
+        entityplayer.playerConnection.sendPacket(new PacketPlayOutStatistic(hashmap));
+    }
+
+    public void updateStatistics(EntityPlayer entityplayer) {
+        HashMap hashmap = Maps.newHashMap();
+        Iterator iterator = AchievementList.e.iterator();
+
+        while (iterator.hasNext()) {
+            Achievement achievement = (Achievement) iterator.next();
+
+            if (this.hasAchievement(achievement)) {
+                hashmap.put(achievement, Integer.valueOf(this.getStatisticValue(achievement)));
+                this.e.remove(achievement);
+            }
+        }
+
+        entityplayer.playerConnection.sendPacket(new PacketPlayOutStatistic(hashmap));
+    }
+
+    public boolean e() {
+        return this.g;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/ShapedRecipes.java b/src/main/java/net/minecraft/server/ShapedRecipes.java
index cc444db..867dd07 100644
--- a/src/main/java/net/minecraft/server/ShapedRecipes.java
+++ b/src/main/java/net/minecraft/server/ShapedRecipes.java
@@ -10,7 +10,7 @@ public class ShapedRecipes implements IRecipe {
     private int width;
     private int height;
     private ItemStack[] items;
-    private ItemStack result;
+    public ItemStack result; // Spigot
     private boolean e;
 
     public ShapedRecipes(int i, int j, ItemStack[] aitemstack, ItemStack itemstack) {
@@ -156,4 +156,11 @@ public class ShapedRecipes implements IRecipe {
         this.e = true;
         return this;
     }
+
+    // Spigot start
+    public java.util.List<ItemStack> getIngredients()
+    {
+        return java.util.Arrays.asList( items );
+    }
+    // Spigot end
 }
diff --git a/src/main/java/net/minecraft/server/ShapelessRecipes.java b/src/main/java/net/minecraft/server/ShapelessRecipes.java
index 0fab83c..21181fb 100644
--- a/src/main/java/net/minecraft/server/ShapelessRecipes.java
+++ b/src/main/java/net/minecraft/server/ShapelessRecipes.java
@@ -11,7 +11,7 @@ import org.bukkit.craftbukkit.inventory.CraftShapelessRecipe;
 
 public class ShapelessRecipes implements IRecipe {
 
-    private final ItemStack result;
+    public final ItemStack result; // Spigot
     private final List ingredients;
 
     public ShapelessRecipes(ItemStack itemstack, List list) {
@@ -75,4 +75,11 @@ public class ShapelessRecipes implements IRecipe {
     public int a() {
         return this.ingredients.size();
     }
+
+    // Spigot start
+    public java.util.List<ItemStack> getIngredients()
+    {
+        return java.util.Collections.unmodifiableList( ingredients );
+    }
+    // Spigot end
 }
diff --git a/src/main/java/net/minecraft/server/SpawnerCreature.java b/src/main/java/net/minecraft/server/SpawnerCreature.java
index 1dfc346..75427b5 100644
--- a/src/main/java/net/minecraft/server/SpawnerCreature.java
+++ b/src/main/java/net/minecraft/server/SpawnerCreature.java
@@ -27,6 +27,23 @@ public final class SpawnerCreature {
         return new ChunkPosition(k, i1, l);
     }
 
+    // Spigot start - get entity count only from chunks being processed in b
+    private int getEntityCount(WorldServer server, Class oClass)
+    {
+        int i = 0;
+        for ( Long coord : this.a.keySet() )
+        {
+            int x = LongHash.msw( coord );
+            int z = LongHash.lsw( coord );
+            if ( !server.chunkProviderServer.unloadQueue.contains( coord ) && server.isChunkLoaded( x, z ) )
+            {
+                i += server.getChunkAt( x, z ).entityCount.get( oClass );
+            }
+        }
+        return i;
+    }
+    // Spigot end
+
     public int spawnEntities(WorldServer worldserver, boolean flag, boolean flag1, boolean flag2) {
         if (!flag && !flag1) {
             return 0;
@@ -42,6 +59,11 @@ public final class SpawnerCreature {
 
                 j = MathHelper.floor(entityhuman.locZ / 16.0D);
                 byte b0 = 8;
+                // Spigot Start
+                b0 = worldserver.spigotConfig.mobSpawnRange;
+                b0 = ( b0 > worldserver.spigotConfig.viewDistance ) ? (byte) worldserver.spigotConfig.viewDistance : b0;
+                b0 = ( b0 > 8 ) ? 8 : b0;
+                // Spigot End
 
                 for (int l = -b0; l <= b0; ++l) {
                     for (int i1 = -b0; i1 <= b0; ++i1) {
@@ -89,13 +111,15 @@ public final class SpawnerCreature {
                 if (limit == 0) {
                     continue;
                 }
+                int mobcnt = 0;
                 // CraftBukkit end
 
-                if ((!enumcreaturetype.d() || flag1) && (enumcreaturetype.d() || flag) && (!enumcreaturetype.e() || flag2) && worldserver.a(enumcreaturetype.a()) <= limit * this.a.size() / 256) { // CraftBukkit - use per-world limits
+                if ((!enumcreaturetype.d() || flag1) && (enumcreaturetype.d() || flag) && (!enumcreaturetype.e() || flag2) && (mobcnt = getEntityCount(worldserver, enumcreaturetype.a())) <= limit * this.a.size() / 256) { // Spigot - use per-world limits and use all loaded chunks
                     Iterator iterator = this.a.keySet().iterator();
 
+                    int moblimit = (limit * this.a.size() / 256) - mobcnt + 1; // Spigot - up to 1 more than limit
                     label110:
-                    while (iterator.hasNext()) {
+                    while (iterator.hasNext() && (moblimit > 0)) { // Spigot - while more allowed
                         // CraftBukkit start = use LongHash and LongObjectHashMap
                         long key = ((Long) iterator.next()).longValue();
 
@@ -160,6 +184,13 @@ public final class SpawnerCreature {
                                                                 groupdataentity = entityinsentient.prepare(groupdataentity);
                                                                 worldserver.addEntity(entityinsentient, SpawnReason.NATURAL);
                                                                 // CraftBukkit end
+                                                                // Spigot start
+                                                                if ( --moblimit <= 0 )
+                                                                {
+                                                                    // If we're past limit, stop spawn
+                                                                    continue label110;
+                                                                }
+                                                                // Spigot end
                                                                 if (j2 >= entityinsentient.bB()) {
                                                                     continue label110;
                                                                 }
diff --git a/src/main/java/net/minecraft/server/StructureGenerator.java b/src/main/java/net/minecraft/server/StructureGenerator.java
new file mode 100644
index 0000000..f835b01
--- /dev/null
+++ b/src/main/java/net/minecraft/server/StructureGenerator.java
@@ -0,0 +1,227 @@
+package net.minecraft.server;
+
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Random;
+import java.util.concurrent.Callable;
+
+public abstract class StructureGenerator extends WorldGenBase {
+
+    private PersistentStructure e;
+    protected Map d = new HashMap();
+
+    public StructureGenerator() {}
+
+    public abstract String a();
+
+    protected final void a(World world, int i, int j, int k, int l, Block[] ablock) {
+        this.a(world);
+        if (!this.d.containsKey(Long.valueOf(ChunkCoordIntPair.a(i, j)))) {
+            this.b.nextInt();
+
+            try {
+                if (this.a(i, j)) {
+                    StructureStart structurestart = this.b(i, j);
+
+                    this.d.put(Long.valueOf(ChunkCoordIntPair.a(i, j)), structurestart);
+                    this.a(i, j, structurestart);
+                }
+            } catch (Throwable throwable) {
+                CrashReport crashreport = CrashReport.a(throwable, "Exception preparing structure feature");
+                CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Feature being prepared");
+
+                crashreportsystemdetails.a("Is feature chunk", (Callable) (new CrashReportIsFeatureChunk(this, i, j)));
+                crashreportsystemdetails.a("Chunk location", String.format("%d,%d", new Object[] { Integer.valueOf(i), Integer.valueOf(j)}));
+                crashreportsystemdetails.a("Chunk pos hash", (Callable) (new CrashReportChunkPosHash(this, i, j)));
+                crashreportsystemdetails.a("Structure type", (Callable) (new CrashReportStructureType(this)));
+                throw new ReportedException(crashreport);
+            }
+        }
+    }
+
+    public boolean a(World world, Random random, int i, int j) {
+        this.a(world);
+        int k = (i << 4) + 8;
+        int l = (j << 4) + 8;
+        boolean flag = false;
+        Iterator iterator = this.d.values().iterator();
+
+        while (iterator.hasNext()) {
+            StructureStart structurestart = (StructureStart) iterator.next();
+
+            if (structurestart.d() && structurestart.a().a(k, l, k + 15, l + 15)) {
+                structurestart.a(world, random, new StructureBoundingBox(k, l, k + 15, l + 15));
+                flag = true;
+                this.a(structurestart.e(), structurestart.f(), structurestart);
+            }
+        }
+
+        return flag;
+    }
+
+    public boolean b(int i, int j, int k) {
+        this.a(this.c);
+        return this.c(i, j, k) != null;
+    }
+
+    protected StructureStart c(int i, int j, int k) {
+        Iterator iterator = this.d.values().iterator();
+
+        while (iterator.hasNext()) {
+            StructureStart structurestart = (StructureStart) iterator.next();
+
+            if (structurestart.d() && structurestart.a().a(i, k, i, k)) {
+                Iterator iterator1 = structurestart.b().iterator();
+
+                while (iterator1.hasNext()) {
+                    StructurePiece structurepiece = (StructurePiece) iterator1.next();
+
+                    if (structurepiece.c().b(i, j, k)) {
+                        return structurestart;
+                    }
+                }
+            }
+        }
+
+        return null;
+    }
+
+    public boolean d(int i, int j, int k) {
+        this.a(this.c);
+        Iterator iterator = this.d.values().iterator();
+
+        StructureStart structurestart;
+
+        do {
+            if (!iterator.hasNext()) {
+                return false;
+            }
+
+            structurestart = (StructureStart) iterator.next();
+        } while (!structurestart.d());
+
+        return structurestart.a().a(i, k, i, k);
+    }
+
+    public ChunkPosition getNearestGeneratedFeature(World world, int i, int j, int k) {
+        this.c = world;
+        this.a(world);
+        this.b.setSeed(world.getSeed());
+        long l = this.b.nextLong();
+        long i1 = this.b.nextLong();
+        long j1 = (long) (i >> 4) * l;
+        long k1 = (long) (k >> 4) * i1;
+
+        this.b.setSeed(j1 ^ k1 ^ world.getSeed());
+        this.a(world, i >> 4, k >> 4, 0, 0, (Block[]) null);
+        double d0 = Double.MAX_VALUE;
+        ChunkPosition chunkposition = null;
+        Iterator iterator = this.d.values().iterator();
+
+        ChunkPosition chunkposition1;
+        int l1;
+        int i2;
+        double d1;
+        int j2;
+
+        while (iterator.hasNext()) {
+            StructureStart structurestart = (StructureStart) iterator.next();
+
+            if (structurestart.d()) {
+                StructurePiece structurepiece = (StructurePiece) structurestart.b().get(0);
+
+                chunkposition1 = structurepiece.a();
+                i2 = chunkposition1.x - i;
+                l1 = chunkposition1.y - j;
+                j2 = chunkposition1.z - k;
+                d1 = (double) (i2 * i2 + l1 * l1 + j2 * j2);
+                if (d1 < d0) {
+                    d0 = d1;
+                    chunkposition = chunkposition1;
+                }
+            }
+        }
+
+        if (chunkposition != null) {
+            return chunkposition;
+        } else {
+            List list = this.o_();
+
+            if (list != null) {
+                ChunkPosition chunkposition2 = null;
+                Iterator iterator1 = list.iterator();
+
+                while (iterator1.hasNext()) {
+                    chunkposition1 = (ChunkPosition) iterator1.next();
+                    i2 = chunkposition1.x - i;
+                    l1 = chunkposition1.y - j;
+                    j2 = chunkposition1.z - k;
+                    d1 = (double) (i2 * i2 + l1 * l1 + j2 * j2);
+                    if (d1 < d0) {
+                        d0 = d1;
+                        chunkposition2 = chunkposition1;
+                    }
+                }
+
+                return chunkposition2;
+            } else {
+                return null;
+            }
+        }
+    }
+
+    protected List o_() {
+        return null;
+    }
+
+    private void a(World world) {
+        if (this.e == null) {
+            // Spigot Start
+            if ( world.spigotConfig.saveStructureInfo && !this.a().equals( "Mineshaft" ) )
+            {
+            this.e = (PersistentStructure) world.a(PersistentStructure.class, this.a());
+            } else
+            {
+                this.e = new PersistentStructure( this.a() );
+            }
+            // Spigot End
+            if (this.e == null) {
+                this.e = new PersistentStructure(this.a());
+                world.a(this.a(), (PersistentBase) this.e);
+            } else {
+                NBTTagCompound nbttagcompound = this.e.a();
+                Iterator iterator = nbttagcompound.c().iterator();
+
+                while (iterator.hasNext()) {
+                    String s = (String) iterator.next();
+                    NBTBase nbtbase = nbttagcompound.get(s);
+
+                    if (nbtbase.getTypeId() == 10) {
+                        NBTTagCompound nbttagcompound1 = (NBTTagCompound) nbtbase;
+
+                        if (nbttagcompound1.hasKey("ChunkX") && nbttagcompound1.hasKey("ChunkZ")) {
+                            int i = nbttagcompound1.getInt("ChunkX");
+                            int j = nbttagcompound1.getInt("ChunkZ");
+                            StructureStart structurestart = WorldGenFactory.a(nbttagcompound1, world);
+
+                            if (structurestart != null) {
+                                this.d.put(Long.valueOf(ChunkCoordIntPair.a(i, j)), structurestart);
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    private void a(int i, int j, StructureStart structurestart) {
+        this.e.a(structurestart.a(i, j), i, j);
+        this.e.c();
+    }
+
+    protected abstract boolean a(int i, int j);
+
+    protected abstract StructureStart b(int i, int j);
+}
diff --git a/src/main/java/net/minecraft/server/ThreadPlayerLookupUUID.java b/src/main/java/net/minecraft/server/ThreadPlayerLookupUUID.java
index 6b91be7..1b2620c 100644
--- a/src/main/java/net/minecraft/server/ThreadPlayerLookupUUID.java
+++ b/src/main/java/net/minecraft/server/ThreadPlayerLookupUUID.java
@@ -25,50 +25,19 @@ class ThreadPlayerLookupUUID extends Thread {
         GameProfile gameprofile = LoginListener.a(this.a);
 
         try {
+            // Spigot Start
+            if ( !LoginListener.c( this.a ).getOnlineMode() )
+            {
+                a.initUUID();
+                fireLoginEvents();
+                return;
+            }
+            // Spigot End
             String s = (new BigInteger(MinecraftEncryption.a(LoginListener.b(this.a), LoginListener.c(this.a).K().getPublic(), LoginListener.d(this.a)))).toString(16);
 
             LoginListener.a(this.a, LoginListener.c(this.a).av().hasJoinedServer(new GameProfile((UUID) null, gameprofile.getName()), s));
             if (LoginListener.a(this.a) != null) {
-                // CraftBukkit start - fire PlayerPreLoginEvent
-                if (!this.a.networkManager.isConnected()) {
-                    return;
-                }
-
-                String playerName = LoginListener.a(this.a).getName();
-                java.net.InetAddress address = ((java.net.InetSocketAddress) a.networkManager.getSocketAddress()).getAddress();
-                java.util.UUID uniqueId = LoginListener.a(this.a).getId();
-                final org.bukkit.craftbukkit.CraftServer server = LoginListener.c(this.a).server;
-
-                AsyncPlayerPreLoginEvent asyncEvent = new AsyncPlayerPreLoginEvent(playerName, address, uniqueId);
-                server.getPluginManager().callEvent(asyncEvent);
-
-                if (PlayerPreLoginEvent.getHandlerList().getRegisteredListeners().length != 0) {
-                    final PlayerPreLoginEvent event = new PlayerPreLoginEvent(playerName, address, uniqueId);
-                    if (asyncEvent.getResult() != PlayerPreLoginEvent.Result.ALLOWED) {
-                        event.disallow(asyncEvent.getResult(), asyncEvent.getKickMessage());
-                    }
-                    Waitable<PlayerPreLoginEvent.Result> waitable = new Waitable<PlayerPreLoginEvent.Result>() {
-                        @Override
-                        protected PlayerPreLoginEvent.Result evaluate() {
-                            server.getPluginManager().callEvent(event);
-                            return event.getResult();
-                        }};
-
-                    LoginListener.c(this.a).processQueue.add(waitable);
-                    if (waitable.get() != PlayerPreLoginEvent.Result.ALLOWED) {
-                        this.a.disconnect(event.getKickMessage());
-                        return;
-                    }
-                } else {
-                    if (asyncEvent.getLoginResult() != AsyncPlayerPreLoginEvent.Result.ALLOWED) {
-                        this.a.disconnect(asyncEvent.getKickMessage());
-                        return;
-                    }
-                }
-                // CraftBukkit end
-
-                LoginListener.e().info("UUID of player " + LoginListener.a(this.a).getName() + " is " + LoginListener.a(this.a).getId());
-                LoginListener.a(this.a, EnumProtocolState.READY_TO_ACCEPT);
+                fireLoginEvents(); // Spigot
             } else if (LoginListener.c(this.a).N()) {
                 LoginListener.e().warn("Failed to verify username but will let them in anyway!");
                 LoginListener.a(this.a, this.a.a(gameprofile));
@@ -93,4 +62,48 @@ class ThreadPlayerLookupUUID extends Thread {
             // CraftBukkit end
         }
     }
+
+    private void fireLoginEvents() throws Exception
+    {
+        // CraftBukkit start - fire PlayerPreLoginEvent
+        if (!this.a.networkManager.isConnected()) {
+            return;
+        }
+
+        String playerName = LoginListener.a(this.a).getName();
+        java.net.InetAddress address = ((java.net.InetSocketAddress) a.networkManager.getSocketAddress()).getAddress();
+        java.util.UUID uniqueId = LoginListener.a(this.a).getId();
+        final org.bukkit.craftbukkit.CraftServer server = LoginListener.c(this.a).server;
+
+        AsyncPlayerPreLoginEvent asyncEvent = new AsyncPlayerPreLoginEvent(playerName, address, uniqueId);
+        server.getPluginManager().callEvent(asyncEvent);
+
+        if (PlayerPreLoginEvent.getHandlerList().getRegisteredListeners().length != 0) {
+            final PlayerPreLoginEvent event = new PlayerPreLoginEvent(playerName, address, uniqueId);
+            if (asyncEvent.getResult() != PlayerPreLoginEvent.Result.ALLOWED) {
+                event.disallow(asyncEvent.getResult(), asyncEvent.getKickMessage());
+            }
+            Waitable<PlayerPreLoginEvent.Result> waitable = new Waitable<PlayerPreLoginEvent.Result>() {
+                @Override
+                protected PlayerPreLoginEvent.Result evaluate() {
+                    server.getPluginManager().callEvent(event);
+                    return event.getResult();
+                }};
+
+            LoginListener.c(this.a).processQueue.add(waitable);
+            if (waitable.get() != PlayerPreLoginEvent.Result.ALLOWED) {
+                this.a.disconnect(event.getKickMessage());
+                return;
+            }
+        } else {
+            if (asyncEvent.getLoginResult() != AsyncPlayerPreLoginEvent.Result.ALLOWED) {
+                this.a.disconnect(asyncEvent.getKickMessage());
+                return;
+            }
+        }
+        // CraftBukkit end
+
+        LoginListener.e().info("UUID of player " + LoginListener.a(this.a).getName() + " is " + LoginListener.a(this.a).getId());
+        LoginListener.a(this.a, EnumProtocolState.READY_TO_ACCEPT);
+    }
 }
diff --git a/src/main/java/net/minecraft/server/TileEntity.java b/src/main/java/net/minecraft/server/TileEntity.java
index b2de58b..3c5ec6f 100644
--- a/src/main/java/net/minecraft/server/TileEntity.java
+++ b/src/main/java/net/minecraft/server/TileEntity.java
@@ -7,10 +7,12 @@ import java.util.concurrent.Callable;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
+import org.spigotmc.CustomTimingsHandler; // Spigot
 import org.bukkit.inventory.InventoryHolder; // CraftBukkit
 
 public class TileEntity {
 
+    public CustomTimingsHandler tickTimer = org.bukkit.craftbukkit.SpigotTimings.getTileEntityTimings(this); // Spigot
     private static final Logger a = LogManager.getLogger();
     private static Map i = new HashMap();
     private static Map j = new HashMap();
@@ -22,6 +24,40 @@ public class TileEntity {
     public int g = -1;
     public Block h;
 
+    // Spigot start
+    // Helper method for scheduleTicks. If the hopper at x0, y0, z0 is pointed
+    // at this tile entity, then make it active.
+    private void scheduleTick(int x0, int y0, int z0) {
+        TileEntity tileEntity = this.world.getTileEntity(x0, y0, z0);
+        if (tileEntity instanceof TileEntityHopper && tileEntity.world != null) {
+            // i is the metadeta assoiated with the direction the hopper faces.
+            int i = BlockHopper.b(tileEntity.p());
+            // Facing class provides arrays for direction offset.
+            if (tileEntity.x + Facing.b[i] == this.x && tileEntity.y + Facing.c[i] == this.y && tileEntity.z + Facing.d[i] == this.z) {
+                ((TileEntityHopper) tileEntity).makeTick();
+            }
+        }
+    }
+    
+    // Called from update when the contents have changed, so hoppers need updates.
+    // Check all 6 faces.
+    public void scheduleTicks() {
+        if (this.world != null && this.world.spigotConfig.altHopperTicking) {
+            // Check the top
+            this.scheduleTick(this.x, this.y + 1, this.z);
+            // Check the sides
+            for (int i = 2; i < 6; i++) {
+                this.scheduleTick(this.x + Facing.b[i], this.y, this.z + Facing.d[i]);
+            }
+            // Check the bottom.
+            TileEntity tileEntity = this.world.getTileEntity(this.x, this.y - 1, this.z);
+            if (tileEntity instanceof TileEntityHopper && tileEntity.world != null) {
+                ((TileEntityHopper) tileEntity).makeTick();
+            }
+        }
+    }
+    // Spigot end
+
     public TileEntity() {}
 
     private static void a(Class oclass, String s) {
@@ -103,6 +139,10 @@ public class TileEntity {
             if (this.q() != Blocks.AIR) {
                 this.world.updateAdjacentComparators(this.x, this.y, this.z, this.q());
             }
+            // Spigot start - Called when the contents have changed, so hoppers around this
+            // tile need updating.
+            this.scheduleTicks();
+            // Spigot end
         }
     }
 
@@ -175,7 +215,14 @@ public class TileEntity {
 
     // CraftBukkit start - add method
     public InventoryHolder getOwner() {
-        org.bukkit.block.BlockState state = world.getWorld().getBlockAt(x, y, z).getState();
+        // Spigot start
+        org.bukkit.block.Block block = world.getWorld().getBlockAt(x, y, z);
+        if (block == null) {
+            org.bukkit.Bukkit.getLogger().log(java.util.logging.Level.WARNING, "No block for owner at %s %d %d %d", new Object[]{world.getWorld(), x, y, z});
+            return null;
+        }
+        // Spigot end
+        org.bukkit.block.BlockState state = block.getState();
         if (state instanceof InventoryHolder) return (InventoryHolder) state;
         return null;
     }
diff --git a/src/main/java/net/minecraft/server/TileEntityEnderChest.java b/src/main/java/net/minecraft/server/TileEntityEnderChest.java
new file mode 100644
index 0000000..b205ab7
--- /dev/null
+++ b/src/main/java/net/minecraft/server/TileEntityEnderChest.java
@@ -0,0 +1,84 @@
+package net.minecraft.server;
+
+public class TileEntityEnderChest extends TileEntity {
+
+    public float a;
+    public float i;
+    public int j;
+    private int k;
+
+    public TileEntityEnderChest() {}
+
+    public void h() {
+        super.h();
+        if (++this.k % 20 * 4 == 0) {
+            this.world.playBlockAction(this.x, this.y, this.z, Blocks.ENDER_CHEST, 1, this.j);
+        }
+
+        this.i = this.a;
+        float f = 0.1F;
+        double d0;
+
+        if (this.j > 0 && this.a == 0.0F) {
+            double d1 = (double) this.x + 0.5D;
+
+            d0 = (double) this.z + 0.5D;
+            this.world.makeSound(d1, (double) this.y + 0.5D, d0, "random.chestopen", 0.5F, this.world.random.nextFloat() * 0.1F + 0.9F);
+        }
+
+        if (this.j == 0 && this.a > 0.0F || this.j > 0 && this.a < 1.0F) {
+            float f1 = this.a;
+
+            if (this.j > 0) {
+                this.a += f;
+            } else {
+                this.a -= f;
+            }
+
+            if (this.a > 1.0F) {
+                this.a = 1.0F;
+            }
+
+            float f2 = 0.5F;
+
+            if (this.a < f2 && f1 >= f2) {
+                d0 = (double) this.x + 0.5D;
+                double d2 = (double) this.z + 0.5D;
+
+                this.world.makeSound(d0, (double) this.y + 0.5D, d2, "random.chestclosed", 0.5F, this.world.random.nextFloat() * 0.1F + 0.9F);
+            }
+
+            if (this.a < 0.0F) {
+                this.a = 0.0F;
+            }
+        }
+    }
+
+    public boolean c(int i, int j) {
+        if (i == 1) {
+            this.j = j;
+            return true;
+        } else {
+            return super.c(i, j);
+        }
+    }
+
+    public void s() {
+        this.u();
+        super.s();
+    }
+
+    public void a() {
+        ++this.j;
+        this.world.playBlockAction(this.x, this.y, this.z, Blocks.ENDER_CHEST, 1, this.j);
+    }
+
+    public void b() {
+        --this.j;
+        this.world.playBlockAction(this.x, this.y, this.z, Blocks.ENDER_CHEST, 1, this.j);
+    }
+
+    public boolean a(EntityHuman entityhuman) {
+        return this.world.getTileEntity(this.x, this.y, this.z) != this ? false : entityhuman.e((double) this.x + 0.5D, (double) this.y + 0.5D, (double) this.z + 0.5D) <= 64.0D;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/TileEntityHopper.java b/src/main/java/net/minecraft/server/TileEntityHopper.java
index ebdf08e..65ee96c 100644
--- a/src/main/java/net/minecraft/server/TileEntityHopper.java
+++ b/src/main/java/net/minecraft/server/TileEntityHopper.java
@@ -17,6 +17,43 @@ public class TileEntityHopper extends TileEntity implements IHopper {
     private String i;
     private int j = -1;
 
+    // Spigot start
+    private long nextTick = -1; // Next tick this hopper will be ticked.
+    private long lastTick = -1; // Last tick this hopper was polled.
+    
+    // If this hopper is not cooling down, assaign a visible tick for next time.
+    public void makeTick() {
+        if (!this.j()) {
+            this.c(0);
+        }
+    }
+    
+    // Contents changed, so make this hopper active.
+    public void scheduleHopperTick() {
+        if (this.world != null && this.world.spigotConfig.altHopperTicking) {
+            this.makeTick();
+        }
+    }
+    
+	// Called after this hopper is assaigned a world or when altHopperTicking is turned
+	// on from reload.
+    public void convertToScheduling() {
+    	// j is the cooldown in ticks
+        this.c(this.j);
+    }
+    
+    // Called when alt hopper ticking is turned off from the reload command
+    public void convertToPolling() {
+        long cooldownDiff;
+        if (this.lastTick == this.world.getTime()) {
+            cooldownDiff = this.nextTick - this.world.getTime();
+        } else {
+            cooldownDiff = this.nextTick - this.world.getTime() + 1;
+        }
+        this.c((int) Math.max(0, Math.min(cooldownDiff, Integer.MAX_VALUE)));
+    }
+    // Spigot end
+
     // CraftBukkit start - add fields and methods
     public List<HumanEntity> transaction = new java.util.ArrayList<HumanEntity>();
     private int maxStack = MAX_STACK;
@@ -80,7 +117,20 @@ public class TileEntityHopper extends TileEntity implements IHopper {
         }
 
         nbttagcompound.set("Items", nbttaglist);
-        nbttagcompound.setInt("TransferCooldown", this.j);
+        // Spigot start - Need to write the correct cooldown to disk. We convert from long to int on saving.
+        if (this.world != null && this.world.spigotConfig.altHopperTicking) {
+            long cooldownDiff;
+            if (this.lastTick == this.world.getTime()) {
+                cooldownDiff = this.nextTick - this.world.getTime();
+            } else {
+                cooldownDiff = this.nextTick - this.world.getTime() + 1;
+            }
+            nbttagcompound.setInt("TransferCooldown", (int) Math.max(0, Math.min(cooldownDiff, Integer.MAX_VALUE)));
+        } else {
+        	// j is the cooldown in ticks.
+            nbttagcompound.setInt("TransferCooldown", this.j);
+        }
+        // Spigot end
         if (this.k_()) {
             nbttagcompound.setString("CustomName", this.i);
         }
@@ -88,6 +138,9 @@ public class TileEntityHopper extends TileEntity implements IHopper {
 
     public void update() {
         super.update();
+        // Spigot start - The contents have changed, so make this hopper active.
+        this.scheduleHopperTick();
+        // Spigot end
     }
 
     public int getSize() {
@@ -167,11 +220,21 @@ public class TileEntityHopper extends TileEntity implements IHopper {
 
     public void h() {
         if (this.world != null && !this.world.isStatic) {
-            --this.j;
-            if (!this.j()) {
-                this.c(0);
-                this.i();
+            // Spigot start
+            if (this.world.spigotConfig.altHopperTicking) {
+                this.lastTick = this.world.getTime();
+                if (this.nextTick == this.world.getTime()) {
+                	// Method that does the pushing and pulling.
+                    this.i();
+                }
+            } else {
+                --this.j;
+                if (!this.j()) {
+                    this.c(0);
+                    this.i();
+                }
             }
+            // Spigot end
         }
     }
 
@@ -189,12 +252,18 @@ public class TileEntityHopper extends TileEntity implements IHopper {
                 }
 
                 if (flag) {
-                    this.c(8);
+                    this.c(world.spigotConfig.hopperTransfer); // Spigot
                     this.update();
                     return true;
                 }
             }
 
+            // Spigot start
+            if ( !world.spigotConfig.altHopperTicking && !this.j() )
+            {
+                this.c( world.spigotConfig.hopperCheck );
+            }
+            // Spigot end
             return false;
         } else {
             return false;
@@ -246,7 +315,7 @@ public class TileEntityHopper extends TileEntity implements IHopper {
                     if (this.getItem(j) != null) {
                         ItemStack itemstack = this.getItem(j).cloneItemStack();
                         // CraftBukkit start - Call event when pushing items into other inventories
-                        CraftItemStack oitemstack = CraftItemStack.asCraftMirror(this.splitStack(j, 1));
+                        CraftItemStack oitemstack = CraftItemStack.asCraftMirror(this.splitStack(j, world.spigotConfig.hopperAmount)); // Spigot
 
                         Inventory destinationInventory;
                         // Have to special case large chests as they work oddly
@@ -260,11 +329,11 @@ public class TileEntityHopper extends TileEntity implements IHopper {
                         this.getWorld().getServer().getPluginManager().callEvent(event);
                         if (event.isCancelled()) {
                             this.setItem(j, itemstack);
-                            this.c(8); // Delay hopper checks
+                            this.c(world.spigotConfig.hopperTransfer); // Spigot
                             return false;
                         }
+                        int origCount = event.getItem().getAmount(); // Spigot
                         ItemStack itemstack1 = addItem(iinventory, CraftItemStack.asNMSCopy(event.getItem()), i);
-
                         if (itemstack1 == null || itemstack1.count == 0) {
                             if (event.getItem().equals(oitemstack)) {
                                 iinventory.update();
@@ -274,7 +343,7 @@ public class TileEntityHopper extends TileEntity implements IHopper {
                             // CraftBukkit end
                             return true;
                         }
-
+                        itemstack.count -= origCount - itemstack1.count; // Spigot
                         this.setItem(j, itemstack);
                     }
                 }
@@ -379,7 +448,7 @@ public class TileEntityHopper extends TileEntity implements IHopper {
         if (itemstack != null && canTakeItemFromInventory(iinventory, itemstack, i, j)) {
             ItemStack itemstack1 = itemstack.cloneItemStack();
             // CraftBukkit start - Call event on collection of items from inventories into the hopper
-            CraftItemStack oitemstack = CraftItemStack.asCraftMirror(iinventory.splitStack(i, 1));
+            CraftItemStack oitemstack = CraftItemStack.asCraftMirror(iinventory.splitStack(i, ihopper.getWorld().spigotConfig.hopperAmount)); // Spigot
 
             Inventory sourceInventory;
             // Have to special case large chests as they work oddly
@@ -396,13 +465,14 @@ public class TileEntityHopper extends TileEntity implements IHopper {
                 iinventory.setItem(i, itemstack1);
 
                 if (ihopper instanceof TileEntityHopper) {
-                    ((TileEntityHopper) ihopper).c(8); // Delay hopper checks
+                    ((TileEntityHopper) ihopper).c(ihopper.getWorld().spigotConfig.hopperTransfer); // Spigot
                 } else if (ihopper instanceof EntityMinecartHopper) {
-                    ((EntityMinecartHopper) ihopper).l(4); // Delay hopper minecart checks
+                    ((EntityMinecartHopper) ihopper).l(ihopper.getWorld().spigotConfig.hopperTransfer / 2); // Spigot
                 }
 
                 return false;
             }
+            int origCount = event.getItem().getAmount(); // Spigot
             ItemStack itemstack2 = addItem(ihopper, CraftItemStack.asNMSCopy(event.getItem()), -1);
 
             if (itemstack2 == null || itemstack2.count == 0) {
@@ -415,6 +485,7 @@ public class TileEntityHopper extends TileEntity implements IHopper {
 
                 return true;
             }
+            itemstack1.count -= origCount - itemstack2.count; // Spigot
 
             iinventory.setItem(i, itemstack1);
         }
@@ -502,7 +573,7 @@ public class TileEntityHopper extends TileEntity implements IHopper {
 
             if (flag) {
                 if (iinventory instanceof TileEntityHopper) {
-                    ((TileEntityHopper) iinventory).c(8);
+                    ((TileEntityHopper) iinventory).c(((TileEntityHopper) iinventory).world.spigotConfig.hopperTransfer); // Spigot
                     iinventory.update();
                 }
 
@@ -534,6 +605,7 @@ public class TileEntityHopper extends TileEntity implements IHopper {
         int i = MathHelper.floor(d0);
         int j = MathHelper.floor(d1);
         int k = MathHelper.floor(d2);
+        if ( !world.isLoaded( i, j, k ) ) return null; // Spigot
         TileEntity tileentity = world.getTileEntity(i, j, k);
 
         if (tileentity != null && tileentity instanceof IInventory) {
@@ -575,10 +647,34 @@ public class TileEntityHopper extends TileEntity implements IHopper {
     }
 
     public void c(int i) {
-        this.j = i;
+        // Spigot start - i is the delay for which this hopper will be ticked next.
+        // i of 1 or below implies a tick next tick.
+        if (this.world != null && this.world.spigotConfig.altHopperTicking) {
+            if (i <= 0) {
+                i = 1;
+            }
+            if (this.lastTick == this.world.getTime()) {
+                this.nextTick = this.world.getTime() + i;
+            } else {
+                this.nextTick = this.world.getTime() + i - 1;
+            }
+        } else {
+            this.j = i;
+        }
+        // Spigot end
     }
 
     public boolean j() {
-        return this.j > 0;
+        // Spigot start - Return whether this hopper is cooling down.
+        if (this.world != null && this.world.spigotConfig.altHopperTicking) {
+            if (this.lastTick == this.world.getTime()) {
+                return this.nextTick > this.world.getTime();
+            } else {
+                return this.nextTick >= this.world.getTime();
+            }
+        } else {
+            return this.j > 0;
+        }
+        // Spigot end
     }
 }
diff --git a/src/main/java/net/minecraft/server/TileEntityLightDetector.java b/src/main/java/net/minecraft/server/TileEntityLightDetector.java
new file mode 100644
index 0000000..143cffb
--- /dev/null
+++ b/src/main/java/net/minecraft/server/TileEntityLightDetector.java
@@ -0,0 +1,15 @@
+package net.minecraft.server;
+
+public class TileEntityLightDetector extends TileEntity {
+
+    public TileEntityLightDetector() {}
+
+    public void h() {
+        if (this.world != null && !this.world.isStatic && this.world.getTime() % 20L == 0L) {
+            this.h = this.q();
+            if (this.h instanceof BlockDaylightDetector) {
+                ((BlockDaylightDetector) this.h).e(this.world, this.x, this.y, this.z);
+            }
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/TileEntitySkull.java b/src/main/java/net/minecraft/server/TileEntitySkull.java
index 7c3757f..1796a56 100644
--- a/src/main/java/net/minecraft/server/TileEntitySkull.java
+++ b/src/main/java/net/minecraft/server/TileEntitySkull.java
@@ -6,11 +6,64 @@ import net.minecraft.util.com.google.common.collect.Iterables;
 import net.minecraft.util.com.mojang.authlib.GameProfile;
 import net.minecraft.util.com.mojang.authlib.properties.Property;
 
+// Spigot start
+import com.google.common.cache.Cache;
+import com.google.common.cache.CacheBuilder;
+import com.google.common.cache.CacheLoader;
+import java.util.concurrent.Executor;
+import java.util.concurrent.Executors;
+import java.util.concurrent.TimeUnit;
+
+import com.google.common.util.concurrent.ThreadFactoryBuilder;
+import net.minecraft.util.com.mojang.authlib.Agent;
+// Spigot end
+
 public class TileEntitySkull extends TileEntity {
 
     private int a;
     private int i;
     private GameProfile j = null;
+    // Spigot start
+    public static final Executor executor = Executors.newFixedThreadPool(3,
+            new ThreadFactoryBuilder()
+                    .setNameFormat("Head Conversion Thread - %1$d")
+                    .build()
+    );
+    public static final Cache<String, GameProfile> skinCache = CacheBuilder.newBuilder()
+            .maximumSize( 5000 )
+            .expireAfterAccess( 60, TimeUnit.MINUTES )
+            .build( new CacheLoader<String, GameProfile>()
+            {
+                @Override
+                public GameProfile load(String key) throws Exception
+                {
+                    GameProfile[] profiles = new GameProfile[1];
+                    GameProfileLookup gameProfileLookup = new GameProfileLookup(profiles);
+
+                    MinecraftServer.getServer().getGameProfileRepository().findProfilesByNames(new String[] { key }, Agent.MINECRAFT, gameProfileLookup);
+
+                    GameProfile profile = profiles[ 0 ];
+                    if (profile == null) {
+                        UUID uuid = EntityHuman.a(new GameProfile(null, key));
+                        profile = new GameProfile(uuid, key);
+
+                        gameProfileLookup.onProfileLookupSucceeded(profile);
+                    } else
+                    {
+
+                        Property property = Iterables.getFirst( profile.getProperties().get( "textures" ), null );
+
+                        if ( property == null )
+                        {
+                            profile = MinecraftServer.getServer().av().fillProfileProperties( profile, true );
+                        }
+                    }
+
+
+                    return profile;
+                }
+            } );
+    // Spigot end
 
     public TileEntitySkull() {}
 
@@ -23,6 +76,7 @@ public class TileEntitySkull extends TileEntity {
 
             GameProfileSerializer.serialize(nbttagcompound1, this.j);
             nbttagcompound.set("Owner", nbttagcompound1);
+            nbttagcompound.setString("ExtraType", nbttagcompound1.getString("Name")); // Spigot
         }
     }
 
@@ -65,18 +119,38 @@ public class TileEntitySkull extends TileEntity {
     private void d() {
         if (this.j != null && !UtilColor.b(this.j.getName())) {
             if (!this.j.isComplete() || !this.j.getProperties().containsKey("textures")) {
-                GameProfile gameprofile = MinecraftServer.getServer().getUserCache().getProfile(this.j.getName());
-
-                if (gameprofile != null) {
-                    Property property = (Property) Iterables.getFirst(gameprofile.getProperties().get("textures"), null);
-
-                    if (property == null) {
-                        gameprofile = MinecraftServer.getServer().av().fillProfileProperties(gameprofile, true);
+                // Spigot start - Handle async
+                final String name = this.j.getName();
+                setSkullType( 0 ); // Work around a client bug
+                executor.execute(new Runnable() {
+                    @Override
+                    public void run() {
+
+                        GameProfile profile = skinCache.getUnchecked( name.toLowerCase() );
+
+                        if (profile != null) {
+                            final GameProfile finalProfile = profile;
+                            MinecraftServer.getServer().processQueue.add(new Runnable() {
+                                @Override
+                                public void run() {
+                                    a = 3;
+                                    j = finalProfile;
+                                    world.notify( x, y, z );
+                                }
+                            });
+                        } else {
+                            MinecraftServer.getServer().processQueue.add(new Runnable() {
+                                @Override
+                                public void run() {
+                                    a = 3;
+                                    j = new GameProfile( null, name );
+                                    world.notify( x, y, z );
+                                }
+                            });
+                        }
                     }
-
-                    this.j = gameprofile;
-                    this.update();
-                }
+                });
+                // Spigot end
             }
         }
     }
diff --git a/src/main/java/net/minecraft/server/UserCache.java b/src/main/java/net/minecraft/server/UserCache.java
new file mode 100644
index 0000000..1ce89c4
--- /dev/null
+++ b/src/main/java/net/minecraft/server/UserCache.java
@@ -0,0 +1,252 @@
+package net.minecraft.server;
+
+import java.io.BufferedReader;
+import java.io.BufferedWriter;
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.lang.reflect.ParameterizedType;
+import java.text.SimpleDateFormat;
+import java.util.ArrayList;
+import java.util.Calendar;
+import java.util.Date;
+import java.util.Iterator;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+import java.util.UUID;
+
+import net.minecraft.util.com.google.common.base.Charsets;
+import net.minecraft.util.com.google.common.collect.Iterators;
+import net.minecraft.util.com.google.common.collect.Lists;
+import net.minecraft.util.com.google.common.collect.Maps;
+import net.minecraft.util.com.google.common.io.Files;
+import net.minecraft.util.com.google.gson.Gson;
+import net.minecraft.util.com.google.gson.GsonBuilder;
+import net.minecraft.util.com.mojang.authlib.Agent;
+import net.minecraft.util.com.mojang.authlib.GameProfile;
+import net.minecraft.util.org.apache.commons.io.IOUtils;
+
+public class UserCache {
+
+    public static final SimpleDateFormat a = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss Z");
+    private final Map c = Maps.newHashMap();
+    private final Map d = Maps.newHashMap();
+    private final LinkedList e = Lists.newLinkedList();
+    private final MinecraftServer f;
+    protected final Gson b;
+    private final File g;
+    private static final ParameterizedType h = new UserCacheEntryType();
+
+    public UserCache(MinecraftServer minecraftserver, File file1) {
+        this.f = minecraftserver;
+        this.g = file1;
+        GsonBuilder gsonbuilder = new GsonBuilder();
+
+        gsonbuilder.registerTypeHierarchyAdapter(UserCacheEntry.class, new BanEntrySerializer(this, (GameProfileLookup) null));
+        this.b = gsonbuilder.create();
+        this.b();
+    }
+
+    private static GameProfile a(MinecraftServer minecraftserver, String s) {
+        GameProfile[] agameprofile = new GameProfile[1];
+        GameProfileLookup gameprofilelookup = new GameProfileLookup(agameprofile);
+
+        minecraftserver.getGameProfileRepository().findProfilesByNames(new String[] { s}, Agent.MINECRAFT, gameprofilelookup);
+        if (!minecraftserver.getOnlineMode() && agameprofile[0] == null) {
+            UUID uuid = EntityHuman.a(new GameProfile((UUID) null, s));
+            GameProfile gameprofile = new GameProfile(uuid, s);
+
+            gameprofilelookup.onProfileLookupSucceeded(gameprofile);
+        }
+
+        return agameprofile[0];
+    }
+
+    public void a(GameProfile gameprofile) {
+        this.a(gameprofile, (Date) null);
+    }
+
+    private void a(GameProfile gameprofile, Date date) {
+        UUID uuid = gameprofile.getId();
+
+        if (date == null) {
+            Calendar calendar = Calendar.getInstance();
+
+            calendar.setTime(new Date());
+            calendar.add(2, 1);
+            date = calendar.getTime();
+        }
+
+        String s = gameprofile.getName().toLowerCase(Locale.ROOT);
+        UserCacheEntry usercacheentry = new UserCacheEntry(this, gameprofile, date, (GameProfileLookup) null);
+        LinkedList linkedlist = this.e;
+
+        synchronized (this.e) {
+            if (this.d.containsKey(uuid)) {
+                UserCacheEntry usercacheentry1 = (UserCacheEntry) this.d.get(uuid);
+
+                this.c.remove(usercacheentry1.a().getName().toLowerCase(Locale.ROOT));
+                this.c.put(gameprofile.getName().toLowerCase(Locale.ROOT), usercacheentry);
+                this.e.remove(gameprofile);
+            } else {
+                this.d.put(uuid, usercacheentry);
+                this.c.put(s, usercacheentry);
+            }
+
+            this.e.addFirst(gameprofile);
+        }
+    }
+
+    public GameProfile getProfile(String s) {
+        String s1 = s.toLowerCase(Locale.ROOT);
+        UserCacheEntry usercacheentry = (UserCacheEntry) this.c.get(s1);
+
+        if (usercacheentry != null && (new Date()).getTime() >= UserCacheEntry.a(usercacheentry).getTime()) {
+            this.d.remove(usercacheentry.a().getId());
+            this.c.remove(usercacheentry.a().getName().toLowerCase(Locale.ROOT));
+            LinkedList linkedlist = this.e;
+
+            synchronized (this.e) {
+                this.e.remove(usercacheentry.a());
+            }
+
+            usercacheentry = null;
+        }
+
+        GameProfile gameprofile;
+
+        if (usercacheentry != null) {
+            gameprofile = usercacheentry.a();
+            LinkedList linkedlist1 = this.e;
+
+            synchronized (this.e) {
+                this.e.remove(gameprofile);
+                this.e.addFirst(gameprofile);
+            }
+        } else {
+            gameprofile = a(this.f, s); // Spigot - use correct case for offline players
+            if (gameprofile != null) {
+                this.a(gameprofile);
+                usercacheentry = (UserCacheEntry) this.c.get(s1);
+            }
+        }
+
+        if( !org.spigotmc.SpigotConfig.saveUserCacheOnStopOnly ) this.c(); // Spigot - skip saving if disabled
+        return usercacheentry == null ? null : usercacheentry.a();
+    }
+
+    public String[] a() {
+        ArrayList arraylist = Lists.newArrayList(this.c.keySet());
+
+        return (String[]) arraylist.toArray(new String[arraylist.size()]);
+    }
+
+    public GameProfile a(UUID uuid) {
+        UserCacheEntry usercacheentry = (UserCacheEntry) this.d.get(uuid);
+
+        return usercacheentry == null ? null : usercacheentry.a();
+    }
+
+    private UserCacheEntry b(UUID uuid) {
+        UserCacheEntry usercacheentry = (UserCacheEntry) this.d.get(uuid);
+
+        if (usercacheentry != null) {
+            GameProfile gameprofile = usercacheentry.a();
+            LinkedList linkedlist = this.e;
+
+            synchronized (this.e) {
+                this.e.remove(gameprofile);
+                this.e.addFirst(gameprofile);
+            }
+        }
+
+        return usercacheentry;
+    }
+
+    public void b() {
+        List list = null;
+        BufferedReader bufferedreader = null;
+
+        label81: {
+            try {
+                bufferedreader = Files.newReader(this.g, Charsets.UTF_8);
+                list = (List) this.b.fromJson(bufferedreader, h);
+                break label81;
+            } catch (FileNotFoundException filenotfoundexception) {
+                ;
+            // Spigot Start
+            } catch (net.minecraft.util.com.google.gson.JsonSyntaxException ex) {
+                JsonList.a.warn( "Usercache.json is corrupted or has bad formatting. Deleting it to prevent further issues." );
+                this.g.delete();
+            // Spigot End
+            } finally {
+                IOUtils.closeQuietly(bufferedreader);
+            }
+
+            return;
+        }
+
+        if (list != null) {
+            this.c.clear();
+            this.d.clear();
+            LinkedList linkedlist = this.e;
+
+            synchronized (this.e) {
+                this.e.clear();
+            }
+
+            list = Lists.reverse(list);
+            Iterator iterator = list.iterator();
+
+            while (iterator.hasNext()) {
+                UserCacheEntry usercacheentry = (UserCacheEntry) iterator.next();
+
+                if (usercacheentry != null) {
+                    this.a(usercacheentry.a(), usercacheentry.b());
+                }
+            }
+        }
+    }
+
+    public void c() {
+        String s = this.b.toJson(this.a(org.spigotmc.SpigotConfig.userCacheCap));
+        BufferedWriter bufferedwriter = null;
+
+        try {
+            bufferedwriter = Files.newWriter(this.g, Charsets.UTF_8);
+            bufferedwriter.write(s);
+            return;
+        } catch (FileNotFoundException filenotfoundexception) {
+            return;
+        } catch (IOException ioexception) {
+            ;
+        } finally {
+            IOUtils.closeQuietly(bufferedwriter);
+        }
+    }
+
+    private List a(int i) {
+        ArrayList arraylist = Lists.newArrayList();
+        LinkedList linkedlist = this.e;
+        ArrayList arraylist1;
+
+        synchronized (this.e) {
+            arraylist1 = Lists.newArrayList(Iterators.limit(this.e.iterator(), i));
+        }
+
+        Iterator iterator = arraylist1.iterator();
+
+        while (iterator.hasNext()) {
+            GameProfile gameprofile = (GameProfile) iterator.next();
+            UserCacheEntry usercacheentry = this.b(gameprofile.getId());
+
+            if (usercacheentry != null) {
+                arraylist.add(usercacheentry);
+            }
+        }
+
+        return arraylist;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/UserCacheEntry.java b/src/main/java/net/minecraft/server/UserCacheEntry.java
new file mode 100644
index 0000000..fe129a5
--- /dev/null
+++ b/src/main/java/net/minecraft/server/UserCacheEntry.java
@@ -0,0 +1,34 @@
+package net.minecraft.server;
+
+import java.util.Date;
+
+import net.minecraft.util.com.mojang.authlib.GameProfile;
+
+class UserCacheEntry {
+
+    private final GameProfile b;
+    private final Date c;
+    final UserCache a;
+
+    private UserCacheEntry(UserCache usercache, GameProfile gameprofile, Date date) {
+        this.a = usercache;
+        this.b = gameprofile;
+        this.c = date;
+    }
+
+    public GameProfile a() {
+        return this.b;
+    }
+
+    public Date b() {
+        return this.c;
+    }
+
+    UserCacheEntry(UserCache usercache, GameProfile gameprofile, Date date, GameProfileLookup gameprofilelookup) {
+        this(usercache, gameprofile, date);
+    }
+
+    static Date a(UserCacheEntry usercacheentry) {
+        return usercacheentry.c;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/WatchableObject.java b/src/main/java/net/minecraft/server/WatchableObject.java
new file mode 100644
index 0000000..678aa91
--- /dev/null
+++ b/src/main/java/net/minecraft/server/WatchableObject.java
@@ -0,0 +1,44 @@
+package net.minecraft.server;
+
+public class WatchableObject {
+
+    private final int a;
+    private final int b;
+    private Object c;
+    private boolean d;
+
+    public WatchableObject(int i, int j, Object object) {
+        this.b = j;
+        this.c = object;
+        this.a = i;
+        this.d = true;
+    }
+
+    public int a() {
+        return this.b;
+    }
+
+    public void a(Object object) {
+        this.c = object;
+    }
+
+    public Object b() {
+        return this.c;
+    }
+
+    public int c() {
+        return this.a;
+    }
+
+    public boolean d() {
+        return this.d;
+    }
+
+    public void a(boolean flag) {
+        this.d = flag;
+    }
+
+    static boolean a(WatchableObject watchableobject, boolean flag) {
+        return watchableobject.d = flag;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/World.java b/src/main/java/net/minecraft/server/World.java
index 08c506c..7a547da 100644
--- a/src/main/java/net/minecraft/server/World.java
+++ b/src/main/java/net/minecraft/server/World.java
@@ -16,6 +16,7 @@ import org.bukkit.Bukkit;
 import org.bukkit.block.BlockState;
 import org.bukkit.craftbukkit.util.CraftMagicNumbers;
 import org.bukkit.craftbukkit.util.LongHashSet;
+import org.bukkit.craftbukkit.SpigotTimings; // Spigot
 import org.bukkit.generator.ChunkGenerator;
 import org.bukkit.craftbukkit.CraftServer;
 import org.bukkit.craftbukkit.CraftWorld;
@@ -30,7 +31,32 @@ import org.bukkit.event.weather.ThunderChangeEvent;
 public abstract class World implements IBlockAccess {
 
     public boolean d;
-    public List entityList = new ArrayList();
+    // Spigot start - guard entity list from removals
+    public List entityList = new ArrayList()
+    {
+        @Override
+        public Object remove(int index)
+        {
+            guard();
+            return super.remove( index );
+        }
+
+        @Override
+        public boolean remove(Object o)
+        {
+            guard();
+            return super.remove( o );
+        }
+
+        private void guard()
+        {
+            if ( guardEntityList )
+            {
+                throw new java.util.ConcurrentModificationException();
+            }
+        }
+    };
+    // Spigot end
     protected List f = new ArrayList();
     public Set tileEntityList = new HashSet(); // CraftBukkit - ArrayList -> HashSet
     private List a = new ArrayList();
@@ -62,7 +88,7 @@ public abstract class World implements IBlockAccess {
     public Scoreboard scoreboard = new Scoreboard(); // CraftBukkit - protected -> public
     public boolean isStatic;
     // CraftBukkit start - public, longhashset
-    protected LongHashSet chunkTickList = new LongHashSet();
+    // protected LongHashSet chunkTickList = new LongHashSet(); // Spigot
     private int K;
     public boolean allowMonsters;
     public boolean allowAnimals;
@@ -79,6 +105,70 @@ public abstract class World implements IBlockAccess {
     private boolean M;
     int[] I;
 
+    // Spigot start
+    private boolean guardEntityList;
+    protected final net.minecraft.util.gnu.trove.map.hash.TLongShortHashMap chunkTickList;
+    protected float growthOdds = 100;
+    protected float modifiedOdds = 100;
+    private final byte chunkTickRadius;
+    public static boolean haveWeSilencedAPhysicsCrash;
+    public static String blockLocation;
+    public List<TileEntity> triggerHoppersList = new ArrayList<TileEntity>(); // Spigot, When altHopperTicking, tile entities being added go through here.
+
+    public static long chunkToKey(int x, int z)
+    {
+        long k = ( ( ( (long) x ) & 0xFFFF0000L ) << 16 ) | ( ( ( (long) x ) & 0x0000FFFFL ) << 0 );
+        k     |= ( ( ( (long) z ) & 0xFFFF0000L ) << 32 ) | ( ( ( (long) z ) & 0x0000FFFFL ) << 16 );
+        return k;
+    }
+
+    public static int keyToX(long k)
+    {
+        return (int) ( ( ( k >> 16 ) & 0xFFFF0000 ) | ( k & 0x0000FFFF ) );
+    }
+
+    public static int keyToZ(long k)
+    {
+        return (int) ( ( ( k >> 32 ) & 0xFFFF0000L ) | ( ( k >> 16 ) & 0x0000FFFF ) );
+    }
+
+    // Spigot Start - Hoppers need to be born ticking.
+    private void initializeHoppers() {
+        if (this.spigotConfig.altHopperTicking) {
+            for (TileEntity o : this.triggerHoppersList) {
+                o.scheduleTicks();
+                if (o instanceof TileEntityHopper) {
+                    ((TileEntityHopper) o).convertToScheduling();
+                    ((TileEntityHopper) o).scheduleHopperTick();
+                }
+            }
+        }
+        triggerHoppersList.clear();
+    }
+    
+    // Helper method for altHopperTicking. Updates chests at the specified location,
+    // accounting for double chests. Updating the chest will update adjacent hoppers.
+    public void updateChestAndHoppers(int a, int b, int c) {
+        Block block = this.getType(a, b, c);
+        if (block instanceof BlockChest) {
+            TileEntity tile = this.getTileEntity(a, b, c);
+            if (tile instanceof TileEntityChest) {
+                tile.scheduleTicks();
+            }
+            for (int i = 2; i < 6; i++) {
+            	// Facing class provides arrays for direction offset.
+                if (this.getType(a + Facing.b[i], b, c + Facing.d[i]) == block) {
+                    tile = this.getTileEntity(a + Facing.b[i], b, c + Facing.d[i]);
+                    if (tile instanceof TileEntityChest) {
+                        tile.scheduleTicks();
+                    }
+                    break;
+                }
+            }
+        }
+    }
+    // Spigot end
+
     public BiomeBase getBiome(int i, int j) {
         if (this.isLoaded(i, 0, j)) {
             Chunk chunk = this.getChunkAtWorldCoords(i, j);
@@ -106,6 +196,9 @@ public abstract class World implements IBlockAccess {
     public boolean pvpMode;
     public boolean keepSpawnInMemory = true;
     public ChunkGenerator generator;
+    public final org.spigotmc.SpigotWorldConfig spigotConfig; // Spigot
+
+    public final SpigotTimings.WorldTimingsHandler timings; // Spigot
 
     public CraftWorld getWorld() {
         return this.world;
@@ -121,11 +214,17 @@ public abstract class World implements IBlockAccess {
 
     // Changed signature - added gen and env
     public World(IDataManager idatamanager, String s, WorldSettings worldsettings, WorldProvider worldprovider, MethodProfiler methodprofiler, ChunkGenerator gen, org.bukkit.World.Environment env) {
+        this.spigotConfig = new org.spigotmc.SpigotWorldConfig( s ); // Spigot
         this.generator = gen;
         this.world = new CraftWorld((WorldServer) this, gen, env);
         this.ticksPerAnimalSpawns = this.getServer().getTicksPerAnimalSpawns(); // CraftBukkit
         this.ticksPerMonsterSpawns = this.getServer().getTicksPerMonsterSpawns(); // CraftBukkit
         // CraftBukkit end
+        // Spigot start
+        this.chunkTickRadius = (byte) ( ( this.getServer().getViewDistance() < 7 ) ? this.getServer().getViewDistance() : 7 );
+        this.chunkTickList = new net.minecraft.util.gnu.trove.map.hash.TLongShortHashMap( spigotConfig.chunksPerTick * 5, 0.7f, Long.MIN_VALUE, Short.MIN_VALUE );
+        this.chunkTickList.setAutoCompactionFactor( 0 );
+        // Spigot end
 
         this.K = this.random.nextInt(12000);
         this.allowMonsters = true;
@@ -152,6 +251,7 @@ public abstract class World implements IBlockAccess {
 
         this.worldProvider.a(this);
         this.chunkProvider = this.j();
+        timings = new SpigotTimings.WorldTimingsHandler(this); // Spigot - code below can generate new world and access timings
         if (!this.worldData.isInitialized()) {
             try {
                 this.a(worldsettings);
@@ -202,9 +302,16 @@ public abstract class World implements IBlockAccess {
         return this.getType(i, k, j);
     }
 
-    public Block getType(int i, int j, int k) {
+    // Spigot start
+    public Block getType(int i, int j, int k)
+    {
+        return getType( i, j, k, true );
+    }
+
+    public Block getType(int i, int j, int k, boolean useCaptured) {
         // CraftBukkit start - tree generation
-        if (captureTreeGeneration) {
+        if (captureTreeGeneration && useCaptured) {
+    // Spigot end
             Iterator<BlockState> it = capturedBlockStates.iterator();
             while (it.hasNext()) {
                 BlockState previous = it.next();
@@ -337,6 +444,14 @@ public abstract class World implements IBlockAccess {
                     this.notifyAndUpdatePhysics(i, j, k, chunk, block1, block, i1);
                 // CraftBukkit end
                 }
+                // Spigot start - If this block is changing to that which a chest beneath it
+                // becomes able to be opened, then the chest must be updated.
+                // block1 is the old block. block is the new block. r returns true if the block type
+                // prevents access to a chest.
+                if (this.spigotConfig.altHopperTicking && block1 != null && block1.r() && !block.r()) {
+                    this.updateChestAndHoppers(i, j - 1, k);
+                }
+                // Spigot end
 
                 return flag;
             }
@@ -516,6 +631,7 @@ public abstract class World implements IBlockAccess {
         this.e(i, j + 1, k, block);
         this.e(i, j, k - 1, block);
         this.e(i, j, k + 1, block);
+        spigotConfig.antiXrayInstance.updateNearbyBlocks(this, i, j, k); // Spigot
     }
 
     public void b(int i, int j, int k, Block block, int l) {
@@ -562,6 +678,9 @@ public abstract class World implements IBlockAccess {
                 // CraftBukkit end
 
                 block1.doPhysics(this, i, j, k, block);
+            } catch (StackOverflowError stackoverflowerror) { // Spigot Start
+                haveWeSilencedAPhysicsCrash = true;
+                blockLocation = i + ", " + j + ", " + k; // Spigot End
             } catch (Throwable throwable) {
                 CrashReport crashreport = CrashReport.a(throwable, "Exception while updating neighbours");
                 CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Block being updated");
@@ -948,6 +1067,7 @@ public abstract class World implements IBlockAccess {
     }
 
     public boolean addEntity(Entity entity, SpawnReason spawnReason) { // Changed signature, added SpawnReason
+        org.spigotmc.AsyncCatcher.catchOp( "entity add"); // Spigot
         if (entity == null) return false;
         // CraftBukkit end
 
@@ -979,6 +1099,23 @@ public abstract class World implements IBlockAccess {
             // Not all projectiles extend EntityProjectile, so check for Bukkit interface instead
             event = CraftEventFactory.callProjectileLaunchEvent(entity);
         }
+        // Spigot start
+        else if (entity instanceof EntityExperienceOrb) {
+            EntityExperienceOrb xp = (EntityExperienceOrb) entity;
+            double radius = spigotConfig.expMerge;
+            if (radius > 0) {
+                List<Entity> entities = this.getEntities(entity, entity.boundingBox.grow(radius, radius, radius));
+                for (Entity e : entities) {
+                    if (e instanceof EntityExperienceOrb) {
+                        EntityExperienceOrb loopItem = (EntityExperienceOrb) e;
+                        if (!loopItem.dead) {
+                            xp.value += loopItem.value;
+                            loopItem.die();
+                        }
+                    }
+                }
+            }
+        } // Spigot end
 
         if (event != null && (event.isCancelled() || entity.dead)) {
             entity.dead = true;
@@ -1033,33 +1170,52 @@ public abstract class World implements IBlockAccess {
         entity.die();
         if (entity instanceof EntityHuman) {
             this.players.remove(entity);
+            // Spigot start
+            for ( Object o : worldMaps.c )
+            {
+                if ( o instanceof WorldMap )
+                {
+                    WorldMap map = (WorldMap) o;
+                    map.i.remove( entity );
+                    for ( Iterator<WorldMapHumanTracker> iter = (Iterator<WorldMapHumanTracker>) map.f.iterator(); iter.hasNext(); )
+                    {
+                        if ( iter.next().trackee == entity )
+                        {
+                            iter.remove();
+                        }
+                    }
+                }
+            }
+            // Spigot end
             this.everyoneSleeping();
         }
     }
 
     public void removeEntity(Entity entity) {
+        org.spigotmc.AsyncCatcher.catchOp( "entity remove"); // Spigot
         entity.die();
         if (entity instanceof EntityHuman) {
             this.players.remove(entity);
             this.everyoneSleeping();
         }
-
-        int i = entity.ah;
-        int j = entity.aj;
-
-        if (entity.ag && this.isChunkLoaded(i, j)) {
-            this.getChunkAt(i, j).b(entity);
-        }
-
-        // CraftBukkit start - Decrement loop variable field if we've already ticked this entity
-        int index = this.entityList.indexOf(entity);
-        if (index != -1) {
-            if (index <= this.tickPosition) {
-                this.tickPosition--;
+        // Spigot start
+        if (!guardEntityList) { // It will get removed after the tick if we are ticking
+            int i = entity.ah;
+            int j = entity.aj;
+            if (entity.ag && this.isChunkLoaded(i, j)) {
+                this.getChunkAt(i, j).b(entity);
+            }
+            // CraftBukkit start - Decrement loop variable field if we've already ticked this entity
+            int index = this.entityList.indexOf(entity);
+            if (index != -1) {
+                if (index <= this.tickPosition) {
+                    this.tickPosition--;
+                }
+                this.entityList.remove(index);
             }
-            this.entityList.remove(index);
+            // CraftBukkit end
         }
-        // CraftBukkit end
+        // Spigot end
 
         this.b(entity);
     }
@@ -1077,23 +1233,42 @@ public abstract class World implements IBlockAccess {
         int i1 = MathHelper.floor(axisalignedbb.c);
         int j1 = MathHelper.floor(axisalignedbb.f + 1.0D);
 
-        for (int k1 = i; k1 < j; ++k1) {
-            for (int l1 = i1; l1 < j1; ++l1) {
-                if (this.isLoaded(k1, 64, l1)) {
-                    for (int i2 = k - 1; i2 < l; ++i2) {
-                        Block block;
-
-                        if (k1 >= -30000000 && k1 < 30000000 && l1 >= -30000000 && l1 < 30000000) {
-                            block = this.getType(k1, i2, l1);
-                        } else {
-                            block = Blocks.STONE;
+        // Spigot start
+        int ystart = ( ( k - 1 ) < 0 ) ? 0 : ( k - 1 );
+        for ( int chunkx = ( i >> 4 ); chunkx <= ( ( j - 1 ) >> 4 ); chunkx++ )
+        {
+            int cx = chunkx << 4;
+            for ( int chunkz = ( i1 >> 4 ); chunkz <= ( ( j1 - 1 ) >> 4 ); chunkz++ )
+            {
+                if ( !this.isChunkLoaded( chunkx, chunkz ) )
+                {
+                    continue;
+                }
+                int cz = chunkz << 4;
+                Chunk chunk = this.getChunkAt( chunkx, chunkz );
+                // Compute ranges within chunk
+                int xstart = ( i < cx ) ? cx : i;
+                int xend = ( j < ( cx + 16 ) ) ? j : ( cx + 16 );
+                int zstart = ( i1 < cz ) ? cz : i1;
+                int zend = ( j1 < ( cz + 16 ) ) ? j1 : ( cz + 16 );
+                // Loop through blocks within chunk
+                for ( int x = xstart; x < xend; x++ )
+                {
+                    for ( int z = zstart; z < zend; z++ )
+                    {
+                        for ( int y = ystart; y < l; y++ )
+                        {
+                            Block block = chunk.getType(x - cx, y, z - cz );
+                            if ( block != null )
+                            {
+                                block.a( this, x, y, z, axisalignedbb, this.L, entity );
+                            }
                         }
-
-                        block.a(this, k1, i2, l1, axisalignedbb, this.L, entity);
                     }
                 }
             }
         }
+        // Spigot end
 
         double d0 = 0.25D;
         List list = this.getEntities(entity, axisalignedbb.grow(d0, d0, d0));
@@ -1263,6 +1438,9 @@ public abstract class World implements IBlockAccess {
         this.f.clear();
         this.methodProfiler.c("regular");
 
+        org.spigotmc.ActivationRange.activateEntities(this); // Spigot
+        timings.entityTick.startTiming(); // Spigot
+        guardEntityList = true; // Spigot
         // CraftBukkit start - Use field for loop variable
         for (this.tickPosition = 0; this.tickPosition < this.entityList.size(); ++this.tickPosition) {
             entity = (Entity) this.entityList.get(this.tickPosition);
@@ -1278,7 +1456,9 @@ public abstract class World implements IBlockAccess {
             this.methodProfiler.a("tick");
             if (!entity.dead) {
                 try {
+                    SpigotTimings.tickEntityTimer.startTiming(); // Spigot
                     this.playerJoinedWorld(entity);
+                    SpigotTimings.tickEntityTimer.stopTiming(); // Spigot
                 } catch (Throwable throwable1) {
                     crashreport = CrashReport.a(throwable1, "Ticking entity");
                     crashreportsystemdetails = crashreport.a("Entity being ticked");
@@ -1296,31 +1476,47 @@ public abstract class World implements IBlockAccess {
                     this.getChunkAt(j, k).b(entity);
                 }
 
+                guardEntityList = false; // Spigot
                 this.entityList.remove(this.tickPosition--); // CraftBukkit - Use field for loop variable
+                guardEntityList = true; // Spigot
                 this.b(entity);
             }
 
             this.methodProfiler.b();
         }
+        guardEntityList = false; // Spigot
 
+        timings.entityTick.stopTiming(); // Spigot
         this.methodProfiler.c("blockEntities");
+        timings.tileEntityTick.startTiming(); // Spigot
         this.M = true;
         // CraftBukkit start - From below, clean up tile entities before ticking them
         if (!this.b.isEmpty()) {
             this.tileEntityList.removeAll(this.b);
             this.b.clear();
         }
-        // CraftBukkit end
+        // Spigot End
 
+        this.initializeHoppers(); // Spigot - Initializes hoppers which have been added recently.
         Iterator iterator = this.tileEntityList.iterator();
 
         while (iterator.hasNext()) {
             TileEntity tileentity = (TileEntity) iterator.next();
+            // Spigot start
+            if (tileentity == null) {
+                getServer().getLogger().severe("Spigot has detected a null entity and has removed it, preventing a crash");
+                iterator.remove();
+                continue;
+            }
+            // Spigot end
 
             if (!tileentity.r() && tileentity.o() && this.isLoaded(tileentity.x, tileentity.y, tileentity.z)) {
                 try {
+                    tileentity.tickTimer.startTiming(); // Spigot
                     tileentity.h();
+                    tileentity.tickTimer.stopTiming(); // Spigot
                 } catch (Throwable throwable2) {
+                    tileentity.tickTimer.stopTiming(); // Spigot
                     crashreport = CrashReport.a(throwable2, "Ticking block entity");
                     crashreportsystemdetails = crashreport.a("Block entity being ticked");
                     tileentity.a(crashreportsystemdetails);
@@ -1340,6 +1536,8 @@ public abstract class World implements IBlockAccess {
             }
         }
 
+        timings.tileEntityTick.stopTiming(); // Spigot
+        timings.tileEntityPending.startTiming(); // Spigot
         this.M = false;
         /* CraftBukkit start - Moved up
         if (!this.b.isEmpty()) {
@@ -1380,6 +1578,7 @@ public abstract class World implements IBlockAccess {
             this.a.clear();
         }
 
+        timings.tileEntityPending.stopTiming(); // Spigot
         this.methodProfiler.b();
         this.methodProfiler.b();
     }
@@ -1401,9 +1600,12 @@ public abstract class World implements IBlockAccess {
         int j = MathHelper.floor(entity.locZ);
         byte b0 = 32;
 
-        // CraftBukkit start - Use neighbor cache instead of looking up
-        Chunk startingChunk = this.getChunkIfLoaded(i >> 4, j >> 4);
-        if (!flag || (startingChunk != null && startingChunk.areNeighborsLoaded(2)) /* this.b(i - b0, 0, j - b0, i + b0, 0, j + b0) */) {
+        // Spigot start
+        if (!org.spigotmc.ActivationRange.checkIfActive(entity)) {
+            entity.ticksLived++;
+            entity.inactiveTick();
+        } else {
+            entity.tickTimer.startTiming(); // Spigot
             // CraftBukkit end
             entity.S = entity.locX;
             entity.T = entity.locY;
@@ -1466,6 +1668,7 @@ public abstract class World implements IBlockAccess {
                     entity.passenger = null;
                 }
             }
+            entity.tickTimer.stopTiming(); // Spigot
         }
     }
 
@@ -1816,6 +2019,7 @@ public abstract class World implements IBlockAccess {
                     }
                 }
 
+                tileentity.a(this); // Spigot - No null worlds
                 this.a.add(tileentity);
             } else {
                 this.tileEntityList.add(tileentity);
@@ -1985,17 +2189,44 @@ public abstract class World implements IBlockAccess {
         int k;
         int l;
 
+        // Spigot start
+        int optimalChunks = spigotConfig.chunksPerTick;
+        // Quick conditions to allow us to exist early
+        if ( optimalChunks <= 0 || players.isEmpty() )
+        {
+            return;
+        }
+        // Keep chunks with growth inside of the optimal chunk range
+        int chunksPerPlayer = Math.min( 200, Math.max( 1, (int) ( ( ( optimalChunks - players.size() ) / (double) players.size() ) + 0.5 ) ) );
+        int randRange = 3 + chunksPerPlayer / 30;
+        // Limit to normal tick radius - including view distance
+        randRange = ( randRange > chunkTickRadius ) ? chunkTickRadius : randRange;
+        // odds of growth happening vs growth happening in vanilla
+        this.growthOdds = this.modifiedOdds = Math.max( 35, Math.min( 100, ( ( chunksPerPlayer + 1 ) * 100F ) / 15F ) );
+        // Spigot end
         for (i = 0; i < this.players.size(); ++i) {
             entityhuman = (EntityHuman) this.players.get(i);
             j = MathHelper.floor(entityhuman.locX / 16.0D);
             k = MathHelper.floor(entityhuman.locZ / 16.0D);
             l = this.p();
 
-            for (int i1 = -l; i1 <= l; ++i1) {
-                for (int j1 = -l; j1 <= l; ++j1) {
-                    this.chunkTickList.add(org.bukkit.craftbukkit.util.LongHash.toLong(i1 + j, j1 + k)); // CraftBukkit
+            // Spigot start - Always update the chunk the player is on
+            long key = chunkToKey( j, k );
+            int existingPlayers = Math.max( 0, chunkTickList.get( key ) ); // filter out -1
+            chunkTickList.put(key, (short) (existingPlayers + 1));
+
+            // Check and see if we update the chunks surrounding the player this tick
+            for ( int chunk = 0; chunk < chunksPerPlayer; chunk++ )
+            {
+                int dx = ( random.nextBoolean() ? 1 : -1 ) * random.nextInt( randRange );
+                int dz = ( random.nextBoolean() ? 1 : -1 ) * random.nextInt( randRange );
+                long hash = chunkToKey( dx + j, dz + k );
+                if ( !chunkTickList.contains( hash ) && this.isChunkLoaded( dx + j, dz + k ) )
+                {
+                    chunkTickList.put( hash, (short) -1 ); // no players
                 }
             }
+            // Spigot End
         }
 
         this.methodProfiler.b();
@@ -2004,7 +2235,7 @@ public abstract class World implements IBlockAccess {
         }
 
         this.methodProfiler.a("playerCheckLight");
-        if (!this.players.isEmpty()) {
+        if (spigotConfig.randomLightUpdates && !this.players.isEmpty()) { // Spigot
             i = this.random.nextInt(this.players.size());
             entityhuman = (EntityHuman) this.players.get(i);
             j = MathHelper.floor(entityhuman.locX) + this.random.nextInt(11) - 5;
@@ -2391,6 +2622,7 @@ public abstract class World implements IBlockAccess {
     }
 
     public void a(List list) {
+        org.spigotmc.AsyncCatcher.catchOp( "entity world add"); // Spigot
         // CraftBukkit start
         // this.entityList.addAll(list);
         Entity entity = null;
diff --git a/src/main/java/net/minecraft/server/WorldGenForestTree.java b/src/main/java/net/minecraft/server/WorldGenForestTree.java
new file mode 100644
index 0000000..6196163
--- /dev/null
+++ b/src/main/java/net/minecraft/server/WorldGenForestTree.java
@@ -0,0 +1,171 @@
+package net.minecraft.server;
+
+import java.util.Random;
+
+public class WorldGenForestTree extends WorldGenTreeAbstract {
+
+    public WorldGenForestTree(boolean flag) {
+        super(flag);
+    }
+
+    public boolean generate(World world, Random random, int i, int j, int k) {
+        int l = random.nextInt(3) + random.nextInt(2) + 6;
+        boolean flag = true;
+
+        if (j >= 1 && j + l + 1 <= 256) {
+            int i1;
+            int j1;
+
+            for (int k1 = j; k1 <= j + 1 + l; ++k1) {
+                byte b0 = 1;
+
+                if (k1 == j) {
+                    b0 = 0;
+                }
+
+                if (k1 >= j + 1 + l - 2) {
+                    b0 = 2;
+                }
+
+                for (i1 = i - b0; i1 <= i + b0 && flag; ++i1) {
+                    for (j1 = k - b0; j1 <= k + b0 && flag; ++j1) {
+                        if (k1 >= 0 && k1 < 256) {
+                            Block block = world.getType(i1, k1, j1);
+
+                            if (!this.a(block)) {
+                                flag = false;
+                            }
+                        } else {
+                            flag = false;
+                        }
+                    }
+                }
+            }
+
+            if (!flag) {
+                return false;
+            } else {
+                Block block1 = world.getType(i, j - 1, k);
+
+                if ((block1 == Blocks.GRASS || block1 == Blocks.DIRT) && j < 256 - l - 1) {
+                    this.setType(world, i, j - 1, k, Blocks.DIRT);
+                    this.setType(world, i + 1, j - 1, k, Blocks.DIRT);
+                    this.setType(world, i + 1, j - 1, k + 1, Blocks.DIRT);
+                    this.setType(world, i, j - 1, k + 1, Blocks.DIRT);
+                    int l1 = random.nextInt(4);
+
+                    i1 = l - random.nextInt(4);
+                    j1 = 2 - random.nextInt(3);
+                    int i2 = i;
+                    int j2 = k;
+                    int k2 = 0;
+
+                    int l2;
+                    int i3;
+
+                    for (l2 = 0; l2 < l; ++l2) {
+                        i3 = j + l2;
+                        if (l2 >= i1 && j1 > 0) {
+                            i2 += Direction.a[l1];
+                            j2 += Direction.b[l1];
+                            --j1;
+                        }
+
+                        Block block2 = world.getType(i2, i3, j2);
+
+                        if (block2.getMaterial() == Material.AIR || block2.getMaterial() == Material.LEAVES) {
+                            this.setTypeAndData(world, i2, i3, j2, Blocks.LOG2, 1);
+                            this.setTypeAndData(world, i2 + 1, i3, j2, Blocks.LOG2, 1);
+                            this.setTypeAndData(world, i2, i3, j2 + 1, Blocks.LOG2, 1);
+                            this.setTypeAndData(world, i2 + 1, i3, j2 + 1, Blocks.LOG2, 1);
+                            k2 = i3;
+                        }
+                    }
+
+                    for (l2 = -2; l2 <= 0; ++l2) {
+                        for (i3 = -2; i3 <= 0; ++i3) {
+                            byte b1 = -1;
+
+                            this.a(world, i2 + l2, k2 + b1, j2 + i3);
+                            this.a(world, 1 + i2 - l2, k2 + b1, j2 + i3);
+                            this.a(world, i2 + l2, k2 + b1, 1 + j2 - i3);
+                            this.a(world, 1 + i2 - l2, k2 + b1, 1 + j2 - i3);
+                            if ((l2 > -2 || i3 > -1) && (l2 != -1 || i3 != -2)) {
+                                byte b2 = 1;
+
+                                this.a(world, i2 + l2, k2 + b2, j2 + i3);
+                                this.a(world, 1 + i2 - l2, k2 + b2, j2 + i3);
+                                this.a(world, i2 + l2, k2 + b2, 1 + j2 - i3);
+                                this.a(world, 1 + i2 - l2, k2 + b2, 1 + j2 - i3);
+                            }
+                        }
+                    }
+
+                    if (random.nextBoolean()) {
+                        this.a(world, i2, k2 + 2, j2);
+                        this.a(world, i2 + 1, k2 + 2, j2);
+                        this.a(world, i2 + 1, k2 + 2, j2 + 1);
+                        this.a(world, i2, k2 + 2, j2 + 1);
+                    }
+
+                    for (l2 = -3; l2 <= 4; ++l2) {
+                        for (i3 = -3; i3 <= 4; ++i3) {
+                            if ((l2 != -3 || i3 != -3) && (l2 != -3 || i3 != 4) && (l2 != 4 || i3 != -3) && (l2 != 4 || i3 != 4) && (Math.abs(l2) < 3 || Math.abs(i3) < 3)) {
+                                this.a(world, i2 + l2, k2, j2 + i3);
+                            }
+                        }
+                    }
+
+                    for (l2 = -1; l2 <= 2; ++l2) {
+                        for (i3 = -1; i3 <= 2; ++i3) {
+                            if ((l2 < 0 || l2 > 1 || i3 < 0 || i3 > 1) && random.nextInt(3) <= 0) {
+                                int j3 = random.nextInt(3) + 2;
+
+                                int k3;
+
+                                for (k3 = 0; k3 < j3; ++k3) {
+                                    Block block = world.getType(i + l2, k2 - k3 - 1, k + i3);
+
+                                    if (block.getMaterial() == Material.AIR || block.getMaterial() == Material.LEAVES)
+                                    {
+                                        this.setTypeAndData(world, i + l2, k2 - k3 - 1, k + i3, Blocks.LOG2, 1);
+                                    }
+                                }
+
+                                int l3;
+
+                                for (k3 = -1; k3 <= 1; ++k3) {
+                                    for (l3 = -1; l3 <= 1; ++l3) {
+                                        this.a(world, i2 + l2 + k3, k2 - 0, j2 + i3 + l3);
+                                    }
+                                }
+
+                                for (k3 = -2; k3 <= 2; ++k3) {
+                                    for (l3 = -2; l3 <= 2; ++l3) {
+                                        if (Math.abs(k3) != 2 || Math.abs(l3) != 2) {
+                                            this.a(world, i2 + l2 + k3, k2 - 1, j2 + i3 + l3);
+                                        }
+                                    }
+                                }
+                            }
+                        }
+                    }
+
+                    return true;
+                } else {
+                    return false;
+                }
+            }
+        } else {
+            return false;
+        }
+    }
+
+    private void a(World world, int i, int j, int k) {
+        Block block = world.getType(i, j, k);
+
+        if (block.getMaterial() == Material.AIR) {
+            this.setTypeAndData(world, i, j, k, Blocks.LEAVES2, 1);
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/WorldGenGroundBush.java b/src/main/java/net/minecraft/server/WorldGenGroundBush.java
index ea8fdb5..1a82656 100644
--- a/src/main/java/net/minecraft/server/WorldGenGroundBush.java
+++ b/src/main/java/net/minecraft/server/WorldGenGroundBush.java
@@ -13,7 +13,7 @@ public class WorldGenGroundBush extends WorldGenTrees {
         this.a = j;
     }
 
-    public boolean a(World world, Random random, int i, int j, int k) {
+    public boolean generate(World world, Random random, int i, int j, int k) { // Spigot
         Block block;
 
         while (((block = world.getType(i, j, k)).getMaterial() == Material.AIR || block.getMaterial() == Material.LEAVES) && j > 0) {
diff --git a/src/main/java/net/minecraft/server/WorldGenLargeFeature.java b/src/main/java/net/minecraft/server/WorldGenLargeFeature.java
new file mode 100644
index 0000000..72f5d10
--- /dev/null
+++ b/src/main/java/net/minecraft/server/WorldGenLargeFeature.java
@@ -0,0 +1,97 @@
+package net.minecraft.server;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Random;
+import java.util.Map.Entry;
+
+public class WorldGenLargeFeature extends StructureGenerator {
+
+    private static List e = Arrays.asList(new BiomeBase[] { BiomeBase.DESERT, BiomeBase.DESERT_HILLS, BiomeBase.JUNGLE, BiomeBase.JUNGLE_HILLS, BiomeBase.SWAMPLAND});
+    private List f;
+    private int g;
+    private int h;
+
+    public WorldGenLargeFeature() {
+        this.f = new ArrayList();
+        this.g = 32;
+        this.h = 8;
+        this.f.add(new BiomeMeta(EntityWitch.class, 1, 1, 1));
+    }
+
+    public WorldGenLargeFeature(Map map) {
+        this();
+        Iterator iterator = map.entrySet().iterator();
+
+        while (iterator.hasNext()) {
+            Entry entry = (Entry) iterator.next();
+
+            if (((String) entry.getKey()).equals("distance")) {
+                this.g = MathHelper.a((String) entry.getValue(), this.g, this.h + 1);
+            }
+        }
+    }
+
+    public String a() {
+        return "Temple";
+    }
+
+    protected boolean a(int i, int j) {
+        int k = i;
+        int l = j;
+
+        if (i < 0) {
+            i -= this.g - 1;
+        }
+
+        if (j < 0) {
+            j -= this.g - 1;
+        }
+
+        int i1 = i / this.g;
+        int j1 = j / this.g;
+        Random random = this.c.A(i1, j1, this.c.spigotConfig.largeFeatureSeed); // Spigot
+
+        i1 *= this.g;
+        j1 *= this.g;
+        i1 += random.nextInt(this.g - this.h);
+        j1 += random.nextInt(this.g - this.h);
+        if (k == i1 && l == j1) {
+            BiomeBase biomebase = this.c.getWorldChunkManager().getBiome(k * 16 + 8, l * 16 + 8);
+            Iterator iterator = e.iterator();
+
+            while (iterator.hasNext()) {
+                BiomeBase biomebase1 = (BiomeBase) iterator.next();
+
+                if (biomebase == biomebase1) {
+                    return true;
+                }
+            }
+        }
+
+        return false;
+    }
+
+    protected StructureStart b(int i, int j) {
+        return new WorldGenLargeFeatureStart(this.c, this.b, i, j);
+    }
+
+    public boolean a(int i, int j, int k) {
+        StructureStart structurestart = this.c(i, j, k);
+
+        if (structurestart != null && structurestart instanceof WorldGenLargeFeatureStart && !structurestart.a.isEmpty()) {
+            StructurePiece structurepiece = (StructurePiece) structurestart.a.getFirst();
+
+            return structurepiece instanceof WorldGenWitchHut;
+        } else {
+            return false;
+        }
+    }
+
+    public List b() {
+        return this.f;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/WorldGenPackedIce2.java b/src/main/java/net/minecraft/server/WorldGenPackedIce2.java
new file mode 100644
index 0000000..ae1bf65
--- /dev/null
+++ b/src/main/java/net/minecraft/server/WorldGenPackedIce2.java
@@ -0,0 +1,101 @@
+package net.minecraft.server;
+
+import java.util.Random;
+
+public class WorldGenPackedIce2 extends WorldGenerator {
+
+    public WorldGenPackedIce2() {}
+
+    public boolean generate(World world, Random random, int i, int j, int k) {
+        while (world.isEmpty(i, j, k) && j > 2) {
+            --j;
+        }
+
+        if (world.getType(i, j, k) != Blocks.SNOW_BLOCK) {
+            return false;
+        } else {
+            j += random.nextInt(4);
+            int l = random.nextInt(4) + 7;
+            int i1 = l / 4 + random.nextInt(2);
+
+            if (i1 > 1 && random.nextInt(60) == 0) {
+                j += 10 + random.nextInt(30);
+            }
+
+            int j1;
+            int k1;
+            int l1;
+
+            for (j1 = 0; j1 < l; ++j1) {
+                float f = (1.0F - (float) j1 / (float) l) * (float) i1;
+
+                k1 = MathHelper.f(f);
+
+                for (l1 = -k1; l1 <= k1; ++l1) {
+                    float f1 = (float) MathHelper.a(l1) - 0.25F;
+
+                    for (int i2 = -k1; i2 <= k1; ++i2) {
+                        float f2 = (float) MathHelper.a(i2) - 0.25F;
+
+                        if ((l1 == 0 && i2 == 0 || f1 * f1 + f2 * f2 <= f * f) && (l1 != -k1 && l1 != k1 && i2 != -k1 && i2 != k1 || random.nextFloat() <= 0.75F)) {
+                            Block block = world.getType(i + l1, j + j1, k + i2);
+
+                            if (block.getMaterial() == Material.AIR || block == Blocks.DIRT || block == Blocks.SNOW_BLOCK || block == Blocks.ICE) {
+                                world.setTypeUpdate(i + l1, j + j1, k + i2, Blocks.PACKED_ICE); // Spigot
+                            }
+
+                            if (j1 != 0 && k1 > 1) {
+                                block = world.getType(i + l1, j - j1, k + i2);
+                                if (block.getMaterial() == Material.AIR || block == Blocks.DIRT || block == Blocks.SNOW_BLOCK || block == Blocks.ICE) {
+                                    world.setTypeUpdate(i + l1, j - j1, k + i2, Blocks.PACKED_ICE); // Spigot
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+
+            j1 = i1 - 1;
+            if (j1 < 0) {
+                j1 = 0;
+            } else if (j1 > 1) {
+                j1 = 1;
+            }
+
+            for (int j2 = -j1; j2 <= j1; ++j2) {
+                k1 = -j1;
+
+                while (k1 <= j1) {
+                    l1 = j - 1;
+                    int k2 = 50;
+
+                    if (Math.abs(j2) == 1 && Math.abs(k1) == 1) {
+                        k2 = random.nextInt(5);
+                    }
+
+                    while (true) {
+                        if (l1 > 50) {
+                            Block block1 = world.getType(i + j2, l1, k + k1);
+
+                            if (block1.getMaterial() == Material.AIR || block1 == Blocks.DIRT || block1 == Blocks.SNOW_BLOCK || block1 == Blocks.ICE || block1 == Blocks.PACKED_ICE) {
+                                world.setTypeUpdate(i + j2, l1, k + k1, Blocks.PACKED_ICE); // Spigot
+                                --l1;
+                                --k2;
+                                if (k2 <= 0) {
+                                    l1 -= random.nextInt(5) + 1;
+                                    k2 = random.nextInt(5);
+                                }
+                                continue;
+                            }
+                        }
+
+                        ++k1;
+                        break;
+                    }
+                }
+            }
+
+            return true;
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/WorldGenVillage.java b/src/main/java/net/minecraft/server/WorldGenVillage.java
new file mode 100644
index 0000000..8d1721a
--- /dev/null
+++ b/src/main/java/net/minecraft/server/WorldGenVillage.java
@@ -0,0 +1,75 @@
+package net.minecraft.server;
+
+import java.util.Arrays;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Random;
+import java.util.Map.Entry;
+
+public class WorldGenVillage extends StructureGenerator {
+
+    public static final List e = Arrays.asList(new BiomeBase[] { BiomeBase.PLAINS, BiomeBase.DESERT, BiomeBase.SAVANNA});
+    private int f;
+    private int g;
+    private int h;
+
+    public WorldGenVillage() {
+        this.g = 32;
+        this.h = 8;
+    }
+
+    public WorldGenVillage(Map map) {
+        this();
+        Iterator iterator = map.entrySet().iterator();
+
+        while (iterator.hasNext()) {
+            Entry entry = (Entry) iterator.next();
+
+            if (((String) entry.getKey()).equals("size")) {
+                this.f = MathHelper.a((String) entry.getValue(), this.f, 0);
+            } else if (((String) entry.getKey()).equals("distance")) {
+                this.g = MathHelper.a((String) entry.getValue(), this.g, this.h + 1);
+            }
+        }
+    }
+
+    public String a() {
+        return "Village";
+    }
+
+    protected boolean a(int i, int j) {
+        int k = i;
+        int l = j;
+
+        if (i < 0) {
+            i -= this.g - 1;
+        }
+
+        if (j < 0) {
+            j -= this.g - 1;
+        }
+
+        int i1 = i / this.g;
+        int j1 = j / this.g;
+        Random random = this.c.A(i1, j1, this.c.spigotConfig.villageSeed); // Spigot
+
+        i1 *= this.g;
+        j1 *= this.g;
+        i1 += random.nextInt(this.g - this.h);
+        j1 += random.nextInt(this.g - this.h);
+        if (k == i1 && l == j1) {
+            boolean flag = this.c.getWorldChunkManager().a(k * 16 + 8, l * 16 + 8, 0, e);
+
+            if (flag) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    protected StructureStart b(int i, int j) {
+        return new WorldGenVillageStart(this.c, this.b, i, j, this.f);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/WorldMap.java b/src/main/java/net/minecraft/server/WorldMap.java
index bd5cfca..3254b87 100644
--- a/src/main/java/net/minecraft/server/WorldMap.java
+++ b/src/main/java/net/minecraft/server/WorldMap.java
@@ -22,7 +22,7 @@ public class WorldMap extends PersistentBase {
     public byte scale;
     public byte[] colors = new byte[16384];
     public List f = new ArrayList();
-    private Map i = new HashMap();
+    public Map i = new HashMap(); // Spigot
     public Map decorations = new LinkedHashMap();
 
     // CraftBukkit start
diff --git a/src/main/java/net/minecraft/server/WorldMapHumanTracker.java b/src/main/java/net/minecraft/server/WorldMapHumanTracker.java
index ec708d1..d22b6c9 100644
--- a/src/main/java/net/minecraft/server/WorldMapHumanTracker.java
+++ b/src/main/java/net/minecraft/server/WorldMapHumanTracker.java
@@ -37,23 +37,29 @@ public class WorldMapHumanTracker {
             int i;
             int j;
 
-            org.bukkit.craftbukkit.map.RenderData render = this.worldMap.mapView.render((org.bukkit.craftbukkit.entity.CraftPlayer) trackee.getBukkitEntity()); // CraftBukkit
+            // Spigot start
+            boolean custom = this.worldMap.mapView.renderers.size() > 1 || !(this.worldMap.mapView.renderers.get(0) instanceof org.bukkit.craftbukkit.map.CraftMapRenderer);
+            org.bukkit.craftbukkit.map.RenderData render = (custom) ? this.worldMap.mapView.render((org.bukkit.craftbukkit.entity.CraftPlayer) trackee.getBukkitEntity()) : null; // CraftBukkit
 
             if (--this.g < 0) {
                 this.g = 4;
-                abyte = new byte[render.cursors.size() * 3 + 1]; // CraftBukkit
+                abyte = new byte[((custom) ? render.cursors.size() : this.worldMap.decorations.size()) * 3 + 1]; // CraftBukkit
                 abyte[0] = 1;
                 i = 0;
 
                 // CraftBukkit start
-                for (i = 0; i < render.cursors.size(); ++i) {
-                    org.bukkit.map.MapCursor cursor = render.cursors.get(i);
-                    if (!cursor.isVisible()) continue;
 
-                    abyte[i * 3 + 1] = (byte) (cursor.getRawType() << 4 | cursor.getDirection() & 15);
-                    abyte[i * 3 + 2] = (byte) cursor.getX();
-                    abyte[i * 3 + 3] = (byte) cursor.getY();
+                // Spigot start
+                for (Iterator iterator = ((custom) ? render.cursors.iterator() : this.worldMap.decorations.values().iterator()); iterator.hasNext(); ++i) {
+                    org.bukkit.map.MapCursor cursor = (custom) ? (org.bukkit.map.MapCursor) iterator.next() : null;
+                    if (cursor != null && !cursor.isVisible()) continue;
+                    WorldMapDecoration deco = (custom) ? null : (WorldMapDecoration) iterator.next();
+
+                    abyte[i * 3 + 1] = (byte) (((custom) ? cursor.getRawType() : deco.type) << 4 | ((custom) ? cursor.getDirection() : deco.rotation) & 15);
+                    abyte[i * 3 + 2] = (byte) ((custom) ? cursor.getX() : deco.locX);
+                    abyte[i * 3 + 3] = (byte) ((custom) ? cursor.getY() : deco.locY);
                 }
+                // Spigot end
                 // CraftBukkit end
 
                 boolean flag = !itemstack.A();
@@ -88,7 +94,7 @@ public class WorldMapHumanTracker {
                     abyte1[2] = (byte) j;
 
                     for (int i1 = 0; i1 < abyte1.length - 3; ++i1) {
-                        abyte1[i1 + 3] = render.buffer[(i1 + j) * 128 + i]; // CraftBukkit
+                        abyte1[i1 + 3] = ((custom) ? render.buffer : this.worldMap.colors)[(i1 + j) * 128 + i];
                     }
 
                     this.c[i] = -1;
diff --git a/src/main/java/net/minecraft/server/WorldNBTStorage.java b/src/main/java/net/minecraft/server/WorldNBTStorage.java
index 93ff8d3..141248e 100644
--- a/src/main/java/net/minecraft/server/WorldNBTStorage.java
+++ b/src/main/java/net/minecraft/server/WorldNBTStorage.java
@@ -54,7 +54,7 @@ public class WorldNBTStorage implements IDataManager, IPlayerFileData {
             }
         } catch (IOException ioexception) {
             ioexception.printStackTrace();
-            throw new RuntimeException("Failed to check session lock, aborting");
+            throw new RuntimeException("Failed to check session lock for world located at " + this.baseDir + ", aborting. Stop the server and delete the session.lock in this world to prevent further issues."); // Spigot
         }
     }
 
@@ -69,13 +69,13 @@ public class WorldNBTStorage implements IDataManager, IPlayerFileData {
 
             try {
                 if (datainputstream.readLong() != this.sessionId) {
-                    throw new ExceptionWorldConflict("The save is being accessed from another location, aborting");
+                    throw new ExceptionWorldConflict("The save for world located at " + this.baseDir + " is being accessed from another location, aborting");  // Spigot
                 }
             } finally {
                 datainputstream.close();
             }
         } catch (IOException ioexception) {
-            throw new ExceptionWorldConflict("Failed to check session lock, aborting");
+            throw new ExceptionWorldConflict("Failed to check session lock for world located at " + this.baseDir + ", aborting. Stop the server and delete the session.lock in this world to prevent further issues."); // Spigot
         }
     }
 
@@ -196,10 +196,28 @@ public class WorldNBTStorage implements IDataManager, IPlayerFileData {
 
         try {
             File file1 = new File(this.playerDir, entityhuman.getUniqueID().toString() + ".dat");
+            // Spigot Start
+            boolean usingWrongFile = false;
+            if ( !file1.exists() )
+            {
+                file1 = new File( this.playerDir, UUID.nameUUIDFromBytes( ( "OfflinePlayer:" + entityhuman.getName() ).getBytes( "UTF-8" ) ).toString() + ".dat");
+                if ( file1.exists() )
+                {
+                    usingWrongFile = true;
+                    org.bukkit.Bukkit.getServer().getLogger().warning( "Using offline mode UUID file for player " + entityhuman.getName() + " as it is the only copy we can find." );
+                }
+            }
+            // Spigot End
 
             if (file1.exists() && file1.isFile()) {
                 nbttagcompound = NBTCompressedStreamTools.a((InputStream) (new FileInputStream(file1)));
             }
+            // Spigot Start
+            if ( usingWrongFile )
+            {
+                file1.renameTo( new File( file1.getPath() + ".offline-read" ) );
+            }
+            // Spigot End
         } catch (Exception exception) {
             a.warn("Failed to load player data for " + entityhuman.getName());
         }
diff --git a/src/main/java/net/minecraft/server/WorldServer.java b/src/main/java/net/minecraft/server/WorldServer.java
index ba7965d..91f036b 100644
--- a/src/main/java/net/minecraft/server/WorldServer.java
+++ b/src/main/java/net/minecraft/server/WorldServer.java
@@ -55,7 +55,7 @@ public class WorldServer extends World {
         // CraftBukkit end
         this.server = minecraftserver;
         this.tracker = new EntityTracker(this);
-        this.manager = new PlayerChunkMap(this);
+        this.manager = new PlayerChunkMap(this, spigotConfig.viewDistance); // Spigot
         if (this.entitiesById == null) {
             this.entitiesById = new IntHashMap();
         }
@@ -87,7 +87,7 @@ public class WorldServer extends World {
         TileEntity result = super.getTileEntity(i, j, k);
         Block type = getType(i, j, k);
 
-        if (type == Blocks.CHEST) {
+        if (type == Blocks.CHEST || type == Blocks.TRAPPED_CHEST) { // Spigot
             if (!(result instanceof TileEntityChest)) {
                 result = fixTileEntity(i, j, k, type, result);
             }
@@ -185,10 +185,13 @@ public class WorldServer extends World {
         // CraftBukkit start - Only call spawner if we have players online and the world allows for mobs or animals
         long time = this.worldData.getTime();
         if (this.getGameRules().getBoolean("doMobSpawning") && (this.allowMonsters || this.allowAnimals) && (this instanceof WorldServer && this.players.size() > 0)) {
+            timings.mobSpawn.startTiming(); // Spigot
             this.R.spawnEntities(this, this.allowMonsters && (this.ticksPerMonsterSpawns != 0 && time % this.ticksPerMonsterSpawns == 0L), this.allowAnimals && (this.ticksPerAnimalSpawns != 0 && time % this.ticksPerAnimalSpawns == 0L), this.worldData.getTime() % 400L == 0L);
+            timings.mobSpawn.stopTiming(); // Spigot
             // CraftBukkit end
         }
-
+        // CraftBukkit end
+        timings.doChunkUnload.startTiming(); // Spigot
         this.methodProfiler.c("chunkSource");
         this.chunkProvider.unloadChunks();
         int j = this.a(1.0F);
@@ -202,21 +205,36 @@ public class WorldServer extends World {
             this.worldData.setDayTime(this.worldData.getDayTime() + 1L);
         }
 
+        timings.doChunkUnload.stopTiming(); // Spigot
         this.methodProfiler.c("tickPending");
+        timings.doTickPending.startTiming(); // Spigot
         this.a(false);
+        timings.doTickPending.stopTiming(); // Spigot
         this.methodProfiler.c("tickBlocks");
+        timings.doTickTiles.startTiming(); // Spigot
         this.g();
+        timings.doTickTiles.stopTiming(); // Spigot
         this.methodProfiler.c("chunkMap");
+        timings.doChunkMap.startTiming(); // Spigot
         this.manager.flush();
+        timings.doChunkMap.stopTiming(); // Spigot
         this.methodProfiler.c("village");
+        timings.doVillages.startTiming(); // Spigot
         this.villages.tick();
         this.siegeManager.a();
+        timings.doVillages.stopTiming(); // Spigot
         this.methodProfiler.c("portalForcer");
+        timings.doPortalForcer.startTiming(); // Spigot
         this.Q.a(this.getTime());
+        timings.doPortalForcer.stopTiming(); // Spigot
         this.methodProfiler.b();
+        timings.doSounds.startTiming(); // Spigot
         this.Z();
+        timings.doSounds.stopTiming(); // Spigot
 
+        timings.doChunkGC.startTiming(); // Spigot
         this.getWorld().processChunkGC(); // CraftBukkit
+        timings.doChunkGC.stopTiming(); // Spigot
     }
 
     public BiomeMeta a(EnumCreatureType enumcreaturetype, int i, int j, int k) {
@@ -307,10 +325,20 @@ public class WorldServer extends World {
         // CraftBukkit start
         // Iterator iterator = this.chunkTickList.iterator();
 
-        for (long chunkCoord : this.chunkTickList.popAll()) {
+        // Spigot start
+        for (net.minecraft.util.gnu.trove.iterator.TLongShortIterator iter = chunkTickList.iterator(); iter.hasNext();) {
+            iter.advance();
+            long chunkCoord = iter.key();
+            int chunkX = World.keyToX(chunkCoord);
+            int chunkZ = World.keyToZ(chunkCoord);
+            // If unloaded, or in procedd of being unloaded, drop it
+            if ( ( !this.isChunkLoaded( chunkX, chunkZ ) ) || ( this.chunkProviderServer.unloadQueue.contains( chunkX, chunkZ ) ) )
+            {
+                iter.remove();
+                continue;
+            }
+            // Spigot end
             // ChunkCoordIntPair chunkcoordintpair = (ChunkCoordIntPair) iterator.next();
-            int chunkX = LongHash.msw(chunkCoord);
-            int chunkZ = LongHash.lsw(chunkCoord);
             int k = chunkX * 16;
             int l = chunkZ * 16;
 
@@ -401,6 +429,7 @@ public class WorldServer extends World {
 
                         if (block.isTicking()) {
                             ++i;
+                            this.growthOdds = (iter.value() < 1) ? this.modifiedOdds : 100; // Spigot - grow fast if no players are in this chunk (value = player count)
                             block.a(this, k2 + k, i3 + chunksection.getYPosition(), l2 + l, this.random);
                         }
                     }
@@ -409,6 +438,12 @@ public class WorldServer extends World {
 
             this.methodProfiler.b();
         }
+        // Spigot Start
+        if ( spigotConfig.clearChunksOnTick )
+        {
+            chunkTickList.clear();
+        }
+        // Spigot End
     }
 
     public boolean a(int i, int j, int k, Block block) {
@@ -479,6 +514,7 @@ public class WorldServer extends World {
         }
 
         super.tickEntities();
+        spigotConfig.currentPrimedTnt = 0; // Spigot
     }
 
     public void i() {
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftEffect.java b/src/main/java/org/bukkit/craftbukkit/CraftEffect.java
index 7de0de5..7eca388 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftEffect.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftEffect.java
@@ -55,6 +55,8 @@ public class CraftEffect {
             Validate.isTrue(((Material) data).isBlock(), "Material is not a block!");
             datavalue = ((Material) data).getId();
             break;
+        case ITEM_BREAK:
+            datavalue = ((Material) data).getId();
         default:
             datavalue = 0;
         }
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index a666131..5b6aa3f 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -85,6 +85,8 @@ import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.MobEffectList;
 import net.minecraft.server.PropertyManager;
 import net.minecraft.server.ServerCommand;
+import net.minecraft.server.RegionFile;
+import net.minecraft.server.RegionFileCache;
 import net.minecraft.server.ServerNBTManager;
 import net.minecraft.server.WorldLoaderServer;
 import net.minecraft.server.WorldManager;
@@ -118,6 +120,7 @@ import org.bukkit.command.CommandSender;
 import org.bukkit.command.ConsoleCommandSender;
 import org.bukkit.command.PluginCommand;
 import org.bukkit.command.SimpleCommandMap;
+import org.bukkit.command.defaults.VanillaCommand;
 import org.bukkit.configuration.ConfigurationSection;
 import org.bukkit.configuration.file.YamlConfiguration;
 import org.bukkit.configuration.serialization.ConfigurationSerialization;
@@ -317,14 +320,16 @@ public final class CraftServer implements Server {
         loadIcon();
 
         updater = new AutoUpdater(new BukkitDLUpdaterService(configuration.getString("auto-updater.host")), getLogger(), configuration.getString("auto-updater.preferred-channel"));
-        updater.setEnabled(configuration.getBoolean("auto-updater.enabled"));
+        updater.setEnabled(false); // Spigot
         updater.setSuggestChannels(configuration.getBoolean("auto-updater.suggest-channels"));
         updater.getOnBroken().addAll(configuration.getStringList("auto-updater.on-broken"));
         updater.getOnUpdate().addAll(configuration.getStringList("auto-updater.on-update"));
         updater.check(serverVersion);
 
-        loadPlugins();
-        enablePlugins(PluginLoadOrder.STARTUP);
+        // Spigot Start - Moved to old location of new DedicatedPlayerList in DedicatedServer
+        // loadPlugins();
+        // enablePlugins(PluginLoadOrder.STARTUP);
+        // Spigot End
     }
 
     public boolean getCommandBlockOverride(String command) {
@@ -391,8 +396,11 @@ public final class CraftServer implements Server {
         }
 
         if (type == PluginLoadOrder.POSTWORLD) {
+            // Spigot start - Allow vanilla commands to be forced to be the main command
+            setVanillaCommands(true);
             commandMap.setFallbackCommands();
-            setVanillaCommands();
+            setVanillaCommands(false);
+            // Spigot end
             commandMap.registerServerAliases();
             loadCustomPermissions();
             DefaultPermissions.registerCorePermissions();
@@ -404,51 +412,64 @@ public final class CraftServer implements Server {
         pluginManager.disablePlugins();
     }
 
-    private void setVanillaCommands() {
-        commandMap.register("minecraft", new VanillaCommandWrapper(new CommandAchievement(), "/achievement give <stat_name> [player]"));
-        commandMap.register("minecraft", new VanillaCommandWrapper(new CommandBan(), "/ban <playername> [reason]"));
-        commandMap.register("minecraft", new VanillaCommandWrapper(new CommandBanIp(), "/ban-ip <ip-address|playername>"));
-        commandMap.register("minecraft", new VanillaCommandWrapper(new CommandBanList(), "/banlist [ips]"));
-        commandMap.register("minecraft", new VanillaCommandWrapper(new CommandClear(), "/clear <playername> [item] [metadata]"));
-        commandMap.register("minecraft", new VanillaCommandWrapper(new CommandGamemodeDefault(), "/defaultgamemode <mode>"));
-        commandMap.register("minecraft", new VanillaCommandWrapper(new CommandDeop(), "/deop <playername>"));
-        commandMap.register("minecraft", new VanillaCommandWrapper(new CommandDifficulty(), "/difficulty <new difficulty>"));
-        commandMap.register("minecraft", new VanillaCommandWrapper(new CommandEffect(), "/effect <player> <effect|clear> [seconds] [amplifier]"));
-        commandMap.register("minecraft", new VanillaCommandWrapper(new CommandEnchant(), "/enchant <playername> <enchantment ID> [enchantment level]"));
-        commandMap.register("minecraft", new VanillaCommandWrapper(new CommandGamemode(), "/gamemode <mode> [player]"));
-        commandMap.register("minecraft", new VanillaCommandWrapper(new CommandGamerule(), "/gamerule <rulename> [true|false]"));
-        commandMap.register("minecraft", new VanillaCommandWrapper(new CommandGive(), "/give <playername> <item> [amount] [metadata] [dataTag]"));
-        commandMap.register("minecraft", new VanillaCommandWrapper(new CommandHelp(), "/help [page|commandname]"));
-        commandMap.register("minecraft", new VanillaCommandWrapper(new CommandIdleTimeout(), "/setidletimeout <Minutes until kick>"));
-        commandMap.register("minecraft", new VanillaCommandWrapper(new CommandKick(), "/kick <playername> [reason]"));
-        commandMap.register("minecraft", new VanillaCommandWrapper(new CommandKill(), "/kill [playername]"));
-        commandMap.register("minecraft", new VanillaCommandWrapper(new CommandList(), "/list"));
-        commandMap.register("minecraft", new VanillaCommandWrapper(new CommandMe(), "/me <actiontext>"));
-        commandMap.register("minecraft", new VanillaCommandWrapper(new CommandOp(), "/op <playername>"));
-        commandMap.register("minecraft", new VanillaCommandWrapper(new CommandPardon(), "/pardon <playername>"));
-        commandMap.register("minecraft", new VanillaCommandWrapper(new CommandPardonIP(), "/pardon-ip <ip-address>"));
-        commandMap.register("minecraft", new VanillaCommandWrapper(new CommandPlaySound(), "/playsound <sound> <playername> [x] [y] [z] [volume] [pitch] [minimumVolume]"));
-        commandMap.register("minecraft", new VanillaCommandWrapper(new CommandSay(), "/say <message>"));
-        commandMap.register("minecraft", new VanillaCommandWrapper(new CommandScoreboard(), "/scoreboard"));
-        commandMap.register("minecraft", new VanillaCommandWrapper(new CommandSeed(), "/seed"));
-        commandMap.register("minecraft", new VanillaCommandWrapper(new CommandSetBlock(), "/setblock <x> <y> <z> <tilename> [datavalue] [oldblockHandling] [dataTag]"));
-        commandMap.register("minecraft", new VanillaCommandWrapper(new CommandSetWorldSpawn(), "/setworldspawn [x] [y] [z]"));
-        commandMap.register("minecraft", new VanillaCommandWrapper(new CommandSpawnpoint(), "/spawnpoint <playername> [x] [y] [z]"));
-        commandMap.register("minecraft", new VanillaCommandWrapper(new CommandSpreadPlayers(), "/spreadplayers <x> <z> [spreadDistance] [maxRange] [respectTeams] <playernames>"));
-        commandMap.register("minecraft", new VanillaCommandWrapper(new CommandSummon(), "/summon <EntityName> [x] [y] [z] [dataTag]"));
-        commandMap.register("minecraft", new VanillaCommandWrapper(new CommandTp(), "/tp [player] <target>\n/tp [player] <x> <y> <z>"));
-        commandMap.register("minecraft", new VanillaCommandWrapper(new CommandTell(), "/tell <playername> <message>"));
-        commandMap.register("minecraft", new VanillaCommandWrapper(new CommandTellRaw(), "/tellraw <playername> <raw message>"));
-        commandMap.register("minecraft", new VanillaCommandWrapper(new CommandTestFor(), "/testfor <playername | selector> [dataTag]"));
-        commandMap.register("minecraft", new VanillaCommandWrapper(new CommandTestForBlock(), "/testforblock <x> <y> <z> <tilename> [datavalue] [dataTag]"));
-        commandMap.register("minecraft", new VanillaCommandWrapper(new CommandTime(), "/time set <value>\n/time add <value>"));
-        commandMap.register("minecraft", new VanillaCommandWrapper(new CommandToggleDownfall(), "/toggledownfall"));
-        commandMap.register("minecraft", new VanillaCommandWrapper(new CommandWeather(), "/weather <clear/rain/thunder> [duration in seconds]"));
-        commandMap.register("minecraft", new VanillaCommandWrapper(new CommandWhitelist(), "/whitelist (add|remove) <player>\n/whitelist (on|off|list|reload)"));
-        commandMap.register("minecraft", new VanillaCommandWrapper(new CommandXp(), "/xp <amount> [player]\n/xp <amount>L [player]"));
+    // Spigot start
+    private void tryRegister(VanillaCommandWrapper commandWrapper, boolean first) {
+        if (org.spigotmc.SpigotConfig.replaceCommands.contains( commandWrapper.getName() ) ) {
+            if (first) {
+                commandMap.register( "minecraft", commandWrapper );
+            }
+        } else if (!first) {
+            commandMap.register( "minecraft", commandWrapper );
+        }
+    }
+
+    private void setVanillaCommands(boolean first)
+    {
+        tryRegister( new VanillaCommandWrapper( new CommandAchievement(), "/achievement give <stat_name> [player]" ), first );
+        tryRegister( new VanillaCommandWrapper( new CommandBan(), "/ban <playername> [reason]" ), first );
+        tryRegister( new VanillaCommandWrapper( new CommandBanIp(), "/ban-ip <ip-address|playername>" ), first );
+        tryRegister( new VanillaCommandWrapper( new CommandBanList(), "/banlist [ips]" ), first );
+        tryRegister( new VanillaCommandWrapper( new CommandClear(), "/clear <playername> [item] [metadata]" ), first );
+        tryRegister( new VanillaCommandWrapper( new CommandGamemodeDefault(), "/defaultgamemode <mode>" ), first );
+        tryRegister( new VanillaCommandWrapper( new CommandDeop(), "/deop <playername>" ), first );
+        tryRegister( new VanillaCommandWrapper( new CommandDifficulty(), "/difficulty <new difficulty>" ), first );
+        tryRegister( new VanillaCommandWrapper( new CommandEffect(), "/effect <player> <effect|clear> [seconds] [amplifier]" ), first );
+        tryRegister( new VanillaCommandWrapper( new CommandEnchant(), "/enchant <playername> <enchantment ID> [enchantment level]" ), first );
+        tryRegister( new VanillaCommandWrapper( new CommandGamemode(), "/gamemode <mode> [player]" ), first );
+        tryRegister( new VanillaCommandWrapper( new CommandGamerule(), "/gamerule <rulename> [true|false]" ), first );
+        tryRegister( new VanillaCommandWrapper( new CommandGive(), "/give <playername> <item> [amount] [metadata] [dataTag]" ), first );
+        tryRegister( new VanillaCommandWrapper( new CommandHelp(), "/help [page|commandname]" ), first );
+        tryRegister( new VanillaCommandWrapper( new CommandIdleTimeout(), "/setidletimeout <Minutes until kick>" ), first );
+        tryRegister( new VanillaCommandWrapper( new CommandKick(), "/kick <playername> [reason]" ), first );
+        tryRegister( new VanillaCommandWrapper( new CommandKill(), "/kill [playername]" ), first );
+        tryRegister( new VanillaCommandWrapper( new CommandList(), "/list" ), first );
+        tryRegister( new VanillaCommandWrapper( new CommandMe(), "/me <actiontext>" ), first );
+        tryRegister( new VanillaCommandWrapper( new CommandOp(), "/op <playername>" ), first );
+        tryRegister( new VanillaCommandWrapper( new CommandPardon(), "/pardon <playername>" ), first );
+        tryRegister( new VanillaCommandWrapper( new CommandPardonIP(), "/pardon-ip <ip-address>" ), first );
+        tryRegister( new VanillaCommandWrapper( new CommandPlaySound(), "/playsound <sound> <playername> [x] [y] [z] [volume] [pitch] [minimumVolume]" ), first );
+        tryRegister( new VanillaCommandWrapper( new CommandSay(), "/say <message>" ), first );
+        tryRegister( new VanillaCommandWrapper( new CommandScoreboard(), "/scoreboard" ), first );
+        tryRegister( new VanillaCommandWrapper( new CommandSeed(), "/seed" ), first );
+        tryRegister( new VanillaCommandWrapper( new CommandSetBlock(), "/setblock <x> <y> <z> <tilename> [datavalue] [oldblockHandling] [dataTag]" ), first );
+        tryRegister( new VanillaCommandWrapper( new CommandSetWorldSpawn(), "/setworldspawn [x] [y] [z]" ), first );
+        tryRegister( new VanillaCommandWrapper( new CommandSpawnpoint(), "/spawnpoint <playername> [x] [y] [z]" ), first );
+        tryRegister( new VanillaCommandWrapper( new CommandSpreadPlayers(), "/spreadplayers <x> <z> [spreadDistance] [maxRange] [respectTeams] <playernames>" ), first );
+        tryRegister( new VanillaCommandWrapper( new CommandSummon(), "/summon <EntityName> [x] [y] [z] [dataTag]" ), first );
+        tryRegister( new VanillaCommandWrapper( new CommandTp(), "/tp [player] <target>\n/tp [player] <x> <y> <z>" ), first );
+        tryRegister( new VanillaCommandWrapper( new CommandTell(), "/tell <playername> <message>" ), first );
+        tryRegister( new VanillaCommandWrapper( new CommandTellRaw(), "/tellraw <playername> <raw message>" ), first );
+        tryRegister( new VanillaCommandWrapper( new CommandTestFor(), "/testfor <playername | selector> [dataTag]" ), first );
+        tryRegister( new VanillaCommandWrapper( new CommandTestForBlock(), "/testforblock <x> <y> <z> <tilename> [datavalue] [dataTag]" ), first );
+        tryRegister( new VanillaCommandWrapper( new CommandTime(), "/time set <value>\n/time add <value>" ), first );
+        tryRegister( new VanillaCommandWrapper( new CommandToggleDownfall(), "/toggledownfall" ), first );
+        tryRegister( new VanillaCommandWrapper( new CommandWeather(), "/weather <clear/rain/thunder> [duration in seconds]" ), first );
+        tryRegister( new VanillaCommandWrapper( new CommandWhitelist(), "/whitelist (add|remove) <player>\n/whitelist (on|off|list|reload)" ), first );
+        tryRegister( new VanillaCommandWrapper( new CommandXp(), "/xp <amount> [player]\n/xp <amount>L [player]" ), first );
         // This is what is in the lang file, I swear.
-        commandMap.register("minecraft", new VanillaCommandWrapper(new CommandNetstat(), "/list"));
+        tryRegister( new VanillaCommandWrapper(new CommandNetstat(), "/list"), first );
     }
+    // Spigot end
 
     private void loadPlugin(Plugin plugin) {
         try {
@@ -674,7 +695,13 @@ public final class CraftServer implements Server {
 
     @Override
     public long getConnectionThrottle() {
-        return this.configuration.getInt("settings.connection-throttle");
+        // Spigot Start - Automatically set connection throttle for bungee configurations
+        if (org.spigotmc.SpigotConfig.bungee) {
+            return -1;
+        } else {
+            return this.configuration.getInt("settings.connection-throttle");
+        }
+        // Spigot End
     }
 
     @Override
@@ -741,11 +768,7 @@ public final class CraftServer implements Server {
             return true;
         }
 
-        if (sender instanceof Player) {
-            sender.sendMessage("Unknown command. Type \"/help\" for help.");
-        } else {
-            sender.sendMessage("Unknown command. Type \"help\" for help.");
-        }
+        sender.sendMessage(org.spigotmc.SpigotConfig.unknownCommandMessage);
 
         return false;
     }
@@ -789,6 +812,7 @@ public final class CraftServer implements Server {
             logger.log(Level.WARNING, "Failed to load banned-players.json, " + ex.getMessage());
         }
 
+        org.spigotmc.SpigotConfig.init(); // Spigot
         for (WorldServer world : console.worlds) {
             world.difficulty = difficulty;
             world.setSpawnFlags(monsters, animals);
@@ -803,11 +827,14 @@ public final class CraftServer implements Server {
             } else {
                 world.ticksPerMonsterSpawns = this.getTicksPerMonsterSpawns();
             }
+            world.spigotConfig.init(); // Spigot
         }
 
         pluginManager.clearPlugins();
         commandMap.clearCommands();
         resetRecipes();
+        org.spigotmc.SpigotConfig.registerCommands(); // Spigot
+
         overrideAllCommandBlockCommands = commandsConfiguration.getStringList("command-block-overrides").contains("*");
 
         int pollCount = 0;
@@ -1056,6 +1083,30 @@ public final class CraftServer implements Server {
         worlds.remove(world.getName().toLowerCase());
         console.worlds.remove(console.worlds.indexOf(handle));
 
+        File parentFolder = world.getWorldFolder().getAbsoluteFile();
+
+        // Synchronized because access to RegionFileCache.a is guarded by this lock.
+        synchronized (RegionFileCache.class) {
+            // RegionFileCache.a should be RegionFileCache.cache
+            Iterator<Map.Entry<File, RegionFile>> i = RegionFileCache.a.entrySet().iterator();
+            while(i.hasNext()) {
+                Map.Entry<File, RegionFile> entry = i.next();
+                File child = entry.getKey().getAbsoluteFile();
+                while (child != null) {
+                    if (child.equals(parentFolder)) {
+                        i.remove();
+                        try {
+                            entry.getValue().c(); // Should be RegionFile.close();
+                        } catch (IOException ex) {
+                            getLogger().log(Level.SEVERE, null, ex);
+                        }
+                        break;
+                    }
+                    child = child.getParentFile();
+                }
+            }
+        }
+
         return true;
     }
 
@@ -1341,16 +1392,18 @@ public final class CraftServer implements Server {
     @Deprecated
     public OfflinePlayer getOfflinePlayer(String name) {
         Validate.notNull(name, "Name cannot be null");
-
-        // If the name given cannot ever be a valid username give a dummy return, for scoreboard plugins
-        if (!validUserPattern.matcher(name).matches()) {
-            return new CraftOfflinePlayer(this, new GameProfile(invalidUserUUID, name));
-        }
+        com.google.common.base.Preconditions.checkArgument( !org.apache.commons.lang.StringUtils.isBlank( name ), "Name cannot be blank" ); // Spigot
 
         OfflinePlayer result = getPlayerExact(name);
         if (result == null) {
-            // This is potentially blocking :(
-            GameProfile profile = MinecraftServer.getServer().getUserCache().getProfile(name);
+            // Spigot Start
+            GameProfile profile = null;
+            // Only fetch an online UUID in online mode
+            if ( MinecraftServer.getServer().getOnlineMode() || org.spigotmc.SpigotConfig.bungee )
+            {
+                profile = MinecraftServer.getServer().getUserCache().getProfile( name );
+            }
+            // Spigot end
             if (profile == null) {
                 // Make an OfflinePlayer using an offline mode UUID since the name has no profile
                 result = getOfflinePlayer(new GameProfile(UUID.nameUUIDFromBytes(("OfflinePlayer:" + name).getBytes(Charsets.UTF_8)), name));
@@ -1666,6 +1719,13 @@ public final class CraftServer implements Server {
     }
 
     public List<String> tabCompleteCommand(Player player, String message) {
+        // Spigot Start
+		if ( (org.spigotmc.SpigotConfig.tabComplete < 0 || message.length() <= org.spigotmc.SpigotConfig.tabComplete) && !message.contains( " " ) )
+        {
+            return ImmutableList.of();
+        }
+        // Spigot End
+
         List<String> completions = null;
         try {
             completions = getCommandMap().tabComplete(player, message.substring(1));
@@ -1768,4 +1828,19 @@ public final class CraftServer implements Server {
     public UnsafeValues getUnsafe() {
         return CraftMagicNumbers.INSTANCE;
     }
+
+    private final Spigot spigot = new Spigot()
+    {
+
+        @Override
+        public YamlConfiguration getConfig()
+        {
+            return org.spigotmc.SpigotConfig.config;
+        }
+    };
+
+    public Spigot spigot()
+    {
+        return spigot;
+    }
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
index f4dec5b..ea786ae 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
@@ -162,6 +162,7 @@ public class CraftWorld implements World {
     }
 
     public boolean unloadChunkRequest(int x, int z, boolean safe) {
+        org.spigotmc.AsyncCatcher.catchOp( "chunk unload"); // Spigot
         if (safe && isChunkInUse(x, z)) {
             return false;
         }
@@ -172,6 +173,7 @@ public class CraftWorld implements World {
     }
 
     public boolean unloadChunk(int x, int z, boolean save, boolean safe) {
+        org.spigotmc.AsyncCatcher.catchOp( "chunk unload"); // Spigot
         if (safe && isChunkInUse(x, z)) {
             return false;
         }
@@ -239,6 +241,7 @@ public class CraftWorld implements World {
     }
 
     public boolean loadChunk(int x, int z, boolean generate) {
+        org.spigotmc.AsyncCatcher.catchOp( "chunk load"); // Spigot
         chunkLoadCount++;
         if (generate) {
             // Use the default variant of loadChunk when generate == true.
@@ -249,9 +252,11 @@ public class CraftWorld implements World {
         net.minecraft.server.Chunk chunk = world.chunkProviderServer.chunks.get(LongHash.toLong(x, z));
 
         if (chunk == null) {
+            world.timings.syncChunkLoadTimer.startTiming(); // Spigot
             chunk = world.chunkProviderServer.loadChunk(x, z);
 
             chunkLoadPostProcess(chunk, x, z);
+            world.timings.syncChunkLoadTimer.stopTiming(); // Spigot
         }
         return chunk != null;
     }
@@ -805,28 +810,18 @@ public class CraftWorld implements World {
             Validate.isTrue(effect.getData() == null, "Wrong kind of data for this effect!");
         }
 
-        int datavalue = data == null ? 0 : CraftEffect.getDataValue(effect, data);
-        playEffect(loc, effect, datavalue, radius);
+        if (data != null && data.getClass().equals( org.bukkit.material.MaterialData.class )) {
+            org.bukkit.material.MaterialData materialData = (org.bukkit.material.MaterialData) data;
+            Validate.isTrue( materialData.getItemType().isBlock(), "Material must be block" );
+            spigot().playEffect( loc, effect, materialData.getItemType().getId(), materialData.getData(), 0, 0, 0, 1, 1, radius );
+        } else {
+            int dataValue = data == null ? 0 : CraftEffect.getDataValue( effect, data );
+            playEffect( loc, effect, dataValue, radius );
+        }
     }
 
     public void playEffect(Location location, Effect effect, int data, int radius) {
-        Validate.notNull(location, "Location cannot be null");
-        Validate.notNull(effect, "Effect cannot be null");
-        Validate.notNull(location.getWorld(), "World cannot be null");
-        int packetData = effect.getId();
-        PacketPlayOutWorldEvent packet = new PacketPlayOutWorldEvent(packetData, location.getBlockX(), location.getBlockY(), location.getBlockZ(), data, false);
-        int distance;
-        radius *= radius;
-
-        for (Player player : getPlayers()) {
-            if (((CraftPlayer) player).getHandle().playerConnection == null) continue;
-            if (!location.getWorld().equals(player.getWorld())) continue;
-
-            distance = (int) player.getLocation().distanceSquared(location);
-            if (distance <= radius) {
-                ((CraftPlayer) player).getHandle().playerConnection.sendPacket(packet);
-            }
-        }
+        spigot().playEffect( location, effect, data, 0, 0, 0, 0, 1, 1, radius );
     }
 
     public <T extends Entity> T spawn(Location location, Class<T> clazz) throws IllegalArgumentException {
@@ -1061,6 +1056,12 @@ public class CraftWorld implements World {
         }
 
         if (entity != null) {
+            // Spigot start
+            if (entity instanceof EntityOcelot)
+            {
+                ( (EntityOcelot) entity ).spawnBonus = false;
+            }
+            // Spigot end
             if (entity instanceof EntityInsentient) {
                 ((EntityInsentient) entity).prepare((GroupDataEntity) null);
             }
@@ -1313,4 +1314,80 @@ public class CraftWorld implements World {
             cps.queueUnload(chunk.locX, chunk.locZ);
         }
     }
+    // Spigot start
+    private final Spigot spigot = new Spigot()
+    {
+        @Override
+        public void playEffect( Location location, Effect effect, int id, int data, float offsetX, float offsetY, float offsetZ, float speed, int particleCount, int radius )
+        {
+            Validate.notNull( location, "Location cannot be null" );
+            Validate.notNull( effect, "Effect cannot be null" );
+            Validate.notNull( location.getWorld(), "World cannot be null" );
+            Packet packet;
+            if ( effect.getType() != Effect.Type.PARTICLE )
+            {
+                int packetData = effect.getId();
+                packet = new PacketPlayOutWorldEvent( packetData, location.getBlockX(), location.getBlockY(), location.getBlockZ(), id, false );
+            } else
+            {
+                StringBuilder particleFullName = new StringBuilder();
+                particleFullName.append( effect.getName() );
+                if ( effect.getData() != null && ( effect.getData().equals( org.bukkit.Material.class ) || effect.getData().equals( org.bukkit.material.MaterialData.class ) ) )
+                {
+                    particleFullName.append( '_' ).append( id );
+                }
+                if ( effect.getData() != null && effect.getData().equals( org.bukkit.material.MaterialData.class ) )
+                {
+                    particleFullName.append( '_' ).append( data );
+                }
+                packet = new PacketPlayOutWorldParticles( particleFullName.toString(), (float) location.getX(), (float) location.getY(), (float) location.getZ(), offsetX, offsetY, offsetZ, speed, particleCount );
+            }
+            int distance;
+            radius *= radius;
+            for ( Player player : getPlayers() )
+            {
+                if ( ( (CraftPlayer) player ).getHandle().playerConnection == null )
+                {
+                    continue;
+                }
+                if ( !location.getWorld().equals( player.getWorld() ) )
+                {
+                    continue;
+                }
+                distance = (int) player.getLocation().distanceSquared( location );
+                if ( distance <= radius )
+                {
+                    ( (CraftPlayer) player ).getHandle().playerConnection.sendPacket( packet );
+                }
+            }
+        }
+
+        @Override
+        public void playEffect( Location location, Effect effect )
+        {
+            CraftWorld.this.playEffect( location, effect, 0 );
+        }
+
+        @Override
+        public LightningStrike strikeLightning(Location loc, boolean isSilent)
+        {
+            EntityLightning lightning = new EntityLightning( world, loc.getX(), loc.getY(), loc.getZ(), false, isSilent );
+            world.strikeLightning( lightning );
+            return new CraftLightningStrike( server, lightning );
+        }
+
+        @Override
+        public LightningStrike strikeLightningEffect(Location loc, boolean isSilent)
+        {
+            EntityLightning lightning = new EntityLightning( world, loc.getX(), loc.getY(), loc.getZ(), true, isSilent );
+            world.strikeLightning( lightning );
+            return new CraftLightningStrike( server, lightning );
+        }
+    };
+
+    public Spigot spigot()
+    {
+        return spigot;
+    }
+    // Spigot end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/Main.java b/src/main/java/org/bukkit/craftbukkit/Main.java
index 8d127fb..0c4976d 100644
--- a/src/main/java/org/bukkit/craftbukkit/Main.java
+++ b/src/main/java/org/bukkit/craftbukkit/Main.java
@@ -2,9 +2,15 @@ package org.bukkit.craftbukkit;
 
 import java.io.File;
 import java.io.IOException;
+import java.net.URL;
 import java.text.SimpleDateFormat;
 import java.util.Arrays;
+import java.util.Calendar;
+import java.util.Date;
+import java.util.Enumeration;
 import java.util.List;
+import java.util.concurrent.TimeUnit;
+import java.util.jar.Manifest;
 import java.util.logging.Level;
 import java.util.logging.Logger;
 import joptsimple.OptionParser;
@@ -15,7 +21,54 @@ public class Main {
     public static boolean useJline = true;
     public static boolean useConsole = true;
 
-    public static void main(String[] args) {
+    public static void main(String[] args) throws Exception {
+        // Spigot Start
+        File lock = new File( ".update-lock" );
+        if ( !new File( "update-lock" ).exists() && !lock.exists()  && System.getProperty( "IReallyKnowWhatIAmDoingThisUpdate" ) == null )
+        {
+            System.err.println( "WARNING: This Minecraft update alters the way in which saved data is stored." );
+            System.err.println( "Please ensure your server is in the correct online/offline mode state, as the changes made are PERMANENT" );
+            System.err.println( "If you are running in offline mode, but your BungeeCord is in online mode, it is imperative that BungeeCord support is enabled in spigot.yml and BungeeCord's config.yml" );
+            System.err.println( "By typing `yes` you acknowledge that you have taken the necessary backups and are aware of this conversion" );
+            System.err.println( "Please type yes to continue starting the server. You have been warned :)" );
+            System.err.println( "See http://www.spigotmc.org/wiki/uuid-conversion/ if you have any questions and remember BACKUP BACKUP BACKUP" );
+            System.err.println( "=================================================================================" );
+            System.err.println( "Starting server in 10 seconds" );
+            lock.createNewFile();
+            try
+            {
+                Thread.sleep( TimeUnit.SECONDS.toMillis( 10 ) );
+            } catch ( InterruptedException ex )
+            {
+            }
+        }
+
+        System.err.println( "This Spigot build supports Minecraft clients both of versions 1.7.x and of 1.8.x.\n"
+                + "*** It is imperative that backups be taken before running this build on your server! ***\n"
+                + "Please report any such issues to http://www.spigotmc.org/, stating your client, server, and if applicable BungeeCord versions.\n"
+                + "*** Any bug reports not running the very latest versions of these softwares will be ignored ***\n\n" );
+
+        Enumeration<URL> resources = Main.class.getClassLoader().getResources( "META-INF/MANIFEST.MF" );
+        while ( resources.hasMoreElements() )
+        {
+            Manifest manifest = new Manifest( resources.nextElement().openStream() );
+            String ts = manifest.getMainAttributes().getValue( "Timestamp" );
+            if ( ts != null )
+            {
+                Date buildDate = new SimpleDateFormat( "yyyyMMdd-hhmm" ).parse( ts );
+
+                Calendar cal = Calendar.getInstance();
+                cal.add( Calendar.DAY_OF_YEAR, -2 );
+                if ( buildDate.before(cal.getTime() ) )
+                {
+                    System.err.println( "WARNING: This build is more than 2 days old and there are likely updates available!" );
+                    System.err.println( "You will get no support with this build unless you update from http://ci.md-5.net/job/Spigot/" );
+                    System.err.println( "The server will start in 10 seconds!" );
+                    Thread.sleep( TimeUnit.SECONDS.toMillis( 10 ) );
+                }
+            }
+        }
+        // Spigot End
         // Todo: Installation script
         OptionParser parser = new OptionParser() {
             {
@@ -155,7 +208,22 @@ public class Main {
                     useConsole = false;
                 }
 
-                System.out.println("Loading libraries, please wait...");
+                // Spigot Start
+                int maxPermGen = 0; // In kb
+                for ( String s : java.lang.management.ManagementFactory.getRuntimeMXBean().getInputArguments() )
+                {
+                    if ( s.startsWith( "-XX:MaxPermSize" ) )
+                    {
+                        maxPermGen = Integer.parseInt( s.replaceAll( "[^\\d]", "" ) );
+                        maxPermGen <<= 10 * ("kmg".indexOf( Character.toLowerCase( s.charAt( s.length() - 1 ) ) ) );
+                    }
+                }
+                if ( Float.parseFloat( System.getProperty( "java.class.version" ) ) < 52 && maxPermGen < ( 128 << 10 ) ) // 128mb
+                {
+                    System.out.println( "Warning, your max perm gen size is not set or less than 128mb. It is recommended you restart Java with the following argument: -XX:MaxPermSize=128M" );
+                    System.out.println( "Please see http://www.spigotmc.org/wiki/changing-permgen-size/ for more details and more in-depth instructions." );
+                }
+                // Spigot End
                 MinecraftServer.main(options);
             } catch (Throwable t) {
                 t.printStackTrace();
diff --git a/src/main/java/org/bukkit/craftbukkit/SpigotTimings.java b/src/main/java/org/bukkit/craftbukkit/SpigotTimings.java
new file mode 100644
index 0000000..41d2d87
--- /dev/null
+++ b/src/main/java/org/bukkit/craftbukkit/SpigotTimings.java
@@ -0,0 +1,173 @@
+package org.bukkit.craftbukkit;
+
+import com.google.common.collect.Maps;
+import net.minecraft.server.*;
+import org.bukkit.plugin.java.JavaPluginLoader;
+import org.spigotmc.CustomTimingsHandler;
+import org.bukkit.scheduler.BukkitTask;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import org.bukkit.craftbukkit.scheduler.CraftTask;
+
+public class SpigotTimings {
+
+    public static final CustomTimingsHandler serverTickTimer = new CustomTimingsHandler("** Full Server Tick");
+    public static final CustomTimingsHandler playerListTimer = new CustomTimingsHandler("Player List");
+    public static final CustomTimingsHandler connectionTimer = new CustomTimingsHandler("Connection Handler");
+    public static final CustomTimingsHandler tickablesTimer = new CustomTimingsHandler("Tickables");
+    public static final CustomTimingsHandler schedulerTimer = new CustomTimingsHandler("Scheduler");
+    public static final CustomTimingsHandler chunkIOTickTimer = new CustomTimingsHandler("ChunkIOTick");
+    public static final CustomTimingsHandler timeUpdateTimer = new CustomTimingsHandler("Time Update");
+    public static final CustomTimingsHandler serverCommandTimer = new CustomTimingsHandler("Server Command");
+    public static final CustomTimingsHandler worldSaveTimer = new CustomTimingsHandler("World Save");
+
+    public static final CustomTimingsHandler entityMoveTimer = new CustomTimingsHandler("** entityMove");
+    public static final CustomTimingsHandler tickEntityTimer = new CustomTimingsHandler("** tickEntity");
+    public static final CustomTimingsHandler activatedEntityTimer = new CustomTimingsHandler("** activatedTickEntity");
+    public static final CustomTimingsHandler tickTileEntityTimer = new CustomTimingsHandler("** tickTileEntity");
+
+    public static final CustomTimingsHandler timerEntityBaseTick = new CustomTimingsHandler("** livingEntityBaseTick");
+    public static final CustomTimingsHandler timerEntityAI = new CustomTimingsHandler("** livingEntityAI");
+    public static final CustomTimingsHandler timerEntityAICollision = new CustomTimingsHandler("** livingEntityAICollision");
+    public static final CustomTimingsHandler timerEntityAIMove = new CustomTimingsHandler("** livingEntityAIMove");
+    public static final CustomTimingsHandler timerEntityTickRest = new CustomTimingsHandler("** livingEntityTickRest");
+
+    public static final CustomTimingsHandler processQueueTimer = new CustomTimingsHandler("processQueue");
+    public static final CustomTimingsHandler schedulerSyncTimer = new CustomTimingsHandler("** Scheduler - Sync Tasks", JavaPluginLoader.pluginParentTimer);
+
+    public static final CustomTimingsHandler playerCommandTimer = new CustomTimingsHandler("** playerCommand");
+
+    public static final CustomTimingsHandler entityActivationCheckTimer = new CustomTimingsHandler("entityActivationCheck");
+    public static final CustomTimingsHandler checkIfActiveTimer = new CustomTimingsHandler("** checkIfActive");
+
+    public static final HashMap<String, CustomTimingsHandler> entityTypeTimingMap = new HashMap<String, CustomTimingsHandler>();
+    public static final HashMap<String, CustomTimingsHandler> tileEntityTypeTimingMap = new HashMap<String, CustomTimingsHandler>();
+    public static final HashMap<String, CustomTimingsHandler> pluginTaskTimingMap = new HashMap<String, CustomTimingsHandler>();
+
+    /**
+     * Gets a timer associated with a plugins tasks.
+     * @param task
+     * @param period
+     * @return
+     */
+    public static CustomTimingsHandler getPluginTaskTimings(BukkitTask task, long period) {
+        if (!task.isSync()) {
+            return null;
+        }
+        String plugin;
+        final CraftTask ctask = (CraftTask) task;
+
+        if (task.getOwner() != null) {
+            plugin = task.getOwner().getDescription().getFullName();
+        } else if (ctask.timingName != null) {
+            plugin = "CraftScheduler";
+        } else {
+            plugin = "Unknown";
+        }
+        String taskname = ctask.getTaskName();
+
+        String name = "Task: " + plugin + " Runnable: " + taskname;
+        if (period > 0) {
+            name += "(interval:" + period +")";
+        } else {
+            name += "(Single)";
+        }
+        CustomTimingsHandler result = pluginTaskTimingMap.get(name);
+        if (result == null) {
+            result = new CustomTimingsHandler(name, SpigotTimings.schedulerSyncTimer);
+            pluginTaskTimingMap.put(name, result);
+        }
+        return result;
+    }
+
+    /**
+     * Get a named timer for the specified entity type to track type specific timings.
+     * @param entity
+     * @return
+     */
+    public static CustomTimingsHandler getEntityTimings(Entity entity) {
+        String entityType = entity.getClass().getSimpleName();
+        CustomTimingsHandler result = entityTypeTimingMap.get(entityType);
+        if (result == null) {
+            result = new CustomTimingsHandler("** tickEntity - " + entityType, activatedEntityTimer);
+            entityTypeTimingMap.put(entityType, result);
+        }
+        return result;
+    }
+
+    /**
+     * Get a named timer for the specified tile entity type to track type specific timings.
+     * @param entity
+     * @return
+     */
+    public static CustomTimingsHandler getTileEntityTimings(TileEntity entity) {
+        String entityType = entity.getClass().getSimpleName();
+        CustomTimingsHandler result = tileEntityTypeTimingMap.get(entityType);
+        if (result == null) {
+            result = new CustomTimingsHandler("** tickTileEntity - " + entityType, tickTileEntityTimer);
+            tileEntityTypeTimingMap.put(entityType, result);
+        }
+        return result;
+    }
+
+    /**
+     * Set of timers per world, to track world specific timings.
+     */
+    public static class WorldTimingsHandler {
+        public final CustomTimingsHandler mobSpawn;
+        public final CustomTimingsHandler doChunkUnload;
+        public final CustomTimingsHandler doPortalForcer;
+        public final CustomTimingsHandler doTickPending;
+        public final CustomTimingsHandler doTickTiles;
+        public final CustomTimingsHandler doVillages;
+        public final CustomTimingsHandler doChunkMap;
+        public final CustomTimingsHandler doChunkGC;
+        public final CustomTimingsHandler doSounds;
+        public final CustomTimingsHandler entityTick;
+        public final CustomTimingsHandler tileEntityTick;
+        public final CustomTimingsHandler tileEntityPending;
+        public final CustomTimingsHandler tracker;
+        public final CustomTimingsHandler doTick;
+        public final CustomTimingsHandler tickEntities;
+
+        public final CustomTimingsHandler syncChunkLoadTimer;
+        public final CustomTimingsHandler syncChunkLoadDataTimer;
+        public final CustomTimingsHandler syncChunkLoadStructuresTimer;
+        public final CustomTimingsHandler syncChunkLoadEntitiesTimer;
+        public final CustomTimingsHandler syncChunkLoadTileEntitiesTimer;
+        public final CustomTimingsHandler syncChunkLoadTileTicksTimer;
+        public final CustomTimingsHandler syncChunkLoadPostTimer;
+
+        public WorldTimingsHandler(World server) {
+            String name = server.worldData.getName() +" - ";
+
+            mobSpawn = new CustomTimingsHandler("** " + name + "mobSpawn");
+            doChunkUnload = new CustomTimingsHandler("** " + name + "doChunkUnload");
+            doTickPending = new CustomTimingsHandler("** " + name + "doTickPending");
+            doTickTiles = new CustomTimingsHandler("** " + name + "doTickTiles");
+            doVillages = new CustomTimingsHandler("** " + name + "doVillages");
+            doChunkMap = new CustomTimingsHandler("** " + name + "doChunkMap");
+            doSounds = new CustomTimingsHandler("** " + name + "doSounds");
+            doChunkGC = new CustomTimingsHandler("** " + name + "doChunkGC");
+            doPortalForcer = new CustomTimingsHandler("** " + name + "doPortalForcer");
+            entityTick = new CustomTimingsHandler("** " + name + "entityTick");
+            tileEntityTick = new CustomTimingsHandler("** " + name + "tileEntityTick");
+            tileEntityPending = new CustomTimingsHandler("** " + name + "tileEntityPending");
+
+            syncChunkLoadTimer = new CustomTimingsHandler("** " + name + "syncChunkLoad");
+            syncChunkLoadDataTimer = new CustomTimingsHandler("** " + name + "syncChunkLoad - Data");
+            syncChunkLoadStructuresTimer = new CustomTimingsHandler("** " + name + "chunkLoad - Structures");
+            syncChunkLoadEntitiesTimer = new CustomTimingsHandler("** " + name + "chunkLoad - Entities");
+            syncChunkLoadTileEntitiesTimer = new CustomTimingsHandler("** " + name + "chunkLoad - TileEntities");
+            syncChunkLoadTileTicksTimer = new CustomTimingsHandler("** " + name + "chunkLoad - TileTicks");
+            syncChunkLoadPostTimer = new CustomTimingsHandler("** " + name + "chunkLoad - Post");
+
+
+            tracker = new CustomTimingsHandler(name + "tracker");
+            doTick = new CustomTimingsHandler(name + "doTick");
+            tickEntities = new CustomTimingsHandler(name + "tickEntities");
+        }
+    }
+}
diff --git a/src/main/java/org/bukkit/craftbukkit/block/CraftSign.java b/src/main/java/org/bukkit/craftbukkit/block/CraftSign.java
index 77717d5..1533dd4 100644
--- a/src/main/java/org/bukkit/craftbukkit/block/CraftSign.java
+++ b/src/main/java/org/bukkit/craftbukkit/block/CraftSign.java
@@ -14,6 +14,12 @@ public class CraftSign extends CraftBlockState implements Sign {
 
         CraftWorld world = (CraftWorld) block.getWorld();
         sign = (TileEntitySign) world.getTileEntityAt(getX(), getY(), getZ());
+        // Spigot start
+        if (sign == null) {
+            lines = new String[]{"", "", "", ""};
+            return;
+        }
+        // Spigot end
         lines = new String[sign.lines.length];
         System.arraycopy(sign.lines, 0, lines, 0, lines.length);
     }
@@ -34,7 +40,7 @@ public class CraftSign extends CraftBlockState implements Sign {
     public boolean update(boolean force, boolean applyPhysics) {
         boolean result = super.update(force, applyPhysics);
 
-        if (result) {
+        if (result && sign != null) { // Spigot, add null check
             sign.lines = sanitizeLines(lines);
             sign.update();
         }
diff --git a/src/main/java/org/bukkit/craftbukkit/chunkio/ChunkIOProvider.java b/src/main/java/org/bukkit/craftbukkit/chunkio/ChunkIOProvider.java
index 9cf1b49..c249e77 100644
--- a/src/main/java/org/bukkit/craftbukkit/chunkio/ChunkIOProvider.java
+++ b/src/main/java/org/bukkit/craftbukkit/chunkio/ChunkIOProvider.java
@@ -40,7 +40,9 @@ class ChunkIOProvider implements AsynchronousExecutor.CallBackProvider<QueuedChu
         chunk.addEntities();
 
         if (queuedChunk.provider.chunkProvider != null) {
+            queuedChunk.provider.world.timings.syncChunkLoadStructuresTimer.startTiming(); // Spigot
             queuedChunk.provider.chunkProvider.recreateStructures(queuedChunk.x, queuedChunk.z);
+            queuedChunk.provider.world.timings.syncChunkLoadStructuresTimer.stopTiming(); // Spigot
         }
 
         Server server = queuedChunk.provider.world.getServer();
diff --git a/src/main/java/org/bukkit/craftbukkit/command/ServerCommandSender.java b/src/main/java/org/bukkit/craftbukkit/command/ServerCommandSender.java
index 1314c74..b339cf3 100644
--- a/src/main/java/org/bukkit/craftbukkit/command/ServerCommandSender.java
+++ b/src/main/java/org/bukkit/craftbukkit/command/ServerCommandSender.java
@@ -12,9 +12,18 @@ import org.bukkit.plugin.Plugin;
 import java.util.Set;
 
 public abstract class ServerCommandSender implements CommandSender {
-    private final PermissibleBase perm = new PermissibleBase(this);
+    private static PermissibleBase blockPermInst;
+    private final PermissibleBase perm;
 
     public ServerCommandSender() {
+        if (this instanceof CraftBlockCommandSender) {
+            if (blockPermInst == null) {
+                blockPermInst = new PermissibleBase(this);
+            }
+            this.perm = blockPermInst;
+        } else {
+            this.perm = new PermissibleBase(this);
+        }
     }
 
     public boolean isPermissionSet(String name) {
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftArrow.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftArrow.java
index 4f8d47d..8c8a173 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftArrow.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftArrow.java
@@ -71,4 +71,26 @@ public class CraftArrow extends AbstractProjectile implements Arrow {
     public void _INVALID_setShooter(LivingEntity shooter) {
         getHandle().shooter = ((CraftLivingEntity) shooter).getHandle();
     }
+
+    // Spigot start
+    private final Arrow.Spigot spigot = new Arrow.Spigot()
+    {
+        @Override
+        public double getDamage()
+        {
+            return getHandle().e();
+        }
+
+        @Override
+        public void setDamage(double damage)
+        {
+            getHandle().b( damage );
+        }
+    };
+
+    public Arrow.Spigot spigot()
+    {
+        return spigot;
+    }
+    // Spigot end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
index b8a9a14..1c8099d 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
@@ -208,7 +208,14 @@ public abstract class CraftEntity implements org.bukkit.entity.Entity {
         // If this entity is riding another entity, we must dismount before teleporting.
         entity.mount(null);
 
-        entity.world = ((CraftWorld) location.getWorld()).getHandle();
+        // Spigot start
+        if (!location.getWorld().equals(getWorld())) {
+          entity.teleportTo(location, cause.equals(TeleportCause.NETHER_PORTAL));
+          return true;
+        }
+
+        // entity.world = ((CraftWorld) location.getWorld()).getHandle();
+        // Spigot end
         entity.setLocation(location.getX(), location.getY(), location.getZ(), location.getYaw(), location.getPitch());
         // entity.setLocation() throws no event, and so cannot be cancelled
         return true;
@@ -402,4 +409,20 @@ public abstract class CraftEntity implements org.bukkit.entity.Entity {
 
         return getHandle().vehicle.getBukkitEntity();
     }
+
+    // Spigot start
+    private final Spigot spigot = new Spigot()
+    {
+        @Override
+        public boolean isInvulnerable()
+        {
+            return getHandle().isInvulnerable();
+        }
+    };
+
+    public Spigot spigot()
+    {
+        return spigot;
+    }
+    // Spigot end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftLightningStrike.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftLightningStrike.java
index 64e346d..be4f10f 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftLightningStrike.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftLightningStrike.java
@@ -1,7 +1,9 @@
 package org.bukkit.craftbukkit.entity;
 
 import net.minecraft.server.EntityLightning;
+
 import org.bukkit.craftbukkit.CraftServer;
+import org.bukkit.entity.Arrow;
 import org.bukkit.entity.EntityType;
 import org.bukkit.entity.LightningStrike;
 
@@ -27,4 +29,22 @@ public class CraftLightningStrike extends CraftEntity implements LightningStrike
     public EntityType getType() {
         return EntityType.LIGHTNING;
     }
+    
+    // Spigot start
+    private final LightningStrike.Spigot spigot = new LightningStrike.Spigot()
+    {
+
+        @Override
+        public boolean isSilent()
+        {
+            return getHandle().isSilent;
+        }
+
+    };
+
+    public LightningStrike.Spigot spigot()
+    {
+        return this.spigot;
+    }
+    // Spigot end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
index bbf310b..35f2bfa 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
@@ -203,17 +203,29 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
         getHandle().listName = name;
 
         // Change the name on the client side
-        PacketPlayOutPlayerInfo oldpacket = new PacketPlayOutPlayerInfo(oldName, false, 9999);
-        PacketPlayOutPlayerInfo packet = new PacketPlayOutPlayerInfo(name, true, getHandle().ping);
+        // Spigot start - protocol patch
+        String temp = getHandle().listName;
+        getHandle().listName = oldName;
+        PacketPlayOutPlayerInfo oldpacket = PacketPlayOutPlayerInfo.removePlayer(getHandle());
+        getHandle().listName = temp;
+        PacketPlayOutPlayerInfo packet = PacketPlayOutPlayerInfo.addPlayer(getHandle());
+        PacketPlayOutPlayerInfo newPacket = PacketPlayOutPlayerInfo.updateDisplayName(getHandle());
         for (int i = 0; i < server.getHandle().players.size(); ++i) {
             EntityPlayer entityplayer = (EntityPlayer) server.getHandle().players.get(i);
             if (entityplayer.playerConnection == null) continue;
 
             if (entityplayer.getBukkitEntity().canSee(this)) {
-                entityplayer.playerConnection.sendPacket(oldpacket);
-                entityplayer.playerConnection.sendPacket(packet);
+                if (entityplayer.playerConnection.networkManager.getVersion() < 28)
+                {
+                    entityplayer.playerConnection.sendPacket( oldpacket );
+                    entityplayer.playerConnection.sendPacket( packet );
+                } else {
+                    entityplayer.playerConnection.sendPacket( newPacket );
+                }
             }
         }
+
+        // Spigot end
     }
 
     @Override
@@ -238,6 +250,7 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
 
     @Override
     public void kickPlayer(String message) {
+        org.spigotmc.AsyncCatcher.catchOp( "player kick"); // Spigot
         if (getHandle().playerConnection == null) return;
 
         getHandle().playerConnection.disconnect(message == null ? "" : message);
@@ -441,7 +454,7 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
             for (int y = 0; y < 128; ++y) {
                 bytes[y + 3] = data.buffer[y * 128 + x];
             }
-            PacketPlayOutMap packet = new PacketPlayOutMap(map.getId(), bytes);
+            PacketPlayOutMap packet = new PacketPlayOutMap(map.getId(), bytes, map.getScale().getValue()); // Spigot - protocol patch
             getHandle().playerConnection.sendPacket(packet);
         }
     }
@@ -893,7 +906,7 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
         }
 
         //remove the hidden player from this player user list
-        getHandle().playerConnection.sendPacket(new PacketPlayOutPlayerInfo(player.getPlayerListName(), false, 9999));
+        getHandle().playerConnection.sendPacket(PacketPlayOutPlayerInfo.removePlayer( ( (CraftPlayer) player ).getHandle ())); // Spigot - protocol patch
     }
 
     public void showPlayer(Player player) {
@@ -910,7 +923,7 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
             entry.updatePlayer(getHandle());
         }
 
-        getHandle().playerConnection.sendPacket(new PacketPlayOutPlayerInfo(player.getPlayerListName(), true, getHandle().ping));
+        getHandle().playerConnection.sendPacket(PacketPlayOutPlayerInfo.addPlayer( ( (CraftPlayer) player ).getHandle ())); // Spigot - protocol patch
     }
 
     public void removeDisconnectingPlayer(Player player) {
@@ -1051,6 +1064,7 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
     }
 
     public void addChannel(String channel) {
+        com.google.common.base.Preconditions.checkState( channels.size() < 128, "Too many channels registered" ); // Spigot
         if (channels.add(channel)) {
             server.getPluginManager().callEvent(new PlayerRegisterChannelEvent(this, channel));
         }
@@ -1164,7 +1178,7 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
     public void setFlySpeed(float value) {
         validateSpeed(value);
         EntityPlayer player = getHandle();
-        player.abilities.flySpeed = value / 2f;
+        player.abilities.flySpeed = Math.max( value, 0.0001f ) / 2f; // Spigot
         player.updateAbilities();
 
     }
@@ -1172,7 +1186,7 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
     public void setWalkSpeed(float value) {
         validateSpeed(value);
         EntityPlayer player = getHandle();
-        player.abilities.walkSpeed = value / 2f;
+        player.abilities.walkSpeed = Math.max( value, 0.0001f ) / 2f; // Spigot
         player.updateAbilities();
     }
 
@@ -1220,7 +1234,7 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
             throw new IllegalStateException("Cannot set scoreboard yet");
         }
         if (playerConnection.isDisconnected()) {
-            throw new IllegalStateException("Cannot set scoreboard for invalid CraftPlayer");
+            // throw new IllegalStateException("Cannot set scoreboard for invalid CraftPlayer"); // Spigot - remove this as Mojang's semi asynchronous Netty implementation can lead to races
         }
 
         this.server.getScoreboardManager().setPlayerBoard(this, scoreboard);
@@ -1285,6 +1299,114 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
                 break;
             }
         }
-        collection.add(new AttributeModifiable(getHandle().getAttributeMap(), (new AttributeRanged("generic.maxHealth", scaledHealth ? healthScale : getMaxHealth(), 0.0D, Float.MAX_VALUE)).a("Max Health").a(true)));
+        // Spigot start
+        double healthMod = scaledHealth ? healthScale : getMaxHealth();
+        if ( healthMod >= Float.MAX_VALUE || healthMod <= 0 )
+        {
+            healthMod = 20; // Reset health
+            getServer().getLogger().warning( getName() + " tried to crash the server with a large health attribute" );
+        }
+        collection.add(new AttributeModifiable(getHandle().getAttributeMap(), (new AttributeRanged("generic.maxHealth", healthMod, 0.0D, Float.MAX_VALUE)).a("Max Health").a(true)));
+        // Spigot end
+    }
+
+    // Spigot start
+    private final Player.Spigot spigot = new Player.Spigot()
+    {
+
+        @Override
+        public InetSocketAddress getRawAddress()
+        {
+            return (InetSocketAddress) getHandle().playerConnection.networkManager.getRawAddress();
+        }
+
+        @Override
+        public boolean getCollidesWithEntities()
+        {
+            return getHandle().collidesWithEntities;
+        }
+
+        @Override
+        public void setCollidesWithEntities(boolean collides)
+        {
+            getHandle().collidesWithEntities = collides;
+            getHandle().k = collides; // First boolean of Entity
+        }
+
+        @Override
+        public void respawn()
+        {
+            if ( getHealth() <= 0 && isOnline() )
+            {
+                server.getServer().getPlayerList().moveToWorld( getHandle(), 0, false );
+            }
+        }
+
+        @Override
+        public void playEffect( Location location, Effect effect, int id, int data, float offsetX, float offsetY, float offsetZ, float speed, int particleCount, int radius )
+        {
+            Validate.notNull( location, "Location cannot be null" );
+            Validate.notNull( effect, "Effect cannot be null" );
+            Validate.notNull( location.getWorld(), "World cannot be null" );
+            Packet packet;
+            if ( effect.getType() != Effect.Type.PARTICLE )
+            {
+                int packetData = effect.getId();
+                packet = new PacketPlayOutWorldEvent( packetData, location.getBlockX(), location.getBlockY(), location.getBlockZ(), id, false );
+            } else
+            {
+                StringBuilder particleFullName = new StringBuilder();
+                particleFullName.append( effect.getName() );
+                if ( effect.getData() != null && ( effect.getData().equals( Material.class ) || effect.getData().equals( org.bukkit.material.MaterialData.class ) ) )
+                {
+                    particleFullName.append( '_' ).append( id );
+                }
+                if ( effect.getData() != null && effect.getData().equals( org.bukkit.material.MaterialData.class ) )
+                {
+                    particleFullName.append( '_' ).append( data );
+                }
+                packet = new PacketPlayOutWorldParticles( particleFullName.toString(), (float) location.getX(), (float) location.getY(), (float) location.getZ(), offsetX, offsetY, offsetZ, speed, particleCount );
+            }
+            int distance;
+            radius *= radius;
+            if ( getHandle().playerConnection == null )
+            {
+                return;
+            }
+            if ( !location.getWorld().equals( getWorld() ) )
+            {
+                return;
+            }
+
+            distance = (int) getLocation().distanceSquared( location );
+            if ( distance <= radius )
+            {
+                getHandle().playerConnection.sendPacket( packet );
+            }
+        }
+
+        @Override
+        public String getLocale()
+        {
+           return getHandle().locale;
+        }
+
+        @Override
+        public Set<Player> getHiddenPlayers()
+        {
+            Set<Player> ret = new HashSet<Player>();
+            for ( UUID u : hiddenPlayers )
+            {
+                ret.add( getServer().getPlayer( u ) );
+            }
+
+            return java.util.Collections.unmodifiableSet( ret );
+        }
+    };
+
+    public Player.Spigot spigot()
+    {
+        return spigot;
     }
+    // Spigot end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java b/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
index 9b10c41..d452df7 100644
--- a/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
+++ b/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
@@ -41,6 +41,7 @@ import org.bukkit.Statistic.Type;
 import org.bukkit.block.Block;
 import org.bukkit.block.BlockFace;
 import org.bukkit.block.BlockState;
+import org.bukkit.block.CreatureSpawner;
 import org.bukkit.craftbukkit.CraftServer;
 import org.bukkit.craftbukkit.CraftStatistic;
 import org.bukkit.craftbukkit.CraftWorld;
@@ -150,6 +151,22 @@ public class CraftEventFactory {
     }
 
     /**
+     * Mob spawner event
+     */
+    public static SpawnerSpawnEvent callSpawnerSpawnEvent(Entity spawnee, int spawnerX, int spawnerY, int spawnerZ) {
+        org.bukkit.craftbukkit.entity.CraftEntity entity = spawnee.getBukkitEntity();
+        BlockState state = entity.getWorld().getBlockAt(spawnerX, spawnerY, spawnerZ).getState();
+
+        if (!(state instanceof CreatureSpawner)) {
+            state = null;
+        }
+
+        SpawnerSpawnEvent event = new SpawnerSpawnEvent(entity, (CreatureSpawner) state);
+        entity.getServer().getPluginManager().callEvent(event);
+        return event;
+    }
+
+    /**
      * Bucket methods
      */
     public static PlayerBucketEmptyEvent callPlayerBucketEmptyEvent(EntityHuman who, int clickedX, int clickedY, int clickedZ, int clickedFace, ItemStack itemInHand) {
@@ -190,7 +207,7 @@ public class CraftEventFactory {
      */
     public static PlayerInteractEvent callPlayerInteractEvent(EntityHuman who, Action action, ItemStack itemstack) {
         if (action != Action.LEFT_CLICK_AIR && action != Action.RIGHT_CLICK_AIR) {
-            throw new AssertionError(String.format("%s performing %s with %s", who, action, itemstack));
+            throw new IllegalArgumentException(String.format("%s performing %s with %s", who, action, itemstack)); // Spigot
         }
         return callPlayerInteractEvent(who, action, 0, 256, 0, 0, itemstack);
     }
@@ -467,7 +484,7 @@ public class CraftEventFactory {
             if (source == DamageSource.CACTUS) {
                 cause = DamageCause.CONTACT;
             } else {
-                throw new AssertionError(String.format("Unhandled damage of %s by %s from %s", entity, damager, source.translationIndex));
+                throw new RuntimeException(String.format("Unhandled damage of %s by %s from %s", entity, damager, source.translationIndex)); // Spigot
             }
             EntityDamageEvent event = callEvent(new EntityDamageByBlockEvent(damager, entity.getBukkitEntity(), cause, modifiers, modifierFunctions));
             if (!event.isCancelled()) {
@@ -485,7 +502,7 @@ public class CraftEventFactory {
             } else if (source == DamageSource.FALL) {
                 cause = DamageCause.FALL;
             } else {
-                throw new AssertionError(String.format("Unhandled damage of %s by %s from %s", entity, damager.getHandle(), source.translationIndex));
+                throw new RuntimeException(String.format("Unhandled damage of %s by %s from %s", entity, damager.getHandle(), source.translationIndex)); // Spigot
             }
             EntityDamageEvent event = callEvent(new EntityDamageByEntityEvent(damager, entity.getBukkitEntity(), cause, modifiers, modifierFunctions));
             if (!event.isCancelled()) {
@@ -523,7 +540,7 @@ public class CraftEventFactory {
             return callEntityDamageEvent(null, entity, cause, modifiers, modifierFunctions);
         }
 
-        throw new AssertionError(String.format("Unhandled damage of %s from %s", entity, source.translationIndex));
+        throw new RuntimeException(String.format("Unhandled damage of %s from %s", entity, source.translationIndex)); // Spigot
     }
 
     private static EntityDamageEvent callEntityDamageEvent(Entity damager, Entity damagee, DamageCause cause, Map<DamageModifier, Double> modifiers, Map<DamageModifier, Function<? super Double, Double>> modifierFunctions) {
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBook.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBook.java
index 1cf8fce..bdc6364 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBook.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBook.java
@@ -17,6 +17,10 @@ import com.google.common.base.Strings;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap.Builder;
 
+// Spigot start
+import static org.spigotmc.ValidateUtils.*;
+// Spigot end
+
 @DelegateDeserialization(SerializableMeta.class)
 class CraftMetaBook extends CraftMetaItem implements BookMeta {
     static final ItemMetaKey BOOK_TITLE = new ItemMetaKey("title");
@@ -45,11 +49,11 @@ class CraftMetaBook extends CraftMetaItem implements BookMeta {
         super(tag);
 
         if (tag.hasKey(BOOK_TITLE.NBT)) {
-            this.title = tag.getString(BOOK_TITLE.NBT);
+            this.title = limit( tag.getString(BOOK_TITLE.NBT), 1024 ); // Spigot
         }
 
         if (tag.hasKey(BOOK_AUTHOR.NBT)) {
-            this.author = tag.getString(BOOK_AUTHOR.NBT);
+            this.author = limit( tag.getString(BOOK_AUTHOR.NBT), 1024 ); // Spigot
         }
 
         if (tag.hasKey(BOOK_PAGES.NBT)) {
@@ -57,7 +61,7 @@ class CraftMetaBook extends CraftMetaItem implements BookMeta {
             String[] pageArray = new String[pages.size()];
 
             for (int i = 0; i < pages.size(); i++) {
-                String page = pages.getString(i);
+                String page = limit( pages.getString(i), 2048 ); // Spigot
                 pageArray[i] = page;
             }
 
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaFirework.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaFirework.java
index 0f7da6b..5a409ae 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaFirework.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaFirework.java
@@ -145,7 +145,7 @@ class CraftMetaFirework extends CraftMetaItem implements FireworkMeta {
             case BURST:
                 return 4;
             default:
-                throw new AssertionError(type);
+                throw new IllegalStateException(type.toString()); // Spigot
         }
     }
 
@@ -162,7 +162,7 @@ class CraftMetaFirework extends CraftMetaItem implements FireworkMeta {
             case 4:
                 return Type.BURST;
             default:
-                throw new AssertionError(nbt);
+                throw new IllegalStateException(Integer.toString(nbt)); // Spigot
         }
     }
 
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaItem.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaItem.java
index c9738c4..f7a7adc 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaItem.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaItem.java
@@ -36,6 +36,12 @@ import com.google.common.base.Strings;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 
+// Spigot start
+import static org.spigotmc.ValidateUtils.*;
+import net.minecraft.server.GenericAttributes;
+import net.minecraft.server.IAttribute;
+// Spigot end
+
 /**
  * Children must include the following:
  *
@@ -195,6 +201,7 @@ class CraftMetaItem implements ItemMeta, Repairable {
     static final ItemMetaKey ATTRIBUTES_UUID_HIGH = new ItemMetaKey("UUIDMost");
     @Specific(Specific.To.NBT)
     static final ItemMetaKey ATTRIBUTES_UUID_LOW = new ItemMetaKey("UUIDLeast");
+    static final ItemMetaKey UNBREAKABLE = new ItemMetaKey("Unbreakable"); // Spigot
 
     private String displayName;
     private List<String> lore;
@@ -220,6 +227,7 @@ class CraftMetaItem implements ItemMeta, Repairable {
 
         this.repairCost = meta.repairCost;
         this.attributes = meta.attributes;
+        spigot.setUnbreakable( meta.spigot.isUnbreakable() ); // Spigot
     }
 
     CraftMetaItem(NBTTagCompound tag) {
@@ -227,7 +235,7 @@ class CraftMetaItem implements ItemMeta, Repairable {
             NBTTagCompound display = tag.getCompound(DISPLAY.NBT);
 
             if (display.hasKey(NAME.NBT)) {
-                displayName = display.getString(NAME.NBT);
+                displayName = limit( display.getString(NAME.NBT), 1024 ); // Spigot
             }
 
             if (display.hasKey(LORE.NBT)) {
@@ -235,7 +243,7 @@ class CraftMetaItem implements ItemMeta, Repairable {
                 lore = new ArrayList<String>(list.size());
 
                 for (int index = 0; index < list.size(); index++) {
-                    String line = list.getString(index);
+                    String line = limit( list.getString(index), 1024 ); // Spigot
                     lore.add(line);
                 }
             }
@@ -252,6 +260,123 @@ class CraftMetaItem implements ItemMeta, Repairable {
             NBTTagList save = null;
             NBTTagList nbttaglist = tag.getList(ATTRIBUTES.NBT, 10);
 
+            // Spigot start
+            net.minecraft.util.gnu.trove.map.hash.TObjectDoubleHashMap<String> attributeTracker = new net.minecraft.util.gnu.trove.map.hash.TObjectDoubleHashMap<String>();
+            net.minecraft.util.gnu.trove.map.hash.TObjectDoubleHashMap<String> attributeTrackerX = new net.minecraft.util.gnu.trove.map.hash.TObjectDoubleHashMap<String>();
+            Map<String, IAttribute> attributesByName = new HashMap<String, IAttribute>();
+            attributeTracker.put( "generic.maxHealth", 20.0 );
+            attributesByName.put( "generic.maxHealth", GenericAttributes.maxHealth );
+            attributeTracker.put( "generic.followRange", 32.0 );
+            attributesByName.put( "generic.followRange", GenericAttributes.b );
+            attributeTracker.put( "generic.knockbackResistance", 0.0 );
+            attributesByName.put( "generic.knockbackResistance", GenericAttributes.c );
+            attributeTracker.put( "generic.movementSpeed", 0.7 );
+            attributesByName.put( "generic.movementSpeed", GenericAttributes.d );
+            attributeTracker.put( "generic.attackDamage", 1.0 );
+            attributesByName.put( "generic.attackDamage", GenericAttributes.e );
+            NBTTagList oldList = nbttaglist;
+            nbttaglist = new NBTTagList();
+
+            List<NBTTagCompound> op0 = new ArrayList<NBTTagCompound>();
+            List<NBTTagCompound> op1 = new ArrayList<NBTTagCompound>();
+            List<NBTTagCompound> op2 = new ArrayList<NBTTagCompound>();
+
+            for ( int i = 0; i < oldList.size(); ++i )
+            {
+                NBTTagCompound nbttagcompound = oldList.get( i );
+                if ( nbttagcompound == null ) continue;
+
+                if ( !( nbttagcompound.get( ATTRIBUTES_UUID_HIGH.NBT ) instanceof NBTTagLong ) )
+                {
+                    continue;
+                }
+                if ( !( nbttagcompound.get( ATTRIBUTES_UUID_LOW.NBT ) instanceof NBTTagLong ) )
+                {
+                    continue;
+                }
+                if ( !( nbttagcompound.get( ATTRIBUTES_IDENTIFIER.NBT ) instanceof NBTTagString ) || !CraftItemFactory.KNOWN_NBT_ATTRIBUTE_NAMES.contains( nbttagcompound.getString( ATTRIBUTES_IDENTIFIER.NBT ) ) )
+                {
+                    continue;
+                }
+                if ( !( nbttagcompound.get( ATTRIBUTES_NAME.NBT ) instanceof NBTTagString ) || nbttagcompound.getString( ATTRIBUTES_NAME.NBT ).isEmpty() )
+                {
+                    continue;
+                }
+                if ( !( nbttagcompound.get( ATTRIBUTES_VALUE.NBT ) instanceof NBTTagDouble ) )
+                {
+                    continue;
+                }
+                if ( !( nbttagcompound.get( ATTRIBUTES_TYPE.NBT ) instanceof NBTTagInt ) || nbttagcompound.getInt( ATTRIBUTES_TYPE.NBT ) < 0 || nbttagcompound.getInt( ATTRIBUTES_TYPE.NBT ) > 2 )
+                {
+                    continue;
+                }
+
+                switch ( nbttagcompound.getInt( ATTRIBUTES_TYPE.NBT ) )
+                {
+                    case 0:
+                        op0.add( nbttagcompound );
+                        break;
+                    case 1:
+                        op1.add( nbttagcompound );
+                        break;
+                    case 2:
+                        op2.add( nbttagcompound );
+                        break;
+                }
+            }
+            for ( NBTTagCompound nbtTagCompound : op0 )
+            {
+                String name = nbtTagCompound.getString( ATTRIBUTES_IDENTIFIER.NBT );
+                if ( attributeTracker.containsKey( name ) )
+                {
+                    double val = attributeTracker.get( name );
+                    val += nbtTagCompound.getDouble( ATTRIBUTES_VALUE.NBT );
+                    if ( val != attributesByName.get( name ).a( val ) )
+                    {
+                        continue;
+                    }
+                    attributeTracker.put( name, val );
+                }
+                nbttaglist.add( nbtTagCompound );
+            }
+            for ( String name : attributeTracker.keySet() )
+            {
+                attributeTrackerX.put( name, attributeTracker.get( name ) );
+            }
+            for ( NBTTagCompound nbtTagCompound : op1 )
+            {
+                String name = nbtTagCompound.getString( ATTRIBUTES_IDENTIFIER.NBT );
+                if ( attributeTracker.containsKey( name ) )
+                {
+                    double val = attributeTracker.get( name );
+                    double valX = attributeTrackerX.get( name );
+                    val += valX * nbtTagCompound.getDouble( ATTRIBUTES_VALUE.NBT );
+                    if ( val != attributesByName.get( name ).a( val ) )
+                    {
+                        continue;
+                    }
+                    attributeTracker.put( name, val );
+                }
+                nbttaglist.add( nbtTagCompound );
+            }
+            for ( NBTTagCompound nbtTagCompound : op2 )
+            {
+                String name = nbtTagCompound.getString( ATTRIBUTES_IDENTIFIER.NBT );
+                if ( attributeTracker.containsKey( name ) )
+                {
+                    double val = attributeTracker.get( name );
+                    val += val * nbtTagCompound.getDouble( ATTRIBUTES_VALUE.NBT );
+                    if ( val != attributesByName.get( name ).a( val ) )
+                    {
+                        continue;
+                    }
+                    attributeTracker.put( name, val );
+                }
+                nbttaglist.add( nbtTagCompound );
+            }
+
+            // Spigot end
+
             for (int i = 0; i < nbttaglist.size(); ++i) {
                 if (!(nbttaglist.get(i) instanceof NBTTagCompound)) {
                     continue;
@@ -295,6 +420,12 @@ class CraftMetaItem implements ItemMeta, Repairable {
         } else {
             attributes = null;
         }
+        // Spigot start
+        if ( tag.hasKey( UNBREAKABLE.NBT ) )
+        {
+            spigot.setUnbreakable( tag.getBoolean( UNBREAKABLE.NBT ) );
+        }
+        // Spigot end
     }
 
     static Map<Enchantment, Integer> buildEnchantments(NBTTagCompound tag, ItemMetaKey key) {
@@ -309,7 +440,11 @@ class CraftMetaItem implements ItemMeta, Repairable {
             int id = 0xffff & ((NBTTagCompound) ench.get(i)).getShort(ENCHANTMENTS_ID.NBT);
             int level = 0xffff & ((NBTTagCompound) ench.get(i)).getShort(ENCHANTMENTS_LVL.NBT);
 
-            enchantments.put(Enchantment.getById(id), level);
+            // Spigot start - skip invalid enchantments
+            Enchantment e = Enchantment.getById(id);
+            if (e == null) continue;
+            // Spigot end
+            enchantments.put(e, level);
         }
 
         return enchantments;
@@ -331,6 +466,13 @@ class CraftMetaItem implements ItemMeta, Repairable {
         }
 
         attributes = null;
+        // Spigot start
+        Boolean unbreakable = SerializableMeta.getObject( Boolean.class, map, UNBREAKABLE.BUKKIT, true );
+        if ( unbreakable != null )
+        {
+            spigot.setUnbreakable( unbreakable );
+        }
+        // Spigot end
     }
 
     static Map<Enchantment, Integer> buildEnchantments(Map<String, Object> map, ItemMetaKey key) {
@@ -363,6 +505,13 @@ class CraftMetaItem implements ItemMeta, Repairable {
 
         applyEnchantments(enchantments, itemTag, ENCHANTMENTS);
 
+        // Spigot start
+        if ( spigot.isUnbreakable() )
+        {
+            itemTag.setBoolean( UNBREAKABLE.NBT, true );
+        }
+        // Spigot end
+
         if (hasRepairCost()) {
             itemTag.setInt(REPAIR.NBT, repairCost);
         }
@@ -386,7 +535,7 @@ class CraftMetaItem implements ItemMeta, Repairable {
     }
 
     static void applyEnchantments(Map<Enchantment, Integer> enchantments, NBTTagCompound tag, ItemMetaKey key) {
-        if (enchantments == null || enchantments.size() == 0) {
+        if (enchantments == null /*|| enchantments.size() == 0*/) { // Spigot - remove size check
             return;
         }
 
@@ -421,7 +570,7 @@ class CraftMetaItem implements ItemMeta, Repairable {
 
     @Overridden
     boolean isEmpty() {
-        return !(hasDisplayName() || hasEnchants() || hasLore() || hasAttributes() || hasRepairCost());
+        return !(hasDisplayName() || hasEnchants() || hasLore() || hasAttributes() || hasRepairCost() || spigot.isUnbreakable()); // Spigot
     }
 
     public String getDisplayName() {
@@ -477,7 +626,14 @@ class CraftMetaItem implements ItemMeta, Repairable {
     }
 
     public boolean removeEnchant(Enchantment ench) {
-        return hasEnchants() && enchantments.remove(ench) != null;
+        // Spigot start
+        boolean b = hasEnchants() && enchantments.remove( ench ) != null;
+        if ( enchantments != null && enchantments.isEmpty() )
+        {
+            this.enchantments = null;
+        }
+        return b;
+        // Spigot end
     }
 
     public boolean hasEnchants() {
@@ -538,7 +694,7 @@ class CraftMetaItem implements ItemMeta, Repairable {
                 && (this.hasEnchants() ? that.hasEnchants() && this.enchantments.equals(that.enchantments) : !that.hasEnchants())
                 && (this.hasLore() ? that.hasLore() && this.lore.equals(that.lore) : !that.hasLore())
                 && (this.hasAttributes() ? that.hasAttributes() && this.attributes.equals(that.attributes) : !that.hasAttributes())
-                && (this.hasRepairCost() ? that.hasRepairCost() && this.repairCost == that.repairCost : !that.hasRepairCost());
+                && (this.hasRepairCost() ? that.hasRepairCost() && this.repairCost == that.repairCost : !that.hasRepairCost()) && this.spigot.isUnbreakable() == that.spigot.isUnbreakable(); // Spigot
     }
 
     /**
@@ -564,6 +720,7 @@ class CraftMetaItem implements ItemMeta, Repairable {
         hash = 61 * hash + (hasEnchants() ? this.enchantments.hashCode() : 0);
         hash = 61 * hash + (hasAttributes() ? this.attributes.hashCode() : 0);
         hash = 61 * hash + (hasRepairCost() ? this.repairCost : 0);
+        hash = 61 * hash + (spigot.isUnbreakable() ? 1231 : 1237); // Spigot
         return hash;
     }
 
@@ -607,6 +764,13 @@ class CraftMetaItem implements ItemMeta, Repairable {
             builder.put(REPAIR.BUKKIT, repairCost);
         }
 
+        // Spigot start
+        if ( spigot.isUnbreakable() )
+        {
+            builder.put( UNBREAKABLE.BUKKIT, true );
+        }
+        // Spigot end
+
         return builder;
     }
 
@@ -665,4 +829,29 @@ class CraftMetaItem implements ItemMeta, Repairable {
     public final String toString() {
         return SerializableMeta.classMap.get(getClass()) + "_META:" + serialize(); // TODO: cry
     }
+
+    // Spigot start
+    private final Spigot spigot = new Spigot()
+    {
+        private boolean unbreakable;
+
+        @Override
+        public void setUnbreakable(boolean setUnbreakable)
+        {
+            unbreakable = setUnbreakable;
+        }
+
+        @Override
+        public boolean isUnbreakable()
+        {
+            return unbreakable;
+        }
+    };
+
+    @Override
+    public Spigot spigot()
+    {
+        return spigot;
+    }
+    // Spigot end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaSkull.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaSkull.java
index d648d05..e32bcb1 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaSkull.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaSkull.java
@@ -46,13 +46,39 @@ class CraftMetaSkull extends CraftMetaItem implements SkullMeta {
     }
 
     @Override
-    void applyToItem(NBTTagCompound tag) {
+    void applyToItem(final NBTTagCompound tag) { // Spigot - make final
         super.applyToItem(tag);
 
         if (hasOwner()) {
             NBTTagCompound owner = new NBTTagCompound();
             GameProfileSerializer.serialize(owner, profile);
-            tag.set(SKULL_OWNER.NBT, owner);
+            tag.set( SKULL_OWNER.NBT, owner );
+            // Spigot start - do an async lookup of the profile. 
+            // Unfortunately there is not way to refresh the holding
+            // inventory, so that responsibility is left to the user.
+            net.minecraft.server.TileEntitySkull.executor.execute( new Runnable()
+            {
+                @Override
+                public void run()
+                {
+
+                    final GameProfile profile = net.minecraft.server.TileEntitySkull.skinCache.getUnchecked( CraftMetaSkull.this.profile.getName().toLowerCase() );
+                    if ( profile != null )
+                    {
+                        MinecraftServer.getServer().processQueue.add( new Runnable()
+                        {
+                            @Override
+                            public void run()
+                            {
+                                NBTTagCompound owner = new NBTTagCompound();
+                                GameProfileSerializer.serialize( owner, profile );
+                                tag.set( SKULL_OWNER.NBT, owner );
+                            }
+                        } );
+                    }
+                }
+            } );
+            // Spigot end
         }
     }
 
diff --git a/src/main/java/org/bukkit/craftbukkit/map/CraftMapView.java b/src/main/java/org/bukkit/craftbukkit/map/CraftMapView.java
index 1a150d9..c9f0027 100644
--- a/src/main/java/org/bukkit/craftbukkit/map/CraftMapView.java
+++ b/src/main/java/org/bukkit/craftbukkit/map/CraftMapView.java
@@ -18,7 +18,7 @@ import org.bukkit.map.MapView;
 public final class CraftMapView implements MapView {
 
     private final Map<CraftPlayer, RenderData> renderCache = new HashMap<CraftPlayer, RenderData>();
-    private final List<MapRenderer> renderers = new ArrayList<MapRenderer>();
+    public final List<MapRenderer> renderers = new ArrayList<MapRenderer>(); // Spigot
     private final Map<MapRenderer, Map<CraftPlayer, CraftMapCanvas>> canvases = new HashMap<MapRenderer, Map<CraftPlayer, CraftMapCanvas>>();
     protected final WorldMap worldMap;
 
diff --git a/src/main/java/org/bukkit/craftbukkit/scheduler/CraftScheduler.java b/src/main/java/org/bukkit/craftbukkit/scheduler/CraftScheduler.java
index 9fea4fb..93d8d42 100644
--- a/src/main/java/org/bukkit/craftbukkit/scheduler/CraftScheduler.java
+++ b/src/main/java/org/bukkit/craftbukkit/scheduler/CraftScheduler.java
@@ -72,7 +72,7 @@ public class CraftScheduler implements BukkitScheduler {
      */
     private final ConcurrentHashMap<Integer, CraftTask> runners = new ConcurrentHashMap<Integer, CraftTask>();
     private volatile int currentTick = -1;
-    private final Executor executor = Executors.newCachedThreadPool();
+    private final Executor executor = Executors.newCachedThreadPool(new com.google.common.util.concurrent.ThreadFactoryBuilder().setNameFormat("Craft Scheduler Thread - %1$d").build()); // Spigot
     private CraftAsyncDebugger debugHead = new CraftAsyncDebugger(-1, null, null) {@Override StringBuilder debugTo(StringBuilder string) {return string;}};
     private CraftAsyncDebugger debugTail = debugHead;
     private static final int RECENT_TICKS;
@@ -346,7 +346,9 @@ public class CraftScheduler implements BukkitScheduler {
             }
             if (task.isSync()) {
                 try {
+                    task.timings.startTiming(); // Spigot
                     task.run();
+                    task.timings.stopTiming(); // Spigot
                 } catch (final Throwable throwable) {
                     task.getOwner().getLogger().log(
                             Level.WARNING,
diff --git a/src/main/java/org/bukkit/craftbukkit/scheduler/CraftTask.java b/src/main/java/org/bukkit/craftbukkit/scheduler/CraftTask.java
index 55db3ff..220e39a 100644
--- a/src/main/java/org/bukkit/craftbukkit/scheduler/CraftTask.java
+++ b/src/main/java/org/bukkit/craftbukkit/scheduler/CraftTask.java
@@ -1,11 +1,13 @@
 package org.bukkit.craftbukkit.scheduler;
 
 import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.SpigotTimings; // Spigot
+import org.spigotmc.CustomTimingsHandler; // Spigot
 import org.bukkit.plugin.Plugin;
 import org.bukkit.scheduler.BukkitTask;
 
 
-class CraftTask implements BukkitTask, Runnable {
+public class CraftTask implements BukkitTask, Runnable { // Spigot
 
     private volatile CraftTask next = null;
     /**
@@ -22,6 +24,7 @@ class CraftTask implements BukkitTask, Runnable {
     private final Plugin plugin;
     private final int id;
 
+    final CustomTimingsHandler timings; // Spigot
     CraftTask() {
         this(null, null, -1, -1);
     }
@@ -30,11 +33,26 @@ class CraftTask implements BukkitTask, Runnable {
         this(null, task, -1, -1);
     }
 
-    CraftTask(final Plugin plugin, final Runnable task, final int id, final long period) {
+    // Spigot start
+    public String timingName = null;
+    CraftTask(String timingName) {
+        this(timingName, null, null, -1, -1);
+    }
+    CraftTask(String timingName, final Runnable task) {
+        this(timingName, null, task, -1, -1);
+    }
+    CraftTask(String timingName, final Plugin plugin, final Runnable task, final int id, final long period) {
         this.plugin = plugin;
         this.task = task;
         this.id = id;
         this.period = period;
+        this.timingName = timingName == null && task == null ? "Unknown" : timingName;
+        timings = this.isSync() ? SpigotTimings.getPluginTaskTimings(this, period) : null;
+    }
+
+    CraftTask(final Plugin plugin, final Runnable task, final int id, final long period) {
+        this(null, plugin, task, id, period);
+    // Spigot end
     }
 
     public final int getTaskId() {
@@ -94,4 +112,13 @@ class CraftTask implements BukkitTask, Runnable {
         setPeriod(-2l);
         return true;
     }
+
+    // Spigot start
+    public String getTaskName() {
+        if (timingName != null) {
+            return timingName;
+        }
+        return task.getClass().getName();
+    }
+    // Spigot end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/scoreboard/CraftObjective.java b/src/main/java/org/bukkit/craftbukkit/scoreboard/CraftObjective.java
index 9eaec71..0ee1147 100644
--- a/src/main/java/org/bukkit/craftbukkit/scoreboard/CraftObjective.java
+++ b/src/main/java/org/bukkit/craftbukkit/scoreboard/CraftObjective.java
@@ -95,6 +95,7 @@ final class CraftObjective extends CraftScoreboardComponent implements Objective
 
     public Score getScore(String entry) throws IllegalArgumentException, IllegalStateException {
         Validate.notNull(entry, "Entry cannot be null");
+        if (entry.length() > 16) throw new IllegalArgumentException("Entry cannot be longer than 16 characters!"); // Spigot
         CraftScoreboard scoreboard = checkState();
 
         return new CraftScore(this, entry);
diff --git a/src/main/java/org/bukkit/craftbukkit/scoreboard/CraftScore.java b/src/main/java/org/bukkit/craftbukkit/scoreboard/CraftScore.java
index 7095f6d..b265616 100644
--- a/src/main/java/org/bukkit/craftbukkit/scoreboard/CraftScore.java
+++ b/src/main/java/org/bukkit/craftbukkit/scoreboard/CraftScore.java
@@ -41,7 +41,7 @@ final class CraftScore implements Score {
         Scoreboard board = objective.checkState().board;
 
         if (board.getPlayers().contains(entry)) { // Lazy
-            Map<String, ScoreboardScore> scores = board.getPlayerObjectives(entry);
+            Map<net.minecraft.server.ScoreboardObjective, ScoreboardScore> scores = board.getPlayerObjectives(entry); // Spigot
             ScoreboardScore score = scores.get(objective.getHandle());
             if (score != null) { // Lazy
                 return score.getScore();
@@ -55,6 +55,15 @@ final class CraftScore implements Score {
         objective.checkState().board.getPlayerScoreForObjective(entry, objective.getHandle()).setScore(score);
     }
 
+    // Spigot start
+    @Override    
+    public boolean isScoreSet() throws IllegalStateException {
+        Scoreboard board = objective.checkState().board;
+
+        return board.getPlayers().contains(entry) && board.getPlayerObjectives(entry).containsKey(objective.getHandle());
+    }
+    // Spigot end
+
     public CraftScoreboard getScoreboard() {
         return objective.getScoreboard();
     }
diff --git a/src/main/java/org/bukkit/craftbukkit/scoreboard/CraftScoreboardManager.java b/src/main/java/org/bukkit/craftbukkit/scoreboard/CraftScoreboardManager.java
index 87259f1..295aed2 100644
--- a/src/main/java/org/bukkit/craftbukkit/scoreboard/CraftScoreboardManager.java
+++ b/src/main/java/org/bukkit/craftbukkit/scoreboard/CraftScoreboardManager.java
@@ -42,6 +42,7 @@ public final class CraftScoreboardManager implements ScoreboardManager {
     }
 
     public CraftScoreboard getNewScoreboard() {
+        org.spigotmc.AsyncCatcher.catchOp( "scoreboard creation"); // Spigot
         CraftScoreboard scoreboard = new CraftScoreboard(new ScoreboardServer(server));
         scoreboards.add(scoreboard);
         return scoreboard;
diff --git a/src/main/java/org/bukkit/craftbukkit/scoreboard/CraftTeam.java b/src/main/java/org/bukkit/craftbukkit/scoreboard/CraftTeam.java
index 8a640d3..a1864a5 100644
--- a/src/main/java/org/bukkit/craftbukkit/scoreboard/CraftTeam.java
+++ b/src/main/java/org/bukkit/craftbukkit/scoreboard/CraftTeam.java
@@ -102,6 +102,19 @@ final class CraftTeam extends CraftScoreboardComponent implements Team {
         return players.build();
     }
 
+    // Spigot start
+    @Override
+    public Set<String> getEntries() throws IllegalStateException {
+        CraftScoreboard scoreboard = checkState();
+        
+        ImmutableSet.Builder<String> entries = ImmutableSet.builder();
+        for (Object o : team.getPlayerNameSet()){
+            entries.add(o.toString());
+        }
+        return entries.build();
+    }
+    // Spigot end
+
     public int getSize() throws IllegalStateException {
         CraftScoreboard scoreboard = checkState();
 
@@ -110,28 +123,50 @@ final class CraftTeam extends CraftScoreboardComponent implements Team {
 
     public void addPlayer(OfflinePlayer player) throws IllegalStateException, IllegalArgumentException {
         Validate.notNull(player, "OfflinePlayer cannot be null");
+        // Spigot Start
+        addEntry(player.getName());
+    }
+    
+    public void addEntry(String entry) throws IllegalStateException, IllegalArgumentException {
+        Validate.notNull(entry, "Entry cannot be null");
         CraftScoreboard scoreboard = checkState();
 
-        scoreboard.board.addPlayerToTeam(player.getName(), team.getName());
+        scoreboard.board.addPlayerToTeam(entry, team.getName());
+        // Spigot end
     }
 
     public boolean removePlayer(OfflinePlayer player) throws IllegalStateException, IllegalArgumentException {
         Validate.notNull(player, "OfflinePlayer cannot be null");
+        // Spigot start
+        return removeEntry(player.getName());
+    }
+    
+    public boolean removeEntry(String entry) throws IllegalStateException, IllegalArgumentException {
+        Validate.notNull(entry, "Entry cannot be null");
         CraftScoreboard scoreboard = checkState();
 
-        if (!team.getPlayerNameSet().contains(player.getName())) {
+        if (!team.getPlayerNameSet().contains(entry)) {
             return false;
         }
 
-        scoreboard.board.removePlayerFromTeam(player.getName(), team);
+        scoreboard.board.removePlayerFromTeam(entry, team);
+        // Spigot end
         return true;
     }
 
     public boolean hasPlayer(OfflinePlayer player) throws IllegalArgumentException, IllegalStateException {
         Validate.notNull(player, "OfflinePlayer cannot be null");
+        // Spigot start
+        return hasEntry(player.getName());
+    }
+
+    public boolean hasEntry(String entry) throws IllegalArgumentException, IllegalStateException {
+        Validate.notNull("Entry cannot be null");
+
         CraftScoreboard scoreboard = checkState();
 
-        return team.getPlayerNameSet().contains(player.getName());
+        return team.getPlayerNameSet().contains(entry);
+        // Spigot end
     }
 
     @Override
diff --git a/src/main/java/org/bukkit/craftbukkit/util/CraftChatMessage.java b/src/main/java/org/bukkit/craftbukkit/util/CraftChatMessage.java
index 256f053..6491b10 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/CraftChatMessage.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/CraftChatMessage.java
@@ -19,7 +19,7 @@ import com.google.common.collect.ImmutableMap.Builder;
 public final class CraftChatMessage {
     private static class StringMessage {
         private static final Map<Character, EnumChatFormat> formatMap;
-        private static final Pattern INCREMENTAL_PATTERN = Pattern.compile("(" + String.valueOf(org.bukkit.ChatColor.COLOR_CHAR) + "[0-9a-fk-or])|(\\n)|(?:(https?://[^ ][^ ]*?)(?=[\\.\\?!,;:]?(?:[ \\n]|$)))", Pattern.CASE_INSENSITIVE);
+        private static final Pattern INCREMENTAL_PATTERN = Pattern.compile("(" + String.valueOf(org.bukkit.ChatColor.COLOR_CHAR) + "[0-9a-fk-or])|(\\n)|((?:(?:https?)://)?(?:[-\\w_\\.]{2,}\\.[a-z]{2,4}.*?(?=[\\.\\?!,;:]?(?:[" + String.valueOf(org.bukkit.ChatColor.COLOR_CHAR) + " \\n]|$))))", Pattern.CASE_INSENSITIVE);
 
         static {
             Builder<Character, EnumChatFormat> builder = ImmutableMap.builder();
@@ -85,6 +85,9 @@ public final class CraftChatMessage {
                     currentChatComponent = null;
                     break;
                 case 3:
+                    if ( !( match.startsWith( "http://" ) || match.startsWith( "https://" ) ) ) {
+                        match = "http://" + match;
+                    }
                     modifier.setChatClickable(new ChatClickable(EnumClickAction.OPEN_URL, match));
                     appendNewComponent(matcher.end(groupId));
                     modifier.setChatClickable((ChatClickable) null);
@@ -96,7 +99,7 @@ public final class CraftChatMessage {
                 appendNewComponent(message.length());
             }
 
-            output = list.toArray(new IChatBaseComponent[0]);
+            output = list.toArray(new IChatBaseComponent[list.size()]);
         }
 
         private void appendNewComponent(int index) {
diff --git a/src/main/java/org/bukkit/craftbukkit/util/LongHash.java b/src/main/java/org/bukkit/craftbukkit/util/LongHash.java
index 691cafd..9d54472 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/LongHash.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/LongHash.java
@@ -10,6 +10,6 @@ public class LongHash {
     }
 
     public static int lsw(long l) {
-        return (int) (l & 0xFFFFFFFF) + Integer.MIN_VALUE;
+        return (int) (l) + Integer.MIN_VALUE; // Spigot - remove redundant &
     }
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/util/LongHashSet.java b/src/main/java/org/bukkit/craftbukkit/util/LongHashSet.java
index 22c96c5..7f659b7 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/LongHashSet.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/LongHashSet.java
@@ -31,6 +31,7 @@ public class LongHashSet {
     private int elements;
     private long[] values;
     private int modCount;
+    private org.spigotmc.FlatMap<Boolean> flat = new org.spigotmc.FlatMap<Boolean>(); // Spigot
 
     public LongHashSet() {
         this(INITIAL_SIZE);
@@ -56,10 +57,30 @@ public class LongHashSet {
     }
 
     public boolean contains(int msw, int lsw) {
+        // Spigot start
+        if ( elements == 0 )
+        {
+            return false;
+        }
+        if ( flat.contains( msw, lsw ) )
+        {
+            return true;
+        }
+        // Spigot end
         return contains(LongHash.toLong(msw, lsw));
     }
 
     public boolean contains(long value) {
+        // Spigot start
+        if ( elements == 0 )
+        {
+            return false;
+        }
+        if ( flat.contains( value ) )
+        {
+            return true;
+        }
+        // Spigot end
         int hash = hash(value);
         int index = (hash & 0x7FFFFFFF) % values.length;
         int offset = 1;
@@ -82,6 +103,7 @@ public class LongHashSet {
     }
 
     public boolean add(long value) {
+        flat.put( value, Boolean.TRUE ); // Spigot
         int hash = hash(value);
         int index = (hash & 0x7FFFFFFF) % values.length;
         int offset = 1;
@@ -125,10 +147,18 @@ public class LongHashSet {
     }
 
     public void remove(int msw, int lsw) {
-        remove(LongHash.toLong(msw, lsw));
+        // Spigot start
+        flat.remove(msw, lsw);
+        remove0(LongHash.toLong(msw, lsw));
     }
 
     public boolean remove(long value) {
+        flat.remove(value);
+        return remove0(value);
+    }
+
+    private boolean remove0(long value) {
+        // Spigot end
         int hash = hash(value);
         int index = (hash & 0x7FFFFFFF) % values.length;
         int offset = 1;
@@ -161,6 +191,7 @@ public class LongHashSet {
 
         freeEntries = values.length;
         modCount++;
+        flat = new org.spigotmc.FlatMap<Boolean>();
     }
 
     public long[] toArray() {
diff --git a/src/main/java/org/bukkit/craftbukkit/util/LongObjectHashMap.java b/src/main/java/org/bukkit/craftbukkit/util/LongObjectHashMap.java
index 01861cc..2e5b436 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/LongObjectHashMap.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/LongObjectHashMap.java
@@ -28,6 +28,7 @@ public class LongObjectHashMap<V> implements Cloneable, Serializable {
     private transient V[][]    values;
     private transient int      modCount;
     private transient int      size;
+    private transient org.spigotmc.FlatMap<V> flat = new org.spigotmc.FlatMap<V>(); // Spigot
 
     public LongObjectHashMap() {
         initialize();
@@ -61,6 +62,17 @@ public class LongObjectHashMap<V> implements Cloneable, Serializable {
     }
 
     public V get(long key) {
+        // Spigot start
+        if ( size == 0 )
+        {
+            return null;
+        }
+        V val = flat.get( key );
+        if ( val != null )
+        {
+            return val;
+        }
+        // Spigot end
         int index = (int) (keyIndex(key) & (BUCKET_SIZE - 1));
         long[] inner = keys[index];
         if (inner == null) return null;
@@ -78,6 +90,7 @@ public class LongObjectHashMap<V> implements Cloneable, Serializable {
     }
 
     public V put(long key, V value) {
+        flat.put(key, value); // Spigot
         int index = (int) (keyIndex(key) & (BUCKET_SIZE - 1));
         long[] innerKeys = keys[index];
         V[] innerValues = values[index];
@@ -124,6 +137,7 @@ public class LongObjectHashMap<V> implements Cloneable, Serializable {
     }
 
     public V remove(long key) {
+        flat.remove(key); // Spigot
         int index = (int) (keyIndex(key) & (BUCKET_SIZE - 1));
         long[] inner = keys[index];
         if (inner == null) {
@@ -174,6 +188,7 @@ public class LongObjectHashMap<V> implements Cloneable, Serializable {
         size = 0;
         Arrays.fill(keys, null);
         Arrays.fill(values, null);
+        flat = new org.spigotmc.FlatMap<V>();
     }
 
     public Set<Long> keySet() {
diff --git a/src/main/java/org/bukkit/craftbukkit/util/Versioning.java b/src/main/java/org/bukkit/craftbukkit/util/Versioning.java
index f905d17..9304637 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/Versioning.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/Versioning.java
@@ -11,7 +11,7 @@ public final class Versioning {
     public static String getBukkitVersion() {
         String result = "Unknown-Version";
 
-        InputStream stream = Bukkit.class.getClassLoader().getResourceAsStream("META-INF/maven/org.bukkit/bukkit/pom.properties");
+        InputStream stream = Bukkit.class.getClassLoader().getResourceAsStream("META-INF/maven/org.spigotmc/spigot-api/pom.properties");
         Properties properties = new Properties();
 
         if (stream != null) {
diff --git a/src/main/java/org/spigotmc/ActivationRange.java b/src/main/java/org/spigotmc/ActivationRange.java
new file mode 100644
index 0000000..903172a
--- /dev/null
+++ b/src/main/java/org/spigotmc/ActivationRange.java
@@ -0,0 +1,296 @@
+package org.spigotmc;
+
+import java.util.ArrayList;
+import java.util.List;
+import net.minecraft.server.AxisAlignedBB;
+import net.minecraft.server.Chunk;
+import net.minecraft.server.Entity;
+import net.minecraft.server.EntityAmbient;
+import net.minecraft.server.EntityAnimal;
+import net.minecraft.server.EntityArrow;
+import net.minecraft.server.EntityComplexPart;
+import net.minecraft.server.EntityCreature;
+import net.minecraft.server.EntityEnderCrystal;
+import net.minecraft.server.EntityEnderDragon;
+import net.minecraft.server.EntityFireball;
+import net.minecraft.server.EntityFireworks;
+import net.minecraft.server.EntityHuman;
+import net.minecraft.server.EntityLiving;
+import net.minecraft.server.EntityMonster;
+import net.minecraft.server.EntityProjectile;
+import net.minecraft.server.EntitySheep;
+import net.minecraft.server.EntitySlime;
+import net.minecraft.server.EntityTNTPrimed;
+import net.minecraft.server.EntityVillager;
+import net.minecraft.server.EntityWeather;
+import net.minecraft.server.EntityWither;
+import net.minecraft.server.MathHelper;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.World;
+import org.bukkit.craftbukkit.SpigotTimings;
+
+public class ActivationRange
+{
+
+    static AxisAlignedBB maxBB = AxisAlignedBB.a( 0, 0, 0, 0, 0, 0 );
+    static AxisAlignedBB miscBB = AxisAlignedBB.a( 0, 0, 0, 0, 0, 0 );
+    static AxisAlignedBB animalBB = AxisAlignedBB.a( 0, 0, 0, 0, 0, 0 );
+    static AxisAlignedBB monsterBB = AxisAlignedBB.a( 0, 0, 0, 0, 0, 0 );
+
+    /**
+     * Initializes an entities type on construction to specify what group this
+     * entity is in for activation ranges.
+     *
+     * @param entity
+     * @return group id
+     */
+    public static byte initializeEntityActivationType(Entity entity)
+    {
+        if ( entity instanceof EntityMonster || entity instanceof EntitySlime )
+        {
+            return 1; // Monster
+        } else if ( entity instanceof EntityCreature || entity instanceof EntityAmbient )
+        {
+            return 2; // Animal
+        } else
+        {
+            return 3; // Misc
+        }
+    }
+
+    /**
+     * These entities are excluded from Activation range checks.
+     *
+     * @param entity
+     * @param world
+     * @return boolean If it should always tick.
+     */
+    public static boolean initializeEntityActivationState(Entity entity, SpigotWorldConfig config)
+    {
+        if ( ( entity.activationType == 3 && config.miscActivationRange == 0 )
+                || ( entity.activationType == 2 && config.animalActivationRange == 0 )
+                || ( entity.activationType == 1 && config.monsterActivationRange == 0 )
+                || entity instanceof EntityHuman
+                || entity instanceof EntityProjectile
+                || entity instanceof EntityEnderDragon
+                || entity instanceof EntityComplexPart
+                || entity instanceof EntityWither
+                || entity instanceof EntityFireball
+                || entity instanceof EntityWeather
+                || entity instanceof EntityTNTPrimed
+                || entity instanceof EntityEnderCrystal
+                || entity instanceof EntityFireworks )
+        {
+            return true;
+        }
+
+        return false;
+    }
+
+    /**
+     * Utility method to grow an AABB without creating a new AABB or touching
+     * the pool, so we can re-use ones we have.
+     *
+     * @param target
+     * @param source
+     * @param x
+     * @param y
+     * @param z
+     */
+    public static void growBB(AxisAlignedBB target, AxisAlignedBB source, int x, int y, int z)
+    {
+        target.a = source.a - x;
+        target.b = source.b - y;
+        target.c = source.c - z;
+        target.d = source.d + x;
+        target.e = source.e + y;
+        target.f = source.f + z;
+    }
+
+    /**
+     * Find what entities are in range of the players in the world and set
+     * active if in range.
+     *
+     * @param world
+     */
+    public static void activateEntities(World world)
+    {
+        SpigotTimings.entityActivationCheckTimer.startTiming();
+        final int miscActivationRange = world.spigotConfig.miscActivationRange;
+        final int animalActivationRange = world.spigotConfig.animalActivationRange;
+        final int monsterActivationRange = world.spigotConfig.monsterActivationRange;
+
+        int maxRange = Math.max( monsterActivationRange, animalActivationRange );
+        maxRange = Math.max( maxRange, miscActivationRange );
+        maxRange = Math.min( ( world.spigotConfig.viewDistance << 4 ) - 8, maxRange );
+
+        for ( Entity player : (List<Entity>) world.players )
+        {
+
+            player.activatedTick = MinecraftServer.currentTick;
+            growBB( maxBB, player.boundingBox, maxRange, 256, maxRange );
+            growBB( miscBB, player.boundingBox, miscActivationRange, 256, miscActivationRange );
+            growBB( animalBB, player.boundingBox, animalActivationRange, 256, animalActivationRange );
+            growBB( monsterBB, player.boundingBox, monsterActivationRange, 256, monsterActivationRange );
+
+            int i = MathHelper.floor( maxBB.a / 16.0D );
+            int j = MathHelper.floor( maxBB.d / 16.0D );
+            int k = MathHelper.floor( maxBB.c / 16.0D );
+            int l = MathHelper.floor( maxBB.f / 16.0D );
+
+            for ( int i1 = i; i1 <= j; ++i1 )
+            {
+                for ( int j1 = k; j1 <= l; ++j1 )
+                {
+                    if ( world.getWorld().isChunkLoaded( i1, j1 ) )
+                    {
+                        activateChunkEntities( world.getChunkAt( i1, j1 ) );
+                    }
+                }
+            }
+        }
+        SpigotTimings.entityActivationCheckTimer.stopTiming();
+    }
+
+    /**
+     * Checks for the activation state of all entities in this chunk.
+     *
+     * @param chunk
+     */
+    private static void activateChunkEntities(Chunk chunk)
+    {
+        for ( List<Entity> slice : chunk.entitySlices )
+        {
+            for ( Entity entity : slice )
+            {
+                if ( MinecraftServer.currentTick > entity.activatedTick )
+                {
+                    if ( entity.defaultActivationState )
+                    {
+                        entity.activatedTick = MinecraftServer.currentTick;
+                        continue;
+                    }
+                    switch ( entity.activationType )
+                    {
+                        case 1:
+                            if ( monsterBB.b( entity.boundingBox ) )
+                            {
+                                entity.activatedTick = MinecraftServer.currentTick;
+                            }
+                            break;
+                        case 2:
+                            if ( animalBB.b( entity.boundingBox ) )
+                            {
+                                entity.activatedTick = MinecraftServer.currentTick;
+                            }
+                            break;
+                        case 3:
+                        default:
+                            if ( miscBB.b( entity.boundingBox ) )
+                            {
+                                entity.activatedTick = MinecraftServer.currentTick;
+                            }
+                    }
+                }
+            }
+        }
+    }
+
+    /**
+     * If an entity is not in range, do some more checks to see if we should
+     * give it a shot.
+     *
+     * @param entity
+     * @return
+     */
+    public static boolean checkEntityImmunities(Entity entity)
+    {
+        // quick checks.
+        if ( entity.inWater /* isInWater */ || entity.fireTicks > 0 )
+        {
+            return true;
+        }
+        if ( !( entity instanceof EntityArrow ) )
+        {
+            if ( !entity.onGround || entity.passenger != null
+                    || entity.vehicle != null )
+            {
+                return true;
+            }
+        } else if ( !( (EntityArrow) entity ).inGround )
+        {
+            return true;
+        }
+        // special cases.
+        if ( entity instanceof EntityLiving )
+        {
+            EntityLiving living = (EntityLiving) entity;
+            if ( living.attackTicks > 0 || living.hurtTicks > 0 || living.effects.size() > 0 )
+            {
+                return true;
+            }
+            if ( entity instanceof EntityCreature && ( (EntityCreature) entity ).target != null )
+            {
+                return true;
+            }
+            if ( entity instanceof EntityVillager && ( (EntityVillager) entity ).bY() /* Getter for first boolean */ )
+            {
+                return true;
+            }
+            if ( entity instanceof EntityAnimal )
+            {
+                EntityAnimal animal = (EntityAnimal) entity;
+                if ( animal.isBaby() || animal.ce() /*love*/ )
+                {
+                    return true;
+                }
+                if ( entity instanceof EntitySheep && ( (EntitySheep) entity ).isSheared() )
+                {
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+
+    /**
+     * Checks if the entity is active for this tick.
+     *
+     * @param entity
+     * @return
+     */
+    public static boolean checkIfActive(Entity entity)
+    {
+        SpigotTimings.checkIfActiveTimer.startTiming();
+        boolean isActive = entity.activatedTick >= MinecraftServer.currentTick || entity.defaultActivationState;
+
+        // Should this entity tick?
+        if ( !isActive )
+        {
+            if ( ( MinecraftServer.currentTick - entity.activatedTick - 1 ) % 20 == 0 )
+            {
+                // Check immunities every 20 ticks.
+                if ( checkEntityImmunities( entity ) )
+                {
+                    // Triggered some sort of immunity, give 20 full ticks before we check again.
+                    entity.activatedTick = MinecraftServer.currentTick + 20;
+                }
+                isActive = true;
+            }
+            // Add a little performance juice to active entities. Skip 1/4 if not immune.
+        } else if ( !entity.defaultActivationState && entity.ticksLived % 4 == 0 && !checkEntityImmunities( entity ) )
+        {
+            isActive = false;
+        }
+        int x = MathHelper.floor( entity.locX );
+        int z = MathHelper.floor( entity.locZ );
+        // Make sure not on edge of unloaded chunk
+        Chunk chunk = entity.world.getChunkIfLoaded( x >> 4, z >> 4 );
+        if ( isActive && !( chunk != null && chunk.areNeighborsLoaded( 1 ) ) )
+        {
+            isActive = false;
+        }
+        SpigotTimings.checkIfActiveTimer.stopTiming();
+        return isActive;
+    }
+}
diff --git a/src/main/java/org/spigotmc/AntiXray.java b/src/main/java/org/spigotmc/AntiXray.java
new file mode 100644
index 0000000..80e538c
--- /dev/null
+++ b/src/main/java/org/spigotmc/AntiXray.java
@@ -0,0 +1,257 @@
+package org.spigotmc;
+
+import net.minecraft.util.gnu.trove.set.TByteSet;
+import net.minecraft.util.gnu.trove.set.hash.TByteHashSet;
+import net.minecraft.server.Block;
+import net.minecraft.server.Blocks;
+import net.minecraft.server.World;
+import org.bukkit.craftbukkit.util.CraftMagicNumbers;
+
+public class AntiXray
+{
+
+    private static final CustomTimingsHandler update = new CustomTimingsHandler( "xray - update" );
+    private static final CustomTimingsHandler obfuscate = new CustomTimingsHandler( "xray - obfuscate" );
+    /*========================================================================*/
+    // Used to keep track of which blocks to obfuscate
+    private final boolean[] obfuscateBlocks = new boolean[ Short.MAX_VALUE ];
+    // Used to select a random replacement ore
+    private final byte[] replacementOres;
+
+    public AntiXray(SpigotWorldConfig config)
+    {
+        // Set all listed blocks as true to be obfuscated
+        for ( int id : ( config.engineMode == 1 ) ? config.hiddenBlocks : config.replaceBlocks )
+        {
+            obfuscateBlocks[id] = true;
+        }
+
+        // For every block
+        TByteSet blocks = new TByteHashSet();
+        for ( Integer i : config.hiddenBlocks )
+        {
+            Block block = Block.getById( i );
+            // Check it exists and is not a tile entity
+            if ( block != null && !block.isTileEntity() )
+            {
+                // Add it to the set of replacement blocks
+                blocks.add( (byte) (int) i );
+            }
+        }
+        // Bake it to a flat array of replacements
+        replacementOres = blocks.toArray();
+    }
+
+    /**
+     * Starts the timings handler, then updates all blocks within the set radius
+     * of the given coordinate, revealing them if they are hidden ores.
+     */
+    public void updateNearbyBlocks(World world, int x, int y, int z)
+    {
+        if ( world.spigotConfig.antiXray )
+        {
+            update.startTiming();
+            updateNearbyBlocks( world, x, y, z, 2, false ); // 2 is the radius, we shouldn't change it as that would make it exponentially slower
+            update.stopTiming();
+        }
+    }
+
+    /**
+     * Starts the timings handler, and then removes all non exposed ores from
+     * the chunk buffer.
+     */
+    public void obfuscateSync(int chunkX, int chunkY, int bitmask, byte[] buffer, World world)
+    {
+        if ( world.spigotConfig.antiXray )
+        {
+            obfuscate.startTiming();
+            obfuscate( chunkX, chunkY, bitmask, buffer, world, false );
+            obfuscate.stopTiming();
+        }
+    }
+
+    /**
+     * Removes all non exposed ores from the chunk buffer.
+     */
+    public void obfuscate(int chunkX, int chunkY, int bitmask, byte[] buffer, World world, boolean newFormat)
+    {
+        // If the world is marked as obfuscated
+        if ( world.spigotConfig.antiXray )
+        {
+            // Initial radius to search around for air
+            int initialRadius = 1;
+            // Which block in the buffer we are looking at, anywhere from 0 to 16^4
+            int index = 0;
+            // The iterator marking which random ore we should use next
+            int randomOre = 0;
+
+            // Chunk corner X and Z blocks
+            int startX = chunkX << 4;
+            int startZ = chunkY << 4;
+
+            byte replaceWithTypeId;
+            switch ( world.getWorld().getEnvironment() )
+            {
+                case NETHER:
+                    replaceWithTypeId = (byte) CraftMagicNumbers.getId(Blocks.NETHERRACK);
+                    break;
+                case THE_END:
+                    replaceWithTypeId = (byte) CraftMagicNumbers.getId(Blocks.WHITESTONE);
+                    break;
+                default:
+                    replaceWithTypeId = (byte) CraftMagicNumbers.getId(Blocks.STONE);
+                    break;
+            }
+
+            // Chunks can have up to 16 sections
+            for ( int i = 0; i < 16; i++ )
+            {
+                // If the bitmask indicates this chunk is sent...
+                if ( ( bitmask & 1 << i ) != 0 )
+                {
+                    // Work through all blocks in the chunk, y,z,x
+                    for ( int y = 0; y < 16; y++ )
+                    {
+                        for ( int z = 0; z < 16; z++ )
+                        {
+                            for ( int x = 0; x < 16; x++ )
+                            {
+                                // For some reason we can get too far ahead of ourselves (concurrent modification on bulk chunks?) so if we do, just abort and move on
+                                if ( index >= buffer.length )
+                                {
+                                    index++;
+                                    if ( newFormat ) index++;
+                                    continue;
+                                }
+                                // Grab the block ID in the buffer.
+                                // TODO: extended IDs are not yet supported
+                                int blockId;
+                                int data = 0;
+                                if ( newFormat )
+                                {
+                                    blockId = (buffer[ index ] & 0xFF) | ( ( buffer[ index + 1 ] & 0xFF ) << 8 );
+                                    data = blockId & 0xF;
+                                    blockId >>>= 4; // Remove data value
+                                } else
+                                {
+                                    blockId = buffer[ index ] & 0xFF;
+                                }
+                                // Check if the block should be obfuscated
+                                if ( obfuscateBlocks[blockId] )
+                                {
+                                    // The world isn't loaded, bail out
+                                    if ( !isLoaded( world, startX + x, ( i << 4 ) + y, startZ + z, initialRadius ) )
+                                    {
+                                        index++;
+                                        if ( newFormat ) index++;
+                                        continue;
+                                    }
+                                    // On the otherhand, if radius is 0, or the nearby blocks are all non air, we can obfuscate
+                                    if ( !hasTransparentBlockAdjacent( world, startX + x, ( i << 4 ) + y, startZ + z, initialRadius ) )
+                                    {
+                                        switch ( world.spigotConfig.engineMode )
+                                        {
+                                            case 1:
+                                                // Replace with replacement material
+                                                if ( newFormat )
+                                                {
+                                                    char replace = (char) ((replaceWithTypeId << 4) | data);
+                                                    buffer[ index ] = (byte) ( replace & 0xFF );
+                                                    buffer[ index + 1 ] = (byte) ( ( replace >> 8 ) & 0xFF );
+                                                } else
+                                                {
+                                                    buffer[ index ] = replaceWithTypeId;
+                                                }
+                                                break;
+                                            case 2:
+                                                // Replace with random ore.
+                                                if ( randomOre >= replacementOres.length )
+                                                {
+                                                    randomOre = 0;
+                                                }
+                                                if ( newFormat )
+                                                {
+                                                    char replace = (char) (replacementOres[ randomOre++ ] & 0xFF);
+                                                    replace = (char) ((replace << 4) | data);
+                                                    buffer[ index ] = (byte) ( replace & 0xFF );
+                                                    buffer[ index + 1 ] = (byte) ( ( replace >> 8 ) & 0xFF );
+                                                } else
+                                                {
+                                                    buffer[ index ] = replacementOres[ randomOre++ ];
+                                                }
+                                                break;
+                                        }
+                                    }
+                                }
+
+                                index++;
+                                if (newFormat) index++;
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    private void updateNearbyBlocks(World world, int x, int y, int z, int radius, boolean updateSelf)
+    {
+        // If the block in question is loaded
+        if ( world.isLoaded( x, y, z ) )
+        {
+            // Get block id
+            Block block = world.getType(x, y, z);
+
+            // See if it needs update
+            if ( updateSelf && obfuscateBlocks[Block.getId( block )] )
+            {
+                // Send the update
+                world.notify( x, y, z );
+            }
+
+            // Check other blocks for updates
+            if ( radius > 0 )
+            {
+                updateNearbyBlocks( world, x + 1, y, z, radius - 1, true );
+                updateNearbyBlocks( world, x - 1, y, z, radius - 1, true );
+                updateNearbyBlocks( world, x, y + 1, z, radius - 1, true );
+                updateNearbyBlocks( world, x, y - 1, z, radius - 1, true );
+                updateNearbyBlocks( world, x, y, z + 1, radius - 1, true );
+                updateNearbyBlocks( world, x, y, z - 1, radius - 1, true );
+            }
+        }
+    }
+
+    private static boolean isLoaded(World world, int x, int y, int z, int radius)
+    {
+        return world.isLoaded( x, y, z )
+                && ( radius == 0 ||
+                ( isLoaded( world, x + 1, y, z, radius - 1 )
+                && isLoaded( world, x - 1, y, z, radius - 1 )
+                && isLoaded( world, x, y + 1, z, radius - 1 )
+                && isLoaded( world, x, y - 1, z, radius - 1 )
+                && isLoaded( world, x, y, z + 1, radius - 1 )
+                && isLoaded( world, x, y, z - 1, radius - 1 ) ) );
+    }
+
+    private static boolean hasTransparentBlockAdjacent(World world, int x, int y, int z, int radius)
+    {
+        return !isSolidBlock(world.getType(x, y, z, false)) /* isSolidBlock */
+                || ( radius > 0
+                && ( hasTransparentBlockAdjacent( world, x + 1, y, z, radius - 1 )
+                || hasTransparentBlockAdjacent( world, x - 1, y, z, radius - 1 )
+                || hasTransparentBlockAdjacent( world, x, y + 1, z, radius - 1 )
+                || hasTransparentBlockAdjacent( world, x, y - 1, z, radius - 1 )
+                || hasTransparentBlockAdjacent( world, x, y, z + 1, radius - 1 )
+                || hasTransparentBlockAdjacent( world, x, y, z - 1, radius - 1 ) ) );
+    }
+
+    private static boolean isSolidBlock(Block block) {
+        // Mob spawners are treated as solid blocks as far as the
+        // game is concerned for lighting and other tasks but for
+        // rendering they can be seen through therefor we special
+        // case them so that the antixray doesn't show the fake
+        // blocks around them.
+        return block.r() && block != Blocks.MOB_SPAWNER;
+    }
+}
diff --git a/src/main/java/org/spigotmc/AsyncCatcher.java b/src/main/java/org/spigotmc/AsyncCatcher.java
new file mode 100644
index 0000000..4b3aa85
--- /dev/null
+++ b/src/main/java/org/spigotmc/AsyncCatcher.java
@@ -0,0 +1,17 @@
+package org.spigotmc;
+
+import net.minecraft.server.MinecraftServer;
+
+public class AsyncCatcher
+{
+
+    public static boolean enabled = true;
+
+    public static void catchOp(String reason)
+    {
+        if ( enabled && Thread.currentThread() != MinecraftServer.getServer().primaryThread )
+        {
+            throw new IllegalStateException( "Asynchronous " + reason + "!" );
+        }
+    }
+}
diff --git a/src/main/java/org/spigotmc/CachedMojangAPIConnection.java b/src/main/java/org/spigotmc/CachedMojangAPIConnection.java
new file mode 100644
index 0000000..42edeba
--- /dev/null
+++ b/src/main/java/org/spigotmc/CachedMojangAPIConnection.java
@@ -0,0 +1,145 @@
+package org.spigotmc;
+
+import com.google.common.base.Charsets;
+import com.google.gson.JsonArray;
+import com.google.gson.JsonElement;
+import com.google.gson.JsonObject;
+import com.google.gson.JsonParser;
+import net.minecraft.util.com.google.common.cache.Cache;
+import net.minecraft.util.com.google.common.cache.CacheBuilder;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.OutputStream;
+import java.net.HttpURLConnection;
+import java.net.Proxy;
+import java.net.URL;
+import java.util.concurrent.TimeUnit;
+
+public class CachedMojangAPIConnection extends HttpURLConnection
+{
+    private final CachedStreamHandlerFactory.CachedStreamHandler cachedStreamHandler;
+    private final Proxy proxy;
+    private final ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
+    private ByteArrayInputStream inputStream;
+    private InputStream errorStream;
+    private boolean outClosed = false;
+
+    private static final Cache<String, String> cache = CacheBuilder.newBuilder()
+            .maximumSize( 10000 )
+            .expireAfterAccess( 1, TimeUnit.HOURS )
+            .build();
+
+    public CachedMojangAPIConnection(CachedStreamHandlerFactory.CachedStreamHandler cachedStreamHandler, URL url, Proxy proxy)
+    {
+        super( url );
+        this.cachedStreamHandler = cachedStreamHandler;
+        this.proxy = proxy;
+    }
+
+    @Override
+    public void disconnect()
+    {
+
+    }
+
+    @Override
+    public boolean usingProxy()
+    {
+        return proxy != null;
+    }
+
+    @Override
+    public void connect() throws IOException
+    {
+
+    }
+
+    @Override
+    public InputStream getInputStream() throws IOException
+    {
+        if ( inputStream == null )
+        {
+            outClosed = true;
+            JsonArray users = new JsonParser().parse( new String( outputStream.toByteArray(), Charsets.UTF_8 ) ).getAsJsonArray();
+            StringBuilder reply = new StringBuilder( "[" );
+            StringBuilder missingUsers = new StringBuilder( "[" );
+            for ( JsonElement user : users )
+            {
+                String username = user.getAsString().toLowerCase();
+                String info = cache.getIfPresent( username );
+                if ( info != null )
+                {
+                    reply.append( info ).append( "," );
+                } else
+                {
+                    missingUsers
+                            .append( "\"" )
+                            .append( username )
+                            .append( "\"" )
+                            .append( "," );
+                }
+            }
+            if ( missingUsers.length() > 1 )
+            {
+                missingUsers.deleteCharAt( missingUsers.length() - 1 ).append( "]" );
+            }
+            if ( missingUsers.length() > 2 )
+            {
+                HttpURLConnection connection;
+                if ( proxy == null )
+                {
+                    connection = (HttpURLConnection) cachedStreamHandler.getDefaultConnection( url );
+                } else
+                {
+                    connection = (HttpURLConnection) cachedStreamHandler.getDefaultConnection( url, proxy );
+                }
+                connection.setRequestMethod( "POST" );
+                connection.setRequestProperty( "Content-Type", "application/json" );
+                connection.setDoInput( true );
+                connection.setDoOutput( true );
+                OutputStream out = connection.getOutputStream();
+                out.write( missingUsers.toString().getBytes( Charsets.UTF_8 ) );
+                out.flush();
+                out.close();
+                JsonArray newUsers = new JsonParser().parse( new InputStreamReader( connection.getInputStream(), Charsets.UTF_8 ) ).getAsJsonArray();
+                for ( JsonElement user : newUsers )
+                {
+                    JsonObject u = user.getAsJsonObject();
+                    cache.put( u.get( "name" ).getAsString(), u.toString() );
+                    reply.append( u.toString() ).append( "," );
+                }
+                responseCode = connection.getResponseCode();
+                errorStream = connection.getErrorStream();
+            } else
+            {
+                responseCode = HTTP_OK;
+            }
+            if ( reply.length() > 1 )
+            {
+                reply.deleteCharAt( reply.length() - 1 );
+            }
+            inputStream = new ByteArrayInputStream( reply.append( "]" ).toString().getBytes( Charsets.UTF_8 ) );
+        }
+        return inputStream;
+    }
+
+    @Override
+    public InputStream getErrorStream()
+    {
+        return errorStream;
+    }
+
+    @Override
+    public OutputStream getOutputStream() throws IOException
+    {
+        if ( outClosed )
+        {
+            throw new RuntimeException( "Write after send" );
+        }
+        return outputStream;
+    }
+}
diff --git a/src/main/java/org/spigotmc/CachedStreamHandlerFactory.java b/src/main/java/org/spigotmc/CachedStreamHandlerFactory.java
new file mode 100644
index 0000000..b9a8736
--- /dev/null
+++ b/src/main/java/org/spigotmc/CachedStreamHandlerFactory.java
@@ -0,0 +1,117 @@
+package org.spigotmc;
+
+import java.io.IOException;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.net.Proxy;
+import java.net.URL;
+import java.net.URLConnection;
+import java.net.URLStreamHandler;
+import java.net.URLStreamHandlerFactory;
+
+public class CachedStreamHandlerFactory implements URLStreamHandlerFactory
+{
+    public static boolean isSet = false;
+
+    @Override
+    public URLStreamHandler createURLStreamHandler(String protocol)
+    {
+        if ( protocol.equals( "http" ) || protocol.equals( "https" ) )
+        {
+            return new CachedStreamHandler( protocol );
+        }
+        return null;
+    }
+
+    public class CachedStreamHandler extends URLStreamHandler
+    {
+        private final String protocol;
+        private final URLStreamHandler handler;
+        private final Method openCon;
+        private final Method openConProxy;
+
+        public CachedStreamHandler(String protocol)
+        {
+            this.protocol = protocol;
+            if ( protocol.equals( "http" ) )
+            {
+                handler = new sun.net.www.protocol.http.Handler();
+            } else
+            {
+                handler = new sun.net.www.protocol.https.Handler();
+            }
+            try
+            {
+                openCon = handler.getClass().getDeclaredMethod( "openConnection", URL.class );
+                openCon.setAccessible( true );
+                openConProxy = handler.getClass().getDeclaredMethod( "openConnection", URL.class, Proxy.class );
+                openConProxy.setAccessible( true );
+            } catch ( NoSuchMethodException e )
+            {
+                throw new RuntimeException( e );
+            }
+        }
+
+        @Override
+        protected URLConnection openConnection(URL u) throws IOException
+        {
+            if ( u.getHost().equals( "api.mojang.com" )
+                    || u.getPath().startsWith( "/profiles/minecraft" ) )
+            {
+                return cachedConnection( u );
+            }
+            return getDefaultConnection( u );
+        }
+
+        @Override
+        protected URLConnection openConnection(URL u, Proxy p) throws IOException
+        {
+            if ( u.getHost().equals( "api.mojang.com" )
+                    || u.getPath().startsWith( "/profiles/minecraft" ) )
+            {
+                return cachedConnection( u, p );
+            }
+            return getDefaultConnection( u, p );
+        }
+
+        private URLConnection cachedConnection(URL u)
+        {
+            return cachedConnection( u, null );
+        }
+
+        private URLConnection cachedConnection(URL u, Proxy p)
+        {
+            return new CachedMojangAPIConnection( this, u, p );
+        }
+
+        public URLConnection getDefaultConnection(URL u)
+        {
+            try
+            {
+                return (URLConnection) openCon.invoke( handler, u );
+            } catch ( IllegalAccessException e )
+            {
+                e.printStackTrace();
+            } catch ( InvocationTargetException e )
+            {
+                e.printStackTrace();
+            }
+            return null;
+        }
+
+        public URLConnection getDefaultConnection(URL u, Proxy p)
+        {
+            try
+            {
+                return (URLConnection) openConProxy.invoke( handler, u, p );
+            } catch ( IllegalAccessException e )
+            {
+                e.printStackTrace();
+            } catch ( InvocationTargetException e )
+            {
+                e.printStackTrace();
+            }
+            return null;
+        }
+    }
+}
diff --git a/src/main/java/org/spigotmc/FlatMap.java b/src/main/java/org/spigotmc/FlatMap.java
new file mode 100644
index 0000000..9416f6e
--- /dev/null
+++ b/src/main/java/org/spigotmc/FlatMap.java
@@ -0,0 +1,64 @@
+package org.spigotmc;
+
+import org.bukkit.craftbukkit.util.LongHash;
+
+public class FlatMap<V>
+{
+
+    private static final int FLAT_LOOKUP_SIZE = 512;
+    private final Object[][] flatLookup = new Object[ FLAT_LOOKUP_SIZE * 2 ][ FLAT_LOOKUP_SIZE * 2 ];
+
+    public void put(long msw, long lsw, V value)
+    {
+        long acx = Math.abs( msw );
+        long acz = Math.abs( lsw );
+        if ( acx < FLAT_LOOKUP_SIZE && acz < FLAT_LOOKUP_SIZE )
+        {
+            flatLookup[(int) ( msw + FLAT_LOOKUP_SIZE )][(int) ( lsw + FLAT_LOOKUP_SIZE )] = value;
+        }
+    }
+
+    public void put(long key, V value)
+    {
+        put( LongHash.msw( key ), LongHash.lsw( key ), value );
+
+    }
+
+    public void remove(long key)
+    {
+        put( key, null );
+    }
+
+    public void remove(long msw, long lsw)
+    {
+        put( msw, lsw, null );
+    }
+
+    public boolean contains(long msw, long lsw)
+    {
+        return get( msw, lsw ) != null;
+    }
+
+    public boolean contains(long key)
+    {
+        return get( key ) != null;
+    }
+
+    public V get(long msw, long lsw)
+    {
+        long acx = Math.abs( msw );
+        long acz = Math.abs( lsw );
+        if ( acx < FLAT_LOOKUP_SIZE && acz < FLAT_LOOKUP_SIZE )
+        {
+            return (V) flatLookup[(int) ( msw + FLAT_LOOKUP_SIZE )][(int) ( lsw + FLAT_LOOKUP_SIZE )];
+        } else
+        {
+            return null;
+        }
+    }
+
+    public V get(long key)
+    {
+        return get( LongHash.msw( key ), LongHash.lsw( key ) );
+    }
+}
diff --git a/src/main/java/org/spigotmc/LimitStream.java b/src/main/java/org/spigotmc/LimitStream.java
new file mode 100644
index 0000000..dcc0548
--- /dev/null
+++ b/src/main/java/org/spigotmc/LimitStream.java
@@ -0,0 +1,39 @@
+package org.spigotmc;
+
+import java.io.FilterInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import net.minecraft.server.NBTReadLimiter;
+
+public class LimitStream extends FilterInputStream
+{
+
+    private final NBTReadLimiter limit;
+
+    public LimitStream(InputStream is, NBTReadLimiter limit)
+    {
+        super( is );
+        this.limit = limit;
+    }
+
+    @Override
+    public int read() throws IOException
+    {
+        limit.a( 1 );
+        return super.read();
+    }
+
+    @Override
+    public int read(byte[] b) throws IOException
+    {
+        limit.a( b.length );
+        return super.read( b );
+    }
+
+    @Override
+    public int read(byte[] b, int off, int len) throws IOException
+    {
+        limit.a( len );
+        return super.read( b, off, len );
+    }
+}
diff --git a/src/main/java/org/spigotmc/Metrics.java b/src/main/java/org/spigotmc/Metrics.java
new file mode 100644
index 0000000..d9c3b63
--- /dev/null
+++ b/src/main/java/org/spigotmc/Metrics.java
@@ -0,0 +1,645 @@
+/*
+ * Copyright 2011-2013 Tyler Blair. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are
+ * permitted provided that the following conditions are met:
+ *
+ *    1. Redistributions of source code must retain the above copyright notice, this list of
+ *       conditions and the following disclaimer.
+ *
+ *    2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *       of conditions and the following disclaimer in the documentation and/or other materials
+ *       provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ''AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * The views and conclusions contained in the software and documentation are those of the
+ * authors and contributors and should not be interpreted as representing official policies,
+ * either expressed or implied, of anybody else.
+ */
+package org.spigotmc;
+
+import org.bukkit.Bukkit;
+import org.bukkit.configuration.file.YamlConfiguration;
+import org.bukkit.configuration.InvalidConfigurationException;
+import org.bukkit.plugin.Plugin;
+import org.bukkit.plugin.PluginDescriptionFile;
+import org.bukkit.scheduler.BukkitTask;
+
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.io.OutputStreamWriter;
+import java.io.UnsupportedEncodingException;
+import java.net.Proxy;
+import java.net.URL;
+import java.net.URLConnection;
+import java.net.URLEncoder;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.LinkedHashSet;
+import java.util.Set;
+import java.util.Timer;
+import java.util.TimerTask;
+import java.util.UUID;
+import java.util.concurrent.TimeUnit;
+import java.util.logging.Level;
+import net.minecraft.server.MinecraftServer;
+
+/**
+ * <p> The metrics class obtains data about a plugin and submits statistics about it to the metrics backend. </p> <p>
+ * Public methods provided by this class: </p>
+ * <code>
+ * Graph createGraph(String name); <br/>
+ * void addCustomData(BukkitMetrics.Plotter plotter); <br/>
+ * void start(); <br/>
+ * </code>
+ */
+public class Metrics {
+
+    /**
+     * The current revision number
+     */
+    private final static int REVISION = 6;
+    /**
+     * The base url of the metrics domain
+     */
+    private static final String BASE_URL = "http://mcstats.org";
+    /**
+     * The url used to report a server's status
+     */
+    private static final String REPORT_URL = "/report/%s";
+    /**
+     * The separator to use for custom data. This MUST NOT change unless you are hosting your own version of metrics and
+     * want to change it.
+     */
+    private static final String CUSTOM_DATA_SEPARATOR = "~~";
+    /**
+     * Interval of time to ping (in minutes)
+     */
+    private static final int PING_INTERVAL = 10;
+    /**
+     * All of the custom graphs to submit to metrics
+     */
+    private final Set<Graph> graphs = Collections.synchronizedSet(new HashSet<Graph>());
+    /**
+     * The default graph, used for addCustomData when you don't want a specific graph
+     */
+    private final Graph defaultGraph = new Graph("Default");
+    /**
+     * The plugin configuration file
+     */
+    private final YamlConfiguration configuration;
+    /**
+     * The plugin configuration file
+     */
+    private final File configurationFile;
+    /**
+     * Unique server id
+     */
+    private final String guid;
+    /**
+     * Debug mode
+     */
+    private final boolean debug;
+    /**
+     * Lock for synchronization
+     */
+    private final Object optOutLock = new Object();
+    /**
+     * The scheduled task
+     */
+    private volatile Timer task = null;
+
+    public Metrics() throws IOException {
+        // load the config
+        configurationFile = getConfigFile();
+        configuration = YamlConfiguration.loadConfiguration(configurationFile);
+
+        // add some defaults
+        configuration.addDefault("opt-out", false);
+        configuration.addDefault("guid", UUID.randomUUID().toString());
+        configuration.addDefault("debug", false);
+
+        // Do we need to create the file?
+        if (configuration.get("guid", null) == null) {
+            configuration.options().header("http://mcstats.org").copyDefaults(true);
+            configuration.save(configurationFile);
+        }
+
+        // Load the guid then
+        guid = configuration.getString("guid");
+        debug = configuration.getBoolean("debug", false);
+    }
+
+    /**
+     * Construct and create a Graph that can be used to separate specific plotters to their own graphs on the metrics
+     * website. Plotters can be added to the graph object returned.
+     *
+     * @param name The name of the graph
+     * @return Graph object created. Will never return NULL under normal circumstances unless bad parameters are given
+     */
+    public Graph createGraph(final String name) {
+        if (name == null) {
+            throw new IllegalArgumentException("Graph name cannot be null");
+        }
+
+        // Construct the graph object
+        final Graph graph = new Graph(name);
+
+        // Now we can add our graph
+        graphs.add(graph);
+
+        // and return back
+        return graph;
+    }
+
+    /**
+     * Add a Graph object to BukkitMetrics that represents data for the plugin that should be sent to the backend
+     *
+     * @param graph The name of the graph
+     */
+    public void addGraph(final Graph graph) {
+        if (graph == null) {
+            throw new IllegalArgumentException("Graph cannot be null");
+        }
+
+        graphs.add(graph);
+    }
+
+    /**
+     * Adds a custom data plotter to the default graph
+     *
+     * @param plotter The plotter to use to plot custom data
+     */
+    public void addCustomData(final Plotter plotter) {
+        if (plotter == null) {
+            throw new IllegalArgumentException("Plotter cannot be null");
+        }
+
+        // Add the plotter to the graph o/
+        defaultGraph.addPlotter(plotter);
+
+        // Ensure the default graph is included in the submitted graphs
+        graphs.add(defaultGraph);
+    }
+
+    /**
+     * Start measuring statistics. This will immediately create an async repeating task as the plugin and send the
+     * initial data to the metrics backend, and then after that it will post in increments of PING_INTERVAL * 1200
+     * ticks.
+     *
+     * @return True if statistics measuring is running, otherwise false.
+     */
+    public boolean start() {
+        synchronized (optOutLock) {
+            // Did we opt out?
+            if (isOptOut()) {
+                return false;
+            }
+
+            // Is metrics already running?
+            if (task != null) {
+                return true;
+            }
+
+            // Begin hitting the server with glorious data
+            task = new Timer("Spigot Metrics Thread", true);
+
+            task.scheduleAtFixedRate(new TimerTask() {
+                private boolean firstPost = true;
+
+                public void run() {
+                    try {
+                        // This has to be synchronized or it can collide with the disable method.
+                        synchronized (optOutLock) {
+                            // Disable Task, if it is running and the server owner decided to opt-out
+                            if (isOptOut() && task != null) {
+                                task.cancel();
+                                task = null;
+                                // Tell all plotters to stop gathering information.
+                                for (Graph graph : graphs) {
+                                    graph.onOptOut();
+                                }
+                            }
+                        }
+
+                        // We use the inverse of firstPost because if it is the first time we are posting,
+                        // it is not a interval ping, so it evaluates to FALSE
+                        // Each time thereafter it will evaluate to TRUE, i.e PING!
+                        postPlugin(!firstPost);
+
+                        // After the first post we set firstPost to false
+                        // Each post thereafter will be a ping
+                        firstPost = false;
+                    } catch (IOException e) {
+                        if (debug) {
+                            Bukkit.getLogger().log(Level.INFO, "[Metrics] " + e.getMessage());
+                        }
+                    }
+                }
+            }, 0, TimeUnit.MINUTES.toMillis(PING_INTERVAL));
+
+            return true;
+        }
+    }
+
+    /**
+     * Has the server owner denied plugin metrics?
+     *
+     * @return true if metrics should be opted out of it
+     */
+    public boolean isOptOut() {
+        synchronized (optOutLock) {
+            try {
+                // Reload the metrics file
+                configuration.load(getConfigFile());
+            } catch (IOException ex) {
+                if (debug) {
+                    Bukkit.getLogger().log(Level.INFO, "[Metrics] " + ex.getMessage());
+                }
+                return true;
+            } catch (InvalidConfigurationException ex) {
+                if (debug) {
+                    Bukkit.getLogger().log(Level.INFO, "[Metrics] " + ex.getMessage());
+                }
+                return true;
+            }
+            return configuration.getBoolean("opt-out", false);
+        }
+    }
+
+    /**
+     * Enables metrics for the server by setting "opt-out" to false in the config file and starting the metrics task.
+     *
+     * @throws java.io.IOException
+     */
+    public void enable() throws IOException {
+        // This has to be synchronized or it can collide with the check in the task.
+        synchronized (optOutLock) {
+            // Check if the server owner has already set opt-out, if not, set it.
+            if (isOptOut()) {
+                configuration.set("opt-out", false);
+                configuration.save(configurationFile);
+            }
+
+            // Enable Task, if it is not running
+            if (task == null) {
+                start();
+            }
+        }
+    }
+
+    /**
+     * Disables metrics for the server by setting "opt-out" to true in the config file and canceling the metrics task.
+     *
+     * @throws java.io.IOException
+     */
+    public void disable() throws IOException {
+        // This has to be synchronized or it can collide with the check in the task.
+        synchronized (optOutLock) {
+            // Check if the server owner has already set opt-out, if not, set it.
+            if (!isOptOut()) {
+                configuration.set("opt-out", true);
+                configuration.save(configurationFile);
+            }
+
+            // Disable Task, if it is running
+            if (task != null) {
+                task.cancel();
+                task = null;
+            }
+        }
+    }
+
+    /**
+     * Gets the File object of the config file that should be used to store data such as the GUID and opt-out status
+     *
+     * @return the File object for the config file
+     */
+    public File getConfigFile() {
+        // I believe the easiest way to get the base folder (e.g craftbukkit set via -P) for plugins to use
+        // is to abuse the plugin object we already have
+        // plugin.getDataFolder() => base/plugins/PluginA/
+        // pluginsFolder => base/plugins/
+        // The base is not necessarily relative to the startup directory.
+        // File pluginsFolder = plugin.getDataFolder().getParentFile();
+
+        // return => base/plugins/PluginMetrics/config.yml
+        return new File(new File((File) MinecraftServer.getServer().options.valueOf("plugins"), "PluginMetrics"), "config.yml");
+    }
+
+    /**
+     * Generic method that posts a plugin to the metrics website
+     */
+    private void postPlugin(final boolean isPing) throws IOException {
+        // Server software specific section
+        String pluginName = "Spigot";
+        boolean onlineMode = Bukkit.getServer().getOnlineMode(); // TRUE if online mode is enabled
+        String pluginVersion = (Metrics.class.getPackage().getImplementationVersion() != null) ? Metrics.class.getPackage().getImplementationVersion() : "unknown";
+        String serverVersion = Bukkit.getVersion();
+        int playersOnline = Bukkit.getServer().getOnlinePlayers().size();
+
+        // END server software specific section -- all code below does not use any code outside of this class / Java
+
+        // Construct the post data
+        final StringBuilder data = new StringBuilder();
+
+        // The plugin's description file containg all of the plugin data such as name, version, author, etc
+        data.append(encode("guid")).append('=').append(encode(guid));
+        encodeDataPair(data, "version", pluginVersion);
+        encodeDataPair(data, "server", serverVersion);
+        encodeDataPair(data, "players", Integer.toString(playersOnline));
+        encodeDataPair(data, "revision", String.valueOf(REVISION));
+
+        // New data as of R6
+        String osname = System.getProperty("os.name");
+        String osarch = System.getProperty("os.arch");
+        String osversion = System.getProperty("os.version");
+        String java_version = System.getProperty("java.version");
+        int coreCount = Runtime.getRuntime().availableProcessors();
+
+        // normalize os arch .. amd64 -> x86_64
+        if (osarch.equals("amd64")) {
+            osarch = "x86_64";
+        }
+
+        encodeDataPair(data, "osname", osname);
+        encodeDataPair(data, "osarch", osarch);
+        encodeDataPair(data, "osversion", osversion);
+        encodeDataPair(data, "cores", Integer.toString(coreCount));
+        encodeDataPair(data, "online-mode", Boolean.toString(onlineMode));
+        encodeDataPair(data, "java_version", java_version);
+
+        // If we're pinging, append it
+        if (isPing) {
+            encodeDataPair(data, "ping", "true");
+        }
+
+        // Acquire a lock on the graphs, which lets us make the assumption we also lock everything
+        // inside of the graph (e.g plotters)
+        synchronized (graphs) {
+            final Iterator<Graph> iter = graphs.iterator();
+
+            while (iter.hasNext()) {
+                final Graph graph = iter.next();
+
+                for (Plotter plotter : graph.getPlotters()) {
+                    // The key name to send to the metrics server
+                    // The format is C-GRAPHNAME-PLOTTERNAME where separator - is defined at the top
+                    // Legacy (R4) submitters use the format Custom%s, or CustomPLOTTERNAME
+                    final String key = String.format("C%s%s%s%s", CUSTOM_DATA_SEPARATOR, graph.getName(), CUSTOM_DATA_SEPARATOR, plotter.getColumnName());
+
+                    // The value to send, which for the foreseeable future is just the string
+                    // value of plotter.getValue()
+                    final String value = Integer.toString(plotter.getValue());
+
+                    // Add it to the http post data :)
+                    encodeDataPair(data, key, value);
+                }
+            }
+        }
+
+        // Create the url
+        URL url = new URL(BASE_URL + String.format(REPORT_URL, encode(pluginName)));
+
+        // Connect to the website
+        URLConnection connection;
+
+        // Mineshafter creates a socks proxy, so we can safely bypass it
+        // It does not reroute POST requests so we need to go around it
+        if (isMineshafterPresent()) {
+            connection = url.openConnection(Proxy.NO_PROXY);
+        } else {
+            connection = url.openConnection();
+        }
+
+        connection.setDoOutput(true);
+
+        // Write the data
+        final OutputStreamWriter writer = new OutputStreamWriter(connection.getOutputStream());
+        writer.write(data.toString());
+        writer.flush();
+
+        // Now read the response
+        final BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));
+        final String response = reader.readLine();
+
+        // close resources
+        writer.close();
+        reader.close();
+
+        if (response == null || response.startsWith("ERR")) {
+            throw new IOException(response); //Throw the exception
+        } else {
+            // Is this the first update this hour?
+            if (response.contains("OK This is your first update this hour")) {
+                synchronized (graphs) {
+                    final Iterator<Graph> iter = graphs.iterator();
+
+                    while (iter.hasNext()) {
+                        final Graph graph = iter.next();
+
+                        for (Plotter plotter : graph.getPlotters()) {
+                            plotter.reset();
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    /**
+     * Check if mineshafter is present. If it is, we need to bypass it to send POST requests
+     *
+     * @return true if mineshafter is installed on the server
+     */
+    private boolean isMineshafterPresent() {
+        try {
+            Class.forName("mineshafter.MineServer");
+            return true;
+        } catch (Exception e) {
+            return false;
+        }
+    }
+
+    /**
+     * <p>Encode a key/value data pair to be used in a HTTP post request. This INCLUDES a & so the first key/value pair
+     * MUST be included manually, e.g:</p>
+     * <code>
+     * StringBuffer data = new StringBuffer();
+     * data.append(encode("guid")).append('=').append(encode(guid));
+     * encodeDataPair(data, "version", description.getVersion());
+     * </code>
+     *
+     * @param buffer the stringbuilder to append the data pair onto
+     * @param key the key value
+     * @param value the value
+     */
+    private static void encodeDataPair(final StringBuilder buffer, final String key, final String value) throws UnsupportedEncodingException {
+        buffer.append('&').append(encode(key)).append('=').append(encode(value));
+    }
+
+    /**
+     * Encode text as UTF-8
+     *
+     * @param text the text to encode
+     * @return the encoded text, as UTF-8
+     */
+    private static String encode(final String text) throws UnsupportedEncodingException {
+        return URLEncoder.encode(text, "UTF-8");
+    }
+
+    /**
+     * Represents a custom graph on the website
+     */
+    public static class Graph {
+
+        /**
+         * The graph's name, alphanumeric and spaces only :) If it does not comply to the above when submitted, it is
+         * rejected
+         */
+        private final String name;
+        /**
+         * The set of plotters that are contained within this graph
+         */
+        private final Set<Plotter> plotters = new LinkedHashSet<Plotter>();
+
+        private Graph(final String name) {
+            this.name = name;
+        }
+
+        /**
+         * Gets the graph's name
+         *
+         * @return the Graph's name
+         */
+        public String getName() {
+            return name;
+        }
+
+        /**
+         * Add a plotter to the graph, which will be used to plot entries
+         *
+         * @param plotter the plotter to add to the graph
+         */
+        public void addPlotter(final Plotter plotter) {
+            plotters.add(plotter);
+        }
+
+        /**
+         * Remove a plotter from the graph
+         *
+         * @param plotter the plotter to remove from the graph
+         */
+        public void removePlotter(final Plotter plotter) {
+            plotters.remove(plotter);
+        }
+
+        /**
+         * Gets an <b>unmodifiable</b> set of the plotter objects in the graph
+         *
+         * @return an unmodifiable {@link java.util.Set} of the plotter objects
+         */
+        public Set<Plotter> getPlotters() {
+            return Collections.unmodifiableSet(plotters);
+        }
+
+        @Override
+        public int hashCode() {
+            return name.hashCode();
+        }
+
+        @Override
+        public boolean equals(final Object object) {
+            if (!(object instanceof Graph)) {
+                return false;
+            }
+
+            final Graph graph = (Graph) object;
+            return graph.name.equals(name);
+        }
+
+        /**
+         * Called when the server owner decides to opt-out of BukkitMetrics while the server is running.
+         */
+        protected void onOptOut() {
+        }
+    }
+
+    /**
+     * Interface used to collect custom data for a plugin
+     */
+    public static abstract class Plotter {
+
+        /**
+         * The plot's name
+         */
+        private final String name;
+
+        /**
+         * Construct a plotter with the default plot name
+         */
+        public Plotter() {
+            this("Default");
+        }
+
+        /**
+         * Construct a plotter with a specific plot name
+         *
+         * @param name the name of the plotter to use, which will show up on the website
+         */
+        public Plotter(final String name) {
+            this.name = name;
+        }
+
+        /**
+         * Get the current value for the plotted point. Since this function defers to an external function it may or may
+         * not return immediately thus cannot be guaranteed to be thread friendly or safe. This function can be called
+         * from any thread so care should be taken when accessing resources that need to be synchronized.
+         *
+         * @return the current value for the point to be plotted.
+         */
+        public abstract int getValue();
+
+        /**
+         * Get the column name for the plotted point
+         *
+         * @return the plotted point's column name
+         */
+        public String getColumnName() {
+            return name;
+        }
+
+        /**
+         * Called after the website graphs have been updated
+         */
+        public void reset() {
+        }
+
+        @Override
+        public int hashCode() {
+            return getColumnName().hashCode();
+        }
+
+        @Override
+        public boolean equals(final Object object) {
+            if (!(object instanceof Plotter)) {
+                return false;
+            }
+
+            final Plotter plotter = (Plotter) object;
+            return plotter.name.equals(name) && plotter.getValue() == getValue();
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/org/spigotmc/ProtocolData.java b/src/main/java/org/spigotmc/ProtocolData.java
new file mode 100644
index 0000000..ff93cbe
--- /dev/null
+++ b/src/main/java/org/spigotmc/ProtocolData.java
@@ -0,0 +1,190 @@
+package org.spigotmc;
+
+public class ProtocolData
+{
+    public static class ByteShort extends Number
+    {
+
+        private short value;
+
+        public ByteShort(short value)
+        {
+            this.value = value;
+        }
+
+        @Override
+        public int intValue()
+        {
+            return value;
+        }
+
+        @Override
+        public long longValue()
+        {
+            return value;
+        }
+
+        @Override
+        public float floatValue()
+        {
+            return value;
+        }
+
+        @Override
+        public double doubleValue()
+        {
+            return value;
+        }
+    }
+
+    public static class DualByte extends Number
+    {
+
+        public byte value;
+        public byte value2;
+
+        public DualByte(byte value, byte value2)
+        {
+            this.value = value;
+            this.value2 = value2;
+        }
+
+        @Override
+        public int intValue()
+        {
+            return value;
+        }
+
+        @Override
+        public long longValue()
+        {
+            return value;
+        }
+
+        @Override
+        public float floatValue()
+        {
+            return value;
+        }
+
+        @Override
+        public double doubleValue()
+        {
+            return value;
+        }
+    }
+
+    public static class HiddenByte extends Number
+    {
+
+        private byte value;
+
+        public HiddenByte(byte value)
+        {
+            this.value = value;
+        }
+
+        @Override
+        public int intValue()
+        {
+            return value;
+        }
+
+        @Override
+        public long longValue()
+        {
+            return value;
+        }
+
+        @Override
+        public float floatValue()
+        {
+            return value;
+        }
+
+        @Override
+        public double doubleValue()
+        {
+            return value;
+        }
+    }
+    public static class IntByte extends Number
+    {
+
+        public int value;
+        public byte value2;
+
+        public IntByte(int value, byte value2)
+        {
+            this.value = value;
+            this.value2 = value2;
+        }
+
+        @Override
+        public byte byteValue()
+        {
+            return value2;
+        }
+
+        @Override
+        public int intValue()
+        {
+            return value;
+        }
+
+        @Override
+        public long longValue()
+        {
+            return value;
+        }
+
+        @Override
+        public float floatValue()
+        {
+            return value;
+        }
+
+        @Override
+        public double doubleValue()
+        {
+            return value;
+        }
+    }
+
+    public static class DualInt extends Number
+    {
+
+        public int value;
+        public int value2;
+
+        public DualInt(int value, int value2)
+        {
+            this.value = value;
+            this.value2 = value2;
+        }
+
+        @Override
+        public int intValue()
+        {
+            return value;
+        }
+
+        @Override
+        public long longValue()
+        {
+            return value;
+        }
+
+        @Override
+        public float floatValue()
+        {
+            return value;
+        }
+
+        @Override
+        public double doubleValue()
+        {
+            return value;
+        }
+    }
+}
diff --git a/src/main/java/org/spigotmc/ProtocolInjector.java b/src/main/java/org/spigotmc/ProtocolInjector.java
new file mode 100644
index 0000000..3b2df91
--- /dev/null
+++ b/src/main/java/org/spigotmc/ProtocolInjector.java
@@ -0,0 +1,253 @@
+package org.spigotmc;
+
+import net.minecraft.server.ChatSerializer;
+import net.minecraft.server.EnumProtocol;
+import net.minecraft.server.IChatBaseComponent;
+import net.minecraft.server.Packet;
+import net.minecraft.server.PacketDataSerializer;
+import net.minecraft.server.PacketListener;
+import net.minecraft.util.com.google.common.collect.BiMap;
+
+import java.io.IOException;
+import java.lang.reflect.Field;
+import java.util.Map;
+
+public class ProtocolInjector
+{
+    public static void inject()
+    {
+        try
+        {
+            addPacket( EnumProtocol.LOGIN, true, 0x3, PacketLoginCompression.class );
+
+            addPacket( EnumProtocol.PLAY, true, 0x45, PacketTitle.class );
+            addPacket( EnumProtocol.PLAY, true, 0x47, PacketTabHeader.class );
+            addPacket( EnumProtocol.PLAY, true, 0x48, PacketPlayResourcePackSend.class );
+            addPacket( EnumProtocol.PLAY, false, 0x19, PacketPlayResourcePackStatus.class );
+        } catch ( NoSuchFieldException e )
+        {
+            e.printStackTrace();
+        } catch ( IllegalAccessException e )
+        {
+            e.printStackTrace();
+        }
+    }
+
+    private static void addPacket(EnumProtocol protocol, boolean clientbound, int id, Class<? extends Packet> packet) throws NoSuchFieldException, IllegalAccessException
+    {
+        Field packets;
+        if (!clientbound) {
+            packets = EnumProtocol.class.getDeclaredField( "h" );
+        } else {
+            packets = EnumProtocol.class.getDeclaredField( "i" );
+        }
+        packets.setAccessible( true );
+        BiMap<Integer, Class<? extends Packet>> pMap = (BiMap<Integer, Class<? extends Packet>>) packets.get( protocol );
+        pMap.put( id, packet );
+        Field map = EnumProtocol.class.getDeclaredField( "f" );
+        map.setAccessible( true );
+        Map<Class<? extends Packet>, EnumProtocol> protocolMap = (Map<Class<? extends Packet>, EnumProtocol>) map.get( null );
+        protocolMap.put( packet, protocol );
+    }
+
+    public static class PacketPlayResourcePackStatus extends Packet {
+
+        @Override
+        public void a(PacketDataSerializer packetdataserializer) throws IOException
+        {
+            packetdataserializer.c( 255 ); // Hash
+            packetdataserializer.a(); // Result
+        }
+
+        @Override
+        public void b(PacketDataSerializer packetdataserializer) throws IOException
+        {
+
+        }
+
+        @Override
+        public void handle(PacketListener packetlistener)
+        {
+
+        }
+    }
+
+    public static class PacketPlayResourcePackSend extends Packet {
+
+        private String url;
+        private String hash;
+
+        public PacketPlayResourcePackSend(String url, String hash)
+        {
+            this.url = url;
+            this.hash = hash;
+        }
+
+        @Override
+        public void a(PacketDataSerializer packetdataserializer) throws IOException
+        {
+
+        }
+
+        @Override
+        public void b(PacketDataSerializer packetdataserializer) throws IOException
+        {
+            packetdataserializer.a( url );
+            packetdataserializer.a( hash );
+        }
+
+        @Override
+        public void handle(PacketListener packetlistener)
+        {
+
+        }
+    }
+
+    public static class PacketLoginCompression extends Packet {
+
+        private int threshold;
+
+        public PacketLoginCompression(int threshold)
+        {
+            this.threshold = threshold;
+        }
+
+        @Override
+        public void a(PacketDataSerializer packetdataserializer) throws IOException
+        {
+
+        }
+
+        @Override
+        public void b(PacketDataSerializer packetdataserializer) throws IOException
+        {
+            packetdataserializer.b( threshold );
+        }
+
+        @Override
+        public void handle(PacketListener packetlistener)
+        {
+
+        }
+    }
+
+    public static class PacketTabHeader extends Packet
+    {
+
+        private IChatBaseComponent header;
+        private IChatBaseComponent footer;
+
+        public PacketTabHeader()
+        {
+        }
+
+        public PacketTabHeader(IChatBaseComponent header, IChatBaseComponent footer)
+        {
+            this.header = header;
+            this.footer = footer;
+        }
+
+        @Override
+        public void a(PacketDataSerializer packetdataserializer) throws IOException
+        {
+            this.header = ChatSerializer.a( packetdataserializer.c( 32767 ) );
+            this.footer = ChatSerializer.a( packetdataserializer.c( 32767 ) );
+        }
+
+        @Override
+        public void b(PacketDataSerializer packetdataserializer) throws IOException
+        {
+            packetdataserializer.a( ChatSerializer.a( this.header ) );
+            packetdataserializer.a( ChatSerializer.a( this.footer ) );
+        }
+
+        @Override
+        public void handle(PacketListener packetlistener)
+        {
+        }
+    }
+
+    public static class PacketTitle extends Packet
+    {
+        private Action action;
+
+        // TITLE & SUBTITLE
+        private IChatBaseComponent text;
+
+        // TIMES
+        private int fadeIn = -1;
+        private int stay = -1;
+        private int fadeOut = -1;
+
+        public PacketTitle() {}
+
+        public PacketTitle(Action action)
+        {
+            this.action = action;
+        }
+
+        public PacketTitle(Action action, IChatBaseComponent text)
+        {
+            this( action );
+            this.text = text;
+        }
+
+        public PacketTitle(Action action, int fadeIn, int stay, int fadeOut)
+        {
+            this( action );
+            this.fadeIn = fadeIn;
+            this.stay = stay;
+            this.fadeOut = fadeOut;
+        }
+
+
+        @Override
+        public void a(PacketDataSerializer packetdataserializer) throws IOException
+        {
+            this.action = Action.values()[packetdataserializer.a()];
+            switch ( action )
+            {
+                case TITLE:
+                case SUBTITLE:
+                    this.text = ChatSerializer.a( packetdataserializer.c(32767) );
+                    break;
+                case TIMES:
+                    this.fadeIn = packetdataserializer.readInt();
+                    this.stay = packetdataserializer.readInt();
+                    this.fadeOut = packetdataserializer.readInt();
+                    break;
+            }
+        }
+
+        @Override
+        public void b(PacketDataSerializer packetdataserializer) throws IOException
+        {
+            packetdataserializer.b( action.ordinal() );
+            switch ( action )
+            {
+                case TITLE:
+                case SUBTITLE:
+                    packetdataserializer.a( ChatSerializer.a( this.text ) );
+                    break;
+                case TIMES:
+                    packetdataserializer.writeInt( this.fadeIn );
+                    packetdataserializer.writeInt( this.stay );
+                    packetdataserializer.writeInt( this.fadeOut );
+                    break;
+            }
+        }
+
+        @Override
+        public void handle(PacketListener packetlistener)
+        {
+        }
+
+        public static enum Action {
+            TITLE,
+            SUBTITLE,
+            TIMES,
+            CLEAR,
+            RESET
+        }
+    }
+}
diff --git a/src/main/java/org/spigotmc/RestartCommand.java b/src/main/java/org/spigotmc/RestartCommand.java
new file mode 100644
index 0000000..429c258
--- /dev/null
+++ b/src/main/java/org/spigotmc/RestartCommand.java
@@ -0,0 +1,124 @@
+package org.spigotmc;
+
+import java.io.File;
+import java.util.List;
+import net.minecraft.server.EntityPlayer;
+import net.minecraft.server.MinecraftServer;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+
+public class RestartCommand extends Command
+{
+
+    public RestartCommand(String name)
+    {
+        super( name );
+        this.description = "Restarts the server";
+        this.usageMessage = "/restart";
+        this.setPermission( "bukkit.command.restart" );
+    }
+
+    @Override
+    public boolean execute(CommandSender sender, String currentAlias, String[] args)
+    {
+        if ( testPermission( sender ) )
+        {
+            MinecraftServer.getServer().processQueue.add( new Runnable()
+            {
+                @Override
+                public void run()
+                {
+                    restart();
+                }
+            } );
+        }
+        return true;
+    }
+
+    public static void restart()
+    {
+        restart( new File( SpigotConfig.restartScript ) );
+    }
+
+    public static void restart(final File script)
+    {
+        AsyncCatcher.enabled = false; // Disable async catcher incase it interferes with us
+        try
+        {
+            if ( script.isFile() )
+            {
+                System.out.println( "Attempting to restart with " + SpigotConfig.restartScript );
+
+                // Disable Watchdog
+                WatchdogThread.doStop();
+
+                // Kick all players
+                for ( EntityPlayer p : (List< EntityPlayer>) MinecraftServer.getServer().getPlayerList().players )
+                {
+                    p.playerConnection.disconnect(SpigotConfig.restartMessage);
+                }
+                // Give the socket a chance to send the packets
+                try
+                {
+                    Thread.sleep( 100 );
+                } catch ( InterruptedException ex )
+                {
+                }
+                // Close the socket so we can rebind with the new process
+                MinecraftServer.getServer().getServerConnection().b();
+
+                // Give time for it to kick in
+                try
+                {
+                    Thread.sleep( 100 );
+                } catch ( InterruptedException ex )
+                {
+                }
+
+                // Actually shutdown
+                try
+                {
+                    MinecraftServer.getServer().stop();
+                } catch ( Throwable t )
+                {
+                }
+
+                // This will be done AFTER the server has completely halted
+                Thread shutdownHook = new Thread()
+                {
+                    @Override
+                    public void run()
+                    {
+                        try
+                        {
+                            String os = System.getProperty( "os.name" ).toLowerCase();
+                            if ( os.contains( "win" ) )
+                            {
+                                Runtime.getRuntime().exec( "cmd /c start " + script.getPath() );
+                            } else
+                            {
+                                Runtime.getRuntime().exec( new String[]
+                                {
+                                    "sh", script.getPath()
+                                } );
+                            }
+                        } catch ( Exception e )
+                        {
+                            e.printStackTrace();
+                        }
+                    }
+                };
+
+                shutdownHook.setDaemon( true );
+                Runtime.getRuntime().addShutdownHook( shutdownHook );
+            } else
+            {
+                System.out.println( "Startup script '" + SpigotConfig.restartScript + "' does not exist! Stopping server." );
+            }
+            System.exit( 0 );
+        } catch ( Exception ex )
+        {
+            ex.printStackTrace();
+        }
+    }
+}
diff --git a/src/main/java/org/spigotmc/SneakyThrow.java b/src/main/java/org/spigotmc/SneakyThrow.java
new file mode 100644
index 0000000..31fc0a9
--- /dev/null
+++ b/src/main/java/org/spigotmc/SneakyThrow.java
@@ -0,0 +1,15 @@
+package org.spigotmc;
+
+public class SneakyThrow
+{
+
+    public static void sneaky(Throwable t)
+    {
+        throw SneakyThrow.<RuntimeException>superSneaky( t );
+    }
+
+    private static <T extends Throwable> T superSneaky(Throwable t) throws T
+    {
+        throw (T) t;
+    }
+}
diff --git a/src/main/java/org/spigotmc/SpigotComponentReverter.java b/src/main/java/org/spigotmc/SpigotComponentReverter.java
new file mode 100644
index 0000000..6093d62
--- /dev/null
+++ b/src/main/java/org/spigotmc/SpigotComponentReverter.java
@@ -0,0 +1,105 @@
+package org.spigotmc;
+
+import net.minecraft.server.ChatComponentText;
+import net.minecraft.server.ChatModifier;
+import net.minecraft.server.EnumChatFormat;
+import net.minecraft.server.IChatBaseComponent;
+import org.bukkit.ChatColor;
+
+import java.util.Iterator;
+import java.util.List;
+
+public class SpigotComponentReverter
+{
+    public static String toLegacy(IChatBaseComponent s)
+    {
+        StringBuilder builder = new StringBuilder();
+        legacy( builder, s );
+        return builder.toString();
+    }
+
+    private static void legacy(StringBuilder builder, IChatBaseComponent s)
+    {
+        ChatModifier modifier = s.getChatModifier();
+        colorize( builder, modifier );
+        if ( s instanceof ChatComponentText )
+        {
+            builder.append( s.e() );
+        } else {
+            throw new RuntimeException( "Unhandled type: " + s.getClass().getSimpleName() );
+        }
+
+        for ( IChatBaseComponent c : getExtra( s ) ) {
+            legacy( builder, c );
+        }
+    }
+
+    private static void colorize(StringBuilder builder, ChatModifier modifier)
+    {
+        if ( modifier == null ) return;
+        // Color first
+        EnumChatFormat color = getColor( modifier );
+        if ( color == null )
+        {
+            color = EnumChatFormat.BLACK;
+        }
+        builder.append( color.toString() );
+
+        if ( isBold( modifier ) )
+        {
+            builder.append( ChatColor.BOLD );
+        }
+        if ( isItalic( modifier ) )
+        {
+            builder.append( ChatColor.ITALIC );
+        }
+        if ( isRandom( modifier ) )
+        {
+            builder.append( ChatColor.MAGIC );
+        }
+        if ( isStrikethrough( modifier ) )
+        {
+            builder.append( ChatColor.STRIKETHROUGH );
+        }
+        if ( isUnderline( modifier ) )
+        {
+            builder.append( ChatColor.UNDERLINE );
+        }
+    }
+
+    // Helpers
+    private static List<IChatBaseComponent> getExtra(IChatBaseComponent c)
+    {
+        return c.a();
+    }
+
+    private static EnumChatFormat getColor(ChatModifier c)
+    {
+        return c.a();
+    }
+
+    private static boolean isBold(ChatModifier c)
+    {
+        return c.b();
+    }
+
+    private static boolean isItalic(ChatModifier c)
+    {
+        return c.c();
+    }
+
+    private static boolean isStrikethrough(ChatModifier c)
+    {
+        return c.d();
+    }
+
+    private static boolean isUnderline(ChatModifier c)
+    {
+        return c.e();
+    }
+
+    private static boolean isRandom(ChatModifier c)
+    {
+        return c.f();
+    }
+}
diff --git a/src/main/java/org/spigotmc/SpigotCompressor.java b/src/main/java/org/spigotmc/SpigotCompressor.java
new file mode 100644
index 0000000..2e0857e
--- /dev/null
+++ b/src/main/java/org/spigotmc/SpigotCompressor.java
@@ -0,0 +1,43 @@
+package org.spigotmc;
+
+import net.minecraft.server.PacketDataSerializer;
+import net.minecraft.util.io.netty.buffer.ByteBuf;
+import net.minecraft.util.io.netty.channel.ChannelHandlerContext;
+import net.minecraft.util.io.netty.handler.codec.MessageToByteEncoder;
+
+import java.util.zip.Deflater;
+
+public class SpigotCompressor extends MessageToByteEncoder
+{
+
+    private final byte[] buffer = new byte[8192];
+    private final Deflater deflater = new Deflater();
+
+    @Override
+    protected void encode(ChannelHandlerContext ctx, Object msg, ByteBuf out) throws Exception
+    {
+        ByteBuf in = (ByteBuf) msg;
+        int origSize = in.readableBytes();
+        PacketDataSerializer serializer = new PacketDataSerializer( out );
+
+        if ( origSize < 256 )
+        {
+            serializer.b( 0 );
+            serializer.writeBytes( in );
+        } else
+        {
+            byte[] data = new byte[ origSize ];
+            in.readBytes( data );
+
+            serializer.b( data.length );
+
+            deflater.setInput( data );
+            deflater.finish();
+            while (!deflater.finished()) {
+                int count = deflater.deflate( buffer );
+                serializer.writeBytes( buffer, 0, count );
+            }
+            deflater.reset();
+        }
+    }
+}
diff --git a/src/main/java/org/spigotmc/SpigotConfig.java b/src/main/java/org/spigotmc/SpigotConfig.java
new file mode 100644
index 0000000..f407eb8
--- /dev/null
+++ b/src/main/java/org/spigotmc/SpigotConfig.java
@@ -0,0 +1,401 @@
+package org.spigotmc;
+
+import com.google.common.base.Throwables;
+import java.io.File;
+import java.io.IOException;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.net.URL;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.logging.Level;
+import net.minecraft.server.AttributeRanged;
+import net.minecraft.server.GenericAttributes;
+import net.minecraft.util.gnu.trove.map.hash.TObjectIntHashMap;
+import net.minecraft.server.MinecraftServer;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.core.LoggerContext;
+import org.apache.logging.log4j.core.config.Configuration;
+import org.bukkit.Bukkit;
+import org.bukkit.ChatColor;
+import org.bukkit.command.Command;
+import org.bukkit.configuration.ConfigurationSection;
+import org.bukkit.configuration.InvalidConfigurationException;
+import org.bukkit.configuration.file.YamlConfiguration;
+
+public class SpigotConfig
+{
+
+    private static final File CONFIG_FILE = new File( "spigot.yml" );
+    private static final String HEADER = "This is the main configuration file for Spigot.\n"
+            + "As you can see, there's tons to configure. Some options may impact gameplay, so use\n"
+            + "with caution, and make sure you know what each option does before configuring.\n"
+            + "For a reference for any variable inside this file, check out the Spigot wiki at\n"
+            + "http://www.spigotmc.org/wiki/spigot-configuration/\n"
+            + "\n"
+            + "If you need help with the configuration or have any questions related to Spigot,\n"
+            + "join us at the IRC or drop by our forums and leave a post.\n"
+            + "\n"
+            + "IRC: #spigot @ irc.spi.gt ( http://www.spigotmc.org/pages/irc/ )\n"
+            + "Forums: http://www.spigotmc.org/\n";
+    /*========================================================================*/
+    public static YamlConfiguration config;
+    static int version;
+    static Map<String, Command> commands;
+    /*========================================================================*/
+    private static Metrics metrics;
+
+    public static void init()
+    {
+        config = new YamlConfiguration();
+        try
+        {
+            config.load( CONFIG_FILE );
+        } catch ( IOException ex )
+        {
+        } catch ( InvalidConfigurationException ex )
+        {
+            Bukkit.getLogger().log( Level.SEVERE, "Could not load spigot.yml, please correct your syntax errors", ex );
+            throw Throwables.propagate( ex );
+        }
+
+        config.options().header( HEADER );
+        config.options().copyDefaults( true );
+
+        commands = new HashMap<String, Command>();
+
+        version = getInt( "config-version", 8 );
+        set( "config-version", 8 );
+        readConfig( SpigotConfig.class, null );
+    }
+
+    public static void registerCommands()
+    {
+        for ( Map.Entry<String, Command> entry : commands.entrySet() )
+        {
+            MinecraftServer.getServer().server.getCommandMap().register( entry.getKey(), "Spigot", entry.getValue() );
+        }
+
+        if ( metrics == null )
+        {
+            try
+            {
+                metrics = new Metrics();
+                metrics.start();
+            } catch ( IOException ex )
+            {
+                Bukkit.getServer().getLogger().log( Level.SEVERE, "Could not start metrics service", ex );
+            }
+        }
+    }
+
+    static void readConfig(Class<?> clazz, Object instance)
+    {
+        for ( Method method : clazz.getDeclaredMethods() )
+        {
+            if ( Modifier.isPrivate( method.getModifiers() ) )
+            {
+                if ( method.getParameterTypes().length == 0 && method.getReturnType() == Void.TYPE )
+                {
+                    try
+                    {
+                        method.setAccessible( true );
+                        method.invoke( instance );
+                    } catch ( InvocationTargetException ex )
+                    {
+                        throw Throwables.propagate( ex.getCause() );
+                    } catch ( Exception ex )
+                    {
+                        Bukkit.getLogger().log( Level.SEVERE, "Error invoking " + method, ex );
+                    }
+                }
+            }
+        }
+
+        try
+        {
+            config.save( CONFIG_FILE );
+        } catch ( IOException ex )
+        {
+            Bukkit.getLogger().log( Level.SEVERE, "Could not save " + CONFIG_FILE, ex );
+        }
+    }
+
+    private static void set(String path, Object val)
+    {
+        config.set( path, val );
+    }
+
+    private static boolean getBoolean(String path, boolean def)
+    {
+        config.addDefault( path, def );
+        return config.getBoolean( path, config.getBoolean( path ) );
+    }
+
+    private static int getInt(String path, int def)
+    {
+        config.addDefault( path, def );
+        return config.getInt( path, config.getInt( path ) );
+    }
+
+    private static <T> List getList(String path, T def)
+    {
+        config.addDefault( path, def );
+        return (List<T>) config.getList( path, config.getList( path ) );
+    }
+
+    private static String getString(String path, String def)
+    {
+        config.addDefault( path, def );
+        return config.getString( path, config.getString( path ) );
+    }
+
+    private static double getDouble(String path, double def)
+    {
+        config.addDefault( path, def );
+        return config.getDouble( path, config.getDouble( path ) );
+    }
+
+    public static boolean logCommands;
+    private static void logCommands()
+    {
+        logCommands = getBoolean( "commands.log", true );
+    }
+
+    public static int tabComplete;
+    private static void tabComplete()
+    {
+        if ( version < 6 )
+        {
+            boolean oldValue = getBoolean( "commands.tab-complete", true );
+            if ( oldValue )
+            {
+                set( "commands.tab-complete", 0 );
+            } else
+            {
+                set( "commands.tab-complete", -1 );
+            }
+        }
+        tabComplete = getInt( "commands.tab-complete", 0 );
+    }
+
+    public static String whitelistMessage;
+    public static String unknownCommandMessage;
+    public static String serverFullMessage;
+    public static String outdatedClientMessage = "Outdated client! Please use {0}";
+    public static String outdatedServerMessage = "Outdated server! I\'m still on {0}";
+    private static String transform(String s)
+    {
+        return ChatColor.translateAlternateColorCodes( '&', s ).replaceAll( "\\n", "\n" );
+    }
+    private static void messages()
+    {
+        if (version < 8)
+        {
+            set( "messages.outdated-client", outdatedClientMessage );
+            set( "messages.outdated-server", outdatedServerMessage );
+        }
+
+        whitelistMessage = transform( getString( "messages.whitelist", "You are not whitelisted on this server!" ) );
+        unknownCommandMessage = transform( getString( "messages.unknown-command", "Unknown command. Type \"/help\" for help." ) );
+        serverFullMessage = transform( getString( "messages.server-full", "The server is full!" ) );
+        outdatedClientMessage = transform( getString( "messages.outdated-client", outdatedClientMessage ) );
+        outdatedServerMessage = transform( getString( "messages.outdated-server", outdatedServerMessage ) );
+    }
+
+    public static int timeoutTime = 60;
+    public static boolean restartOnCrash = true;
+    public static String restartScript = "./start.sh";
+    public static String restartMessage;
+    private static void watchdog()
+    {
+        timeoutTime = getInt( "settings.timeout-time", timeoutTime );
+        restartOnCrash = getBoolean( "settings.restart-on-crash", restartOnCrash );
+        restartScript = getString( "settings.restart-script", restartScript );
+        restartMessage = transform( getString( "messages.restart", "Server is restarting" ) );
+        commands.put( "restart", new RestartCommand( "restart" ) );
+        WatchdogThread.doStart( timeoutTime, restartOnCrash );
+    }
+
+    public static boolean bungee;
+    private static void bungee() {
+        if ( version < 4 )
+        {
+            set( "settings.bungeecord", false );
+            System.out.println( "Oudated config, disabling BungeeCord support!" );
+        }
+        bungee = getBoolean( "settings.bungeecord", false );
+    }
+
+    private static void nettyThreads()
+    {
+        int count = getInt( "settings.netty-threads", 4 );
+        System.setProperty( "io.netty.eventLoopThreads", Integer.toString( count ) );
+        Bukkit.getLogger().log( Level.INFO, "Using {0} threads for Netty based IO", count );
+    }
+
+    public static boolean lateBind;
+    private static void lateBind() {
+        lateBind = getBoolean( "settings.late-bind", false );
+    }
+
+    public static boolean disableStatSaving;
+    public static TObjectIntHashMap<String> forcedStats = new TObjectIntHashMap<String>();
+    private static void stats()
+    {
+        disableStatSaving = getBoolean( "stats.disable-saving", false );
+
+        if ( !config.contains( "stats.forced-stats" ) ) {
+            config.createSection( "stats.forced-stats" );
+        }
+
+        ConfigurationSection section = config.getConfigurationSection( "stats.forced-stats" );
+        for ( String name : section.getKeys( true ) )
+        {
+            if ( section.isInt( name ) )
+            {
+                forcedStats.put( name, section.getInt( name ) );
+            }
+        }
+
+        if ( disableStatSaving && section.getInt( "achievement.openInventory", 0 ) < 1 )
+        {
+            Bukkit.getLogger().warning( "*** WARNING *** stats.disable-saving is true but stats.forced-stats.achievement.openInventory" +
+                    " isn't set to 1. Disabling stat saving without forcing the achievement may cause it to get stuck on the player's " +
+                    "screen." );
+        }
+    }
+
+    private static void tpsCommand()
+    {
+        commands.put( "tps", new TicksPerSecondCommand( "tps" ) );
+    }
+
+    public static int playerSample;
+    private static void playerSample()
+    {
+        playerSample = getInt( "settings.sample-count", 12 );
+        System.out.println( "Server Ping Player Sample Count: " + playerSample );
+    }
+
+    public static int playerShuffle;
+    private static void playerShuffle()
+    {
+        playerShuffle = getInt( "settings.player-shuffle", 0 );
+    }
+
+    public static List<String> spamExclusions;
+    private static void spamExclusions()
+    {
+        spamExclusions = getList( "commands.spam-exclusions", Arrays.asList( new String[]
+        {
+                "/skill"
+        } ) );
+    }
+
+    public static boolean silentCommandBlocks;
+    private static void silentCommandBlocks()
+    {
+        silentCommandBlocks = getBoolean( "commands.silent-commandblock-console", false );
+    }
+
+    public static boolean filterCreativeItems;
+    private static void filterCreativeItems()
+    {
+        filterCreativeItems = getBoolean( "settings.filter-creative-items", true );
+    }
+
+    public static Set<String> replaceCommands;
+    private static void replaceCommands()
+    {
+        if ( config.contains( "replace-commands" ) )
+        {
+            set( "commands.replace-commands", config.getStringList( "replace-commands" ) );
+            config.set( "replace-commands", null );
+        }
+        replaceCommands = new HashSet<String>( (List<String>) getList( "commands.replace-commands",
+                Arrays.asList( "setblock", "summon", "testforblock", "tellraw" ) ) );
+    }
+    
+    public static int userCacheCap;
+    private static void userCacheCap()
+    {
+        userCacheCap = getInt( "settings.user-cache-size", 1000 );
+    }
+    
+    public static boolean saveUserCacheOnStopOnly;
+    private static void saveUserCacheOnStopOnly()
+    {
+        saveUserCacheOnStopOnly = getBoolean( "settings.save-user-cache-on-stop-only", false );
+    }
+
+    public static int intCacheLimit;
+    private static void intCacheLimit()
+    {
+        intCacheLimit = getInt( "settings.int-cache-limit", 1024 );
+    }
+
+    public static double movedWronglyThreshold;
+    private static void movedWronglyThreshold()
+    {
+        movedWronglyThreshold = getDouble( "settings.moved-wrongly-threshold", 0.0625D );
+    }
+
+    public static double movedTooQuicklyThreshold;
+    private static void movedTooQuicklyThreshold()
+    {
+        movedTooQuicklyThreshold = getDouble( "settings.moved-too-quickly-threshold", 100.0D );
+    }
+
+    public static double maxHealth = 2048;
+    public static double movementSpeed = 2048;
+    public static double attackDamage = 2048;
+    private static void attributeMaxes()
+    {
+        maxHealth = getDouble( "settings.attribute.maxHealth.max", maxHealth );
+        ( (AttributeRanged) GenericAttributes.maxHealth ).b = maxHealth;
+        movementSpeed = getDouble( "settings.attribute.movementSpeed.max", movementSpeed );
+        ( (AttributeRanged) GenericAttributes.d ).b = movementSpeed;
+        attackDamage = getDouble( "settings.attribute.attackDamage.max", attackDamage );
+        ( (AttributeRanged) GenericAttributes.e ).b = attackDamage;
+    }
+
+    private static void globalAPICache()
+    {
+        if ( getBoolean( "settings.global-api-cache", false ) && !CachedStreamHandlerFactory.isSet )
+        {
+            Bukkit.getLogger().info( "Global API cache enabled - All requests to Mojang's API will be " +
+                    "handled by Spigot" );
+            CachedStreamHandlerFactory.isSet = true;
+            URL.setURLStreamHandlerFactory(new CachedStreamHandlerFactory());
+        }
+    }
+
+    public static boolean debug;
+    private static void debug()
+    {
+        debug = getBoolean( "settings.debug", false );
+
+        if ( debug && !LogManager.getRootLogger().isTraceEnabled() )
+        {
+            // Enable debug logging
+            LoggerContext ctx = (LoggerContext) LogManager.getContext( false );
+            Configuration conf = ctx.getConfiguration();
+            conf.getLoggerConfig( LogManager.ROOT_LOGGER_NAME ).setLevel( org.apache.logging.log4j.Level.ALL );
+            ctx.updateLoggers( conf );
+        }
+
+        if ( LogManager.getRootLogger().isTraceEnabled() )
+        {
+            Bukkit.getLogger().info( "Debug logging is enabled" );
+        } else
+        {
+            Bukkit.getLogger().info( "Debug logging is disabled" );
+        }
+    }
+}
diff --git a/src/main/java/org/spigotmc/SpigotDebreakifier.java b/src/main/java/org/spigotmc/SpigotDebreakifier.java
new file mode 100644
index 0000000..d811f55
--- /dev/null
+++ b/src/main/java/org/spigotmc/SpigotDebreakifier.java
@@ -0,0 +1,102 @@
+package org.spigotmc;
+
+import com.google.common.base.Charsets;
+import com.google.gson.JsonArray;
+import com.google.gson.JsonElement;
+import com.google.gson.JsonParser;
+import net.minecraft.server.Block;
+import net.minecraft.server.Blocks;
+import net.minecraft.server.Item;
+import net.minecraft.server.Items;
+import net.minecraft.util.gnu.trove.map.hash.TIntIntHashMap;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.util.Arrays;
+
+public class SpigotDebreakifier
+{
+
+    private static final boolean[] validBlocks = new boolean[ 198 << 4 ];
+    private static final int[] correctedValues = new int[ 198 ];
+
+    static
+    {
+        Arrays.fill( correctedValues, -1 );
+        InputStream in = SpigotDebreakifier.class.getResourceAsStream( "/blocks.json" );
+        try
+        {
+            JsonArray e = new JsonParser().parse( new InputStreamReader( in, Charsets.UTF_8 ) ).getAsJsonArray();
+            for ( JsonElement entry : e )
+            {
+                String[] parts = entry.getAsString().split( ":" );
+                int id = Integer.parseInt( parts[ 0 ] );
+                int data = Integer.parseInt( parts[ 1 ] );
+                validBlocks[ ( id << 4 ) | data ] = true;
+                if ( correctedValues[ id ] == -1 || data < correctedValues[ id ] )
+                {
+                    correctedValues[ id ] = data;
+                }
+            }
+        } finally
+        {
+            try
+            {
+                in.close();
+            } catch ( IOException e )
+            {
+                throw new RuntimeException( e );
+            }
+        }
+    }
+
+    public static int getCorrectedData(int id, int data)
+    {
+        if ( id > 197 ) return data;
+        if ( id == 175 && data > 8 )
+        {
+            data = 8;
+        }
+        if ( validBlocks[ ( id << 4 ) | data ] )
+        {
+            return data;
+        } else
+        {
+            return correctedValues[ id ] & 0xF;
+        }
+    }
+
+    private static TIntIntHashMap invalidItems = new TIntIntHashMap();
+    static {
+        replace( Blocks.WATER, Items.WATER_BUCKET );
+        replace( Blocks.STATIONARY_WATER, Items.WATER_BUCKET );
+        replace( Blocks.LAVA, Items.LAVA_BUCKET );
+        replace( Blocks.STATIONARY_LAVA, Items.LAVA_BUCKET );
+        replace( Blocks.PORTAL, Items.NETHER_BRICK );
+        replace( Blocks.DOUBLE_STEP, Blocks.STEP );
+        replace( Blocks.FIRE, Items.FLINT_AND_STEEL );
+        replace( Blocks.ENDER_PORTAL, Blocks.ENDER_PORTAL_FRAME );
+        replace( Blocks.WOOD_DOUBLE_STEP, Blocks.WOOD_STEP );
+        replace( Blocks.COCOA, Items.SEEDS );
+        replace( Blocks.CARROTS, Items.CARROT );
+        replace( Blocks.POTATOES, Items.POTATO );
+    }
+
+    public static int getItemId(int id)
+    {
+        return invalidItems.containsKey( id ) ? invalidItems.get( id ) : id;
+    }
+
+    private static void replace(Block block, Block other) {
+        replace( Block.getId( block ), Block.getId( other ) );
+    }
+
+    private static void replace(Block block, Item other) {
+        replace( Block.getId( block ), Item.getId( other ) );
+    }
+
+    private static void replace(int block, int other) {
+        invalidItems.put( block, other );
+    }
+}
diff --git a/src/main/java/org/spigotmc/SpigotDecompressor.java b/src/main/java/org/spigotmc/SpigotDecompressor.java
new file mode 100644
index 0000000..ffebf5d
--- /dev/null
+++ b/src/main/java/org/spigotmc/SpigotDecompressor.java
@@ -0,0 +1,42 @@
+package org.spigotmc;
+
+import net.minecraft.server.PacketDataSerializer;
+import net.minecraft.util.io.netty.buffer.ByteBuf;
+import net.minecraft.util.io.netty.buffer.Unpooled;
+import net.minecraft.util.io.netty.channel.ChannelHandlerContext;
+import net.minecraft.util.io.netty.handler.codec.ByteToMessageDecoder;
+
+import java.util.List;
+import java.util.zip.Inflater;
+
+public class SpigotDecompressor extends ByteToMessageDecoder
+{
+
+    private final Inflater inflater = new Inflater();
+
+    @Override
+    protected void decode(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf, List<Object> objects) throws Exception
+    {
+        if ( byteBuf.readableBytes() == 0 )
+        {
+            return;
+        }
+
+        PacketDataSerializer serializer = new PacketDataSerializer( byteBuf );
+        int size = serializer.a();
+        if ( size == 0 )
+        {
+            objects.add( serializer.readBytes( serializer.readableBytes() ) );
+        } else
+        {
+            byte[] compressedData = new byte[ serializer.readableBytes() ];
+            serializer.readBytes( compressedData );
+            inflater.setInput( compressedData );
+
+            byte[] data = new byte[ size ];
+            inflater.inflate( data );
+            objects.add( Unpooled.wrappedBuffer( data ) );
+            inflater.reset();
+        }
+    }
+}
diff --git a/src/main/java/org/spigotmc/SpigotWorldConfig.java b/src/main/java/org/spigotmc/SpigotWorldConfig.java
new file mode 100644
index 0000000..854ba6d
--- /dev/null
+++ b/src/main/java/org/spigotmc/SpigotWorldConfig.java
@@ -0,0 +1,358 @@
+package org.spigotmc;
+
+import java.util.Arrays;
+import java.util.List;
+import org.bukkit.Bukkit;
+import org.bukkit.configuration.file.YamlConfiguration;
+
+public class SpigotWorldConfig
+{
+
+    private final String worldName;
+    private final YamlConfiguration config;
+    private boolean verbose;
+
+    public SpigotWorldConfig(String worldName)
+    {
+        this.worldName = worldName;
+        this.config = SpigotConfig.config;
+        init();
+    }
+
+    public void init()
+    {
+        this.verbose = getBoolean( "verbose", true );
+
+        log( "-------- World Settings For [" + worldName + "] --------" );
+        SpigotConfig.readConfig( SpigotWorldConfig.class, this );
+    }
+
+    private void log(String s)
+    {
+        if ( verbose )
+        {
+            Bukkit.getLogger().info( s );
+        }
+    }
+
+    private void set(String path, Object val)
+    {
+        config.set( "world-settings.default." + path, val );
+    }
+
+    private boolean getBoolean(String path, boolean def)
+    {
+        config.addDefault( "world-settings.default." + path, def );
+        return config.getBoolean( "world-settings." + worldName + "." + path, config.getBoolean( "world-settings.default." + path ) );
+    }
+
+    private double getDouble(String path, double def)
+    {
+        config.addDefault( "world-settings.default." + path, def );
+        return config.getDouble( "world-settings." + worldName + "." + path, config.getDouble( "world-settings.default." + path ) );
+    }
+
+    private int getInt(String path, int def)
+    {
+        config.addDefault( "world-settings.default." + path, def );
+        return config.getInt( "world-settings." + worldName + "." + path, config.getInt( "world-settings.default." + path ) );
+    }
+
+    private <T> List getList(String path, T def)
+    {
+        config.addDefault( "world-settings.default." + path, def );
+        return (List<T>) config.getList( "world-settings." + worldName + "." + path, config.getList( "world-settings.default." + path ) );
+    }
+
+    private String getString(String path, String def)
+    {
+        config.addDefault( "world-settings.default." + path, def );
+        return config.getString( "world-settings." + worldName + "." + path, config.getString( "world-settings.default." + path ) );
+    }
+
+    public int chunksPerTick;
+    public boolean clearChunksOnTick;
+    private void chunksPerTick()
+    {
+        chunksPerTick = getInt( "chunks-per-tick", 650 );
+        log( "Chunks to Grow per Tick: " + chunksPerTick );
+
+        clearChunksOnTick = getBoolean( "clear-tick-list", false );
+        log( "Clear tick list: " + clearChunksOnTick );
+    }
+
+    // Crop growth rates
+    public int cactusModifier;
+    public int caneModifier;
+    public int melonModifier;
+    public int mushroomModifier;
+    public int pumpkinModifier;
+    public int saplingModifier;
+    public int wheatModifier;
+    private int getAndValidateGrowth(String crop)
+    {
+        int modifier = getInt( "growth." + crop.toLowerCase() + "-modifier", 100 );
+        if ( modifier == 0 )
+        {
+            log( "Cannot set " + crop + " growth to zero, defaulting to 100" );
+            modifier = 100;
+        }
+        log( crop + " Growth Modifier: " + modifier + "%" );
+
+        return modifier;
+    }
+    private void growthModifiers()
+    {
+        cactusModifier = getAndValidateGrowth( "Cactus" );
+        caneModifier = getAndValidateGrowth( "Cane" );
+        melonModifier = getAndValidateGrowth( "Melon" );
+        mushroomModifier = getAndValidateGrowth( "Mushroom" );
+        pumpkinModifier = getAndValidateGrowth( "Pumpkin" );
+        saplingModifier = getAndValidateGrowth( "Sapling" );
+        wheatModifier = getAndValidateGrowth( "Wheat" );
+    }
+
+    public double itemMerge;
+    private void itemMerge()
+    {
+        itemMerge = getDouble("merge-radius.item", 2.5 );
+        log( "Item Merge Radius: " + itemMerge );
+    }
+
+    public double expMerge;
+    private void expMerge()
+    {
+        expMerge = getDouble("merge-radius.exp", 3.0 );
+        log( "Experience Merge Radius: " + expMerge );
+    }
+
+    public int viewDistance;
+    private void viewDistance()
+    {
+        viewDistance = getInt( "view-distance", Bukkit.getViewDistance() );
+        log( "View Distance: " + viewDistance );
+    }
+
+    public byte mobSpawnRange;
+    private void mobSpawnRange()
+    {
+        mobSpawnRange = (byte) getInt( "mob-spawn-range", 4 );
+        log( "Mob Spawn Range: " + mobSpawnRange );
+    }
+
+    public int animalActivationRange = 32;
+    public int monsterActivationRange = 32;
+    public int miscActivationRange = 16;
+    private void activationRange()
+    {
+        animalActivationRange = getInt( "entity-activation-range.animals", animalActivationRange );
+        monsterActivationRange = getInt( "entity-activation-range.monsters", monsterActivationRange );
+        miscActivationRange = getInt( "entity-activation-range.misc", miscActivationRange );
+        log( "Entity Activation Range: An " + animalActivationRange + " / Mo " + monsterActivationRange + " / Mi " + miscActivationRange );
+    }
+
+    public int playerTrackingRange = 48;
+    public int animalTrackingRange = 48;
+    public int monsterTrackingRange = 48;
+    public int miscTrackingRange = 32;
+    public int otherTrackingRange = 64;
+    private void trackingRange()
+    {
+        playerTrackingRange = getInt( "entity-tracking-range.players", playerTrackingRange );
+        animalTrackingRange = getInt( "entity-tracking-range.animals", animalTrackingRange );
+        monsterTrackingRange = getInt( "entity-tracking-range.monsters", monsterTrackingRange );
+        miscTrackingRange = getInt( "entity-tracking-range.misc", miscTrackingRange );
+        otherTrackingRange = getInt( "entity-tracking-range.other", otherTrackingRange );
+        log( "Entity Tracking Range: Pl " + playerTrackingRange + " / An " + animalTrackingRange + " / Mo " + monsterTrackingRange + " / Mi " + miscTrackingRange + " / Other " + otherTrackingRange );
+    }
+
+    public boolean altHopperTicking;
+    public int hopperTransfer;
+    public int hopperCheck;
+    public int hopperAmount;
+    private void hoppers()
+    {
+        // Alternate ticking method. Uses inventory changes, redstone updates etc.
+        // to update hoppers. Hopper-check is disabled when this is true.
+        boolean prev = altHopperTicking;
+        altHopperTicking = getBoolean( "hopper-alt-ticking", false );
+        // Necessary for the reload command
+        if (prev != altHopperTicking) {
+            net.minecraft.server.World world = (net.minecraft.server.World) Bukkit.getWorld(this.worldName);
+            if (world != null) {
+                if (altHopperTicking) {
+                    for (Object o : world.tileEntityList) {
+                        if (o instanceof net.minecraft.server.TileEntityHopper) {
+                            ((net.minecraft.server.TileEntityHopper) o).convertToScheduling();
+                        }
+                    }
+                } else {
+                    for (Object o : world.tileEntityList) {
+                        if (o instanceof net.minecraft.server.TileEntityHopper) {
+                            ((net.minecraft.server.TileEntityHopper) o).convertToPolling();
+                        }
+                    }
+                }
+            }
+        }
+        // Set the tick delay between hopper item movements
+        hopperTransfer = getInt( "ticks-per.hopper-transfer", 8 );
+        // Set the tick delay between checking for items after the associated
+        // container is empty. Default to the hopperTransfer value to prevent
+        // hopper sorting machines from becoming out of sync.
+        hopperCheck = getInt( "ticks-per.hopper-check", hopperTransfer );
+        hopperAmount = getInt( "hopper-amount", 1 );
+        log( "Alternative Hopper Ticking: " + altHopperTicking );
+        log( "Hopper Transfer: " + hopperTransfer + " Hopper Check: " + hopperCheck + " Hopper Amount: " + hopperAmount );
+    }
+
+    public boolean randomLightUpdates;
+    private void lightUpdates()
+    {
+        randomLightUpdates = getBoolean( "random-light-updates", false );
+        log( "Random Lighting Updates: " + randomLightUpdates );
+    }
+
+    public boolean saveStructureInfo;
+    private void structureInfo()
+    {
+        saveStructureInfo = getBoolean( "save-structure-info", true );
+        log( "Structure Info Saving: " + saveStructureInfo );
+        if ( !saveStructureInfo )
+        {
+            log( "*** WARNING *** You have selected to NOT save structure info. This may cause structures such as fortresses to not spawn mobs when updating to 1.7!" );
+            log( "*** WARNING *** Please use this option with caution, SpigotMC is not responsible for any issues this option may cause in the future!" );
+        }
+    }
+
+    public int itemDespawnRate;
+    private void itemDespawnRate()
+    {
+        itemDespawnRate = getInt( "item-despawn-rate", 6000 );
+        log( "Item Despawn Rate: " + itemDespawnRate );
+    }
+
+    public int arrowDespawnRate;
+    private void arrowDespawnRate()
+    {
+        arrowDespawnRate = getInt( "arrow-despawn-rate", 1200  );
+        log( "Arrow Despawn Rate: " + arrowDespawnRate );
+    }
+    
+    public boolean antiXray;
+    public int engineMode;
+    public List<Integer> hiddenBlocks;
+    public List<Integer> replaceBlocks;
+    public AntiXray antiXrayInstance;
+    private void antiXray()
+    {
+        antiXray = getBoolean( "anti-xray.enabled", true );
+        log( "Anti X-Ray: " + antiXray );
+
+        engineMode = getInt( "anti-xray.engine-mode", 1 );
+        log( "\tEngine Mode: " + engineMode );
+
+        if ( SpigotConfig.version < 5 )
+        {
+            set( "anti-xray.blocks", null );
+        }
+        hiddenBlocks = getList( "anti-xray.hide-blocks", Arrays.asList( new Integer[]
+        {
+            14, 15, 16, 21, 48, 49, 54, 56, 73, 74, 82, 129, 130
+        } ) );
+        log( "\tHidden Blocks: " + hiddenBlocks );
+
+        replaceBlocks = getList( "anti-xray.replace-blocks", Arrays.asList( new Integer[]
+        {
+            1, 5
+        } ) );
+        log( "\tReplace Blocks: " + replaceBlocks );
+
+        antiXrayInstance = new AntiXray( this );
+    }
+
+    public boolean zombieAggressiveTowardsVillager;
+    private void zombieAggressiveTowardsVillager()
+    {
+        zombieAggressiveTowardsVillager = getBoolean( "zombie-aggressive-towards-villager", true );
+        log( "Zombie Aggressive Towards Villager: " + zombieAggressiveTowardsVillager );
+    }
+
+    public boolean nerfSpawnerMobs;
+    private void nerfSpawnerMobs()
+    {
+        nerfSpawnerMobs = getBoolean( "nerf-spawner-mobs", false );
+        log( "Nerfing mobs spawned from spawners: " + nerfSpawnerMobs );
+    }
+
+    public boolean enableZombiePigmenPortalSpawns;
+    private void enableZombiePigmenPortalSpawns()
+    {
+        enableZombiePigmenPortalSpawns = getBoolean( "enable-zombie-pigmen-portal-spawns", true );
+        log( "Allow Zombie Pigmen to spawn from portal blocks: " + enableZombiePigmenPortalSpawns );
+    }
+
+    public int maxBulkChunk;
+    private void bulkChunkCount()
+    {
+        maxBulkChunk = getInt( "max-bulk-chunks", 5 );
+        log( "Sending up to " + maxBulkChunk + " chunks per packet" );
+    }
+
+    public int maxCollisionsPerEntity;
+    private void maxEntityCollision()
+    {
+        maxCollisionsPerEntity = getInt( "max-entity-collisions", 8 );
+        log( "Max Entity Collisions: " + maxCollisionsPerEntity );
+    }
+
+    public int dragonDeathSoundRadius;
+    private void keepDragonDeathPerWorld()
+    {
+        dragonDeathSoundRadius = getInt( "dragon-death-sound-radius", 0 );
+    }
+
+    public int witherSpawnSoundRadius;
+    private void witherSpawnSoundRadius()
+    {
+        witherSpawnSoundRadius = getInt( "wither-spawn-sound-radius", 0 );
+    }
+
+    public int villageSeed;
+    public int largeFeatureSeed;
+    private void initWorldGenSeeds()
+    {
+        villageSeed = getInt( "seed-village", 10387312 );
+        largeFeatureSeed = getInt( "seed-feature", 14357617 );
+        log( "Custom Map Seeds:  Village: " + villageSeed + " Feature: " + largeFeatureSeed );
+    }
+
+    public float walkExhaustion;
+    public float sprintExhaustion;
+    public float combatExhaustion;
+    public float regenExhaustion;
+    private void initHunger()
+    {
+        walkExhaustion = (float) getDouble( "hunger.walk-exhaustion", 0.2 );
+        sprintExhaustion = (float) getDouble( "hunger.sprint-exhaustion", 0.8 );
+        combatExhaustion = (float) getDouble( "hunger.combat-exhaustion", 0.3 );
+        regenExhaustion = (float) getDouble( "hunger.regen-exhaustion", 3 );
+    }
+
+    public int currentPrimedTnt = 0;
+    public int maxTntTicksPerTick;
+    private void maxTntPerTick() {
+        if ( SpigotConfig.version < 7 )
+        {
+            set( "max-tnt-per-tick", 100 );
+        }
+        maxTntTicksPerTick = getInt( "max-tnt-per-tick", 100 );
+        log( "Max TNT Explosions: " + maxTntTicksPerTick );
+    }
+
+    public int hangingTickFrequency;
+    private void hangingTickFrequency()
+    {
+        hangingTickFrequency = getInt( "hanging-tick-frequency", 100 );
+    }
+}
diff --git a/src/main/java/org/spigotmc/TicksPerSecondCommand.java b/src/main/java/org/spigotmc/TicksPerSecondCommand.java
new file mode 100644
index 0000000..2b8343d
--- /dev/null
+++ b/src/main/java/org/spigotmc/TicksPerSecondCommand.java
@@ -0,0 +1,45 @@
+package org.spigotmc;
+
+import com.google.common.base.Joiner;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.util.com.google.common.collect.Iterables;
+import org.bukkit.ChatColor;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+
+public class TicksPerSecondCommand extends Command
+{
+
+    public TicksPerSecondCommand(String name)
+    {
+        super( name );
+        this.description = "Gets the current ticks per second for the server";
+        this.usageMessage = "/tps";
+        this.setPermission( "bukkit.command.tps" );
+    }
+
+    @Override
+    public boolean execute(CommandSender sender, String currentAlias, String[] args)
+    {
+        if ( !testPermission( sender ) )
+        {
+            return true;
+        }
+
+        StringBuilder sb = new StringBuilder( ChatColor.GOLD + "TPS from last 1m, 5m, 15m: " );
+        for ( double tps : MinecraftServer.getServer().recentTps )
+        {
+            sb.append( format( tps ) );
+            sb.append( ", " );
+        }
+        sender.sendMessage( sb.substring( 0, sb.length() - 2 ) );
+
+        return true;
+    }
+
+    private String format(double tps)
+    {
+        return ( ( tps > 18.0 ) ? ChatColor.GREEN : ( tps > 16.0 ) ? ChatColor.YELLOW : ChatColor.RED ).toString()
+                + ( ( tps > 20.0 ) ? "*" : "" ) + Math.min( Math.round( tps * 100.0 ) / 100.0, 20.0 );
+    }
+}
diff --git a/src/main/java/org/spigotmc/TrackingRange.java b/src/main/java/org/spigotmc/TrackingRange.java
new file mode 100644
index 0000000..4bf4d2a
--- /dev/null
+++ b/src/main/java/org/spigotmc/TrackingRange.java
@@ -0,0 +1,51 @@
+package org.spigotmc;
+
+import net.minecraft.server.Entity;
+import net.minecraft.server.EntityExperienceOrb;
+import net.minecraft.server.EntityGhast;
+import net.minecraft.server.EntityItem;
+import net.minecraft.server.EntityItemFrame;
+import net.minecraft.server.EntityPainting;
+import net.minecraft.server.EntityPlayer;
+
+public class TrackingRange
+{
+
+    /**
+     * Gets the range an entity should be 'tracked' by players and visible in
+     * the client.
+     *
+     * @param entity
+     * @param defaultRange Default range defined by Mojang
+     * @return
+     */
+    public static int getEntityTrackingRange(Entity entity, int defaultRange)
+    {
+        SpigotWorldConfig config = entity.world.spigotConfig;
+        if ( entity instanceof EntityPlayer )
+        {
+            return config.playerTrackingRange;
+        }  else if ( entity.activationType == 1 )
+        {
+            return config.monsterTrackingRange;
+        } else if ( entity instanceof EntityGhast )
+        {
+            if ( config.monsterTrackingRange > config.monsterActivationRange )
+            {
+                return config.monsterTrackingRange;
+            } else
+            {
+                return config.monsterActivationRange;
+            }
+        } else if ( entity.activationType == 2 )
+        {
+            return config.animalTrackingRange;
+        } else if ( entity instanceof EntityItemFrame || entity instanceof EntityPainting || entity instanceof EntityItem || entity instanceof EntityExperienceOrb )
+        {
+            return config.miscTrackingRange;
+        } else 
+        {
+            return config.otherTrackingRange;
+        }
+    }
+}
diff --git a/src/main/java/org/spigotmc/ValidateUtils.java b/src/main/java/org/spigotmc/ValidateUtils.java
new file mode 100644
index 0000000..58a9534
--- /dev/null
+++ b/src/main/java/org/spigotmc/ValidateUtils.java
@@ -0,0 +1,14 @@
+package org.spigotmc;
+
+public class ValidateUtils
+{
+
+    public static String limit(String str, int limit)
+    {
+        if ( str.length() > limit )
+        {
+            return str.substring( 0, limit );
+        }
+        return str;
+    }
+}
diff --git a/src/main/java/org/spigotmc/WatchdogThread.java b/src/main/java/org/spigotmc/WatchdogThread.java
new file mode 100644
index 0000000..94a3d42
--- /dev/null
+++ b/src/main/java/org/spigotmc/WatchdogThread.java
@@ -0,0 +1,124 @@
+package org.spigotmc;
+
+import java.lang.management.ManagementFactory;
+import java.lang.management.MonitorInfo;
+import java.lang.management.ThreadInfo;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+import net.minecraft.server.MinecraftServer;
+import org.bukkit.Bukkit;
+
+public class WatchdogThread extends Thread
+{
+
+    private static WatchdogThread instance;
+    private final long timeoutTime;
+    private final boolean restart;
+    private volatile long lastTick;
+    private volatile boolean stopping;
+
+    private WatchdogThread(long timeoutTime, boolean restart)
+    {
+        super( "Spigot Watchdog Thread" );
+        this.timeoutTime = timeoutTime;
+        this.restart = restart;
+    }
+
+    public static void doStart(int timeoutTime, boolean restart)
+    {
+        if ( instance == null )
+        {
+            instance = new WatchdogThread( timeoutTime * 1000L, restart );
+            instance.start();
+        }
+    }
+
+    public static void tick()
+    {
+        instance.lastTick = System.currentTimeMillis();
+    }
+
+    public static void doStop()
+    {
+        if ( instance != null )
+        {
+            instance.stopping = true;
+        }
+    }
+
+    @Override
+    public void run()
+    {
+        while ( !stopping )
+        {
+            //
+            if ( lastTick != 0 && System.currentTimeMillis() > lastTick + timeoutTime )
+            {
+                Logger log = Bukkit.getServer().getLogger();
+                log.log( Level.SEVERE, "The server has stopped responding!" );
+                log.log( Level.SEVERE, "Please report this to http://www.spigotmc.org/" );
+                log.log( Level.SEVERE, "Be sure to include ALL relevant console errors and Minecraft crash reports" );
+                log.log( Level.SEVERE, "Spigot version: " + Bukkit.getServer().getVersion() );
+                //
+                if(net.minecraft.server.World.haveWeSilencedAPhysicsCrash)
+                {
+                    log.log( Level.SEVERE, "------------------------------" );
+                    log.log( Level.SEVERE, "During the run of the server, a physics stackoverflow was supressed" );
+                    log.log( Level.SEVERE, "near " + net.minecraft.server.World.blockLocation);
+                }
+                //
+                log.log( Level.SEVERE, "------------------------------" );
+                log.log( Level.SEVERE, "Server thread dump (Look for plugins here before reporting to Spigot!):" );
+                dumpThread( ManagementFactory.getThreadMXBean().getThreadInfo( MinecraftServer.getServer().primaryThread.getId(), Integer.MAX_VALUE ), log );
+                log.log( Level.SEVERE, "------------------------------" );
+                //
+                log.log( Level.SEVERE, "Entire Thread Dump:" );
+                ThreadInfo[] threads = ManagementFactory.getThreadMXBean().dumpAllThreads( true, true );
+                for ( ThreadInfo thread : threads )
+                {
+                    dumpThread( thread, log );
+                }
+                log.log( Level.SEVERE, "------------------------------" );
+
+                if ( restart )
+                {
+                    RestartCommand.restart();
+                }
+                break;
+            }
+
+            try
+            {
+                sleep( 10000 );
+            } catch ( InterruptedException ex )
+            {
+                interrupt();
+            }
+        }
+    }
+
+    private static void dumpThread(ThreadInfo thread, Logger log)
+    {
+        log.log( Level.SEVERE, "------------------------------" );
+        //
+        log.log( Level.SEVERE, "Current Thread: " + thread.getThreadName() );
+        log.log( Level.SEVERE, "\tPID: " + thread.getThreadId()
+                + " | Suspended: " + thread.isSuspended()
+                + " | Native: " + thread.isInNative()
+                + " | State: " + thread.getThreadState() );
+        if ( thread.getLockedMonitors().length != 0 )
+        {
+            log.log( Level.SEVERE, "\tThread is waiting on monitor(s):" );
+            for ( MonitorInfo monitor : thread.getLockedMonitors() )
+            {
+                log.log( Level.SEVERE, "\t\tLocked on:" + monitor.getLockedStackFrame() );
+            }
+        }
+        log.log( Level.SEVERE, "\tStack:" );
+        //
+        for ( StackTraceElement stack : thread.getStackTrace() )
+        {
+            log.log( Level.SEVERE, "\t\t" + stack );
+        }
+    }
+}
diff --git a/src/main/resources/blocks.json b/src/main/resources/blocks.json
new file mode 100644
index 0000000..8dd484d
--- /dev/null
+++ b/src/main/resources/blocks.json
@@ -0,0 +1 @@
+["0:0","1:0","1:1","1:2","1:3","1:4","1:5","1:6","2:0","3:0","3:1","3:2","4:0","5:0","5:1","5:2","5:3","5:4","5:5","6:0","6:1","6:2","6:3","6:4","6:5","6:8","6:9","6:10","6:11","6:12","6:13","7:0","8:0","8:1","8:2","8:3","8:4","8:5","8:6","8:7","8:8","8:9","8:10","8:11","8:12","8:13","8:14","8:15","9:0","9:1","9:2","9:3","9:4","9:5","9:6","9:7","9:8","9:9","9:10","9:11","9:12","9:13","9:14","9:15","10:0","10:1","10:2","10:3","10:4","10:5","10:6","10:7","10:8","10:9","10:10","10:11","10:12","10:13","10:14","10:15","11:0","11:1","11:2","11:3","11:4","11:5","11:6","11:7","11:8","11:9","11:10","11:11","11:12","11:13","11:14","11:15","12:0","12:1","13:0","14:0","15:0","16:0","17:0","17:1","17:2","17:3","17:4","17:5","17:6","17:7","17:8","17:9","17:10","17:11","17:12","17:13","17:14","17:15","18:0","18:1","18:2","18:3","18:4","18:5","18:6","18:7","18:8","18:9","18:10","18:11","18:12","18:13","18:14","18:15","19:0","19:1","20:0","21:0","22:0","23:0","23:1","23:2","23:3","23:4","23:5","23:8","23:9","23:10","23:11","23:12","23:13","24:0","24:1","24:2","25:0","26:0","26:1","26:2","26:3","26:8","26:9","26:10","26:11","26:12","26:13","26:14","26:15","27:0","27:1","27:2","27:3","27:4","27:5","27:8","27:9","27:10","27:11","27:12","27:13","28:0","28:1","28:2","28:3","28:4","28:5","28:8","28:9","28:10","28:11","28:12","28:13","29:0","29:1","29:2","29:3","29:4","29:5","29:8","29:9","29:10","29:11","29:12","29:13","30:0","31:0","31:1","31:2","32:0","33:0","33:1","33:2","33:3","33:4","33:5","33:8","33:9","33:10","33:11","33:12","33:13","34:0","34:1","34:2","34:3","34:4","34:5","34:8","34:9","34:10","34:11","34:12","34:13","35:0","35:1","35:2","35:3","35:4","35:5","35:6","35:7","35:8","35:9","35:10","35:11","35:12","35:13","35:14","35:15","36:0","36:1","36:2","36:3","36:4","36:5","36:8","36:9","36:10","36:11","36:12","36:13","37:0","38:0","38:1","38:2","38:3","38:4","38:5","38:6","38:7","38:8","39:0","40:0","41:0","42:0","43:0","43:1","43:2","43:3","43:4","43:5","43:6","43:7","43:8","43:9","43:10","43:11","43:12","43:13","43:14","43:15","44:0","44:1","44:2","44:3","44:4","44:5","44:6","44:7","44:8","44:9","44:10","44:11","44:12","44:13","44:14","44:15","45:0","46:0","46:1","47:0","48:0","49:0","50:1","50:2","50:3","50:4","50:5","51:0","51:1","51:2","51:3","51:4","51:5","51:6","51:7","51:8","51:9","51:10","51:11","51:12","51:13","51:14","51:15","52:0","53:0","53:1","53:2","53:3","53:4","53:5","53:6","53:7","54:2","54:3","54:4","54:5","55:0","55:1","55:2","55:3","55:4","55:5","55:6","55:7","55:8","55:9","55:10","55:11","55:12","55:13","55:14","55:15","56:0","57:0","58:0","59:0","59:1","59:2","59:3","59:4","59:5","59:6","59:7","60:0","60:1","60:2","60:3","60:4","60:5","60:6","60:7","61:2","61:3","61:4","61:5","62:2","62:3","62:4","62:5","63:0","63:1","63:2","63:3","63:4","63:5","63:6","63:7","63:8","63:9","63:10","63:11","63:12","63:13","63:14","63:15","64:0","64:1","64:2","64:3","64:4","64:5","64:6","64:7","64:8","64:9","64:10","64:11","65:2","65:3","65:4","65:5","66:0","66:1","66:2","66:3","66:4","66:5","66:6","66:7","66:8","66:9","67:0","67:1","67:2","67:3","67:4","67:5","67:6","67:7","68:2","68:3","68:4","68:5","69:0","69:1","69:2","69:3","69:4","69:5","69:6","69:7","69:8","69:9","69:10","69:11","69:12","69:13","69:14","69:15","70:0","70:1","71:0","71:1","71:2","71:3","71:4","71:5","71:6","71:7","71:8","71:9","71:10","71:11","72:0","72:1","73:0","74:0","75:1","75:2","75:3","75:4","75:5","76:1","76:2","76:3","76:4","76:5","77:0","77:1","77:2","77:3","77:4","77:5","77:8","77:9","77:10","77:11","77:12","77:13","78:0","78:1","78:2","78:3","78:4","78:5","78:6","78:7","79:0","80:0","81:0","81:1","81:2","81:3","81:4","81:5","81:6","81:7","81:8","81:9","81:10","81:11","81:12","81:13","81:14","81:15","82:0","83:0","83:1","83:2","83:3","83:4","83:5","83:6","83:7","83:8","83:9","83:10","83:11","83:12","83:13","83:14","83:15","84:0","84:1","85:0","86:0","86:1","86:2","86:3","87:0","88:0","89:0","90:1","90:2","91:0","91:1","91:2","91:3","92:0","92:1","92:2","92:3","92:4","92:5","92:6","93:0","93:1","93:2","93:3","93:4","93:5","93:6","93:7","93:8","93:9","93:10","93:11","93:12","93:13","93:14","93:15","94:0","94:1","94:2","94:3","94:4","94:5","94:6","94:7","94:8","94:9","94:10","94:11","94:12","94:13","94:14","94:15","95:0","95:1","95:2","95:3","95:4","95:5","95:6","95:7","95:8","95:9","95:10","95:11","95:12","95:13","95:14","95:15","96:0","96:1","96:2","96:3","96:4","96:5","96:6","96:7","96:8","96:9","96:10","96:11","96:12","96:13","96:14","96:15","97:0","97:1","97:2","97:3","97:4","97:5","98:0","98:1","98:2","98:3","99:0","99:1","99:2","99:3","99:4","99:5","99:6","99:7","99:8","99:9","99:10","99:14","99:15","100:0","100:1","100:2","100:3","100:4","100:5","100:6","100:7","100:8","100:9","100:10","100:14","100:15","101:0","102:0","103:0","104:0","104:1","104:2","104:3","104:4","104:5","104:6","104:7","105:0","105:1","105:2","105:3","105:4","105:5","105:6","105:7","106:0","106:1","106:2","106:3","106:4","106:5","106:6","106:7","106:8","106:9","106:10","106:11","106:12","106:13","106:14","106:15","107:0","107:1","107:2","107:3","107:4","107:5","107:6","107:7","107:8","107:9","107:10","107:11","107:12","107:13","107:14","107:15","108:0","108:1","108:2","108:3","108:4","108:5","108:6","108:7","109:0","109:1","109:2","109:3","109:4","109:5","109:6","109:7","110:0","111:0","112:0","113:0","114:0","114:1","114:2","114:3","114:4","114:5","114:6","114:7","115:0","115:1","115:2","115:3","116:0","117:0","117:1","117:2","117:3","117:4","117:5","117:6","117:7","118:0","118:1","118:2","118:3","119:0","120:0","120:1","120:2","120:3","120:4","120:5","120:6","120:7","121:0","122:0","123:0","124:0","125:0","125:1","125:2","125:3","125:4","125:5","126:0","126:1","126:2","126:3","126:4","126:5","126:8","126:9","126:10","126:11","126:12","126:13","127:0","127:1","127:2","127:3","127:4","127:5","127:6","127:7","127:8","127:9","127:10","127:11","128:0","128:1","128:2","128:3","128:4","128:5","128:6","128:7","129:0","130:2","130:3","130:4","130:5","131:0","131:1","131:2","131:3","131:4","131:5","131:6","131:7","131:8","131:9","131:10","131:11","131:12","131:13","131:14","131:15","132:0","132:1","132:2","132:3","132:4","132:5","132:6","132:7","132:8","132:9","132:10","132:11","132:12","132:13","132:14","132:15","133:0","134:0","134:1","134:2","134:3","134:4","134:5","134:6","134:7","135:0","135:1","135:2","135:3","135:4","135:5","135:6","135:7","136:0","136:1","136:2","136:3","136:4","136:5","136:6","136:7","137:0","137:1","138:0","139:0","139:1","140:0","140:1","140:2","140:3","140:4","140:5","140:6","140:7","140:8","140:9","140:10","140:11","140:12","140:13","140:14","140:15","141:0","141:1","141:2","141:3","141:4","141:5","141:6","141:7","142:0","142:1","142:2","142:3","142:4","142:5","142:6","142:7","143:0","143:1","143:2","143:3","143:4","143:5","143:8","143:9","143:10","143:11","143:12","143:13","144:0","144:1","144:2","144:3","144:4","144:5","144:8","144:9","144:10","144:11","144:12","144:13","145:0","145:1","145:2","145:3","145:4","145:5","145:6","145:7","145:8","145:9","145:10","145:11","146:2","146:3","146:4","146:5","147:0","147:1","147:2","147:3","147:4","147:5","147:6","147:7","147:8","147:9","147:10","147:11","147:12","147:13","147:14","147:15","148:0","148:1","148:2","148:3","148:4","148:5","148:6","148:7","148:8","148:9","148:10","148:11","148:12","148:13","148:14","148:15","149:0","149:1","149:2","149:3","149:4","149:5","149:6","149:7","149:8","149:9","149:10","149:11","149:12","149:13","149:14","149:15","150:0","150:1","150:2","150:3","150:4","150:5","150:6","150:7","150:8","150:9","150:10","150:11","150:12","150:13","150:14","150:15","151:0","151:1","151:2","151:3","151:4","151:5","151:6","151:7","151:8","151:9","151:10","151:11","151:12","151:13","151:14","151:15","152:0","153:0","154:0","154:2","154:3","154:4","154:5","154:8","154:10","154:11","154:12","154:13","155:0","155:1","155:2","155:3","155:4","156:0","156:1","156:2","156:3","156:4","156:5","156:6","156:7","157:0","157:1","157:2","157:3","157:4","157:5","157:8","157:9","157:10","157:11","157:12","157:13","158:0","158:1","158:2","158:3","158:4","158:5","158:8","158:9","158:10","158:11","158:12","158:13","159:0","159:1","159:2","159:3","159:4","159:5","159:6","159:7","159:8","159:9","159:10","159:11","159:12","159:13","159:14","159:15","160:0","160:1","160:2","160:3","160:4","160:5","160:6","160:7","160:8","160:9","160:10","160:11","160:12","160:13","160:14","160:15","161:0","161:1","161:4","161:5","161:8","161:9","161:12","161:13","162:0","162:1","162:4","162:5","162:8","162:9","162:12","162:13","163:0","163:1","163:2","163:3","163:4","163:5","163:6","163:7","164:0","164:1","164:2","164:3","164:4","164:5","164:6","164:7","165:0","166:0","167:0","167:1","167:2","167:3","167:4","167:5","167:6","167:7","167:8","167:9","167:10","167:11","167:12","167:13","167:14","167:15","168:0","168:1","168:2","169:0","170:0","170:4","170:8","171:0","171:1","171:2","171:3","171:4","171:5","171:6","171:7","171:8","171:9","171:10","171:11","171:12","171:13","171:14","171:15","172:0","173:0","174:0","175:0","175:1","175:2","175:3","175:4","175:5","175:8","176:0","176:1","176:2","176:3","176:4","176:5","176:6","176:7","176:8","176:9","176:10","176:11","176:12","176:13","176:14","176:15","177:2","177:3","177:4","177:5","178:0","178:1","178:2","178:3","178:4","178:5","178:6","178:7","178:8","178:9","178:10","178:11","178:12","178:13","178:14","178:15","179:0","179:1","179:2","180:0","180:1","180:2","180:3","180:4","180:5","180:6","180:7","181:0","181:8","182:0","182:8","183:0","183:1","183:2","183:3","183:4","183:5","183:6","183:7","183:8","183:9","183:10","183:11","183:12","183:13","183:14","183:15","184:0","184:1","184:2","184:3","184:4","184:5","184:6","184:7","184:8","184:9","184:10","184:11","184:12","184:13","184:14","184:15","185:0","185:1","185:2","185:3","185:4","185:5","185:6","185:7","185:8","185:9","185:10","185:11","185:12","185:13","185:14","185:15","186:0","186:1","186:2","186:3","186:4","186:5","186:6","186:7","186:8","186:9","186:10","186:11","186:12","186:13","186:14","186:15","187:0","187:1","187:2","187:3","187:4","187:5","187:6","187:7","187:8","187:9","187:10","187:11","187:12","187:13","187:14","187:15","188:0","189:0","190:0","191:0","192:0","193:0","193:1","193:2","193:3","193:4","193:5","193:6","193:7","193:8","193:9","193:10","193:11","194:0","194:1","194:2","194:3","194:4","194:5","194:6","194:7","194:8","194:9","194:10","194:11","195:0","195:1","195:2","195:3","195:4","195:5","195:6","195:7","195:8","195:9","195:10","195:11","196:0","196:1","196:2","196:3","196:4","196:5","196:6","196:7","196:8","196:9","196:10","196:11","197:0","197:1","197:2","197:3","197:4","197:5","197:6","197:7","197:8","197:9","197:10","197:11"]
diff --git a/src/main/resources/configurations/bukkit.yml b/src/main/resources/configurations/bukkit.yml
index 129ac34..751bbfc 100644
--- a/src/main/resources/configurations/bukkit.yml
+++ b/src/main/resources/configurations/bukkit.yml
@@ -6,11 +6,10 @@
 # If you need help on this file, feel free to join us on irc or leave a message
 # on the forums asking for advice.
 # 
-# IRC: #bukkit @ esper.net
-#    (If this means nothing to you, just go to http://webchat.esper.net/?channels=bukkit )
-# Forums: http://forums.bukkit.org/forums/bukkit-help.6/
-# Twitter: http://twitter.com/CraftBukkit
-# Bug tracker: http://leaky.bukkit.org/
+# IRC: #spigot @ irc.spi.gt
+#    (If this means nothing to you, just go to http://irc.spi.gt/iris/?nick=&channels=spigot )
+# Forums: http://www.spigotmc.org/forums/help.40/
+# Bug tracker: http://www.spigotmc.org/forums/bugs-feature-requests.8/
 
 
 settings:
diff --git a/src/main/resources/configurations/commands.yml b/src/main/resources/configurations/commands.yml
index 0a5d414..d6bcf5c 100644
--- a/src/main/resources/configurations/commands.yml
+++ b/src/main/resources/configurations/commands.yml
@@ -5,11 +5,10 @@
 # If you need help on this file, feel free to join us on irc or leave a message
 # on the forums asking for advice.
 # 
-# IRC: #bukkit @ esper.net
-#    (If this means nothing to you, just go to http://webchat.esper.net/?channels=bukkit )
-# Forums: http://forums.bukkit.org/forums/bukkit-help.6/
-# Twitter: http://twitter.com/CraftBukkit
-# Bug tracker: http://leaky.bukkit.org/
+# IRC: #spigot @ irc.spi.gt
+#    (If this means nothing to you, just go to http://irc.spi.gt/iris/?nick=&channels=spigot )
+# Forums: http://www.spigotmc.org/forums/help.40/
+# Bug tracker: http://www.spigotmc.org/forums/bugs-feature-requests.8/
 
 command-block-overrides: []
 aliases:
diff --git a/src/main/resources/log4j2.xml b/src/main/resources/log4j2.xml
index 36eff85..65c09a8 100644
--- a/src/main/resources/log4j2.xml
+++ b/src/main/resources/log4j2.xml
@@ -1,5 +1,5 @@
 <?xml version="1.0" encoding="UTF-8"?>
-<Configuration status="WARN" packages="net.minecraft,com.mojang">
+<Configuration status="WARN" packages="net.minecraft.util.com.mojang.util">
     <Appenders>
         <Console name="WINDOWS_COMPAT" target="SYSTEM_OUT"></Console>
         <Queue name="TerminalConsole">
@@ -18,9 +18,9 @@
             <filters>
                 <MarkerFilter marker="NETWORK_PACKETS" onMatch="DENY" onMismatch="NEUTRAL" />
             </filters>
-            <AppenderRef ref="WINDOWS_COMPAT"/>
+            <AppenderRef ref="WINDOWS_COMPAT" level="info"/>
             <AppenderRef ref="File"/>
-            <AppenderRef ref="TerminalConsole"/>
+            <AppenderRef ref="TerminalConsole" level="info"/>
         </Root>
     </Loggers>
 </Configuration>
diff --git a/src/main/resources/org/spigotmc/SneakyThrow.class b/src/main/resources/org/spigotmc/SneakyThrow.class
new file mode 100644
index 0000000000000000000000000000000000000000..635518693adaeee6f771d2a4c9f92672048a4c4d
GIT binary patch
literal 184
zcmX^0Z`VEsW(HjbE=C64;Jnnt?8=agqWp5bEOrKVMh1bb#Ii*FoW#6zegCAa)Z`LI
z2Cm@z(xT*4x6GVWMg|t={1hN1q2Ys22-csNl#^<$83vTfFG|-hF33#JFUd{TN3wyD
ufvp&9A3M-~MFu7YP6iNQ1kxM~Y(Sb7$m0Xjj6j-6Yd=U5$YufY7#IQ5^(s;T

literal 0
HcmV?d00001

-- 
1.9.1

