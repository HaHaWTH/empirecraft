From 9d7eb914086946b3f0e078a6b957307134be8f34 Mon Sep 17 00:00:00 2001
From: Aikar <aikar@aikar.co>
Date: Thu, 24 Jan 2013 21:01:32 -0500
Subject: [PATCH] Timings improvements

---
 .../net/minecraft/server/ChunkProviderServer.java  |   6 +-
 src/main/java/net/minecraft/server/Entity.java     |   5 +
 .../java/net/minecraft/server/EntityLiving.java    |  31 ++----
 .../java/net/minecraft/server/MinecraftServer.java |  17 +++-
 .../net/minecraft/server/PlayerConnection.java     |  12 +--
 src/main/java/net/minecraft/server/TileEntity.java |   2 +
 src/main/java/net/minecraft/server/World.java      |  20 ++--
 .../bukkit/craftbukkit/OrebfuscatorManager.java    |   2 +-
 .../java/org/bukkit/craftbukkit/SpigotTimings.java | 111 +++++++++++++++++++++
 .../bukkit/craftbukkit/scheduler/CraftTask.java    |  18 ++++
 .../java/org/bukkit/event/WorldTimingsHandler.java |  20 ----
 11 files changed, 184 insertions(+), 60 deletions(-)
 create mode 100644 src/main/java/org/bukkit/craftbukkit/SpigotTimings.java
 delete mode 100644 src/main/java/org/bukkit/event/WorldTimingsHandler.java

diff --git a/src/main/java/net/minecraft/server/ChunkProviderServer.java b/src/main/java/net/minecraft/server/ChunkProviderServer.java
index 279ba9e..5772932 100644
--- a/src/main/java/net/minecraft/server/ChunkProviderServer.java
+++ b/src/main/java/net/minecraft/server/ChunkProviderServer.java
@@ -15,7 +15,6 @@ import org.bukkit.craftbukkit.chunkio.ChunkIOExecutor;
 import org.bukkit.craftbukkit.util.LongHash;
 import org.bukkit.craftbukkit.util.LongHashSet;
 import org.bukkit.craftbukkit.util.LongObjectHashMap;
-import org.bukkit.event.CustomTimingsHandler;
 import org.bukkit.event.world.ChunkUnloadEvent;
 // CraftBukkit end
 
@@ -29,7 +28,6 @@ public class ChunkProviderServer implements IChunkProvider {
     public boolean forceChunkLoad = false; // true -> false
     public LongObjectHashMap<Chunk> chunks = new LongObjectHashMap<Chunk>();
     public WorldServer world;
-    static private CustomTimingsHandler syncChunkLoadTimer = new CustomTimingsHandler("syncChunkLoad"); // Spigot
     // CraftBukkit end
 
     public ChunkProviderServer(WorldServer worldserver, IChunkLoader ichunkloader, IChunkProvider ichunkprovider) {
@@ -105,7 +103,7 @@ public class ChunkProviderServer implements IChunkProvider {
         // CraftBukkit end
 
         if (chunk == null) {
-            syncChunkLoadTimer.startTiming(); // Spigot
+            org.bukkit.craftbukkit.SpigotTimings.syncChunkLoadTimer.startTiming(); // Spigot
             chunk = this.loadChunk(i, j);
             if (chunk == null) {
                 if (this.chunkProvider == null) {
@@ -144,7 +142,7 @@ public class ChunkProviderServer implements IChunkProvider {
             // CraftBukkit end
 
             chunk.a(this, this, i, j);
-            syncChunkLoadTimer.stopTiming(); // Spigot
+            org.bukkit.craftbukkit.SpigotTimings.syncChunkLoadTimer.stopTiming(); // Spigot
         }
 
         // CraftBukkit start - If we didn't need to load the chunk run the callback now
diff --git a/src/main/java/net/minecraft/server/Entity.java b/src/main/java/net/minecraft/server/Entity.java
index d0a58f8..bf9108a 100644
--- a/src/main/java/net/minecraft/server/Entity.java
+++ b/src/main/java/net/minecraft/server/Entity.java
@@ -15,6 +15,7 @@ import org.bukkit.block.BlockFace;
 import org.bukkit.entity.LivingEntity;
 import org.bukkit.entity.Painting;
 import org.bukkit.entity.Vehicle;
+import org.bukkit.CustomTimingsHandler; // Spigot
 import org.bukkit.event.entity.EntityCombustByEntityEvent;
 import org.bukkit.event.painting.PaintingBreakByEntityEvent;
 import org.bukkit.event.vehicle.VehicleBlockCollisionEvent;
@@ -111,6 +112,8 @@ public abstract class Entity {
     public UUID uniqueId = UUID.randomUUID(); // CraftBukkit
     public boolean valid = false; // CraftBukkit
 
+    public CustomTimingsHandler tickTimer = org.bukkit.craftbukkit.SpigotTimings.getEntityTimings(this); // Spigot
+
     public Entity(World world) {
         this.id = entityCount++;
         this.l = 1.0D;
@@ -424,6 +427,7 @@ public abstract class Entity {
 
     public void move(double d0, double d1, double d2) {
         if (d0 == 0 && d1 == 0 && d2 == 0) { return; } // Spigot
+        org.bukkit.craftbukkit.SpigotTimings.entityMoveTimer.startTiming(); // Spigot
         if (this.Y) {
             this.boundingBox.d(d0, d1, d2);
             this.locX = (this.boundingBox.a + this.boundingBox.d) / 2.0D;
@@ -729,6 +733,7 @@ public abstract class Entity {
 
             this.world.methodProfiler.b();
         }
+        org.bukkit.craftbukkit.SpigotTimings.entityMoveTimer.stopTiming(); // Spigot
     }
 
     protected void D() {
diff --git a/src/main/java/net/minecraft/server/EntityLiving.java b/src/main/java/net/minecraft/server/EntityLiving.java
index bbbb008..01b16ac 100644
--- a/src/main/java/net/minecraft/server/EntityLiving.java
+++ b/src/main/java/net/minecraft/server/EntityLiving.java
@@ -8,7 +8,6 @@ import java.util.Random;
 
 // CraftBukkit start
 import org.bukkit.craftbukkit.event.CraftEventFactory;
-import org.bukkit.event.CustomTimingsHandler;
 import org.bukkit.event.entity.EntityDamageByBlockEvent;
 import org.bukkit.event.entity.EntityDamageEvent;
 import org.bukkit.event.entity.EntityRegainHealthEvent;
@@ -111,14 +110,6 @@ public abstract class EntityLiving extends Entity {
     public int expToDrop = 0;
     public int maxAirTicks = 300;
     public int maxHealth = this.getMaxHealth();
-    // Spigot Start
-    public static CustomTimingsHandler timerEntityBaseTick = new CustomTimingsHandler("** entityBaseTick");
-    public static CustomTimingsHandler timerEntityAI = new CustomTimingsHandler("** entityAI");
-    public static CustomTimingsHandler timerEntityAIJump = new CustomTimingsHandler("** entityAIJump");
-    public static CustomTimingsHandler timerEntityAIMove = new CustomTimingsHandler("** entityAIMove");
-    public static CustomTimingsHandler timerEntityAILoot = new CustomTimingsHandler("** entityAILoot");
-    public static CustomTimingsHandler timerEntityTickRest = new CustomTimingsHandler("** entityTickRest");
-    // Spigot End
     // CraftBukkit end
 
     public EntityLiving(World world) {
@@ -514,7 +505,7 @@ public abstract class EntityLiving extends Entity {
     }
 
     public void j_() {
-        timerEntityBaseTick.startTiming(); // Spigot
+        org.bukkit.craftbukkit.SpigotTimings.timerEntityBaseTick.startTiming(); // Spigot
         super.j_();
         if (!this.world.isStatic) {
             int i;
@@ -541,9 +532,9 @@ public abstract class EntityLiving extends Entity {
             }
         }
 
-        timerEntityBaseTick.stopTiming(); // Spigot
+        org.bukkit.craftbukkit.SpigotTimings.timerEntityBaseTick.stopTiming(); // Spigot
         this.c();
-        timerEntityTickRest.startTiming(); // Spigot
+        org.bukkit.craftbukkit.SpigotTimings.timerEntityTickRest.startTiming(); // Spigot
         double d0 = this.locX - this.lastX;
         double d1 = this.locZ - this.lastZ;
         float f = (float) (d0 * d0 + d1 * d1);
@@ -634,7 +625,7 @@ public abstract class EntityLiving extends Entity {
 
         this.world.methodProfiler.b();
         this.aD += f2;
-        timerEntityTickRest.stopTiming(); // Spigot
+        org.bukkit.craftbukkit.SpigotTimings.timerEntityTickRest.stopTiming(); // Spigot
     }
 
     // CraftBukkit start - delegate so we can handle providing a reason for health being regained
@@ -1241,7 +1232,7 @@ public abstract class EntityLiving extends Entity {
     }
 
     public void c() {
-        timerEntityAI.startTiming(); // Spigot
+        org.bukkit.craftbukkit.SpigotTimings.timerEntityAI.startTiming(); // Spigot
         if (this.bV > 0) {
             --this.bV;
         }
@@ -1293,11 +1284,10 @@ public abstract class EntityLiving extends Entity {
                 this.az = this.yaw;
             }
         }
-        timerEntityAI.stopTiming(); // Spigot
+        org.bukkit.craftbukkit.SpigotTimings.timerEntityAI.stopTiming(); // Spigot
 
         this.world.methodProfiler.b();
         this.world.methodProfiler.a("jump");
-        timerEntityAIJump.startTiming(); // Spigot
         if (this.bF) {
             if (!this.H() && !this.J()) {
                 if (this.onGround && this.bV == 0) {
@@ -1311,10 +1301,9 @@ public abstract class EntityLiving extends Entity {
             this.bV = 0;
         }
 
-        timerEntityAIJump.stopTiming(); // Spigot
         this.world.methodProfiler.b();
         this.world.methodProfiler.a("travel");
-        timerEntityAIMove.startTiming(); // Spigot
+        org.bukkit.craftbukkit.SpigotTimings.timerEntityAIMove.startTiming(); // Spigot
         this.bC *= 0.98F;
         this.bD *= 0.98F;
         this.bE *= 0.9F;
@@ -1323,16 +1312,17 @@ public abstract class EntityLiving extends Entity {
         this.aN *= this.bB();
         this.e(this.bC, this.bD);
         this.aN = f;
-        timerEntityAIMove.stopTiming(); // Spigot
+        org.bukkit.craftbukkit.SpigotTimings.timerEntityAIMove.stopTiming(); // Spigot
         this.world.methodProfiler.b();
         this.world.methodProfiler.a("push");
+        org.bukkit.craftbukkit.SpigotTimings.timerEntityAICollision.startTiming(); // Spigot
         if (!this.world.isStatic) {
             this.bd();
         }
+        org.bukkit.craftbukkit.SpigotTimings.timerEntityAICollision.stopTiming(); // Spigot
 
         this.world.methodProfiler.b();
         this.world.methodProfiler.a("looting");
-        timerEntityAILoot.startTiming(); // Spigot
         // CraftBukkit - Don't run mob pickup code on players
         if (!this.world.isStatic && !(this instanceof EntityPlayer) && this.canPickUpLoot && !this.bc && this.world.getGameRules().getBoolean("mobGriefing")) {
             List list = this.world.a(EntityItem.class, this.boundingBox.grow(1.0D, 0.0D, 1.0D));
@@ -1397,7 +1387,6 @@ public abstract class EntityLiving extends Entity {
             }
         }
 
-        timerEntityAILoot.stopTiming(); // Spigot
         this.world.methodProfiler.b();
     }
 
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index c9b51ce..faa79c8 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -6,7 +6,6 @@ import java.security.KeyPair;
 import java.text.SimpleDateFormat;
 import java.util.ArrayList;
 import java.util.Date;
-import java.util.Iterator;
 import java.util.List;
 import java.util.concurrent.Callable;
 import java.util.logging.Level;
@@ -21,6 +20,7 @@ import jline.console.ConsoleReader;
 import joptsimple.OptionSet;
 
 import org.bukkit.World.Environment;
+import org.bukkit.craftbukkit.SpigotTimings; // Spigot
 import org.bukkit.craftbukkit.util.Waitable;
 import org.bukkit.event.server.RemoteServerCommandEvent;
 import org.bukkit.event.world.WorldSaveEvent;
@@ -419,7 +419,10 @@ public abstract class MinecraftServer implements ICommandListener, Runnable, IMo
                     currentTPS = (currentTPS * 0.95) + (1E9 / (curTime - lastTick) * 0.05);
                     lastTick = curTime;
                     MinecraftServer.currentTick++;
+                    SpigotTimings.serverTickTimer.startTiming();
                     this.q();
+                    SpigotTimings.serverTickTimer.stopTiming();
+                    org.bukkit.CustomTimingsHandler.tick();
                 }
                 // Spigot end
             } else {
@@ -520,6 +523,7 @@ public abstract class MinecraftServer implements ICommandListener, Runnable, IMo
         this.methodProfiler.a("levels");
 
         // CraftBukkit start - only send timeupdates to the people in that world
+        SpigotTimings.schedulerTimer.startTiming(); // Spigot
         this.server.getScheduler().mainThreadHeartbeat(this.ticks);
 
         // Run tasks that are waiting on processing
@@ -527,7 +531,10 @@ public abstract class MinecraftServer implements ICommandListener, Runnable, IMo
             processQueue.remove().run();
         }
 
+        SpigotTimings.schedulerTimer.stopTiming(); // Spigot
+        SpigotTimings.chunkIOTickTimer.startTiming(); // Spigot
         org.bukkit.craftbukkit.chunkio.ChunkIOExecutor.tick();
+        SpigotTimings.chunkIOTickTimer.stopTiming(); // Spigot
 
         // Send timeupdates to everyone, it will get the right time from the world the player is in.
         if (this.ticks % 20 == 0) {
@@ -579,7 +586,9 @@ public abstract class MinecraftServer implements ICommandListener, Runnable, IMo
 
                 this.methodProfiler.b();
                 this.methodProfiler.a("tracker");
+                worldserver.timings.tracker.startTiming(); // Spigot
                 worldserver.getTracker().updatePlayers();
+                worldserver.timings.tracker.stopTiming(); // Spigot
                 this.methodProfiler.b();
                 this.methodProfiler.b();
             // } // CraftBukkit
@@ -588,14 +597,20 @@ public abstract class MinecraftServer implements ICommandListener, Runnable, IMo
         }
 
         this.methodProfiler.c("connection");
+        SpigotTimings.connectionTimer.startTiming(); // Spigot
         this.ae().b();
+        SpigotTimings.connectionTimer.stopTiming(); // Spigot
         this.methodProfiler.c("players");
+        SpigotTimings.playerListTimer.startTiming(); // Spigot
         this.t.tick();
+        SpigotTimings.playerListTimer.stopTiming(); // Spigot
         this.methodProfiler.c("tickables");
 
+        SpigotTimings.tickablesTimer.startTiming(); // Spigot
         for (i = 0; i < this.p.size(); ++i) {
             ((IUpdatePlayerListBox) this.p.get(i)).a();
         }
+        SpigotTimings.tickablesTimer.stopTiming(); // Spigot
 
         this.methodProfiler.b();
         org.bukkit.craftbukkit.util.WatchdogThread.tick(); // Spigot
diff --git a/src/main/java/net/minecraft/server/PlayerConnection.java b/src/main/java/net/minecraft/server/PlayerConnection.java
index 0aabc64..15f8dda 100644
--- a/src/main/java/net/minecraft/server/PlayerConnection.java
+++ b/src/main/java/net/minecraft/server/PlayerConnection.java
@@ -25,7 +25,6 @@ import org.bukkit.craftbukkit.util.Waitable;
 import org.bukkit.craftbukkit.entity.CraftPlayer;
 import org.bukkit.craftbukkit.event.CraftEventFactory;
 import org.bukkit.entity.Player;
-import org.bukkit.event.CustomTimingsHandler;
 import org.bukkit.event.Event;
 import org.bukkit.event.block.Action;
 import org.bukkit.event.block.SignChangeEvent;
@@ -69,7 +68,6 @@ public class PlayerConnection extends Connection {
     private double q;
     public boolean checkMovement = true; // CraftBukkit - private -> public
     private IntHashMap s = new IntHashMap();
-    static private CustomTimingsHandler playerCommandTimer = new CustomTimingsHandler("playerCommand"); // Spigot
 
     public PlayerConnection(MinecraftServer minecraftserver, INetworkManager inetworkmanager, EntityPlayer entityplayer) {
         this.minecraftServer = minecraftserver;
@@ -978,7 +976,7 @@ public class PlayerConnection extends Connection {
     // CraftBukkit end
 
     private void handleCommand(String s) {
-        playerCommandTimer.startTiming(); // Spigot
+        org.bukkit.craftbukkit.SpigotTimings.playerCommandTimer.startTiming(); // Spigot
         // CraftBukkit start
         CraftPlayer player = this.getPlayer();
 
@@ -986,23 +984,23 @@ public class PlayerConnection extends Connection {
         this.server.getPluginManager().callEvent(event);
 
         if (event.isCancelled()) {
-            playerCommandTimer.stopTiming(); // Spigot
+            org.bukkit.craftbukkit.SpigotTimings.playerCommandTimer.stopTiming(); // Spigot
             return;
         }
 
         try {
             if (server.logCommands) logger.info(event.getPlayer().getName() + " issued server command: " + event.getMessage()); // Spigot
             if (this.server.dispatchCommand(event.getPlayer(), event.getMessage().substring(1))) {
-                playerCommandTimer.stopTiming(); // Spigot
+                org.bukkit.craftbukkit.SpigotTimings.playerCommandTimer.stopTiming(); // Spigot
                 return;
             }
         } catch (org.bukkit.command.CommandException ex) {
             player.sendMessage(org.bukkit.ChatColor.RED + "An internal error occurred while attempting to perform this command");
             Logger.getLogger(PlayerConnection.class.getName()).log(Level.SEVERE, null, ex);
-            playerCommandTimer.stopTiming(); // Spigot
+            org.bukkit.craftbukkit.SpigotTimings.playerCommandTimer.stopTiming(); // Spigot
             return;
         }
-        playerCommandTimer.stopTiming(); // Spigot
+        org.bukkit.craftbukkit.SpigotTimings.playerCommandTimer.stopTiming(); // Spigot
         // CraftBukkit end
 
         /* CraftBukkit start - No longer needed as we have already handled it in server.dispatchServerCommand above.
diff --git a/src/main/java/net/minecraft/server/TileEntity.java b/src/main/java/net/minecraft/server/TileEntity.java
index d8eb6b9..b6b0d5f 100644
--- a/src/main/java/net/minecraft/server/TileEntity.java
+++ b/src/main/java/net/minecraft/server/TileEntity.java
@@ -4,10 +4,12 @@ import java.util.HashMap;
 import java.util.Map;
 import java.util.concurrent.Callable;
 
+import org.bukkit.CustomTimingsHandler; // Spigot
 import org.bukkit.inventory.InventoryHolder; // CraftBukkit
 
 public class TileEntity {
 
+    public CustomTimingsHandler tickTimer = org.bukkit.craftbukkit.SpigotTimings.getTileEntityTimings(this); // Spigot
     private static Map a = new HashMap();
     private static Map b = new HashMap();
     public World world; // CraftBukkit - protected -> public
diff --git a/src/main/java/net/minecraft/server/World.java b/src/main/java/net/minecraft/server/World.java
index cd7ad64..a25c51d 100644
--- a/src/main/java/net/minecraft/server/World.java
+++ b/src/main/java/net/minecraft/server/World.java
@@ -13,8 +13,8 @@ import java.util.concurrent.Callable;
 // CraftBukkit start
 import org.bukkit.Bukkit;
 import org.bukkit.craftbukkit.util.LongHashSet;
+import org.bukkit.craftbukkit.SpigotTimings; // Spigot
 import org.bukkit.craftbukkit.util.UnsafeList;
-import org.bukkit.event.WorldTimingsHandler;
 import org.bukkit.generator.ChunkGenerator;
 import org.bukkit.craftbukkit.CraftServer;
 import org.bukkit.craftbukkit.CraftWorld;
@@ -115,7 +115,8 @@ public abstract class World implements IBlockAccess {
     final Object chunkLock = new Object();
     private byte chunkTickRadius;
 
-    public WorldTimingsHandler timings; // Spigot
+    public final SpigotTimings.WorldTimingsHandler timings; // Spigot
+
     public CraftWorld getWorld() {
         return this.world;
     }
@@ -195,7 +196,7 @@ public abstract class World implements IBlockAccess {
         this.a();
 
         this.getServer().addWorld(this.world); // CraftBukkit
-        timings = new WorldTimingsHandler(this); // Spigot
+        timings = new SpigotTimings.WorldTimingsHandler(this); // Spigot
     }
 
     protected abstract IChunkProvider j();
@@ -1184,7 +1185,6 @@ public abstract class World implements IBlockAccess {
         CrashReport crashreport;
         CrashReportSystemDetails crashreportsystemdetails;
 
-        timings.entityBaseTick.startTiming(); // Spigot
         for (i = 0; i < this.i.size(); ++i) {
             entity = (Entity) this.i.get(i);
             // CraftBukkit start - fixed an NPE, don't process entities in chunks queued for unload
@@ -1239,7 +1239,6 @@ public abstract class World implements IBlockAccess {
 
         this.f.clear();
         this.methodProfiler.c("regular");
-        timings.entityBaseTick.stopTiming(); // Spigot
 
         timings.entityTick.startTiming(); // Spigot
         for (i = 0; i < this.entityList.size(); ++i) {
@@ -1264,7 +1263,9 @@ public abstract class World implements IBlockAccess {
             this.methodProfiler.a("tick");
             if (!entity.dead) {
                 try {
+                    SpigotTimings.tickEntityTimer.startTiming(); // Spigot
                     this.playerJoinedWorld(entity);
+                    SpigotTimings.tickEntityTimer.stopTiming(); // Spigot
                 } catch (Throwable throwable1) {
                     crashreport = CrashReport.a(throwable1, "Ticking entity");
                     crashreportsystemdetails = crashreport.a("Entity being ticked");
@@ -1318,8 +1319,11 @@ public abstract class World implements IBlockAccess {
 
             if (!tileentity.r() && tileentity.o() && this.isLoaded(tileentity.x, tileentity.y, tileentity.z)) {
                 try {
+                    tileentity.tickTimer.startTiming(); // Spigot
                     tileentity.g();
+                    tileentity.tickTimer.stopTiming(); // Spigot
                 } catch (Throwable throwable2) {
+                    tileentity.tickTimer.stopTiming(); // Spigot
                     crashreport = CrashReport.a(throwable2, "Ticking tile entity");
                     crashreportsystemdetails = crashreport.a("Tile entity being ticked");
                     if (tileentity == null) {
@@ -1344,6 +1348,8 @@ public abstract class World implements IBlockAccess {
             }
         }
 
+        timings.tileEntityTick.stopTiming(); // Spigot
+        timings.tileEntityPending.startTiming(); // Spigot
         this.M = false;
         if (!this.b.isEmpty()) {
             this.tileEntityList.removeAll(this.b);
@@ -1382,7 +1388,7 @@ public abstract class World implements IBlockAccess {
             this.a.clear();
         }
 
-        timings.tileEntityTick.stopTiming(); // Spigot
+        timings.tileEntityPending.stopTiming(); // Spigot
         this.methodProfiler.b();
         this.methodProfiler.b();
     }
@@ -1435,6 +1441,7 @@ public abstract class World implements IBlockAccess {
         byte b0 = 32;
 
         if (!flag || this.d(i - b0, 0, j - b0, i + b0, 0, j + b0)) {
+            entity.tickTimer.startTiming(); // Spigot
             entity.T = entity.locX;
             entity.U = entity.locY;
             entity.V = entity.locZ;
@@ -1496,6 +1503,7 @@ public abstract class World implements IBlockAccess {
                     entity.passenger = null;
                 }
             }
+            entity.tickTimer.stopTiming(); // Spigot
         }
     }
 
diff --git a/src/main/java/org/bukkit/craftbukkit/OrebfuscatorManager.java b/src/main/java/org/bukkit/craftbukkit/OrebfuscatorManager.java
index c0ee505..6c6517f 100644
--- a/src/main/java/org/bukkit/craftbukkit/OrebfuscatorManager.java
+++ b/src/main/java/org/bukkit/craftbukkit/OrebfuscatorManager.java
@@ -2,7 +2,7 @@ package org.bukkit.craftbukkit;
 
 import net.minecraft.server.Block;
 import net.minecraft.server.World;
-import org.bukkit.event.CustomTimingsHandler;
+import org.bukkit.CustomTimingsHandler;
 
 public class OrebfuscatorManager {
 
diff --git a/src/main/java/org/bukkit/craftbukkit/SpigotTimings.java b/src/main/java/org/bukkit/craftbukkit/SpigotTimings.java
new file mode 100644
index 0000000..df837a3
--- /dev/null
+++ b/src/main/java/org/bukkit/craftbukkit/SpigotTimings.java
@@ -0,0 +1,111 @@
+package org.bukkit.craftbukkit;
+
+import net.minecraft.server.*;
+import org.bukkit.CustomTimingsHandler;
+import org.bukkit.plugin.Plugin;
+import org.bukkit.scheduler.BukkitTask;
+
+import java.util.HashMap;
+
+public class SpigotTimings {
+
+    public static final CustomTimingsHandler serverTickTimer = new CustomTimingsHandler("** Full Server Tick");
+    public static final CustomTimingsHandler playerListTimer = new CustomTimingsHandler("Player List");
+    public static final CustomTimingsHandler connectionTimer = new CustomTimingsHandler("Connection");
+    public static final CustomTimingsHandler tickablesTimer = new CustomTimingsHandler("Tickables");
+    public static final CustomTimingsHandler schedulerTimer = new CustomTimingsHandler("Scheduler");
+    public static final CustomTimingsHandler chunkIOTickTimer = new CustomTimingsHandler("ChunkIOTick");
+    public static final CustomTimingsHandler syncChunkLoadTimer = new CustomTimingsHandler("syncChunkLoad");
+
+    public static final CustomTimingsHandler entityMoveTimer = new CustomTimingsHandler("** entityMove");
+    public static final CustomTimingsHandler tickEntityTimer = new CustomTimingsHandler("** tickEntity");
+    public static final CustomTimingsHandler activatedEntityTimer = new CustomTimingsHandler("** activatedTickEntity");
+    public static final CustomTimingsHandler tickTileEntityTimer = new CustomTimingsHandler("** tickTileEntity");
+
+    public static final CustomTimingsHandler timerEntityBaseTick = new CustomTimingsHandler("** livingEntityBaseTick");
+    public static final CustomTimingsHandler timerEntityAI = new CustomTimingsHandler("** livingEntityAI");
+    public static final CustomTimingsHandler timerEntityAICollision = new CustomTimingsHandler("** livingEntityAICollision");
+    public static final CustomTimingsHandler timerEntityAIMove = new CustomTimingsHandler("** livingEntityAIMove");
+    public static final CustomTimingsHandler timerEntityTickRest = new CustomTimingsHandler("** livingEntityTickRest");
+
+    public static final CustomTimingsHandler playerCommandTimer = new CustomTimingsHandler("** playerCommand");
+
+    public static final HashMap<String, CustomTimingsHandler> entityTypeTimingMap = new HashMap<String, CustomTimingsHandler>();
+    public static final HashMap<String, CustomTimingsHandler> tileEntityTypeTimingMap = new HashMap<String, CustomTimingsHandler>();
+    public static final HashMap<String, CustomTimingsHandler> pluginTaskTimingMap = new HashMap<String, CustomTimingsHandler>();
+
+    /**
+     * Gets a timer associated with a plugins tasks.
+     * @param task
+     * @param period
+     * @return
+     */
+    public static CustomTimingsHandler getPluginTaskTimings(BukkitTask task, long period) {
+        String plugin = task.getOwner().getDescription().getFullName();
+        if (period > 0) {
+            String name = "Task: " + plugin +" Id:(interval:" + period + ":id:"+task.getTaskId()+")";
+            return new CustomTimingsHandler(name);
+        } else {
+            String name = "Task: " + plugin + " Id:(Single)";
+            CustomTimingsHandler result = pluginTaskTimingMap.get(name);
+            if (result == null) {
+                result = new CustomTimingsHandler(name);
+                pluginTaskTimingMap.put(name, result);
+            }
+            return result;
+        }
+    }
+
+    /**
+     * Get a named timer for the specified entity type to track type specific timings.
+     * @param entity
+     * @return
+     */
+    public static CustomTimingsHandler getEntityTimings(Entity entity) {
+        String entityType = entity.getClass().getSimpleName();
+        CustomTimingsHandler result = entityTypeTimingMap.get(entityType);
+        if (result == null) {
+            result = new CustomTimingsHandler("** tickEntity - " + entityType, activatedEntityTimer);
+            entityTypeTimingMap.put(entityType, result);
+        }
+        return result;
+    }
+
+    /**
+     * Get a named timer for the specified tile entity type to track type specific timings.
+     * @param entity
+     * @return
+     */
+    public static CustomTimingsHandler getTileEntityTimings(TileEntity entity) {
+        String entityType = entity.getClass().getSimpleName();
+        CustomTimingsHandler result = tileEntityTypeTimingMap.get(entityType);
+        if (result == null) {
+            result = new CustomTimingsHandler("** tickTileEntity - " + entityType, tickTileEntityTimer);
+            tileEntityTypeTimingMap.put(entityType, result);
+        }
+        return result;
+    }
+
+    /**
+     * Set of timers per world, to track world specific timings.
+     */
+    public static class WorldTimingsHandler {
+        public final CustomTimingsHandler mobSpawn;
+        public final CustomTimingsHandler doTickRest;
+        public final CustomTimingsHandler entityTick;
+        public final CustomTimingsHandler tileEntityTick;
+        public final CustomTimingsHandler tileEntityPending;
+        public final CustomTimingsHandler tracker;
+
+        public WorldTimingsHandler(World server) {
+            String name = server.worldData.getName() +" - ";
+
+            mobSpawn = new CustomTimingsHandler(name + "mobSpawn");
+            doTickRest = new CustomTimingsHandler(name + "doTickRest");
+            entityTick = new CustomTimingsHandler(name + "entityTick");
+            tileEntityTick = new CustomTimingsHandler(name + "tileEntityTick");
+            tileEntityPending = new CustomTimingsHandler(name + "tileEntityPending");
+            tracker = new CustomTimingsHandler(name + "tracker");
+        }
+    }
+}
diff --git a/src/main/java/org/bukkit/craftbukkit/scheduler/CraftTask.java b/src/main/java/org/bukkit/craftbukkit/scheduler/CraftTask.java
index 55db3ff..df134e3 100644
--- a/src/main/java/org/bukkit/craftbukkit/scheduler/CraftTask.java
+++ b/src/main/java/org/bukkit/craftbukkit/scheduler/CraftTask.java
@@ -1,6 +1,8 @@
 package org.bukkit.craftbukkit.scheduler;
 
 import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.SpigotTimings; // Spigot
+import org.bukkit.CustomTimingsHandler; // Spigot
 import org.bukkit.plugin.Plugin;
 import org.bukkit.scheduler.BukkitTask;
 
@@ -22,6 +24,7 @@ class CraftTask implements BukkitTask, Runnable {
     private final Plugin plugin;
     private final int id;
 
+    CustomTimingsHandler timings = null; // Spigot
     CraftTask() {
         this(null, null, -1, -1);
     }
@@ -50,7 +53,22 @@ class CraftTask implements BukkitTask, Runnable {
     }
 
     public void run() {
+        // Spigot start - Wrap custom timings on Tasks
+        if (!Bukkit.getServer().getPluginManager().useTimings()) {
+            task.run();
+            return;
+        }
+        if (timings == null && this.getOwner() != null && this.isSync()) {
+            timings = SpigotTimings.getPluginTaskTimings(this, period);
+        }
+        if (timings != null) {
+            timings.startTiming();
+        }
         task.run();
+        if (timings != null) {
+            timings.stopTiming();
+        }
+        // Spigot end
     }
 
     long getPeriod() {
diff --git a/src/main/java/org/bukkit/event/WorldTimingsHandler.java b/src/main/java/org/bukkit/event/WorldTimingsHandler.java
deleted file mode 100644
index bb0c191..0000000
--- a/src/main/java/org/bukkit/event/WorldTimingsHandler.java
+++ /dev/null
@@ -1,20 +0,0 @@
-package org.bukkit.event;
-
-import net.minecraft.server.World;
-
-public class WorldTimingsHandler {
-    public CustomTimingsHandler mobSpawn;
-    public CustomTimingsHandler doTickRest;
-    public CustomTimingsHandler entityBaseTick;
-    public CustomTimingsHandler entityTick;
-    public CustomTimingsHandler tileEntityTick;
-    public WorldTimingsHandler(World server) {
-        String name = server.worldData.getName() +" - ";
-
-        mobSpawn       = new CustomTimingsHandler(name + "mobSpawn");
-        doTickRest     = new CustomTimingsHandler(name + "doTickRest");
-        entityBaseTick = new CustomTimingsHandler(name + "entityBaseTick");
-        entityTick     = new CustomTimingsHandler(name + "entityTick");
-        tileEntityTick = new CustomTimingsHandler(name + "tileEntityTick");
-    }
-}
-- 
1.8.1.1

