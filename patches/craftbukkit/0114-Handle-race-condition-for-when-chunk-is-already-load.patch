From 3999e8717a207d59199aed3da05b7ade4693fb3f Mon Sep 17 00:00:00 2001
From: Aikar <aikar@aikar.co>
Date: Sat, 19 Sep 2015 00:56:28 -0400
Subject: [PATCH] Handle race condition for when chunk is already loaded after
 async load

CraftWorld.loadChunk can load the chunk while an async load is in progress.
When the async stage 2 calls, it was not checking to make sure the chunk
wasn't already loaded first, resulting in entities being duplicated.

Also move CraftWorld.loadChunk to load the chunk through the Executor
---
 .../net/minecraft/server/ChunkProviderServer.java  |  2 +-
 .../java/org/bukkit/craftbukkit/CraftWorld.java    | 25 ++++++++++------------
 .../craftbukkit/chunkio/ChunkIOProvider.java       | 10 +++++++--
 3 files changed, 20 insertions(+), 17 deletions(-)

diff --git a/src/main/java/net/minecraft/server/ChunkProviderServer.java b/src/main/java/net/minecraft/server/ChunkProviderServer.java
index d6854d3..75009f5 100644
--- a/src/main/java/net/minecraft/server/ChunkProviderServer.java
+++ b/src/main/java/net/minecraft/server/ChunkProviderServer.java
@@ -29,7 +29,7 @@ public class ChunkProviderServer implements IChunkProvider {
     public LongHashSet unloadQueue = new LongHashSet(); // CraftBukkit - LongHashSet
     public Chunk emptyChunk;
     public IChunkProvider chunkProvider;
-    private IChunkLoader chunkLoader;
+    public IChunkLoader chunkLoader; // PAIL public
     public boolean forceChunkLoad = false; // CraftBukkit - true -> false
     public LongObjectHashMap<Chunk> chunks = new LongObjectHashMap<Chunk>();
     public WorldServer world;
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
index e09d892..d264d92 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
@@ -32,6 +32,7 @@ import org.bukkit.block.BlockFace;
 import org.bukkit.block.BlockState;
 import org.bukkit.craftbukkit.block.CraftBlock;
 import org.bukkit.craftbukkit.block.CraftBlockState;
+import org.bukkit.craftbukkit.chunkio.ChunkIOExecutor;
 import org.bukkit.craftbukkit.entity.*;
 import org.bukkit.craftbukkit.inventory.CraftItemStack;
 import org.bukkit.craftbukkit.metadata.BlockMetadataStore;
@@ -297,22 +298,18 @@ public class CraftWorld implements World {
     public boolean loadChunk(int x, int z, boolean generate) {
         org.spigotmc.AsyncCatcher.catchOp( "chunk load"); // Spigot
         chunkLoadCount++;
-        if (generate) {
-            // Use the default variant of loadChunk when generate == true.
-            return world.chunkProviderServer.getChunkAt(x, z) != null;
+        final ChunkProviderServer chunkProviderServer = world.chunkProviderServer;
+        if (chunkProviderServer.getChunkIfLoaded(x, z) != null) {
+            return true;
         }
-
-        world.chunkProviderServer.unloadQueue.remove(x, z);
-        net.minecraft.server.Chunk chunk = world.chunkProviderServer.chunks.get(LongHash.toLong(x, z));
-
-        if (chunk == null) {
-            world.timings.syncChunkLoadTimer.startTiming(); // Spigot
-            chunk = world.chunkProviderServer.loadChunk(x, z);
-
-            chunkLoadPostProcess(chunk, x, z);
-            world.timings.syncChunkLoadTimer.stopTiming(); // Spigot
+        ChunkRegionLoader loader = null;
+        if (chunkProviderServer.chunkLoader instanceof ChunkRegionLoader) {
+            loader = (ChunkRegionLoader) chunkProviderServer.chunkLoader;
         }
-        return chunk != null;
+        if (generate || (loader != null && loader.chunkExists(world, x, z))) {
+            return chunkProviderServer.getChunkAt(x, z) != null;
+        }
+        return false;
     }
 
     private void chunkLoadPostProcess(net.minecraft.server.Chunk chunk, int cx, int cz) {
diff --git a/src/main/java/org/bukkit/craftbukkit/chunkio/ChunkIOProvider.java b/src/main/java/org/bukkit/craftbukkit/chunkio/ChunkIOProvider.java
index 1178ad7..797b4bb 100644
--- a/src/main/java/org/bukkit/craftbukkit/chunkio/ChunkIOProvider.java
+++ b/src/main/java/org/bukkit/craftbukkit/chunkio/ChunkIOProvider.java
@@ -42,10 +42,16 @@ class ChunkIOProvider implements AsynchronousExecutor.CallBackProvider<QueuedChu
             queuedChunk.provider.originalGetChunkAt(queuedChunk.x, queuedChunk.z);
             return;
         }
-
+        final long chunkKey = LongHash.toLong(queuedChunk.x, queuedChunk.z);
+        // Check if something else (CraftWorld.loadChunk?) beat us to it
+        if (queuedChunk.provider.chunks.containsKey(chunkKey)) {
+            boolean b = queuedChunk.provider.unloadQueue.contains(chunkKey); // EMC
+            System.err.println("Chunk Already was loaded: " + queuedChunk.x + "," + queuedChunk.z + " - unloading? " + b); // EMC
+        }
         queuedChunk.loader.loadEntities(chunk, queuedChunk.compound.getCompound("Level"), queuedChunk.world);
         chunk.setLastSaved(queuedChunk.provider.world.getTime());
-        queuedChunk.provider.chunks.put(LongHash.toLong(queuedChunk.x, queuedChunk.z), chunk);
+
+        queuedChunk.provider.chunks.put(chunkKey, chunk);
         chunk.addEntities();
 
         if (queuedChunk.provider.chunkProvider != null) {
-- 
2.6.2

