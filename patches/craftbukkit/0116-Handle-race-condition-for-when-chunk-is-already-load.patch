From fef8f71ed37524d71e80309ff923c8303b390d75 Mon Sep 17 00:00:00 2001
From: Aikar <aikar@aikar.co>
Date: Sat, 19 Sep 2015 00:56:28 -0400
Subject: [PATCH] Handle race condition for when chunk is already loaded after
 async load

CraftWorld.loadChunk can load the chunk while an async load is in progress.
When the async stage 2 calls, it was not checking to make sure the chunk
wasn't already loaded first, resulting in entities being duplicated.

Also move CraftWorld.loadChunk to load the chunk through the Executor
---
 .../java/net/minecraft/server/ChunkProviderServer.java |  2 +-
 src/main/java/org/bukkit/craftbukkit/CraftWorld.java   | 18 +++++++-----------
 .../bukkit/craftbukkit/chunkio/ChunkIOProvider.java    |  9 +++++++--
 3 files changed, 15 insertions(+), 14 deletions(-)

diff --git a/src/main/java/net/minecraft/server/ChunkProviderServer.java b/src/main/java/net/minecraft/server/ChunkProviderServer.java
index d6854d3..75009f5 100644
--- a/src/main/java/net/minecraft/server/ChunkProviderServer.java
+++ b/src/main/java/net/minecraft/server/ChunkProviderServer.java
@@ -29,7 +29,7 @@ public class ChunkProviderServer implements IChunkProvider {
     public LongHashSet unloadQueue = new LongHashSet(); // CraftBukkit - LongHashSet
     public Chunk emptyChunk;
     public IChunkProvider chunkProvider;
-    private IChunkLoader chunkLoader;
+    public IChunkLoader chunkLoader; // PAIL public
     public boolean forceChunkLoad = false; // CraftBukkit - true -> false
     public LongObjectHashMap<Chunk> chunks = new LongObjectHashMap<Chunk>();
     public WorldServer world;
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
index e09d892..b98ed9a 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
@@ -32,6 +32,7 @@ import org.bukkit.block.BlockFace;
 import org.bukkit.block.BlockState;
 import org.bukkit.craftbukkit.block.CraftBlock;
 import org.bukkit.craftbukkit.block.CraftBlockState;
+import org.bukkit.craftbukkit.chunkio.ChunkIOExecutor;
 import org.bukkit.craftbukkit.entity.*;
 import org.bukkit.craftbukkit.inventory.CraftItemStack;
 import org.bukkit.craftbukkit.metadata.BlockMetadataStore;
@@ -297,22 +298,17 @@ public class CraftWorld implements World {
     public boolean loadChunk(int x, int z, boolean generate) {
         org.spigotmc.AsyncCatcher.catchOp( "chunk load"); // Spigot
         chunkLoadCount++;
+        final ChunkProviderServer chunkProviderServer = world.chunkProviderServer;
         if (generate) {
             // Use the default variant of loadChunk when generate == true.
-            return world.chunkProviderServer.getChunkAt(x, z) != null;
+            return chunkProviderServer.getChunkAt(x, z) != null;
         }
 
-        world.chunkProviderServer.unloadQueue.remove(x, z);
-        net.minecraft.server.Chunk chunk = world.chunkProviderServer.chunks.get(LongHash.toLong(x, z));
-
-        if (chunk == null) {
-            world.timings.syncChunkLoadTimer.startTiming(); // Spigot
-            chunk = world.chunkProviderServer.loadChunk(x, z);
-
-            chunkLoadPostProcess(chunk, x, z);
-            world.timings.syncChunkLoadTimer.stopTiming(); // Spigot
+        ChunkRegionLoader loader = null;
+        if (chunkProviderServer.chunkLoader instanceof ChunkRegionLoader) {
+            loader = (ChunkRegionLoader) chunkProviderServer.chunkLoader;
         }
-        return chunk != null;
+        return ChunkIOExecutor.syncChunkLoad(world, loader, chunkProviderServer, x, z) != null;
     }
 
     private void chunkLoadPostProcess(net.minecraft.server.Chunk chunk, int cx, int cz) {
diff --git a/src/main/java/org/bukkit/craftbukkit/chunkio/ChunkIOProvider.java b/src/main/java/org/bukkit/craftbukkit/chunkio/ChunkIOProvider.java
index 1178ad7..90e67ff 100644
--- a/src/main/java/org/bukkit/craftbukkit/chunkio/ChunkIOProvider.java
+++ b/src/main/java/org/bukkit/craftbukkit/chunkio/ChunkIOProvider.java
@@ -42,10 +42,15 @@ class ChunkIOProvider implements AsynchronousExecutor.CallBackProvider<QueuedChu
             queuedChunk.provider.originalGetChunkAt(queuedChunk.x, queuedChunk.z);
             return;
         }
-
+        final long chunkKey = LongHash.toLong(queuedChunk.x, queuedChunk.z);
+        // Check if something else (CraftWorld.loadChunk?) beat us to it
+        if (queuedChunk.provider.chunks.containsKey(chunkKey)) {
+            return;
+        }
         queuedChunk.loader.loadEntities(chunk, queuedChunk.compound.getCompound("Level"), queuedChunk.world);
         chunk.setLastSaved(queuedChunk.provider.world.getTime());
-        queuedChunk.provider.chunks.put(LongHash.toLong(queuedChunk.x, queuedChunk.z), chunk);
+
+        queuedChunk.provider.chunks.put(chunkKey, chunk);
         chunk.addEntities();
 
         if (queuedChunk.provider.chunkProvider != null) {
-- 
1.9.1

