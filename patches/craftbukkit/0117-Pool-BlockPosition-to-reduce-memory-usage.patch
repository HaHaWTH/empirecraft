From 356a67ae91672805081f67f8824e36030045172e Mon Sep 17 00:00:00 2001
From: Aikar <aikar@aikar.co>
Date: Sun, 30 Aug 2015 00:50:50 -0400
Subject: [PATCH] Pool BlockPosition to reduce memory usage

Implements a PooledMutableBlockPosition system.

Use pooled BlockPosition for many hot spots of the server that does not hold a reference past its current scope.
---
 src/main/java/net/minecraft/server/Chunk.java      |   4 +-
 src/main/java/net/minecraft/server/Entity.java     |   4 +-
 .../net/minecraft/server/PathfinderNormal.java     |  14 ++-
 .../server/PooledMutableBlockPosition.java         | 116 +++++++++++++++++++++
 src/main/java/net/minecraft/server/World.java      |  34 ++++--
 5 files changed, 155 insertions(+), 17 deletions(-)
 create mode 100644 src/main/java/net/minecraft/server/PooledMutableBlockPosition.java

diff --git a/src/main/java/net/minecraft/server/Chunk.java b/src/main/java/net/minecraft/server/Chunk.java
index 66e1f33..2762cf4 100644
--- a/src/main/java/net/minecraft/server/Chunk.java
+++ b/src/main/java/net/minecraft/server/Chunk.java
@@ -1257,7 +1257,7 @@ public class Chunk {
         int k = this.g();
         boolean flag = false;
         boolean flag1 = false;
-        BlockPosition.MutableBlockPosition blockposition_mutableblockposition = new BlockPosition.MutableBlockPosition((this.locX << 4) + i, 0, (this.locZ << 4) + j);
+        PooledMutableBlockPosition blockposition_mutableblockposition = PooledMutableBlockPosition.acquire((this.locX << 4) + i, 0, (this.locZ << 4) + j); // Spigot
 
         int l;
 
@@ -1272,6 +1272,7 @@ public class Chunk {
             if (!flag && i1 > 0) {
                 flag = true;
             } else if (flag && i1 == 0 && !this.world.x(blockposition_mutableblockposition)) {
+                blockposition_mutableblockposition.release(); // Spigot
                 return false;
             }
         }
@@ -1283,6 +1284,7 @@ public class Chunk {
             }
         }
 
+        blockposition_mutableblockposition.release(); // Spigot
         return true;
     }
 
diff --git a/src/main/java/net/minecraft/server/Entity.java b/src/main/java/net/minecraft/server/Entity.java
index c96832a..6028060 100644
--- a/src/main/java/net/minecraft/server/Entity.java
+++ b/src/main/java/net/minecraft/server/Entity.java
@@ -1450,7 +1450,7 @@ public abstract class Entity implements ICommandListener {
         if (this.noclip) {
             return false;
         } else {
-            BlockPosition.MutableBlockPosition blockposition_mutableblockposition = new BlockPosition.MutableBlockPosition(Integer.MIN_VALUE, Integer.MIN_VALUE, Integer.MIN_VALUE);
+            PooledMutableBlockPosition blockposition_mutableblockposition = PooledMutableBlockPosition.acquire(Integer.MIN_VALUE, Integer.MIN_VALUE, Integer.MIN_VALUE); // Spigot
 
             for (int i = 0; i < 8; ++i) {
                 int j = MathHelper.floor(this.locY + (double) (((float) ((i >> 0) % 2) - 0.5F) * 0.1F) + (double) this.getHeadHeight());
@@ -1460,10 +1460,12 @@ public abstract class Entity implements ICommandListener {
                 if (blockposition_mutableblockposition.getX() != k || blockposition_mutableblockposition.getY() != j || blockposition_mutableblockposition.getZ() != l) {
                     blockposition_mutableblockposition.c(k, j, l);
                     if (this.world.getType(blockposition_mutableblockposition).getBlock().w()) {
+                        blockposition_mutableblockposition.release(); // Spigot
                         return true;
                     }
                 }
             }
+            blockposition_mutableblockposition.release();
 
             return false;
         }
diff --git a/src/main/java/net/minecraft/server/PathfinderNormal.java b/src/main/java/net/minecraft/server/PathfinderNormal.java
index 0a14c9d..dca0087 100644
--- a/src/main/java/net/minecraft/server/PathfinderNormal.java
+++ b/src/main/java/net/minecraft/server/PathfinderNormal.java
@@ -9,6 +9,9 @@ public class PathfinderNormal extends PathfinderAbstract {
     private boolean j;
 
     public PathfinderNormal() {}
+    // Spigot - Too many places to release these back to pool, so just keep 2 around for re-use.
+    private static final PooledMutableBlockPosition MUTABLE_BLOCK_POSITION1 = PooledMutableBlockPosition.acquire(); // Spigot
+    private static final PooledMutableBlockPosition MUTABLE_BLOCK_POSITION2 = PooledMutableBlockPosition.acquire(); // Spigot
 
     public void a(IBlockAccess iblockaccess, Entity entity) {
         super.a(iblockaccess, entity);
@@ -25,12 +28,13 @@ public class PathfinderNormal extends PathfinderAbstract {
 
         if (this.i && entity.V()) {
             i = (int) entity.getBoundingBox().b;
-            BlockPosition.MutableBlockPosition blockposition_mutableblockposition = new BlockPosition.MutableBlockPosition(MathHelper.floor(entity.locX), i, MathHelper.floor(entity.locZ));
+            PooledMutableBlockPosition blockposition_mutableblockposition = PooledMutableBlockPosition.acquire(MathHelper.floor(entity.locX), i, MathHelper.floor(entity.locZ)); // Spigot
 
             for (Block block = this.a.getType(blockposition_mutableblockposition).getBlock(); block == Blocks.FLOWING_WATER || block == Blocks.WATER; block = this.a.getType(blockposition_mutableblockposition).getBlock()) {
                 ++i;
                 blockposition_mutableblockposition.c(MathHelper.floor(entity.locX), i, MathHelper.floor(entity.locZ));
             }
+            blockposition_mutableblockposition.release(); // Spigot
 
             this.h = false;
         } else {
@@ -132,8 +136,8 @@ public class PathfinderNormal extends PathfinderAbstract {
 
     public static int a(IBlockAccess iblockaccess, Entity entity, int i, int j, int k, int l, int i1, int j1, boolean flag, boolean flag1, boolean flag2) {
         boolean flag3 = false;
-        BlockPosition blockposition = new BlockPosition(entity);
-        BlockPosition.MutableBlockPosition blockposition_mutableblockposition = new BlockPosition.MutableBlockPosition();
+        PooledMutableBlockPosition blockposition = MUTABLE_BLOCK_POSITION1;blockposition.set(entity); // Spigot
+        PooledMutableBlockPosition blockposition_mutableblockposition = MUTABLE_BLOCK_POSITION2; // Spigot
 
         for (int k1 = i; k1 < i + l; ++k1) {
             for (int l1 = j; l1 < j + i1; ++l1) {
@@ -158,8 +162,8 @@ public class PathfinderNormal extends PathfinderAbstract {
                             flag3 = true;
                         }
 
-                        if (entity.world.getType(blockposition_mutableblockposition).getBlock() instanceof BlockMinecartTrackAbstract) {
-                            if (!(entity.world.getType(blockposition).getBlock() instanceof BlockMinecartTrackAbstract) && !(entity.world.getType(blockposition.down()).getBlock() instanceof BlockMinecartTrackAbstract)) {
+                        if (block instanceof BlockMinecartTrackAbstract) { // Spigot
+                            if (!(entity.world.getType(blockposition).getBlock() instanceof BlockMinecartTrackAbstract) && !(entity.world.getType(blockposition.adjustY(-1)).getBlock() instanceof BlockMinecartTrackAbstract)) { // Spigot
                                 return -3;
                             }
                         } else if (!block.b(iblockaccess, blockposition_mutableblockposition) && (!flag1 || !(block instanceof BlockDoor) || block.getMaterial() != Material.WOOD)) {
diff --git a/src/main/java/net/minecraft/server/PooledMutableBlockPosition.java b/src/main/java/net/minecraft/server/PooledMutableBlockPosition.java
new file mode 100644
index 0000000..0ab11e1
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PooledMutableBlockPosition.java
@@ -0,0 +1,116 @@
+/*
+ * Copyright (c) 2015. Starlis LLC / dba Empire Minecraft
+ *
+ * This source code is proprietary software and must not be redistributed without Starlis LLC's approval
+ *
+ */
+
+package net.minecraft.server;
+
+import com.google.common.collect.Lists;
+import org.apache.logging.log4j.Level;
+
+import java.util.List;
+
+public final class PooledMutableBlockPosition extends BlockPosition {
+
+    private int x;
+    private int y;
+    private int z;
+    private boolean free = false;
+
+    private static final int MAX_SIZE = 100;
+    private static final List<PooledMutableBlockPosition> pool = Lists.newArrayList();
+
+    private PooledMutableBlockPosition(int x, int y, int z) {
+        super(0, 0, 0);
+        this.x = x;
+        this.y = y;
+        this.z = z;
+    }
+
+    public static PooledMutableBlockPosition acquire() {
+        return acquire(0, 0, 0);
+    }
+
+    public static PooledMutableBlockPosition acquire(Entity entity) {
+        return acquire(MathHelper.floor(entity.locX), MathHelper.floor(entity.locY), MathHelper.floor(entity.locZ));
+    }
+
+    public static synchronized PooledMutableBlockPosition acquire(int x, int y, int z) {
+        if (!pool.isEmpty()) {
+            PooledMutableBlockPosition pos = pool.remove(pool.size() - 1);
+            if (pos.free) {
+                pos.free = false;
+                pos.set(x, y, z);
+                return pos;
+            }
+        }
+        return new PooledMutableBlockPosition(x, y, z);
+    }
+
+    public void release() {
+        if (pool.size() < MAX_SIZE) {
+            pool.add(this);
+        }
+        free = true;
+    }
+
+    public int getX() {
+        return this.x;
+    }
+
+    public int getY() {
+        return this.y;
+    }
+
+    public int getZ() {
+        return this.z;
+    }
+
+    /**
+     * This method is purely to provide compile time test incase c() doesn't get renamed
+     */
+    private static void testMutableBlockPositionMethod() {
+        BlockPosition.MutableBlockPosition test = (new BlockPosition.MutableBlockPosition()).c(0,0,0);
+    }
+    // PAIL: Rename BlockPosition.MutableBlockPosition to adjust
+    public PooledMutableBlockPosition c(int x, int y, int z) {
+        return set(x, y, z);
+    }
+    public PooledMutableBlockPosition set(int x, int y, int z) {
+        if (free) {
+            MinecraftServer.LOGGER.log(Level.ERROR, "PooledMutableBlockPosition modified after it was released.", new Throwable());
+            free = false;
+        }
+        this.x = x;
+        this.y = y;
+        this.z = z;
+        return this;
+    }
+
+    public PooledMutableBlockPosition set(Entity entity) {
+        return set(MathHelper.floor(entity.locX), MathHelper.floor(entity.locY), MathHelper.floor(entity.locZ));
+    }
+
+    public PooledMutableBlockPosition adjust(int x, int y, int z) {
+        return set(this.x + x, this.y + y, this.z + z);
+    }
+
+    public PooledMutableBlockPosition adjustX(int x) {
+        return set(this.x + x, this.y, this.z);
+    }
+
+    public PooledMutableBlockPosition adjustY(int y) {
+        return set(this.x, this.y + y, this.z);
+    }
+    public PooledMutableBlockPosition adjustZ(int z) {
+        return set(this.x, this.y, this.z + z);
+    }
+
+    @Override
+    public int compareTo(BaseBlockPosition o) {
+        return y == o.getY() ? (z == o.getZ() ? x - o.getX() : z - o.getZ()) : y - o.getY();
+    }
+
+}
diff --git a/src/main/java/net/minecraft/server/World.java b/src/main/java/net/minecraft/server/World.java
index 69171a8..4e0cee9 100644
--- a/src/main/java/net/minecraft/server/World.java
+++ b/src/main/java/net/minecraft/server/World.java
@@ -1180,7 +1180,7 @@ public abstract class World implements IBlockAccess {
         boolean flag = entity.aT();
         boolean flag1 = this.a(worldborder, entity);
         IBlockData iblockdata = Blocks.STONE.getBlockData();
-        BlockPosition.MutableBlockPosition blockposition_mutableblockposition = new BlockPosition.MutableBlockPosition();
+        //BlockPosition.MutableBlockPosition blockposition_mutableblockposition = new BlockPosition.MutableBlockPosition(); // Spigot - not used
 
         // Spigot start
         int ystart = ( ( k - 1 ) < 0 ) ? 0 : ( k - 1 );
@@ -1283,7 +1283,7 @@ public abstract class World implements IBlockAccess {
         int l = MathHelper.floor(axisalignedbb.e + 1.0D);
         int i1 = MathHelper.floor(axisalignedbb.c);
         int j1 = MathHelper.floor(axisalignedbb.f + 1.0D);
-        BlockPosition.MutableBlockPosition blockposition_mutableblockposition = new BlockPosition.MutableBlockPosition();
+        PooledMutableBlockPosition blockposition_mutableblockposition = PooledMutableBlockPosition.acquire(); // Spigot
 
         for (int k1 = i; k1 < j; ++k1) {
             for (int l1 = i1; l1 < j1; ++l1) {
@@ -1303,6 +1303,7 @@ public abstract class World implements IBlockAccess {
                 }
             }
         }
+        blockposition_mutableblockposition.release(); // Spigot
 
         return arraylist;
     }
@@ -1729,7 +1730,7 @@ public abstract class World implements IBlockAccess {
         int l = MathHelper.floor(axisalignedbb.e);
         int i1 = MathHelper.floor(axisalignedbb.c);
         int j1 = MathHelper.floor(axisalignedbb.f);
-        BlockPosition.MutableBlockPosition blockposition_mutableblockposition = new BlockPosition.MutableBlockPosition();
+        PooledMutableBlockPosition blockposition_mutableblockposition = PooledMutableBlockPosition.acquire(); // Spigot
 
         for (int k1 = i; k1 <= j; ++k1) {
             for (int l1 = k; l1 <= l; ++l1) {
@@ -1737,11 +1738,13 @@ public abstract class World implements IBlockAccess {
                     Block block = this.getType(blockposition_mutableblockposition.c(k1, l1, i2)).getBlock();
 
                     if (block.getMaterial() != Material.AIR) {
+                        blockposition_mutableblockposition.release(); // Spigot
                         return true;
                     }
                 }
             }
         }
+        blockposition_mutableblockposition.release(); // Spigot
 
         return false;
     }
@@ -1753,7 +1756,7 @@ public abstract class World implements IBlockAccess {
         int l = MathHelper.floor(axisalignedbb.e);
         int i1 = MathHelper.floor(axisalignedbb.c);
         int j1 = MathHelper.floor(axisalignedbb.f);
-        BlockPosition.MutableBlockPosition blockposition_mutableblockposition = new BlockPosition.MutableBlockPosition();
+        PooledMutableBlockPosition blockposition_mutableblockposition = PooledMutableBlockPosition.acquire(); // Spigot
 
         for (int k1 = i; k1 <= j; ++k1) {
             for (int l1 = k; l1 <= l; ++l1) {
@@ -1761,11 +1764,13 @@ public abstract class World implements IBlockAccess {
                     Block block = this.getType(blockposition_mutableblockposition.c(k1, l1, i2)).getBlock();
 
                     if (block.getMaterial().isLiquid()) {
+                        blockposition_mutableblockposition.release(); // Spigot
                         return true;
                     }
                 }
             }
         }
+        blockposition_mutableblockposition.release(); // Spigot
 
         return false;
     }
@@ -1779,7 +1784,7 @@ public abstract class World implements IBlockAccess {
         int j1 = MathHelper.floor(axisalignedbb.f + 1.0D);
 
         if (this.isAreaLoaded(i, k, i1, j, l, j1, true)) {
-            BlockPosition.MutableBlockPosition blockposition_mutableblockposition = new BlockPosition.MutableBlockPosition();
+            PooledMutableBlockPosition blockposition_mutableblockposition = PooledMutableBlockPosition.acquire(); // Spigot
 
             for (int k1 = i; k1 < j; ++k1) {
                 for (int l1 = k; l1 < l; ++l1) {
@@ -1787,11 +1792,13 @@ public abstract class World implements IBlockAccess {
                         Block block = this.getType(blockposition_mutableblockposition.c(k1, l1, i2)).getBlock();
 
                         if (block == Blocks.FIRE || block == Blocks.FLOWING_LAVA || block == Blocks.LAVA) {
+                            blockposition_mutableblockposition.release(); // Spigot
                             return true;
                         }
                     }
                 }
             }
+            blockposition_mutableblockposition.release(); // Spigot
         }
 
         return false;
@@ -1810,7 +1817,7 @@ public abstract class World implements IBlockAccess {
         } else {
             boolean flag = false;
             Vec3D vec3d = new Vec3D(0.0D, 0.0D, 0.0D);
-            BlockPosition.MutableBlockPosition blockposition_mutableblockposition = new BlockPosition.MutableBlockPosition();
+            PooledMutableBlockPosition blockposition_mutableblockposition = PooledMutableBlockPosition.acquire(); // Spigot
 
             for (int k1 = i; k1 < j; ++k1) {
                 for (int l1 = k; l1 < l; ++l1) {
@@ -1830,6 +1837,7 @@ public abstract class World implements IBlockAccess {
                     }
                 }
             }
+            blockposition_mutableblockposition.release(); // Spigot
 
             if (vec3d.b() > 0.0D && entity.aL()) {
                 vec3d = vec3d.a();
@@ -1851,17 +1859,19 @@ public abstract class World implements IBlockAccess {
         int l = MathHelper.floor(axisalignedbb.e + 1.0D);
         int i1 = MathHelper.floor(axisalignedbb.c);
         int j1 = MathHelper.floor(axisalignedbb.f + 1.0D);
-        BlockPosition.MutableBlockPosition blockposition_mutableblockposition = new BlockPosition.MutableBlockPosition();
+        PooledMutableBlockPosition blockposition_mutableblockposition = PooledMutableBlockPosition.acquire(); // Spigot
 
         for (int k1 = i; k1 < j; ++k1) {
             for (int l1 = k; l1 < l; ++l1) {
                 for (int i2 = i1; i2 < j1; ++i2) {
                     if (this.getType(blockposition_mutableblockposition.c(k1, l1, i2)).getBlock().getMaterial() == material) {
+                        blockposition_mutableblockposition.release(); // Spigot
                         return true;
                     }
                 }
             }
         }
+        blockposition_mutableblockposition.release(); // Spigot
 
         return false;
     }
@@ -1873,7 +1883,7 @@ public abstract class World implements IBlockAccess {
         int l = MathHelper.floor(axisalignedbb.e + 1.0D);
         int i1 = MathHelper.floor(axisalignedbb.c);
         int j1 = MathHelper.floor(axisalignedbb.f + 1.0D);
-        BlockPosition.MutableBlockPosition blockposition_mutableblockposition = new BlockPosition.MutableBlockPosition();
+        PooledMutableBlockPosition blockposition_mutableblockposition = PooledMutableBlockPosition.acquire(); // Spigot
 
         for (int k1 = i; k1 < j; ++k1) {
             for (int l1 = k; l1 < l; ++l1) {
@@ -1890,12 +1900,14 @@ public abstract class World implements IBlockAccess {
                         }
 
                         if (d0 >= axisalignedbb.b) {
+                            blockposition_mutableblockposition.release(); // Spigot
                             return true;
                         }
                     }
                 }
             }
         }
+        blockposition_mutableblockposition.release(); // Spigot
 
         return false;
     }
@@ -2441,7 +2453,7 @@ public abstract class World implements IBlockAccess {
                     j2 = (l1 >> 6 & 63) - 32 + j1;
                     k2 = (l1 >> 12 & 63) - 32 + k1;
                     int l3 = l1 >> 18 & 15;
-                    BlockPosition blockposition1 = new BlockPosition(i2, j2, k2);
+                    PooledMutableBlockPosition blockposition1 = PooledMutableBlockPosition.acquire(i2, j2, k2); // Spigot
 
                     l2 = this.b(enumskyblock, blockposition1);
                     if (l2 == l3) {
@@ -2451,7 +2463,7 @@ public abstract class World implements IBlockAccess {
                             j3 = MathHelper.a(j2 - j1);
                             k3 = MathHelper.a(k2 - k1);
                             if (i3 + j3 + k3 < 17) {
-                                BlockPosition.MutableBlockPosition blockposition_mutableblockposition = new BlockPosition.MutableBlockPosition();
+                                PooledMutableBlockPosition blockposition_mutableblockposition = PooledMutableBlockPosition.acquire(); // Spigot
                                 EnumDirection[] aenumdirection = EnumDirection.values();
                                 int i4 = aenumdirection.length;
 
@@ -2469,9 +2481,11 @@ public abstract class World implements IBlockAccess {
                                         this.H[j++] = k4 - i1 + 32 | l4 - j1 + 32 << 6 | i5 - k1 + 32 << 12 | l3 - j5 << 18;
                                     }
                                 }
+                                blockposition_mutableblockposition.release(); // Spigot
                             }
                         }
                     }
+                    blockposition1.release(); // Spigot
                 }
 
                 i = 0;
-- 
1.9.1

