From a82c6dd780329ee71fb9765007f437cf7958baf7 Mon Sep 17 00:00:00 2001
From: Aikar <aikar@aikar.co>
Date: Sun, 30 Aug 2015 00:50:50 -0400
Subject: [PATCH] Pool BlockPosition to reduce memory usage

Implements a PooledMutableBlockPosition system.

Use pooled BlockPosition for many hot spots of the server that does not hold a reference past its current scope.
---
 src/main/java/net/minecraft/server/Chunk.java      |  12 +-
 src/main/java/net/minecraft/server/Entity.java     |  13 ++-
 .../net/minecraft/server/PathfinderNormal.java     |  14 ++-
 .../server/PooledMutableBlockPosition.java         | 126 +++++++++++++++++++++
 src/main/java/net/minecraft/server/World.java      |  39 +++++--
 .../org/bukkit/craftbukkit/block/CraftBlock.java   |  56 ++++++---
 6 files changed, 222 insertions(+), 38 deletions(-)
 create mode 100644 src/main/java/net/minecraft/server/PooledMutableBlockPosition.java

diff --git a/src/main/java/net/minecraft/server/Chunk.java b/src/main/java/net/minecraft/server/Chunk.java
index 66e1f33..05b5304 100644
--- a/src/main/java/net/minecraft/server/Chunk.java
+++ b/src/main/java/net/minecraft/server/Chunk.java
@@ -273,13 +273,17 @@ public class Chunk {
     }
 
     private void a(int i, int j, int k, int l) {
-        if (l > k && this.world.areChunksLoaded(new BlockPosition(i, 0, j), 16)) {
+        final PooledMutableBlockPosition pos1 = PooledMutableBlockPosition.acquire(i, 0, j); // Spigot
+        if (l > k && this.world.areChunksLoaded(pos1, 16)) { // Spigot
             for (int i1 = k; i1 < l; ++i1) {
-                this.world.c(EnumSkyBlock.SKY, new BlockPosition(i, i1, j));
+                final PooledMutableBlockPosition pos2 = PooledMutableBlockPosition.acquire(i, i1, j); // Spigot
+                this.world.c(EnumSkyBlock.SKY, pos2); // Spigot
+                pos2.release(); // Spigot
             }
 
             this.q = true;
         }
+        pos1.release(); // Spigot
 
     }
 
@@ -1257,7 +1261,7 @@ public class Chunk {
         int k = this.g();
         boolean flag = false;
         boolean flag1 = false;
-        BlockPosition.MutableBlockPosition blockposition_mutableblockposition = new BlockPosition.MutableBlockPosition((this.locX << 4) + i, 0, (this.locZ << 4) + j);
+        PooledMutableBlockPosition blockposition_mutableblockposition = PooledMutableBlockPosition.acquire((this.locX << 4) + i, 0, (this.locZ << 4) + j); // Spigot
 
         int l;
 
@@ -1272,6 +1276,7 @@ public class Chunk {
             if (!flag && i1 > 0) {
                 flag = true;
             } else if (flag && i1 == 0 && !this.world.x(blockposition_mutableblockposition)) {
+                blockposition_mutableblockposition.release(); // Spigot
                 return false;
             }
         }
@@ -1283,6 +1288,7 @@ public class Chunk {
             }
         }
 
+        blockposition_mutableblockposition.release(); // Spigot
         return true;
     }
 
diff --git a/src/main/java/net/minecraft/server/Entity.java b/src/main/java/net/minecraft/server/Entity.java
index c96832a..d89b2e0 100644
--- a/src/main/java/net/minecraft/server/Entity.java
+++ b/src/main/java/net/minecraft/server/Entity.java
@@ -627,15 +627,15 @@ public abstract class Entity implements ICommandListener {
             int i = MathHelper.floor(this.locX);
             int j = MathHelper.floor(this.locY - 0.20000000298023224D);
             int k = MathHelper.floor(this.locZ);
-            BlockPosition blockposition = new BlockPosition(i, j, k);
+            PooledMutableBlockPosition blockposition = PooledMutableBlockPosition.acquire(i, j, k); // Spigot
             Block block = this.world.getType(blockposition).getBlock();
 
             if (block.getMaterial() == Material.AIR) {
-                Block block1 = this.world.getType(blockposition.down()).getBlock();
-
+                Block block1 = this.world.getType(blockposition.adjustY(-1)).getBlock(); // Spigot down 1 temporarily
+                blockposition.adjustY(1); // Spigot - reset back
                 if (block1 instanceof BlockFence || block1 instanceof BlockCobbleWall || block1 instanceof BlockFenceGate) {
                     block = block1;
-                    blockposition = blockposition.down();
+                    blockposition = blockposition.adjustY(-1); // Spigot
                 }
             }
 
@@ -703,6 +703,7 @@ public abstract class Entity implements ICommandListener {
                     block.a(this.world, blockposition, this); // CraftBukkit moved from above
                 }
             }
+            blockposition.release(); // Spigot
 
             // CraftBukkit start - Move to the top of the method
             /*
@@ -1450,7 +1451,7 @@ public abstract class Entity implements ICommandListener {
         if (this.noclip) {
             return false;
         } else {
-            BlockPosition.MutableBlockPosition blockposition_mutableblockposition = new BlockPosition.MutableBlockPosition(Integer.MIN_VALUE, Integer.MIN_VALUE, Integer.MIN_VALUE);
+            PooledMutableBlockPosition blockposition_mutableblockposition = PooledMutableBlockPosition.acquire(Integer.MIN_VALUE, Integer.MIN_VALUE, Integer.MIN_VALUE); // Spigot
 
             for (int i = 0; i < 8; ++i) {
                 int j = MathHelper.floor(this.locY + (double) (((float) ((i >> 0) % 2) - 0.5F) * 0.1F) + (double) this.getHeadHeight());
@@ -1460,10 +1461,12 @@ public abstract class Entity implements ICommandListener {
                 if (blockposition_mutableblockposition.getX() != k || blockposition_mutableblockposition.getY() != j || blockposition_mutableblockposition.getZ() != l) {
                     blockposition_mutableblockposition.c(k, j, l);
                     if (this.world.getType(blockposition_mutableblockposition).getBlock().w()) {
+                        blockposition_mutableblockposition.release(); // Spigot
                         return true;
                     }
                 }
             }
+            blockposition_mutableblockposition.release();
 
             return false;
         }
diff --git a/src/main/java/net/minecraft/server/PathfinderNormal.java b/src/main/java/net/minecraft/server/PathfinderNormal.java
index 0a14c9d..dca0087 100644
--- a/src/main/java/net/minecraft/server/PathfinderNormal.java
+++ b/src/main/java/net/minecraft/server/PathfinderNormal.java
@@ -9,6 +9,9 @@ public class PathfinderNormal extends PathfinderAbstract {
     private boolean j;
 
     public PathfinderNormal() {}
+    // Spigot - Too many places to release these back to pool, so just keep 2 around for re-use.
+    private static final PooledMutableBlockPosition MUTABLE_BLOCK_POSITION1 = PooledMutableBlockPosition.acquire(); // Spigot
+    private static final PooledMutableBlockPosition MUTABLE_BLOCK_POSITION2 = PooledMutableBlockPosition.acquire(); // Spigot
 
     public void a(IBlockAccess iblockaccess, Entity entity) {
         super.a(iblockaccess, entity);
@@ -25,12 +28,13 @@ public class PathfinderNormal extends PathfinderAbstract {
 
         if (this.i && entity.V()) {
             i = (int) entity.getBoundingBox().b;
-            BlockPosition.MutableBlockPosition blockposition_mutableblockposition = new BlockPosition.MutableBlockPosition(MathHelper.floor(entity.locX), i, MathHelper.floor(entity.locZ));
+            PooledMutableBlockPosition blockposition_mutableblockposition = PooledMutableBlockPosition.acquire(MathHelper.floor(entity.locX), i, MathHelper.floor(entity.locZ)); // Spigot
 
             for (Block block = this.a.getType(blockposition_mutableblockposition).getBlock(); block == Blocks.FLOWING_WATER || block == Blocks.WATER; block = this.a.getType(blockposition_mutableblockposition).getBlock()) {
                 ++i;
                 blockposition_mutableblockposition.c(MathHelper.floor(entity.locX), i, MathHelper.floor(entity.locZ));
             }
+            blockposition_mutableblockposition.release(); // Spigot
 
             this.h = false;
         } else {
@@ -132,8 +136,8 @@ public class PathfinderNormal extends PathfinderAbstract {
 
     public static int a(IBlockAccess iblockaccess, Entity entity, int i, int j, int k, int l, int i1, int j1, boolean flag, boolean flag1, boolean flag2) {
         boolean flag3 = false;
-        BlockPosition blockposition = new BlockPosition(entity);
-        BlockPosition.MutableBlockPosition blockposition_mutableblockposition = new BlockPosition.MutableBlockPosition();
+        PooledMutableBlockPosition blockposition = MUTABLE_BLOCK_POSITION1;blockposition.set(entity); // Spigot
+        PooledMutableBlockPosition blockposition_mutableblockposition = MUTABLE_BLOCK_POSITION2; // Spigot
 
         for (int k1 = i; k1 < i + l; ++k1) {
             for (int l1 = j; l1 < j + i1; ++l1) {
@@ -158,8 +162,8 @@ public class PathfinderNormal extends PathfinderAbstract {
                             flag3 = true;
                         }
 
-                        if (entity.world.getType(blockposition_mutableblockposition).getBlock() instanceof BlockMinecartTrackAbstract) {
-                            if (!(entity.world.getType(blockposition).getBlock() instanceof BlockMinecartTrackAbstract) && !(entity.world.getType(blockposition.down()).getBlock() instanceof BlockMinecartTrackAbstract)) {
+                        if (block instanceof BlockMinecartTrackAbstract) { // Spigot
+                            if (!(entity.world.getType(blockposition).getBlock() instanceof BlockMinecartTrackAbstract) && !(entity.world.getType(blockposition.adjustY(-1)).getBlock() instanceof BlockMinecartTrackAbstract)) { // Spigot
                                 return -3;
                             }
                         } else if (!block.b(iblockaccess, blockposition_mutableblockposition) && (!flag1 || !(block instanceof BlockDoor) || block.getMaterial() != Material.WOOD)) {
diff --git a/src/main/java/net/minecraft/server/PooledMutableBlockPosition.java b/src/main/java/net/minecraft/server/PooledMutableBlockPosition.java
new file mode 100644
index 0000000..4c30e20
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PooledMutableBlockPosition.java
@@ -0,0 +1,126 @@
+/*
+ * Copyright (c) 2015. Starlis LLC / dba Empire Minecraft
+ *
+ * This source code is proprietary software and must not be redistributed without Starlis LLC's approval
+ *
+ */
+
+package net.minecraft.server;
+
+import com.google.common.collect.Lists;
+import org.apache.logging.log4j.Level;
+
+import java.util.List;
+
+public final class PooledMutableBlockPosition extends BlockPosition {
+
+    private int x;
+    private int y;
+    private int z;
+    private boolean free = false;
+
+    private static final int MAX_SIZE = 200;
+    private static final List<PooledMutableBlockPosition> pool = Lists.newArrayListWithExpectedSize(MAX_SIZE);
+
+    private PooledMutableBlockPosition(int x, int y, int z) {
+        super(0, 0, 0);
+        this.x = x;
+        this.y = y;
+        this.z = z;
+    }
+
+    public static PooledMutableBlockPosition acquire() {
+        return acquire(0, 0, 0);
+    }
+
+    public static PooledMutableBlockPosition acquire(Entity entity) {
+        return acquire(MathHelper.floor(entity.locX), MathHelper.floor(entity.locY), MathHelper.floor(entity.locZ));
+    }
+    public static PooledMutableBlockPosition acquire(BlockPosition pos) {
+        return acquire(pos.getX(), pos.getY(), pos.getZ());
+    }
+
+    public static synchronized PooledMutableBlockPosition acquire(int x, int y, int z) {
+        if (!pool.isEmpty()) {
+            PooledMutableBlockPosition pos = pool.remove(pool.size() - 1);
+            if (pos.free) {
+                pos.free = false;
+                pos.set(x, y, z);
+                return pos;
+            }
+        }
+        return new PooledMutableBlockPosition(x, y, z);
+    }
+
+    public void release() {
+        if (pool.size() < MAX_SIZE) {
+            pool.add(this);
+        }
+        free = true;
+    }
+
+    public int getX() {
+        return this.x;
+    }
+
+    public int getY() {
+        return this.y;
+    }
+
+    public int getZ() {
+        return this.z;
+    }
+
+    /**
+     * This method is purely to provide compile time test incase c() doesn't get renamed
+     */
+    private static void testMutableBlockPositionMethod() {
+        BlockPosition.MutableBlockPosition test = (new BlockPosition.MutableBlockPosition()).c(0,0,0);
+    }
+    // PAIL: Rename BlockPosition.MutableBlockPosition to adjust
+    public PooledMutableBlockPosition c(int x, int y, int z) {
+        return set(x, y, z);
+    }
+    public PooledMutableBlockPosition set(int x, int y, int z) {
+        if (free) {
+            MinecraftServer.LOGGER.log(Level.ERROR, "PooledMutableBlockPosition modified after it was released.", new Throwable());
+            free = false;
+        }
+        this.x = x;
+        this.y = y;
+        this.z = z;
+        return this;
+    }
+
+    public PooledMutableBlockPosition set(Entity entity) {
+        return set(MathHelper.floor(entity.locX), MathHelper.floor(entity.locY), MathHelper.floor(entity.locZ));
+    }
+
+    public PooledMutableBlockPosition adjust(int x, int y, int z) {
+        return set(this.x + x, this.y + y, this.z + z);
+    }
+
+    public PooledMutableBlockPosition adjustX(int x) {
+        return set(this.x + x, this.y, this.z);
+    }
+
+    public PooledMutableBlockPosition adjustY(int y) {
+        return set(this.x, this.y + y, this.z);
+    }
+    public PooledMutableBlockPosition adjustZ(int z) {
+        return set(this.x, this.y, this.z + z);
+    }
+
+    public PooledMutableBlockPosition adjust(EnumDirection enumdirection) {
+        return adjust(enumdirection, 1);
+    }
+
+    public PooledMutableBlockPosition adjust(EnumDirection dir, int i) {
+        return set(x + dir.getAdjacentX() * i, y + dir.getAdjacentY() * i, z + dir.getAdjacentZ() * i);
+    }
+
+    @Override
+    public int compareTo(BaseBlockPosition o) {
+        return y == o.getY() ? (z == o.getZ() ? x - o.getX() : z - o.getZ()) : y - o.getY();
+    }
+}
diff --git a/src/main/java/net/minecraft/server/World.java b/src/main/java/net/minecraft/server/World.java
index 69171a8..f857fed 100644
--- a/src/main/java/net/minecraft/server/World.java
+++ b/src/main/java/net/minecraft/server/World.java
@@ -1180,7 +1180,7 @@ public abstract class World implements IBlockAccess {
         boolean flag = entity.aT();
         boolean flag1 = this.a(worldborder, entity);
         IBlockData iblockdata = Blocks.STONE.getBlockData();
-        BlockPosition.MutableBlockPosition blockposition_mutableblockposition = new BlockPosition.MutableBlockPosition();
+        //BlockPosition.MutableBlockPosition blockposition_mutableblockposition = new BlockPosition.MutableBlockPosition(); // Spigot - not used
 
         // Spigot start
         int ystart = ( ( k - 1 ) < 0 ) ? 0 : ( k - 1 );
@@ -1283,7 +1283,7 @@ public abstract class World implements IBlockAccess {
         int l = MathHelper.floor(axisalignedbb.e + 1.0D);
         int i1 = MathHelper.floor(axisalignedbb.c);
         int j1 = MathHelper.floor(axisalignedbb.f + 1.0D);
-        BlockPosition.MutableBlockPosition blockposition_mutableblockposition = new BlockPosition.MutableBlockPosition();
+        PooledMutableBlockPosition blockposition_mutableblockposition = PooledMutableBlockPosition.acquire(); // Spigot
 
         for (int k1 = i; k1 < j; ++k1) {
             for (int l1 = i1; l1 < j1; ++l1) {
@@ -1303,6 +1303,7 @@ public abstract class World implements IBlockAccess {
                 }
             }
         }
+        blockposition_mutableblockposition.release(); // Spigot
 
         return arraylist;
     }
@@ -1729,7 +1730,7 @@ public abstract class World implements IBlockAccess {
         int l = MathHelper.floor(axisalignedbb.e);
         int i1 = MathHelper.floor(axisalignedbb.c);
         int j1 = MathHelper.floor(axisalignedbb.f);
-        BlockPosition.MutableBlockPosition blockposition_mutableblockposition = new BlockPosition.MutableBlockPosition();
+        PooledMutableBlockPosition blockposition_mutableblockposition = PooledMutableBlockPosition.acquire(); // Spigot
 
         for (int k1 = i; k1 <= j; ++k1) {
             for (int l1 = k; l1 <= l; ++l1) {
@@ -1737,11 +1738,13 @@ public abstract class World implements IBlockAccess {
                     Block block = this.getType(blockposition_mutableblockposition.c(k1, l1, i2)).getBlock();
 
                     if (block.getMaterial() != Material.AIR) {
+                        blockposition_mutableblockposition.release(); // Spigot
                         return true;
                     }
                 }
             }
         }
+        blockposition_mutableblockposition.release(); // Spigot
 
         return false;
     }
@@ -1753,7 +1756,7 @@ public abstract class World implements IBlockAccess {
         int l = MathHelper.floor(axisalignedbb.e);
         int i1 = MathHelper.floor(axisalignedbb.c);
         int j1 = MathHelper.floor(axisalignedbb.f);
-        BlockPosition.MutableBlockPosition blockposition_mutableblockposition = new BlockPosition.MutableBlockPosition();
+        PooledMutableBlockPosition blockposition_mutableblockposition = PooledMutableBlockPosition.acquire(); // Spigot
 
         for (int k1 = i; k1 <= j; ++k1) {
             for (int l1 = k; l1 <= l; ++l1) {
@@ -1761,11 +1764,13 @@ public abstract class World implements IBlockAccess {
                     Block block = this.getType(blockposition_mutableblockposition.c(k1, l1, i2)).getBlock();
 
                     if (block.getMaterial().isLiquid()) {
+                        blockposition_mutableblockposition.release(); // Spigot
                         return true;
                     }
                 }
             }
         }
+        blockposition_mutableblockposition.release(); // Spigot
 
         return false;
     }
@@ -1779,7 +1784,7 @@ public abstract class World implements IBlockAccess {
         int j1 = MathHelper.floor(axisalignedbb.f + 1.0D);
 
         if (this.isAreaLoaded(i, k, i1, j, l, j1, true)) {
-            BlockPosition.MutableBlockPosition blockposition_mutableblockposition = new BlockPosition.MutableBlockPosition();
+            PooledMutableBlockPosition blockposition_mutableblockposition = PooledMutableBlockPosition.acquire(); // Spigot
 
             for (int k1 = i; k1 < j; ++k1) {
                 for (int l1 = k; l1 < l; ++l1) {
@@ -1787,11 +1792,13 @@ public abstract class World implements IBlockAccess {
                         Block block = this.getType(blockposition_mutableblockposition.c(k1, l1, i2)).getBlock();
 
                         if (block == Blocks.FIRE || block == Blocks.FLOWING_LAVA || block == Blocks.LAVA) {
+                            blockposition_mutableblockposition.release(); // Spigot
                             return true;
                         }
                     }
                 }
             }
+            blockposition_mutableblockposition.release(); // Spigot
         }
 
         return false;
@@ -1810,7 +1817,7 @@ public abstract class World implements IBlockAccess {
         } else {
             boolean flag = false;
             Vec3D vec3d = new Vec3D(0.0D, 0.0D, 0.0D);
-            BlockPosition.MutableBlockPosition blockposition_mutableblockposition = new BlockPosition.MutableBlockPosition();
+            PooledMutableBlockPosition blockposition_mutableblockposition = PooledMutableBlockPosition.acquire(); // Spigot
 
             for (int k1 = i; k1 < j; ++k1) {
                 for (int l1 = k; l1 < l; ++l1) {
@@ -1830,6 +1837,7 @@ public abstract class World implements IBlockAccess {
                     }
                 }
             }
+            blockposition_mutableblockposition.release(); // Spigot
 
             if (vec3d.b() > 0.0D && entity.aL()) {
                 vec3d = vec3d.a();
@@ -1851,17 +1859,19 @@ public abstract class World implements IBlockAccess {
         int l = MathHelper.floor(axisalignedbb.e + 1.0D);
         int i1 = MathHelper.floor(axisalignedbb.c);
         int j1 = MathHelper.floor(axisalignedbb.f + 1.0D);
-        BlockPosition.MutableBlockPosition blockposition_mutableblockposition = new BlockPosition.MutableBlockPosition();
+        PooledMutableBlockPosition blockposition_mutableblockposition = PooledMutableBlockPosition.acquire(); // Spigot
 
         for (int k1 = i; k1 < j; ++k1) {
             for (int l1 = k; l1 < l; ++l1) {
                 for (int i2 = i1; i2 < j1; ++i2) {
                     if (this.getType(blockposition_mutableblockposition.c(k1, l1, i2)).getBlock().getMaterial() == material) {
+                        blockposition_mutableblockposition.release(); // Spigot
                         return true;
                     }
                 }
             }
         }
+        blockposition_mutableblockposition.release(); // Spigot
 
         return false;
     }
@@ -1873,7 +1883,7 @@ public abstract class World implements IBlockAccess {
         int l = MathHelper.floor(axisalignedbb.e + 1.0D);
         int i1 = MathHelper.floor(axisalignedbb.c);
         int j1 = MathHelper.floor(axisalignedbb.f + 1.0D);
-        BlockPosition.MutableBlockPosition blockposition_mutableblockposition = new BlockPosition.MutableBlockPosition();
+        PooledMutableBlockPosition blockposition_mutableblockposition = PooledMutableBlockPosition.acquire(); // Spigot
 
         for (int k1 = i; k1 < j; ++k1) {
             for (int l1 = k; l1 < l; ++l1) {
@@ -1890,12 +1900,14 @@ public abstract class World implements IBlockAccess {
                         }
 
                         if (d0 >= axisalignedbb.b) {
+                            blockposition_mutableblockposition.release(); // Spigot
                             return true;
                         }
                     }
                 }
             }
         }
+        blockposition_mutableblockposition.release(); // Spigot
 
         return false;
     }
@@ -2383,12 +2395,13 @@ public abstract class World implements IBlockAccess {
             } else if (i >= 14) {
                 return i;
             } else {
+                PooledMutableBlockPosition mutable = PooledMutableBlockPosition.acquire(blockposition); // Spigot
                 EnumDirection[] aenumdirection = EnumDirection.values();
                 int k = aenumdirection.length;
 
                 for (int l = 0; l < k; ++l) {
                     EnumDirection enumdirection = aenumdirection[l];
-                    BlockPosition blockposition1 = blockposition.shift(enumdirection);
+                    BlockPosition blockposition1 = mutable.adjust(enumdirection); // Spigot
                     int i1 = this.b(enumskyblock, blockposition1) - j;
 
                     if (i1 > i) {
@@ -2396,9 +2409,11 @@ public abstract class World implements IBlockAccess {
                     }
 
                     if (i >= 14) {
+                        mutable.release(); // Spigot
                         return i;
                     }
                 }
+                mutable.release(); // Spigto
 
                 return i;
             }
@@ -2441,7 +2456,7 @@ public abstract class World implements IBlockAccess {
                     j2 = (l1 >> 6 & 63) - 32 + j1;
                     k2 = (l1 >> 12 & 63) - 32 + k1;
                     int l3 = l1 >> 18 & 15;
-                    BlockPosition blockposition1 = new BlockPosition(i2, j2, k2);
+                    PooledMutableBlockPosition blockposition1 = PooledMutableBlockPosition.acquire(i2, j2, k2); // Spigot
 
                     l2 = this.b(enumskyblock, blockposition1);
                     if (l2 == l3) {
@@ -2451,7 +2466,7 @@ public abstract class World implements IBlockAccess {
                             j3 = MathHelper.a(j2 - j1);
                             k3 = MathHelper.a(k2 - k1);
                             if (i3 + j3 + k3 < 17) {
-                                BlockPosition.MutableBlockPosition blockposition_mutableblockposition = new BlockPosition.MutableBlockPosition();
+                                PooledMutableBlockPosition blockposition_mutableblockposition = PooledMutableBlockPosition.acquire(); // Spigot
                                 EnumDirection[] aenumdirection = EnumDirection.values();
                                 int i4 = aenumdirection.length;
 
@@ -2469,9 +2484,11 @@ public abstract class World implements IBlockAccess {
                                         this.H[j++] = k4 - i1 + 32 | l4 - j1 + 32 << 6 | i5 - k1 + 32 << 12 | l3 - j5 << 18;
                                     }
                                 }
+                                blockposition_mutableblockposition.release(); // Spigot
                             }
                         }
                     }
+                    blockposition1.release(); // Spigot
                 }
 
                 i = 0;
diff --git a/src/main/java/org/bukkit/craftbukkit/block/CraftBlock.java b/src/main/java/org/bukkit/craftbukkit/block/CraftBlock.java
index 22a8055..b44f4ed 100644
--- a/src/main/java/org/bukkit/craftbukkit/block/CraftBlock.java
+++ b/src/main/java/org/bukkit/craftbukkit/block/CraftBlock.java
@@ -24,6 +24,8 @@ import org.bukkit.metadata.MetadataValue;
 import org.bukkit.plugin.Plugin;
 import org.bukkit.util.BlockVector;
 
+import net.minecraft.server.PooledMutableBlockPosition;
+
 public class CraftBlock implements Block {
     private final CraftChunk chunk;
     private final int x;
@@ -102,13 +104,17 @@ public class CraftBlock implements Block {
 
     private void setData(final byte data, int flag) {
         net.minecraft.server.World world = chunk.getHandle().getWorld();
-        BlockPosition position = new BlockPosition(x, y, z);
+        final PooledMutableBlockPosition position = PooledMutableBlockPosition.acquire(this.x, this.y, this.z); // Spigot
         IBlockData blockData = world.getType(position);
         world.setTypeAndData(position, blockData.getBlock().fromLegacyData(data), flag);
+        position.release(); // Spigot
     }
 
     public byte getData() {
-        IBlockData blockData = chunk.getHandle().getBlockData(new BlockPosition(x, y, z));
+        // Spigot - pooled BlockPosition
+        final PooledMutableBlockPosition position = PooledMutableBlockPosition.acquire(this.x, this.y, this.z); // Spigot
+        IBlockData blockData = chunk.getHandle().getBlockData(position);
+        position.release();
         return (byte) blockData.getBlock().toLegacyData(blockData);
     }
 
@@ -132,14 +138,17 @@ public class CraftBlock implements Block {
 
     public boolean setTypeIdAndData(final int type, final byte data, final boolean applyPhysics) {
         IBlockData blockData = getNMSBlock(type).fromLegacyData(data);
-        BlockPosition position = new BlockPosition(x, y, z);
+        final PooledMutableBlockPosition position = PooledMutableBlockPosition.acquire(this.x, this.y, this.z); // Spigot
         if (applyPhysics) {
-            return chunk.getHandle().getWorld().setTypeAndData(position, blockData, 3);
+            final boolean ret = chunk.getHandle().getWorld().setTypeAndData(position, blockData, 3);
+            position.release(); // Spigot
+            return ret;
         } else {
             boolean success = chunk.getHandle().getWorld().setTypeAndData(position, blockData, 2);
             if (success) {
                 chunk.getHandle().getWorld().notify(position);
             }
+            position.release(); // Spigot
             return success;
         }
     }
@@ -151,19 +160,35 @@ public class CraftBlock implements Block {
     @Deprecated
     @Override
     public int getTypeId() {
-        return CraftMagicNumbers.getId(chunk.getHandle().getType(new BlockPosition(this.x, this.y, this.z)));
+        // Spigot - pooled BlockPosition
+        final PooledMutableBlockPosition blockposition = PooledMutableBlockPosition.acquire(this.x, this.y, this.z);
+        final net.minecraft.server.Block type = chunk.getHandle().getType(blockposition);
+        blockposition.release();
+        return CraftMagicNumbers.getId(type);
     }
 
     public byte getLightLevel() {
-        return (byte) chunk.getHandle().getWorld().getLightLevel(new BlockPosition(this.x, this.y, this.z));
+        // Spigot - pooled BlockPosition
+        final PooledMutableBlockPosition blockposition = PooledMutableBlockPosition.acquire(this.x, this.y, this.z);
+        final byte lightLevel = (byte) chunk.getHandle().getWorld().getLightLevel(blockposition);
+        blockposition.release();
+        return lightLevel;
     }
 
     public byte getLightFromSky() {
-        return (byte) chunk.getHandle().getBrightness(EnumSkyBlock.SKY, new BlockPosition(this.x, this.y, this.z));
+        // Spigot - pooled BlockPosition
+        final PooledMutableBlockPosition blockposition = PooledMutableBlockPosition.acquire(this.x, this.y, this.z);
+        final byte brightness = (byte) chunk.getHandle().getBrightness(EnumSkyBlock.SKY, blockposition);
+        blockposition.release();
+        return brightness;
     }
 
     public byte getLightFromBlocks() {
-        return (byte) chunk.getHandle().getBrightness(EnumSkyBlock.BLOCK, new BlockPosition(this.x, this.y, this.z));
+        // Spigot - pooled BlockPosition
+        final PooledMutableBlockPosition blockposition = PooledMutableBlockPosition.acquire(this.x, this.y, this.z);
+        final byte brightness = (byte) chunk.getHandle().getBrightness(EnumSkyBlock.BLOCK, blockposition);
+        blockposition.release();
+        return brightness;
     }
 
 
@@ -359,14 +384,17 @@ public class CraftBlock implements Block {
 
     public int getBlockPower(BlockFace face) {
         int power = 0;
+        // Spigot - replace all positions with position.set()
+        final PooledMutableBlockPosition position = PooledMutableBlockPosition.acquire(this.x, this.y, this.z); // Spigot
         BlockRedstoneWire wire = Blocks.REDSTONE_WIRE;
         net.minecraft.server.World world = chunk.getHandle().getWorld();
-        if ((face == BlockFace.DOWN || face == BlockFace.SELF) && world.isBlockFacePowered(new BlockPosition(x, y - 1, z), EnumDirection.DOWN)) power = wire.getPower(world, new BlockPosition(x, y - 1, z), power);
-        if ((face == BlockFace.UP || face == BlockFace.SELF) && world.isBlockFacePowered(new BlockPosition(x, y + 1, z), EnumDirection.UP)) power = wire.getPower(world, new BlockPosition(x, y + 1, z), power);
-        if ((face == BlockFace.EAST || face == BlockFace.SELF) && world.isBlockFacePowered(new BlockPosition(x + 1, y, z), EnumDirection.EAST)) power = wire.getPower(world, new BlockPosition(x + 1, y, z), power);
-        if ((face == BlockFace.WEST || face == BlockFace.SELF) && world.isBlockFacePowered(new BlockPosition(x - 1, y, z), EnumDirection.WEST)) power = wire.getPower(world, new BlockPosition(x - 1, y, z), power);
-        if ((face == BlockFace.NORTH || face == BlockFace.SELF) && world.isBlockFacePowered(new BlockPosition(x, y, z - 1), EnumDirection.NORTH)) power = wire.getPower(world, new BlockPosition(x, y, z - 1), power);
-        if ((face == BlockFace.SOUTH || face == BlockFace.SELF) && world.isBlockFacePowered(new BlockPosition(x, y, z + 1), EnumDirection.SOUTH)) power = wire.getPower(world, new BlockPosition(x, y, z - 1), power);
+        if ((face == BlockFace.DOWN || face == BlockFace.SELF) && world.isBlockFacePowered(position.set(x, y - 1, z), EnumDirection.DOWN)) power = wire.getPower(world, position.set(x, y - 1, z), power);
+        if ((face == BlockFace.UP || face == BlockFace.SELF) && world.isBlockFacePowered(position.set(x, y + 1, z), EnumDirection.UP)) power = wire.getPower(world, position.set(x, y + 1, z), power);
+        if ((face == BlockFace.EAST || face == BlockFace.SELF) && world.isBlockFacePowered(position.set(x + 1, y, z), EnumDirection.EAST)) power = wire.getPower(world, position.set(x + 1, y, z), power);
+        if ((face == BlockFace.WEST || face == BlockFace.SELF) && world.isBlockFacePowered(position.set(x - 1, y, z), EnumDirection.WEST)) power = wire.getPower(world, position.set(x - 1, y, z), power);
+        if ((face == BlockFace.NORTH || face == BlockFace.SELF) && world.isBlockFacePowered(position.set(x, y, z - 1), EnumDirection.NORTH)) power = wire.getPower(world, position.set(x, y, z - 1), power);
+        if ((face == BlockFace.SOUTH || face == BlockFace.SELF) && world.isBlockFacePowered(position.set(x, y, z + 1), EnumDirection.SOUTH)) power = wire.getPower(world, position.set(x, y, z - 1), power);
+        position.release(); // Spigot
         return power > 0 ? power : (face == BlockFace.SELF ? isBlockIndirectlyPowered() : isBlockFaceIndirectlyPowered(face)) ? 15 : 0;
     }
 
-- 
1.9.1

