From cc2bbc13e3f593351ad7bf94619ac04b4c8a2f68 Mon Sep 17 00:00:00 2001
From: md_5 <md_5@bigpond.com>
Date: Thu, 9 Jan 2014 20:58:09 -0500
Subject: [PATCH] Spigot

---
 pom.xml                                            |  52 ++----
 src/main/java/org/bukkit/Effect.java               | 196 ++++++++++++++++++++-
 src/main/java/org/bukkit/World.java                |  50 ++++++
 .../java/org/bukkit/command/SimpleCommandMap.java  |  14 ++
 .../bukkit/command/defaults/PluginsCommand.java    |   8 +
 .../org/bukkit/command/defaults/ReloadCommand.java |   9 +
 .../org/bukkit/command/defaults/SayCommand.java    |   2 +-
 .../org/bukkit/command/defaults/TellCommand.java   |  12 ++
 .../bukkit/command/defaults/TestForCommand.java    |  12 ++
 .../bukkit/command/defaults/TimingsCommand.java    | 111 +++++++++++-
 .../org/bukkit/conversations/BooleanPrompt.java    |   3 +-
 .../org/bukkit/conversations/Conversation.java     |   7 +
 .../bukkit/conversations/ConversationContext.java  |   8 +
 src/main/java/org/bukkit/entity/Arrow.java         |  20 ++-
 src/main/java/org/bukkit/entity/Entity.java        |  18 ++
 src/main/java/org/bukkit/entity/Player.java        |  53 ++++++
 .../bukkit/event/entity/CreatureSpawnEvent.java    |  32 +---
 .../org/bukkit/event/entity/EntitySpawnEvent.java  |  45 +++++
 .../org/bukkit/event/entity/ItemSpawnEvent.java    |  40 +----
 .../org/bukkit/event/entity/SpawnerSpawnEvent.java |  22 +++
 .../event/inventory/InventoryClickEvent.java       |  16 ++
 .../bukkit/event/player/PlayerItemDamageEvent.java |  54 ++++++
 .../org/bukkit/event/player/PlayerLoginEvent.java  |  27 ++-
 .../org/bukkit/plugin/PluginDescriptionFile.java   |   4 -
 .../org/bukkit/plugin/SimplePluginManager.java     |   1 +
 .../org/bukkit/plugin/TimedRegisteredListener.java |  21 ++-
 .../java/org/bukkit/plugin/java/JavaPlugin.java    | 176 +++++-------------
 .../org/bukkit/plugin/java/JavaPluginLoader.java   | 175 ++++++++++++++----
 .../org/bukkit/plugin/java/PluginClassLoader.java  | 116 ++++++------
 .../messaging/ChannelNotRegisteredException.java   |   2 +-
 .../bukkit/plugin/messaging/StandardMessenger.java |  10 +-
 src/main/java/org/bukkit/util/StringUtil.java      |   6 +-
 .../java/org/spigotmc/CustomTimingsHandler.java    | 175 ++++++++++++++++++
 .../spigotmc/event/entity/EntityDismountEvent.java |  39 ++++
 .../spigotmc/event/entity/EntityMountEvent.java    |  52 ++++++
 src/test/java/org/bukkit/EffectTest.java           |   6 +-
 .../bukkit/plugin/TimedRegisteredListenerTest.java |   1 -
 .../org/bukkit/util/StringUtilStartsWithTest.java  |  86 ---------
 src/test/java/org/bukkit/util/StringUtilTest.java  |  61 -------
 39 files changed, 1241 insertions(+), 501 deletions(-)
 create mode 100644 src/main/java/org/bukkit/event/entity/EntitySpawnEvent.java
 create mode 100644 src/main/java/org/bukkit/event/entity/SpawnerSpawnEvent.java
 create mode 100644 src/main/java/org/bukkit/event/player/PlayerItemDamageEvent.java
 create mode 100644 src/main/java/org/spigotmc/CustomTimingsHandler.java
 create mode 100644 src/main/java/org/spigotmc/event/entity/EntityDismountEvent.java
 create mode 100644 src/main/java/org/spigotmc/event/entity/EntityMountEvent.java
 delete mode 100644 src/test/java/org/bukkit/util/StringUtilStartsWithTest.java
 delete mode 100644 src/test/java/org/bukkit/util/StringUtilTest.java

diff --git a/pom.xml b/pom.xml
index 6c07c03..f6ee82d 100644
--- a/pom.xml
+++ b/pom.xml
@@ -1,43 +1,23 @@
 <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
     <modelVersion>4.0.0</modelVersion>
-    <groupId>org.bukkit</groupId>
-    <artifactId>bukkit</artifactId>
+
+    <parent>
+        <groupId>org.spigotmc</groupId>
+        <artifactId>spigot-parent</artifactId>
+        <version>dev-SNAPSHOT</version>
+        <relativePath>../pom.xml</relativePath>
+    </parent>
+
+    <groupId>org.spigotmc</groupId>
+    <artifactId>spigot-api</artifactId>
     <version>1.7.2-R0.3-SNAPSHOT</version>
-    <name>Bukkit</name>
-    <url>http://www.bukkit.org</url>
+    <name>Spigot-API</name>
+    <url>http://www.spigotmc.org</url>
 
     <properties>
         <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
     </properties>
 
-    <scm>
-        <developerConnection>scm:git:git@github.com:Bukkit/Bukkit.git</developerConnection>
-        <connection>scm:git:git://github.com/Bukkit/Bukkit.git</connection>
-        <url>https://github.com/Bukkit/Bukkit/tree/master/</url>
-    </scm>
-
-    <ciManagement>
-        <system>jenkins</system>
-        <url>http://ci.bukkit.org</url>
-    </ciManagement>
-
-    <distributionManagement>
-        <site>
-            <id>jd.bukkit.org</id>
-            <url>file:///home/javadocs/public_html/</url>
-        </site>
-        <repository>
-            <id>repobo-rel</id>
-            <name>repo.bukkit.org Releases</name>
-            <url>http://repo.bukkit.org/content/repositories/releases/</url>
-        </repository>
-        <snapshotRepository>
-            <id>repobo-snap</id>
-            <name>repo.bukkit.org Snapshots</name>
-            <url>http://repo.bukkit.org/content/repositories/snapshots/</url>
-        </snapshotRepository>
-    </distributionManagement>
-
     <build>
         <plugins>
             <plugin>
@@ -97,21 +77,21 @@
         <dependency>
             <groupId>org.yaml</groupId>
             <artifactId>snakeyaml</artifactId>
-            <version>1.9</version>
+            <version>1.12</version>
             <type>jar</type>
             <scope>compile</scope>
         </dependency>
         <dependency>
             <groupId>com.googlecode.json-simple</groupId>
             <artifactId>json-simple</artifactId>
-            <version>1.1</version>
+            <version>1.1.1</version>
             <type>jar</type>
             <scope>compile</scope>
         </dependency>
         <dependency>
             <groupId>org.avaje</groupId>
             <artifactId>ebean</artifactId>
-            <version>2.7.3</version>
+            <version>2.8.1</version>
             <type>jar</type>
             <scope>compile</scope>
         </dependency>
@@ -125,7 +105,7 @@
         <dependency>
             <groupId>commons-lang</groupId>
             <artifactId>commons-lang</artifactId>
-            <version>2.3</version>
+            <version>2.6</version>
         </dependency>
 
         <!-- testing -->
diff --git a/src/main/java/org/bukkit/Effect.java b/src/main/java/org/bukkit/Effect.java
index 2474a2d..3b71c11 100644
--- a/src/main/java/org/bukkit/Effect.java
+++ b/src/main/java/org/bukkit/Effect.java
@@ -5,6 +5,7 @@ import java.util.Map;
 import com.google.common.collect.Maps;
 
 import org.bukkit.block.BlockFace;
+import org.bukkit.material.MaterialData;
 import org.bukkit.potion.Potion;
 
 /**
@@ -79,27 +80,178 @@ public enum Effect {
     /**
      * The flames seen on a mobspawner; a visual effect.
      */
-    MOBSPAWNER_FLAMES(2004, Type.VISUAL);
+    MOBSPAWNER_FLAMES(2004, Type.VISUAL),
+    /**
+     * The spark that comes off a fireworks
+     */
+    FIREWORKS_SPARK("fireworksSpark", Type.PARTICLE),
+    /**
+     * Critical hit particles
+     */
+    CRIT("crit", Type.PARTICLE),
+    /**
+     * Blue critical hit particles
+     */
+    MAGIC_CRIT("magicCrit", Type.PARTICLE),
+    /**
+     * Multicolored potion effect particles
+     */
+    POTION_SWIRL("mobSpell", Type.PARTICLE),
+    /**
+     * Multicolored potion effect particles that are slightly transparent
+     */
+    POTION_SWIRL_TRANSPARENT("mobSpellAmbient", Type.PARTICLE),
+    /**
+     * A puff of white potion swirls
+     */
+    SPELL("spell", Type.PARTICLE),
+    /**
+     * A puff of white stars
+     */
+    INSTANT_SPELL("instantSpell", Type.PARTICLE),
+    /**
+     * A puff of purple particles
+     */
+    WITCH_MAGIC("witchMagic", Type.PARTICLE),
+    /**
+     * The note that appears above note blocks
+     */
+    NOTE("note", Type.PARTICLE),
+    /**
+     * The particles shown at nether portals
+     */
+    PORTAL("portal", Type.PARTICLE),
+    /**
+     * The symbols that fly towards the enchantment table
+     */
+    FLYING_GLYPH("enchantmenttable", Type.PARTICLE),
+    /**
+     * Fire particles
+     */
+    FLAME("flame", Type.PARTICLE),
+    /**
+     * The particles that pop out of lava
+     */
+    LAVA_POP("lava", Type.PARTICLE),
+    /**
+     * A small gray square
+     */
+    FOOTSTEP("footstep", Type.PARTICLE),
+    /**
+     * Water particles
+     */
+    SPLASH("splash", Type.PARTICLE),
+    /**
+     * Smoke particles
+     */
+    PARTICLE_SMOKE("smoke", Type.PARTICLE),
+    /**
+     * The biggest explosion particle effect
+     */
+    EXPLOSION_HUGE("hugeexplosion", Type.PARTICLE),
+    /**
+     * A larger version of the explode particle
+     */
+    EXPLOSION_LARGE("largeexplode", Type.PARTICLE),
+    /**
+     * Explosion particles
+     */
+    EXPLOSION("explode", Type.PARTICLE),
+    /**
+     * Small gray particles
+     */
+    VOID_FOG("depthsuspend", Type.PARTICLE),
+    /**
+     * Small gray particles
+     */
+    SMALL_SMOKE("townaura", Type.PARTICLE),
+    /**
+     * A puff of white smoke
+     */
+    CLOUD("cloud", Type.PARTICLE),
+    /**
+     * Multicolored dust particles
+     */
+    COLOURED_DUST("reddust", Type.PARTICLE),
+    /**
+     * Snowball breaking
+     */
+    SNOWBALL_BREAK("snowballpoof", Type.PARTICLE),
+    /**
+     * The water drip particle that appears on blocks under water
+     */
+    WATERDRIP("dripWater", Type.PARTICLE),
+    /**
+     * The lava drip particle that appears on blocks under lava
+     */
+    LAVADRIP("dripLava", Type.PARTICLE),
+    /**
+     * White particles
+     */
+    SNOW_SHOVEL("snowshovel", Type.PARTICLE),
+    /**
+     * The particle shown when a slime jumps
+     */
+    SLIME("slime", Type.PARTICLE),
+    /**
+     * The particle that appears when breading animals
+     */
+    HEART("heart", Type.PARTICLE),
+    /**
+     * The particle that appears when hitting a villager
+     */
+    VILLAGER_THUNDERCLOUD("angryVillager", Type.PARTICLE),
+    /**
+     * The particle that appears when trading with a villager
+     */
+    HAPPY_VILLAGER("happyVillager", Type.PARTICLE),
+    /**
+     * The particles generated when a tool breaks.
+     * This particle requires a Material so that the client can select the correct texture.
+     */
+    ITEM_BREAK("iconcrack", Type.PARTICLE, Material.class),
+    /**
+     * The particles generated while breaking a block.
+     * This particle requires a Material and data value so that the client can select the correct texture.
+     */
+    TILE_BREAK("blockcrack", Type.PARTICLE, MaterialData.class);
 
     private final int id;
     private final Type type;
     private final Class<?> data;
     private static final Map<Integer, Effect> BY_ID = Maps.newHashMap();
+    private static final Map<String, Effect> BY_NAME = Maps.newHashMap();
+    private final String particleName;
 
-    Effect(int id, Type type) {
+    private Effect(int id, Type type) {
         this(id,type,null);
     }
 
-    Effect(int id, Type type, Class<?> data) {
+    private Effect(int id, Type type, Class<?> data) {
         this.id = id;
         this.type = type;
         this.data = data;
+        particleName = null;
+    }
+
+    private Effect(String particleName, Type type, Class<?> data) {
+        this.particleName = particleName;
+        this.type = type;
+        id = 0;
+        this.data = data;
+    }
+
+    private Effect(String particleName, Type type) {
+        this.particleName = particleName;
+        this.type = type;
+        id = 0;
+        this.data = null;
     }
 
     /**
      * Gets the ID for this effect.
      *
-     * @return ID of this effect
+     * @return if this Effect isn't of type PARTICLE it returns ID of this effect
      * @deprecated Magic value
      */
     @Deprecated
@@ -108,6 +260,15 @@ public enum Effect {
     }
 
     /**
+     * Returns the effect's name. This returns null if the effect is not a particle
+     *
+     * @return The effect's name
+     */
+    public String getName() {
+        return particleName;
+    }
+
+    /**
      * @return The type of the effect.
      */
     public Type getType() {
@@ -115,8 +276,7 @@ public enum Effect {
     }
 
     /**
-     * @return The class which represents data for this effect, or null if
-     *     none
+     * @return if this Effect isn't of type PARTICLE it returns the class which represents data for this effect, or null if none
      */
     public Class<?> getData() {
         return this.data;
@@ -136,12 +296,32 @@ public enum Effect {
 
     static {
         for (Effect effect : values()) {
-            BY_ID.put(effect.id, effect);
+            if (effect.type != Type.PARTICLE) {
+                BY_ID.put(effect.id, effect);
+            }
+        }
+    }
+
+    /**
+     * Gets the Effect associated with the given name.
+     *
+     * @param name name of the Effect to return
+     * @return Effect with the given name
+     */
+    public static Effect getByName(String name) {
+        return BY_NAME.get(name);
+    }
+
+    static {
+        for (Effect effect : values()) {
+            if (effect.type == Type.PARTICLE) {
+                BY_NAME.put(effect.particleName, effect);
+            }
         }
     }
 
     /**
      * Represents the type of an effect.
      */
-    public enum Type {SOUND, VISUAL}
+    public enum Type {SOUND, VISUAL, PARTICLE}
 }
diff --git a/src/main/java/org/bukkit/World.java b/src/main/java/org/bukkit/World.java
index f02bfb7..a58eb05 100644
--- a/src/main/java/org/bukkit/World.java
+++ b/src/main/java/org/bukkit/World.java
@@ -1151,6 +1151,56 @@ public interface World extends PluginMessageRecipient, Metadatable {
      */
     public boolean isGameRule(String rule);
 
+    // Spigot start
+    public class Spigot
+    {
+
+        /**
+         * Plays an effect to all players within a default radius around a given
+         * location.
+         *
+         * @param location the {@link Location} around which players must be to
+         * see the effect
+         * @param effect the {@link Effect}
+         * @throws IllegalArgumentException if the location or effect is null.
+         * It also throws when the effect requires a material or a material data
+         */
+        public void playEffect(Location location, Effect effect)
+        {
+            throw new UnsupportedOperationException( "Not supported yet." );
+        }
+
+        /**
+         * Plays an effect to all players within a default radius around a given
+         * location. The effect will use the provided material (and material
+         * data if required). The particle's position on the client will be the
+         * given location, adjusted on each axis by a normal distribution with
+         * mean 0 and standard deviation given in the offset parameters, each
+         * particle has independently calculated offsets. The effect will have
+         * the given speed and particle count if the effect is a particle. Some
+         * effect will create multiple particles.
+         *
+         * @param location the {@link Location} around which players must be to
+         * see the effect
+         * @param effect effect the {@link Effect}
+         * @param id the item/block/data id for the effect
+         * @param data the data value of the block/item for the effect
+         * @param offsetX the amount to be randomly offset by in the X axis
+         * @param offsetY the amount to be randomly offset by in the Y axis
+         * @param offsetZ the amount to be randomly offset by in the Z axis
+         * @param speed the speed of the particles
+         * @param particleCount the number of particles
+         * @param radius the radius around the location
+         */
+        public void playEffect(Location location, Effect effect, int id, int data, float offsetX, float offsetY, float offsetZ, float speed, int particleCount, int radius)
+        {
+            throw new UnsupportedOperationException( "Not supported yet." );
+        }
+    }
+
+    Spigot spigot();
+    // Spigot end
+
     /**
      * Represents various map environment types that a world may be
      */
diff --git a/src/main/java/org/bukkit/command/SimpleCommandMap.java b/src/main/java/org/bukkit/command/SimpleCommandMap.java
index c2f488a..9283b23 100644
--- a/src/main/java/org/bukkit/command/SimpleCommandMap.java
+++ b/src/main/java/org/bukkit/command/SimpleCommandMap.java
@@ -330,4 +330,18 @@ public class SimpleCommandMap implements CommandMap {
             }
         }
     }
+
+    // Spigot Start
+    public static void removeFallback(String name)
+    {
+        Iterator<VanillaCommand> it = fallbackCommands.iterator();
+        while ( it.hasNext() )
+        {
+            if ( it.next().getName().equals( name ) )
+            {
+                it.remove();
+            }
+        }
+    }
+    // Spigot End
 }
diff --git a/src/main/java/org/bukkit/command/defaults/PluginsCommand.java b/src/main/java/org/bukkit/command/defaults/PluginsCommand.java
index b888da1..e21d167 100644
--- a/src/main/java/org/bukkit/command/defaults/PluginsCommand.java
+++ b/src/main/java/org/bukkit/command/defaults/PluginsCommand.java
@@ -40,4 +40,12 @@ public class PluginsCommand extends BukkitCommand {
 
         return "(" + plugins.length + "): " + pluginList.toString();
     }
+
+    // Spigot Start
+    @Override
+    public java.util.List<String> tabComplete(CommandSender sender, String alias, String[] args) throws IllegalArgumentException
+    {
+        return java.util.Collections.emptyList();
+    }
+    // Spigot End
 }
diff --git a/src/main/java/org/bukkit/command/defaults/ReloadCommand.java b/src/main/java/org/bukkit/command/defaults/ReloadCommand.java
index fb3c90f..16dfdbd 100644
--- a/src/main/java/org/bukkit/command/defaults/ReloadCommand.java
+++ b/src/main/java/org/bukkit/command/defaults/ReloadCommand.java
@@ -20,9 +20,18 @@ public class ReloadCommand extends BukkitCommand {
     public boolean execute(CommandSender sender, String currentAlias, String[] args) {
         if (!testPermission(sender)) return true;
 
+        org.spigotmc.CustomTimingsHandler.reload(); // Spigot: TODO: Why is this here?
         Bukkit.reload();
         Command.broadcastCommandMessage(sender, ChatColor.GREEN + "Reload complete.");
 
         return true;
     }
+
+    // Spigot Start
+    @Override
+    public java.util.List<String> tabComplete(CommandSender sender, String alias, String[] args) throws IllegalArgumentException
+    {
+        return java.util.Collections.emptyList();
+    }
+    // Spigot End
 }
diff --git a/src/main/java/org/bukkit/command/defaults/SayCommand.java b/src/main/java/org/bukkit/command/defaults/SayCommand.java
index 658fe21..c48c5c3 100644
--- a/src/main/java/org/bukkit/command/defaults/SayCommand.java
+++ b/src/main/java/org/bukkit/command/defaults/SayCommand.java
@@ -14,7 +14,7 @@ import com.google.common.collect.ImmutableList;
 public class SayCommand extends VanillaCommand {
     public SayCommand() {
         super("say");
-        this.description = "Broadcasts the given message as the sender";
+        this.description = "Broadcasts the given message as the console";
         this.usageMessage = "/say <message ...>";
         this.setPermission("bukkit.command.say");
     }
diff --git a/src/main/java/org/bukkit/command/defaults/TellCommand.java b/src/main/java/org/bukkit/command/defaults/TellCommand.java
index d0aa102..0c2c9a1 100644
--- a/src/main/java/org/bukkit/command/defaults/TellCommand.java
+++ b/src/main/java/org/bukkit/command/defaults/TellCommand.java
@@ -48,4 +48,16 @@ public class TellCommand extends VanillaCommand {
     public boolean matches(String input) {
         return input.equalsIgnoreCase("tell") || input.equalsIgnoreCase("w") || input.equalsIgnoreCase("msg");
     }
+
+    // Spigot Start
+    @Override
+    public java.util.List<String> tabComplete(CommandSender sender, String alias, String[] args) throws IllegalArgumentException
+    {
+        if ( args.length == 0 )
+        {
+            return super.tabComplete( sender, alias, args );
+        }
+        return java.util.Collections.emptyList();
+    }
+    // Spigot End
 }
diff --git a/src/main/java/org/bukkit/command/defaults/TestForCommand.java b/src/main/java/org/bukkit/command/defaults/TestForCommand.java
index c9ac1ce..a687fef 100644
--- a/src/main/java/org/bukkit/command/defaults/TestForCommand.java
+++ b/src/main/java/org/bukkit/command/defaults/TestForCommand.java
@@ -23,4 +23,16 @@ public class TestForCommand extends VanillaCommand {
         sender.sendMessage(ChatColor.RED + "/testfor is only usable by commandblocks with analog output.");
         return true;
     }
+
+    // Spigot Start
+    @Override
+    public java.util.List<String> tabComplete(CommandSender sender, String alias, String[] args) throws IllegalArgumentException
+    {
+        if ( args.length == 0 )
+        {
+            return super.tabComplete( sender, alias, args );
+        }
+        return java.util.Collections.emptyList();
+    }
+    // Spigot End
 }
diff --git a/src/main/java/org/bukkit/command/defaults/TimingsCommand.java b/src/main/java/org/bukkit/command/defaults/TimingsCommand.java
index 05cfcb0..ec1320f 100644
--- a/src/main/java/org/bukkit/command/defaults/TimingsCommand.java
+++ b/src/main/java/org/bukkit/command/defaults/TimingsCommand.java
@@ -19,30 +19,60 @@ import org.bukkit.util.StringUtil;
 
 import com.google.common.collect.ImmutableList;
 
+// Spigot start
+import java.io.ByteArrayOutputStream;
+import java.io.OutputStream;
+import java.net.HttpURLConnection;
+import java.net.URL;
+import java.net.URLEncoder;
+import java.util.logging.Level;
+// Spigot end
+
 public class TimingsCommand extends BukkitCommand {
     private static final List<String> TIMINGS_SUBCOMMANDS = ImmutableList.of("merged", "reset", "separate");
+    public static long timingStart = 0; // Spigot
 
     public TimingsCommand(String name) {
         super(name);
         this.description = "Records timings for all plugin events";
-        this.usageMessage = "/timings <reset|merged|separate>";
+        this.usageMessage = "/timings <reset|merged|separate|on|off> [paste]"; // Spigot
         this.setPermission("bukkit.command.timings");
     }
 
     @Override
     public boolean execute(CommandSender sender, String currentAlias, String[] args) {
         if (!testPermission(sender)) return true;
-        if (args.length != 1)  {
+        if (args.length < 1)  { // Spigot
             sender.sendMessage(ChatColor.RED + "Usage: " + usageMessage);
             return false;
         }
-        if (!sender.getServer().getPluginManager().useTimings()) {
+        /*if (!sender.getServer().getPluginManager().useTimings()) {
             sender.sendMessage("Please enable timings by setting \"settings.plugin-profiling\" to true in bukkit.yml");
             return true;
+        }*/
+
+        // Spigot start - dynamic enable
+        if ( "on".equals( args[0] ) )
+        {
+            ( (org.bukkit.plugin.SimplePluginManager) Bukkit.getPluginManager() ).useTimings( true );
+            sender.sendMessage( "Enabled Timings" );
+        } else if ( "off".equals( args[0] ) )
+        {
+            ( (org.bukkit.plugin.SimplePluginManager) Bukkit.getPluginManager() ).useTimings( false );
+            sender.sendMessage( "Disabled Timings" );
         }
+        // Spigot end
 
         boolean separate = "separate".equals(args[0]);
-        if ("reset".equals(args[0])) {
+        boolean paste = "paste".equals( args[0] ); // Spigot
+        if ("on".equals(args[0]) || "reset".equals(args[0])) { // Spigot
+            // Spigot start
+            if ( !"on".equals( args[0] ) && !Bukkit.getPluginManager().useTimings() )
+            {
+                sender.sendMessage( "Please enable timings by typing /timings on" );
+                return true;
+            }
+            // Spigot end
             for (HandlerList handlerList : HandlerList.getHandlerLists()) {
                 for (RegisteredListener listener : handlerList.getRegisteredListeners()) {
                     if (listener instanceof TimedRegisteredListener) {
@@ -50,20 +80,30 @@ public class TimingsCommand extends BukkitCommand {
                     }
                 }
             }
+            // Spigot start
+            org.spigotmc.CustomTimingsHandler.reload();
+            timingStart = System.nanoTime();
             sender.sendMessage("Timings reset");
-        } else if ("merged".equals(args[0]) || separate) {
-
+        } else if ("merged".equals(args[0]) || separate || paste) {
+            if ( !Bukkit.getPluginManager().useTimings() )
+            {
+                sender.sendMessage( "Please enable timings by typing /timings on" );
+                return true;
+            }
+            long sampleTime = System.nanoTime() - timingStart;
+            // Spigot end
             int index = 0;
             int pluginIdx = 0;
             File timingFolder = new File("timings");
             timingFolder.mkdirs();
             File timings = new File(timingFolder, "timings.txt");
             File names = null;
+            ByteArrayOutputStream bout = ( paste ) ? new ByteArrayOutputStream() : null; // Spigot
             while (timings.exists()) timings = new File(timingFolder, "timings" + (++index) + ".txt");
             PrintStream fileTimings = null;
             PrintStream fileNames = null;
             try {
-                fileTimings = new PrintStream(timings);
+                fileTimings = ( paste ) ? new PrintStream( bout ) : new PrintStream( timings );
                 if (separate) {
                     names = new File(timingFolder, "names" + index + ".txt");
                     fileNames = new PrintStream(names);
@@ -86,13 +126,25 @@ public class TimingsCommand extends BukkitCommand {
                             totalTime += time;
                             Class<? extends Event> eventClass = trl.getEventClass();
                             if (count > 0 && eventClass != null) {
-                                fileTimings.println("    " + eventClass.getSimpleName() + (trl.hasMultiple() ? " (and sub-classes)" : "") + " Time: " + time + " Count: " + count + " Avg: " + avg);
+                                fileTimings.println("    " + eventClass.getSimpleName() + (trl.hasMultiple() ? " (and sub-classes)" : "") + " Time: " + time + " Count: " + count + " Avg: " + avg + " Violations: " + trl.violations); // Spigot
                             }
                         }
                     }
                     fileTimings.println("    Total time " + totalTime + " (" + totalTime / 1000000000 + "s)");
                 }
+
+                // Spigot start
+                org.spigotmc.CustomTimingsHandler.printTimings(fileTimings);
+                fileTimings.println( "Sample time " + sampleTime + " (" + sampleTime / 1E9 + "s)" ); // Spigot
+                // Spigot start
+                if ( paste )
+                {
+                    new PasteThread( sender, bout ).start();
+                    return true;
+                }
+                // Spigot end
                 sender.sendMessage("Timings written to " + timings.getPath());
+                sender.sendMessage( "Paste contents of file into form at http://aikar.co/timings.php to read results." );
                 if (separate) sender.sendMessage("Names written to " + names.getPath());
             } catch (IOException e) {
             } finally {
@@ -118,4 +170,47 @@ public class TimingsCommand extends BukkitCommand {
         }
         return ImmutableList.of();
     }
+
+    // Spigot start
+    private static class PasteThread extends Thread
+    {
+
+        private final CommandSender sender;
+        private final ByteArrayOutputStream bout;
+
+        public PasteThread(CommandSender sender, ByteArrayOutputStream bout)
+        {
+            super( "Timings paste thread" );
+            this.sender = sender;
+            this.bout = bout;
+        }
+
+        @Override
+        public void run()
+        {
+            try
+            {
+                HttpURLConnection con = (HttpURLConnection) new URL( "http://paste.ubuntu.com/" ).openConnection();
+                con.setDoOutput( true );
+                con.setRequestMethod( "POST" );
+                con.setInstanceFollowRedirects( false );
+
+                OutputStream out = con.getOutputStream();
+                out.write( "poster=Spigot&syntax=text&content=".getBytes( "UTF-8" ) );
+                out.write( URLEncoder.encode( bout.toString( "UTF-8" ), "UTF-8" ).getBytes( "UTF-8" ) );
+                out.close();
+                con.getInputStream().close();
+
+                String location = con.getHeaderField( "Location" );
+                String pasteID = location.substring( "http://paste.ubuntu.com/".length(), location.length() - 1 );
+                sender.sendMessage( ChatColor.GREEN + "Your timings have been pasted to " + location );
+                sender.sendMessage( ChatColor.GREEN + "You can view the results at http://aikar.co/timings.php?url=" + pasteID );
+            } catch ( IOException ex )
+            {
+                sender.sendMessage( ChatColor.RED + "Error pasting timings, check your console for more information" );
+                Bukkit.getServer().getLogger().log( Level.WARNING, "Could not paste timings", ex );
+            }
+        }
+    }
+    // Spigot end
 }
diff --git a/src/main/java/org/bukkit/conversations/BooleanPrompt.java b/src/main/java/org/bukkit/conversations/BooleanPrompt.java
index 3f2c97f..81ef78c 100644
--- a/src/main/java/org/bukkit/conversations/BooleanPrompt.java
+++ b/src/main/java/org/bukkit/conversations/BooleanPrompt.java
@@ -15,12 +15,13 @@ public abstract class BooleanPrompt extends ValidatingPrompt{
 
     @Override
     protected boolean isInputValid(ConversationContext context, String input) {
-        String[] accepted = {"true", "false", "on", "off", "yes", "no"};
+        String[] accepted = {"true", "false", "on", "off", "yes", "no" /* Spigot: */, "y", "n", "1", "0", "right", "wrong", "correct", "incorrect", "valid", "invalid"}; // Spigot
         return ArrayUtils.contains(accepted, input.toLowerCase());
     }
 
     @Override
     protected Prompt acceptValidatedInput(ConversationContext context, String input) {
+        if (input.equalsIgnoreCase("y") || input.equals("1") || input.equalsIgnoreCase("right") || input.equalsIgnoreCase("correct") || input.equalsIgnoreCase("valid")) input = "true"; // Spigot
         return acceptValidatedInput(context, BooleanUtils.toBoolean(input));
     }
 
diff --git a/src/main/java/org/bukkit/conversations/Conversation.java b/src/main/java/org/bukkit/conversations/Conversation.java
index d4c1f6d..46912c8 100644
--- a/src/main/java/org/bukkit/conversations/Conversation.java
+++ b/src/main/java/org/bukkit/conversations/Conversation.java
@@ -209,6 +209,7 @@ public class Conversation {
      * @param input The user's chat text.
      */
     public void acceptInput(String input) {
+        try { // Spigot
         if (currentPrompt != null) {
 
             // Echo the user's input
@@ -228,6 +229,12 @@ public class Conversation {
             currentPrompt = currentPrompt.acceptInput(context, input);
             outputNextPrompt();
         }
+        // Spigot Start
+        } catch ( Throwable t )
+        {
+            org.bukkit.Bukkit.getLogger().log( java.util.logging.Level.SEVERE, "Error handling conversation prompt", t );
+        }
+        // Spigot End
     }
 
     /**
diff --git a/src/main/java/org/bukkit/conversations/ConversationContext.java b/src/main/java/org/bukkit/conversations/ConversationContext.java
index 4f33ff4..7390a77 100644
--- a/src/main/java/org/bukkit/conversations/ConversationContext.java
+++ b/src/main/java/org/bukkit/conversations/ConversationContext.java
@@ -46,6 +46,14 @@ public class ConversationContext {
     }
 
     /**
+     * Gets the entire sessionData map.
+     * @return The full sessionData map.
+     */
+    public Map<Object, Object> getAllSessionData() {
+        return sessionData;
+    }
+
+    /**
      * Gets session data shared between all {@link Prompt} invocations. Use
      * this as a way to pass data through each Prompt as the conversation
      * develops.
diff --git a/src/main/java/org/bukkit/entity/Arrow.java b/src/main/java/org/bukkit/entity/Arrow.java
index 26d3473..676fe2b 100644
--- a/src/main/java/org/bukkit/entity/Arrow.java
+++ b/src/main/java/org/bukkit/entity/Arrow.java
@@ -3,4 +3,22 @@ package org.bukkit.entity;
 /**
  * Represents an arrow.
  */
-public interface Arrow extends Projectile {}
+public interface Arrow extends Projectile
+{
+
+    public class Spigot extends Entity.Spigot
+    {
+
+        public double getDamage()
+        {
+            throw new UnsupportedOperationException( "Not supported yet." );
+        }
+
+        public void setDamage(double damage)
+        {
+            throw new UnsupportedOperationException( "Not supported yet." );
+        }
+    }
+
+    Spigot spigot();
+}
diff --git a/src/main/java/org/bukkit/entity/Entity.java b/src/main/java/org/bukkit/entity/Entity.java
index 396ea20..294e80b 100644
--- a/src/main/java/org/bukkit/entity/Entity.java
+++ b/src/main/java/org/bukkit/entity/Entity.java
@@ -291,4 +291,22 @@ public interface Entity extends Metadatable {
      * @return The current vehicle.
      */
     public Entity getVehicle();
+
+    // Spigot Start
+    public class Spigot
+    {
+
+        /**
+         * Returns whether this entity is invulnerable.
+         *         
+        * @return True if the entity is invulnerable.
+         */
+        public boolean isInvulnerable()
+        {
+            throw new UnsupportedOperationException( "Not supported yet." );
+        }
+    }
+
+    Spigot spigot();
+    // Spigot End
 }
diff --git a/src/main/java/org/bukkit/entity/Player.java b/src/main/java/org/bukkit/entity/Player.java
index 7aa697d..15481e7 100644
--- a/src/main/java/org/bukkit/entity/Player.java
+++ b/src/main/java/org/bukkit/entity/Player.java
@@ -788,4 +788,57 @@ public interface Player extends HumanEntity, Conversable, CommandSender, Offline
      * @see Player#setHealthScaled(boolean)
      */
     public double getHealthScale();
+
+    // Spigot start
+    public class Spigot extends Entity.Spigot
+    {
+
+        /**
+         * Gets the connection address of this player, regardless of whether it
+         * has been spoofed or not.
+         *
+         * @return the player's connection address
+         */
+        public InetSocketAddress getRawAddress()
+        {
+            throw new UnsupportedOperationException( "Not supported yet." );
+        }
+
+        public void playEffect(Location location, Effect effect, int id, int data, float offsetX, float offsetY, float offsetZ, float speed, int particleCount, int radius)
+        {
+            throw new UnsupportedOperationException( "Not supported yet." );
+        }
+
+        /**
+         * Gets whether the player collides with entities
+         *
+         * @return the player's collision toggle state
+         */
+        public boolean getCollidesWithEntities()
+        {
+            throw new UnsupportedOperationException( "Not supported yet." );
+        }
+
+        /**
+         * Sets whether the player collides with entities
+         *
+         * @param collides whether the player should collide with entities or
+         * not.
+         */
+        public void setCollidesWithEntities(boolean collides)
+        {
+            throw new UnsupportedOperationException( "Not supported yet." );
+        }
+
+        /**
+         * Respawns the player if dead.
+         */
+        public void respawn()
+        {
+            throw new UnsupportedOperationException( "Not supported yet." );
+        }
+    }
+
+    Spigot spigot();
+    // Spigot end
 }
diff --git a/src/main/java/org/bukkit/event/entity/CreatureSpawnEvent.java b/src/main/java/org/bukkit/event/entity/CreatureSpawnEvent.java
index 3055ea7..6bde0fe 100644
--- a/src/main/java/org/bukkit/event/entity/CreatureSpawnEvent.java
+++ b/src/main/java/org/bukkit/event/entity/CreatureSpawnEvent.java
@@ -4,17 +4,13 @@ import org.bukkit.Location;
 import org.bukkit.entity.CreatureType;
 import org.bukkit.entity.Entity;
 import org.bukkit.entity.LivingEntity;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
 
 /**
  * Called when a creature is spawned into a world.
  * <p>
  * If a Creature Spawn event is cancelled, the creature will not spawn.
  */
-public class CreatureSpawnEvent extends EntityEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private boolean canceled;
+public class CreatureSpawnEvent extends EntitySpawnEvent {
     private final SpawnReason spawnReason;
 
     public CreatureSpawnEvent(final LivingEntity spawnee, final SpawnReason spawnReason) {
@@ -28,29 +24,12 @@ public class CreatureSpawnEvent extends EntityEvent implements Cancellable {
         spawnReason = reason;
     }
 
-    public boolean isCancelled() {
-        return canceled;
-    }
-
-    public void setCancelled(boolean cancel) {
-        canceled = cancel;
-    }
-
     @Override
     public LivingEntity getEntity() {
         return (LivingEntity) entity;
     }
 
     /**
-     * Gets the location at which the creature is spawning.
-     *
-     * @return The location at which the creature is spawning
-     */
-    public Location getLocation() {
-        return getEntity().getLocation();
-    }
-
-    /**
      * Gets the type of creature being spawned.
      *
      * @return A CreatureType value detailing the type of creature being
@@ -72,15 +51,6 @@ public class CreatureSpawnEvent extends EntityEvent implements Cancellable {
         return spawnReason;
     }
 
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-
     /**
      * An enum to specify the type of spawning
      */
diff --git a/src/main/java/org/bukkit/event/entity/EntitySpawnEvent.java b/src/main/java/org/bukkit/event/entity/EntitySpawnEvent.java
new file mode 100644
index 0000000..5dcf98f
--- /dev/null
+++ b/src/main/java/org/bukkit/event/entity/EntitySpawnEvent.java
@@ -0,0 +1,45 @@
+package org.bukkit.event.entity;
+
+import org.bukkit.Location;
+import org.bukkit.entity.Entity;
+import org.bukkit.event.HandlerList;
+
+/**
+ * Called when an entity is spawned into a world.
+ * <p>
+ * If an Entity Spawn event is cancelled, the entity will not spawn.
+ */
+public class EntitySpawnEvent extends EntityEvent implements org.bukkit.event.Cancellable {
+    private static final HandlerList handlers = new HandlerList();
+    private boolean canceled;
+
+    public EntitySpawnEvent(final Entity spawnee) {
+        super(spawnee);
+    }
+
+    public boolean isCancelled() {
+        return canceled;
+    }
+
+    public void setCancelled(boolean cancel) {
+        canceled = cancel;
+    }
+
+    /**
+     * Gets the location at which the entity is spawning.
+     *
+     * @return The location at which the entity is spawning
+     */
+    public Location getLocation() {
+        return getEntity().getLocation();
+    }
+
+    @Override
+    public HandlerList getHandlers() {
+        return handlers;
+    }
+
+    public static HandlerList getHandlerList() {
+        return handlers;
+    }
+}
diff --git a/src/main/java/org/bukkit/event/entity/ItemSpawnEvent.java b/src/main/java/org/bukkit/event/entity/ItemSpawnEvent.java
index bafd934..776f8e7 100644
--- a/src/main/java/org/bukkit/event/entity/ItemSpawnEvent.java
+++ b/src/main/java/org/bukkit/event/entity/ItemSpawnEvent.java
@@ -1,51 +1,23 @@
 package org.bukkit.event.entity;
 
-import org.bukkit.entity.Item;
 import org.bukkit.Location;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
+import org.bukkit.entity.Item;
 
 /**
  * Called when an item is spawned into a world
  */
-public class ItemSpawnEvent extends EntityEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private final Location location;
-    private boolean canceled;
-
-    public ItemSpawnEvent(final Item spawnee, final Location loc) {
+public class ItemSpawnEvent extends EntitySpawnEvent {
+    public ItemSpawnEvent(final Item spawnee) {
         super(spawnee);
-        this.location = loc;
     }
 
-    public boolean isCancelled() {
-        return canceled;
-    }
-
-    public void setCancelled(boolean cancel) {
-        canceled = cancel;
+    @Deprecated
+    public ItemSpawnEvent(final Item spawnee, final Location loc) {
+        this(spawnee);
     }
 
     @Override
     public Item getEntity() {
         return (Item) entity;
     }
-
-    /**
-     * Gets the location at which the item is spawning.
-     *
-     * @return The location at which the item is spawning
-     */
-    public Location getLocation() {
-        return location;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
 }
diff --git a/src/main/java/org/bukkit/event/entity/SpawnerSpawnEvent.java b/src/main/java/org/bukkit/event/entity/SpawnerSpawnEvent.java
new file mode 100644
index 0000000..1acb3c4
--- /dev/null
+++ b/src/main/java/org/bukkit/event/entity/SpawnerSpawnEvent.java
@@ -0,0 +1,22 @@
+package org.bukkit.event.entity;
+
+import org.bukkit.block.CreatureSpawner;
+import org.bukkit.entity.Entity;
+
+/**
+ * Called when an entity is spawned into a world by a spawner.
+ * <p>
+ * If a Spawner Spawn event is cancelled, the entity will not spawn.
+ */
+public class SpawnerSpawnEvent extends EntitySpawnEvent {
+    private final CreatureSpawner spawner;
+
+    public SpawnerSpawnEvent(final Entity spawnee, final CreatureSpawner spawner) {
+        super(spawnee);
+        this.spawner = spawner;
+    }
+
+    public CreatureSpawner getSpawner() {
+        return spawner;
+    }
+}
diff --git a/src/main/java/org/bukkit/event/inventory/InventoryClickEvent.java b/src/main/java/org/bukkit/event/inventory/InventoryClickEvent.java
index 28198b8..3313d91 100644
--- a/src/main/java/org/bukkit/event/inventory/InventoryClickEvent.java
+++ b/src/main/java/org/bukkit/event/inventory/InventoryClickEvent.java
@@ -47,6 +47,7 @@ public class InventoryClickEvent extends InventoryInteractEvent {
     private static final HandlerList handlers = new HandlerList();
     private final ClickType click;
     private final InventoryAction action;
+    private final Inventory clickedInventory;
     private SlotType slot_type;
     private int whichSlot;
     private int rawSlot;
@@ -62,6 +63,13 @@ public class InventoryClickEvent extends InventoryInteractEvent {
         super(view);
         this.slot_type = type;
         this.rawSlot = slot;
+        if (slot < 0) {
+            this.clickedInventory = null;
+        } else if (view.getTopInventory() != null && slot < view.getTopInventory().getSize()) {
+            this.clickedInventory = view.getTopInventory();
+        } else {
+            this.clickedInventory = view.getBottomInventory();
+        }
         this.whichSlot = view.convertSlot(slot);
         this.click = click;
         this.action = action;
@@ -73,6 +81,14 @@ public class InventoryClickEvent extends InventoryInteractEvent {
     }
 
     /**
+     * Gets the inventory that was clicked, or null if outside of window
+     * @return The clicked inventory
+     */
+    public Inventory getClickedInventory() {
+        return clickedInventory;
+    }
+
+    /**
      * Gets the type of slot that was clicked.
      *
      * @return the slot type
diff --git a/src/main/java/org/bukkit/event/player/PlayerItemDamageEvent.java b/src/main/java/org/bukkit/event/player/PlayerItemDamageEvent.java
new file mode 100644
index 0000000..38a72ab
--- /dev/null
+++ b/src/main/java/org/bukkit/event/player/PlayerItemDamageEvent.java
@@ -0,0 +1,54 @@
+package org.bukkit.event.player;
+
+import org.bukkit.entity.Player;
+import org.bukkit.event.Cancellable;
+import org.bukkit.event.HandlerList;
+import org.bukkit.inventory.ItemStack;
+
+public class PlayerItemDamageEvent extends PlayerEvent implements Cancellable {
+
+    private static final HandlerList handlers = new HandlerList();
+    private final ItemStack item;
+    private int damage;
+    private boolean cancelled = false;
+
+    public PlayerItemDamageEvent(Player player, ItemStack what, int damage) {
+        super(player);
+        this.item = what;
+        this.damage = damage;
+    }
+
+    public ItemStack getItem() {
+        return item;
+    }
+
+    /**
+     * Gets the amount of durability damage this item will be taking.
+     *
+     * @return durability change
+     */
+    public int getDamage() {
+        return damage;
+    }
+
+    public void setDamage(int damage) {
+        this.damage = damage;
+    }
+
+    public boolean isCancelled() {
+        return cancelled;
+    }
+
+    public void setCancelled(boolean cancel) {
+        this.cancelled = cancel;
+    }
+
+    @Override
+    public HandlerList getHandlers() {
+        return handlers;
+    }
+
+    public static HandlerList getHandlerList() {
+        return handlers;
+    }
+}
diff --git a/src/main/java/org/bukkit/event/player/PlayerLoginEvent.java b/src/main/java/org/bukkit/event/player/PlayerLoginEvent.java
index b74b7b8..8fb1c98 100644
--- a/src/main/java/org/bukkit/event/player/PlayerLoginEvent.java
+++ b/src/main/java/org/bukkit/event/player/PlayerLoginEvent.java
@@ -14,6 +14,7 @@ public class PlayerLoginEvent extends PlayerEvent {
     private final String hostname;
     private Result result = Result.ALLOWED;
     private String message = "";
+    private final InetAddress realAddress; // Spigot
 
     /**
      * @deprecated Address should be provided in other constructor
@@ -40,10 +41,17 @@ public class PlayerLoginEvent extends PlayerEvent {
      * @param address The address the player used to connect, provided for
      *     timing issues
      */
-    public PlayerLoginEvent(final Player player, final String hostname, final InetAddress address) {
+    public PlayerLoginEvent(final Player player, final String hostname, final InetAddress address, final InetAddress realAddress) { // Spigot
         super(player);
         this.hostname = hostname;
         this.address = address;
+        // Spigot start
+        this.realAddress = address;
+    }
+
+    public PlayerLoginEvent(final Player player, final String hostname, final InetAddress address) {
+        this(player, hostname, address, address);
+        // Spigot end
     }
 
     /**
@@ -52,7 +60,7 @@ public class PlayerLoginEvent extends PlayerEvent {
      */
     @Deprecated
     public PlayerLoginEvent(final Player player, final Result result, final String message) {
-        this(player, "", null, result, message);
+        this(player, "", null, result, message, null); // Spigot
     }
 
     /**
@@ -65,12 +73,23 @@ public class PlayerLoginEvent extends PlayerEvent {
      * @param result The result status for this event
      * @param message The message to be displayed if result denies login
      */
-    public PlayerLoginEvent(final Player player, String hostname, final InetAddress address, final Result result, final String message) {
-        this(player, hostname, address);
+    public PlayerLoginEvent(final Player player, String hostname, final InetAddress address, final Result result, final String message, final InetAddress realAddress) { // Spigot
+        this(player, hostname, address, realAddress); // Spigot
         this.result = result;
         this.message = message;
     }
 
+    // Spigot start
+    /**
+     * Gets the connection address of this player, regardless of whether it has been spoofed or not.
+     *
+     * @return the player's connection address
+     */
+    public InetAddress getRealAddress() {
+        return realAddress;
+    }
+    // Spigot end
+
     /**
      * Gets the current result of the login, as an enum
      *
diff --git a/src/main/java/org/bukkit/plugin/PluginDescriptionFile.java b/src/main/java/org/bukkit/plugin/PluginDescriptionFile.java
index 1d79e63..d2a59e4 100644
--- a/src/main/java/org/bukkit/plugin/PluginDescriptionFile.java
+++ b/src/main/java/org/bukkit/plugin/PluginDescriptionFile.java
@@ -773,10 +773,6 @@ public final class PluginDescriptionFile {
         return name + " v" + version;
     }
 
-    /**
-     * @deprecated unused
-     */
-    @Deprecated
     public String getClassLoaderOf() {
         return classLoaderOf;
     }
diff --git a/src/main/java/org/bukkit/plugin/SimplePluginManager.java b/src/main/java/org/bukkit/plugin/SimplePluginManager.java
index 3c9611b..2c4b03b 100644
--- a/src/main/java/org/bukkit/plugin/SimplePluginManager.java
+++ b/src/main/java/org/bukkit/plugin/SimplePluginManager.java
@@ -275,6 +275,7 @@ public final class SimplePluginManager implements PluginManager {
             }
         }
 
+        org.bukkit.command.defaults.TimingsCommand.timingStart = System.nanoTime(); // Spigot
         return result.toArray(new Plugin[result.size()]);
     }
 
diff --git a/src/main/java/org/bukkit/plugin/TimedRegisteredListener.java b/src/main/java/org/bukkit/plugin/TimedRegisteredListener.java
index e09234c..ab2c65e 100644
--- a/src/main/java/org/bukkit/plugin/TimedRegisteredListener.java
+++ b/src/main/java/org/bukkit/plugin/TimedRegisteredListener.java
@@ -11,6 +11,10 @@ import org.bukkit.event.Listener;
 public class TimedRegisteredListener extends RegisteredListener {
     private int count;
     private long totalTime;
+    // Spigot start
+    public long curTickTotal = 0;
+    public long violations = 0;
+    // Spigot end
     private Class<? extends Event> eventClass;
     private boolean multiple = false;
 
@@ -20,6 +24,13 @@ public class TimedRegisteredListener extends RegisteredListener {
 
     @Override
     public void callEvent(Event event) throws EventException {
+        // Spigot start
+        if ( org.bukkit.Bukkit.getServer() != null && !org.bukkit.Bukkit.getServer().getPluginManager().useTimings() )
+        {
+            super.callEvent( event );
+            return;
+        }
+        // Spigot end
         if (event.isAsynchronous()) {
             super.callEvent(event);
             return;
@@ -34,7 +45,11 @@ public class TimedRegisteredListener extends RegisteredListener {
         }
         long start = System.nanoTime();
         super.callEvent(event);
-        totalTime += System.nanoTime() - start;
+        // Spigot start
+        long diff = System.nanoTime() - start;
+        curTickTotal += diff;
+        totalTime += diff;
+        // Spigot end
     }
 
     private static Class<?> getCommonSuperclass(Class<?> class1, Class<?> class2) {
@@ -50,6 +65,10 @@ public class TimedRegisteredListener extends RegisteredListener {
     public void reset() {
         count = 0;
         totalTime = 0;
+        // Spigot start
+        curTickTotal = 0;
+        violations = 0;
+        // Spigot end
     }
 
     /**
diff --git a/src/main/java/org/bukkit/plugin/java/JavaPlugin.java b/src/main/java/org/bukkit/plugin/java/JavaPlugin.java
index 8fd726b..3815da2 100644
--- a/src/main/java/org/bukkit/plugin/java/JavaPlugin.java
+++ b/src/main/java/org/bukkit/plugin/java/JavaPlugin.java
@@ -12,16 +12,13 @@ import java.util.List;
 import java.util.logging.Level;
 import java.util.logging.Logger;
 
-import org.apache.commons.lang.Validate;
 import org.bukkit.Server;
-import org.bukkit.Warning.WarningState;
 import org.bukkit.command.Command;
 import org.bukkit.command.CommandSender;
 import org.bukkit.command.PluginCommand;
 import org.bukkit.configuration.file.FileConfiguration;
 import org.bukkit.configuration.file.YamlConfiguration;
 import org.bukkit.generator.ChunkGenerator;
-import org.bukkit.plugin.AuthorNagException;
 import org.bukkit.plugin.PluginBase;
 import org.bukkit.plugin.PluginDescriptionFile;
 import org.bukkit.plugin.PluginLoader;
@@ -39,6 +36,7 @@ import com.avaje.ebeaninternal.server.ddl.DdlGenerator;
  */
 public abstract class JavaPlugin extends PluginBase {
     private boolean isEnabled = false;
+    private boolean initialized = false;
     private PluginLoader loader = null;
     private Server server = null;
     private File file = null;
@@ -51,37 +49,7 @@ public abstract class JavaPlugin extends PluginBase {
     private File configFile = null;
     private PluginLogger logger = null;
 
-    public JavaPlugin() {
-        final ClassLoader classLoader = this.getClass().getClassLoader();
-        if (!(classLoader instanceof PluginClassLoader)) {
-            throw new IllegalStateException("JavaPlugin requires " + PluginClassLoader.class.getName());
-        }
-        ((PluginClassLoader) classLoader).initialize(this);
-    }
-
-    /**
-     * @deprecated This method is intended for unit testing purposes when the
-     *     other {@linkplain #JavaPlugin(JavaPluginLoader,
-     *     PluginDescriptionFile, File, File) constructor} cannot be used.
-     *     <p>
-     *     Its existence may be temporary.
-     */
-    @Deprecated
-    protected JavaPlugin(final PluginLoader loader, final Server server, final PluginDescriptionFile description, final File dataFolder, final File file) {
-        final ClassLoader classLoader = this.getClass().getClassLoader();
-        if (classLoader instanceof PluginClassLoader) {
-            throw new IllegalStateException("Cannot use initialization constructor at runtime");
-        }
-        init(loader, server, description, dataFolder, file, classLoader);
-    }
-
-    protected JavaPlugin(final JavaPluginLoader loader, final PluginDescriptionFile description, final File dataFolder, final File file) {
-        final ClassLoader classLoader = this.getClass().getClassLoader();
-        if (classLoader instanceof PluginClassLoader) {
-            throw new IllegalStateException("Cannot use initialization constructor at runtime");
-        }
-        init(loader, loader.server, description, dataFolder, file, classLoader);
-    }
+    public JavaPlugin() {}
 
     /**
      * Returns the folder that the plugin data's files are located in. The
@@ -255,46 +223,50 @@ public abstract class JavaPlugin extends PluginBase {
     }
 
     /**
-     * @deprecated This method is legacy and will be removed - it must be
-     *     replaced by the specially provided constructor(s).
+     * Initializes this plugin with the given variables.
+     * <p>
+     * This method should never be called manually.
+     *
+     * @param loader PluginLoader that is responsible for this plugin
+     * @param server Server instance that is running this plugin
+     * @param description PluginDescriptionFile containing metadata on this
+     *     plugin
+     * @param dataFolder Folder containing the plugin's data
+     * @param file File containing this plugin
+     * @param classLoader ClassLoader which holds this plugin
      */
-    @Deprecated
     protected final void initialize(PluginLoader loader, Server server, PluginDescriptionFile description, File dataFolder, File file, ClassLoader classLoader) {
-        if (server.getWarningState() == WarningState.OFF) {
-            return;
-        }
-        getLogger().log(Level.WARNING, getClass().getName() + " is already initialized", server.getWarningState() == WarningState.DEFAULT ? null : new AuthorNagException("Explicit initialization"));
-    }
-
-    final void init(PluginLoader loader, Server server, PluginDescriptionFile description, File dataFolder, File file, ClassLoader classLoader) {
-        this.loader = loader;
-        this.server = server;
-        this.file = file;
-        this.description = description;
-        this.dataFolder = dataFolder;
-        this.classLoader = classLoader;
-        this.configFile = new File(dataFolder, "config.yml");
-        this.logger = new PluginLogger(this);
-
-        if (description.isDatabaseEnabled()) {
-            ServerConfig db = new ServerConfig();
-
-            db.setDefaultServer(false);
-            db.setRegister(false);
-            db.setClasses(getDatabaseClasses());
-            db.setName(description.getName());
-            server.configureDbConfig(db);
-
-            DataSourceConfig ds = db.getDataSourceConfig();
-
-            ds.setUrl(replaceDatabaseString(ds.getUrl()));
-            dataFolder.mkdirs();
-
-            ClassLoader previous = Thread.currentThread().getContextClassLoader();
-
-            Thread.currentThread().setContextClassLoader(classLoader);
-            ebean = EbeanServerFactory.create(db);
-            Thread.currentThread().setContextClassLoader(previous);
+        if (!initialized) {
+            this.initialized = true;
+            this.loader = loader;
+            this.server = server;
+            this.file = file;
+            this.description = description;
+            this.dataFolder = dataFolder;
+            this.classLoader = classLoader;
+            this.configFile = new File(dataFolder, "config.yml");
+            this.logger = new PluginLogger(this);
+
+            if (description.isDatabaseEnabled()) {
+                ServerConfig db = new ServerConfig();
+
+                db.setDefaultServer(false);
+                db.setRegister(false);
+                db.setClasses(getDatabaseClasses());
+                db.setName(description.getName());
+                server.configureDbConfig(db);
+
+                DataSourceConfig ds = db.getDataSourceConfig();
+
+                ds.setUrl(replaceDatabaseString(ds.getUrl()));
+                dataFolder.mkdirs();
+
+                ClassLoader previous = Thread.currentThread().getContextClassLoader();
+
+                Thread.currentThread().setContextClassLoader(classLoader);
+                ebean = EbeanServerFactory.create(db);
+                Thread.currentThread().setContextClassLoader(previous);
+            }
         }
     }
 
@@ -317,12 +289,9 @@ public abstract class JavaPlugin extends PluginBase {
      * Gets the initialization status of this plugin
      *
      * @return true if this plugin is initialized, otherwise false
-     * @deprecated This method cannot return false, as {@link
-     *     JavaPlugin} is now initialized in the constructor.
      */
-    @Deprecated
     public final boolean isInitialized() {
-        return true;
+        return initialized;
     }
 
     /**
@@ -406,59 +375,4 @@ public abstract class JavaPlugin extends PluginBase {
     public String toString() {
         return description.getFullName();
     }
-
-    /**
-     * This method provides fast access to the plugin that has {@link
-     * #getProvidingPlugin(Class) provided} the given plugin class, which is
-     * usually the plugin that implemented it.
-     * <p>
-     * An exception to this would be if plugin's jar that contained the class
-     * does not extend the class, where the intended plugin would have
-     * resided in a different jar / classloader.
-     *
-     * @param clazz the class desired
-     * @return the plugin that provides and implements said class, or null
-     *     if called from an inconsistent static initialization block
-     * @throws IllegalArgumentException if clazz is null
-     * @throws IllegalArgumentException if clazz does not extend {@link
-     *     JavaPlugin}
-     * @throws IllegalArgumentException if clazz was not provided by a
-     *     plugin, for example, if called with
-     *     <code>JavaPlugin.getPlugin(JavaPlugin.class)</code>
-     * @throws ClassCastException if plugin that provided the class does not
-     *     extend the class
-     */
-    public static <T extends JavaPlugin> T getPlugin(Class<T> clazz) {
-        Validate.notNull(clazz, "Null class cannot have a plugin");
-        if (!JavaPlugin.class.isAssignableFrom(clazz)) {
-            throw new IllegalArgumentException(clazz + " does not extend " + JavaPlugin.class);
-        }
-        final ClassLoader cl = clazz.getClassLoader();
-        if (!(cl instanceof PluginClassLoader)) {
-            throw new IllegalArgumentException(clazz + " is not initialized by " + PluginClassLoader.class);
-        }
-        JavaPlugin plugin = ((PluginClassLoader) cl).plugin;
-        if (plugin == null) {
-            throw new IllegalStateException("Cannot get plugin for " + clazz + " from a static initializer");
-        }
-        return clazz.cast(plugin);
-    }
-
-    /**
-     * This method provides fast access to the plugin that has {@link
-     * #getProvidingPlugin(Class) provided} the given plugin class, which is
-     * usually the plugin that implemented it.
-     */
-    public static JavaPlugin getProvidingPlugin(Class<?> clazz) {
-        Validate.notNull(clazz, "Null class cannot have a plugin");
-        final ClassLoader cl = clazz.getClassLoader();
-        if (!(cl instanceof PluginClassLoader)) {
-            throw new IllegalArgumentException(clazz + " is not provided by " + PluginClassLoader.class);
-        }
-        JavaPlugin plugin = ((PluginClassLoader) cl).plugin;
-        if (plugin == null) {
-            throw new IllegalStateException("Cannot get plugin for " + clazz + " from a static initializer");
-        }
-        return plugin;
-    }
 }
diff --git a/src/main/java/org/bukkit/plugin/java/JavaPluginLoader.java b/src/main/java/org/bukkit/plugin/java/JavaPluginLoader.java
index 57681dc..d905435 100644
--- a/src/main/java/org/bukkit/plugin/java/JavaPluginLoader.java
+++ b/src/main/java/org/bukkit/plugin/java/JavaPluginLoader.java
@@ -4,8 +4,10 @@ import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStream;
+import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
+import java.net.URL;
 import java.util.Arrays;
 import java.util.HashMap;
 import java.util.HashSet;
@@ -47,19 +49,44 @@ import com.google.common.collect.ImmutableList;
 /**
  * Represents a Java plugin loader, allowing plugins in the form of .jar
  */
-public final class JavaPluginLoader implements PluginLoader {
+public class JavaPluginLoader implements PluginLoader {
     final Server server;
-    private final Pattern[] fileFilters = new Pattern[] { Pattern.compile("\\.jar$"), };
-    private final Map<String, Class<?>> classes = new HashMap<String, Class<?>>();
-    private final Map<String, PluginClassLoader> loaders = new LinkedHashMap<String, PluginClassLoader>();
+    final boolean extended = this.getClass() != JavaPluginLoader.class;
+    boolean warn;
 
+    private final Pattern[] fileFilters0 = new Pattern[] { Pattern.compile("\\.jar$"), };
     /**
-     * This class was not meant to be constructed explicitly
+     * @deprecated Internal field that wasn't intended to be exposed
+     */
+    @Deprecated
+    protected final Pattern[] fileFilters = fileFilters0;
+
+    private final Map<String, Class<?>> classes0 = new HashMap<String, Class<?>>();
+    /**
+     * @deprecated Internal field that wasn't intended to be exposed
+     */
+    @Deprecated
+    protected final Map<String, Class<?>> classes = classes0;
+
+    private final Map<String, PluginClassLoader> loaders0 = new LinkedHashMap<String, PluginClassLoader>();
+    /**
+     * @deprecated Internal field that wasn't intended to be exposed
+     */
+    @Deprecated
+    protected final Map<String, PluginClassLoader> loaders = loaders0;
+
+    /**
+     * This class was not meant to be extended
      */
     @Deprecated
     public JavaPluginLoader(Server instance) {
         Validate.notNull(instance, "Server cannot be null");
         server = instance;
+        warn = instance.getWarningState() != WarningState.OFF;
+        if (extended && warn) {
+            warn = false;
+            instance.getLogger().log(Level.WARNING, "JavaPluginLoader not intended to be extended by " + getClass() + ", and may be final in a future version of Bukkit");
+        }
     }
 
     public Plugin loadPlugin(File file) throws InvalidPluginException {
@@ -77,7 +104,7 @@ public final class JavaPluginLoader implements PluginLoader {
         }
 
         File dataFolder = new File(file.getParentFile(), description.getName());
-        File oldDataFolder = getDataFolder(file);
+        File oldDataFolder = extended ? getDataFolder(file) : getDataFolder0(file); // Don't warn on deprecation, but maintain overridability
 
         // Found old data folder
         if (dataFolder.equals(oldDataFolder)) {
@@ -118,31 +145,75 @@ public final class JavaPluginLoader implements PluginLoader {
         }
 
         for (String pluginName : depend) {
-            if (loaders == null) {
+            if (loaders0 == null) {
                 throw new UnknownDependencyException(pluginName);
             }
-            PluginClassLoader current = loaders.get(pluginName);
+            PluginClassLoader current = loaders0.get(pluginName);
 
             if (current == null) {
                 throw new UnknownDependencyException(pluginName);
             }
         }
 
-        PluginClassLoader loader;
+        PluginClassLoader loader = null;
+        JavaPlugin result = null;
+
         try {
-            loader = new PluginClassLoader(this, getClass().getClassLoader(), description, dataFolder, file);
-        } catch (InvalidPluginException ex) {
-            throw ex;
+            URL[] urls = new URL[1];
+
+            urls[0] = file.toURI().toURL();
+
+            if (description.getClassLoaderOf() != null) {
+                loader = loaders0.get(description.getClassLoaderOf());
+                loader.addURL(urls[0]);
+            } else {
+                loader = new PluginClassLoader(this, urls, getClass().getClassLoader(), null);
+            }
+
+            Class<?> jarClass = Class.forName(description.getMain(), true, loader);
+            Class<? extends JavaPlugin> plugin = jarClass.asSubclass(JavaPlugin.class);
+
+            Constructor<? extends JavaPlugin> constructor = plugin.getConstructor();
+
+            result = constructor.newInstance();
+
+            result.initialize(this, server, description, dataFolder, file, loader);
+        } catch (InvocationTargetException ex) {
+            throw new InvalidPluginException(ex.getCause());
         } catch (Throwable ex) {
             throw new InvalidPluginException(ex);
         }
 
-        loaders.put(description.getName(), loader);
+        loaders0.put(description.getName(), loader);
 
-        return loader.plugin;
+        return result;
     }
 
-    private File getDataFolder(File file) {
+    /**
+     * @deprecated Relic method from PluginLoader that didn't get purged
+     */
+    @Deprecated
+    public Plugin loadPlugin(File file, boolean ignoreSoftDependencies) throws InvalidPluginException {
+        if (warn) {
+            server.getLogger().log(Level.WARNING, "Method \"public Plugin loadPlugin(File, boolean)\" is Deprecated, and may be removed in a future version of Bukkit", new AuthorNagException(""));
+            warn = false;
+        }
+        return loadPlugin(file);
+    }
+
+    /**
+     * @deprecated Internal method that wasn't intended to be exposed
+     */
+    @Deprecated
+    protected File getDataFolder(File file) {
+        if (warn) {
+            server.getLogger().log(Level.WARNING, "Method \"protected File getDataFolder(File)\" is Deprecated, and may be removed in a future version of Bukkit", new AuthorNagException(""));
+            warn = false;
+        }
+        return getDataFolder0(file);
+    }
+
+    private File getDataFolder0(File file) {
         File dataFolder = null;
 
         String filename = file.getName();
@@ -201,20 +272,32 @@ public final class JavaPluginLoader implements PluginLoader {
     }
 
     public Pattern[] getPluginFileFilters() {
-        return fileFilters.clone();
+        return fileFilters0.clone();
+    }
+
+    /**
+     * @deprecated Internal method that wasn't intended to be exposed
+     */
+    @Deprecated
+    public Class<?> getClassByName(final String name) {
+        if (warn) {
+            server.getLogger().log(Level.WARNING, "Method \"public Class<?> getClassByName(String)\" is Deprecated, and may be removed in a future version of Bukkit", new AuthorNagException(""));
+            warn = false;
+        }
+        return getClassByName0(name);
     }
 
-    Class<?> getClassByName(final String name) {
-        Class<?> cachedClass = classes.get(name);
+    Class<?> getClassByName0(final String name) {
+        Class<?> cachedClass = classes0.get(name);
 
         if (cachedClass != null) {
             return cachedClass;
         } else {
-            for (String current : loaders.keySet()) {
-                PluginClassLoader loader = loaders.get(current);
+            for (String current : loaders0.keySet()) {
+                PluginClassLoader loader = loaders0.get(current);
 
                 try {
-                    cachedClass = loader.findClass(name, false);
+                    cachedClass = loader.extended ? loader.findClass(name, false) : loader.findClass0(name, false); // Don't warn on deprecation, but maintain overridability
                 } catch (ClassNotFoundException cnfe) {}
                 if (cachedClass != null) {
                     return cachedClass;
@@ -224,9 +307,21 @@ public final class JavaPluginLoader implements PluginLoader {
         return null;
     }
 
-    void setClass(final String name, final Class<?> clazz) {
-        if (!classes.containsKey(name)) {
-            classes.put(name, clazz);
+    /**
+     * @deprecated Internal method that wasn't intended to be exposed
+     */
+    @Deprecated
+    public void setClass(final String name, final Class<?> clazz) {
+        if (warn) {
+            server.getLogger().log(Level.WARNING, "Method \"public void setClass(String, Class<?>)\" is Deprecated, and may be removed in a future version of Bukkit", new AuthorNagException(""));
+            warn = false;
+        }
+        setClass0(name, clazz);
+    }
+
+    void setClass0(final String name, final Class<?> clazz) {
+        if (!classes0.containsKey(name)) {
+            classes0.put(name, clazz);
 
             if (ConfigurationSerializable.class.isAssignableFrom(clazz)) {
                 Class<? extends ConfigurationSerializable> serializable = clazz.asSubclass(ConfigurationSerializable.class);
@@ -235,8 +330,20 @@ public final class JavaPluginLoader implements PluginLoader {
         }
     }
 
-    private void removeClass(String name) {
-        Class<?> clazz = classes.remove(name);
+    /**
+     * @deprecated Internal method that wasn't intended to be exposed
+     */
+    @Deprecated
+    public void removeClass(String name) {
+        if (warn) {
+            server.getLogger().log(Level.WARNING, "Method \"public void removeClass(String)\" is Deprecated, and may be removed in a future version of Bukkit", new AuthorNagException(""));
+            warn = false;
+        }
+        removeClass0(name);
+    }
+
+    private void removeClass0(String name) {
+        Class<?> clazz = classes0.remove(name);
 
         try {
             if ((clazz != null) && (ConfigurationSerializable.class.isAssignableFrom(clazz))) {
@@ -323,7 +430,7 @@ public final class JavaPluginLoader implements PluginLoader {
                     }
                 }
             };
-            if (useTimings) {
+            if (true) { // Spigot - TRL handles useTimings check now
                 eventSet.add(new TimedRegisteredListener(listener, executor, eh.priority(), plugin, eh.ignoreCancelled()));
             } else {
                 eventSet.add(new RegisteredListener(listener, executor, eh.priority(), plugin, eh.ignoreCancelled()));
@@ -342,8 +449,8 @@ public final class JavaPluginLoader implements PluginLoader {
 
             String pluginName = jPlugin.getDescription().getName();
 
-            if (!loaders.containsKey(pluginName)) {
-                loaders.put(pluginName, (PluginClassLoader) jPlugin.getClassLoader());
+            if (!loaders0.containsKey(pluginName)) {
+                loaders0.put(pluginName, (PluginClassLoader) jPlugin.getClassLoader());
             }
 
             try {
@@ -376,14 +483,18 @@ public final class JavaPluginLoader implements PluginLoader {
                 server.getLogger().log(Level.SEVERE, "Error occurred while disabling " + plugin.getDescription().getFullName() + " (Is it up to date?)", ex);
             }
 
-            loaders.remove(jPlugin.getDescription().getName());
+            loaders0.remove(jPlugin.getDescription().getName());
 
             if (cloader instanceof PluginClassLoader) {
                 PluginClassLoader loader = (PluginClassLoader) cloader;
-                Set<String> names = loader.getClasses();
+                Set<String> names = loader.extended ? loader.getClasses() : loader.getClasses0(); // Don't warn on deprecation, but maintain overridability
 
                 for (String name : names) {
-                    removeClass(name);
+                    if (extended) {
+                        removeClass(name);
+                    } else {
+                        removeClass0(name);
+                    }
                 }
             }
         }
diff --git a/src/main/java/org/bukkit/plugin/java/PluginClassLoader.java b/src/main/java/org/bukkit/plugin/java/PluginClassLoader.java
index 13f8633..29ec3fc 100644
--- a/src/main/java/org/bukkit/plugin/java/PluginClassLoader.java
+++ b/src/main/java/org/bukkit/plugin/java/PluginClassLoader.java
@@ -1,68 +1,71 @@
 package org.bukkit.plugin.java;
 
-import java.io.File;
-import java.net.MalformedURLException;
 import java.net.URL;
 import java.net.URLClassLoader;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.Set;
+import java.util.logging.Level;
 
 import org.apache.commons.lang.Validate;
-import org.bukkit.plugin.InvalidPluginException;
-import org.bukkit.plugin.PluginDescriptionFile;
+import org.bukkit.plugin.AuthorNagException;
 
 /**
  * A ClassLoader for plugins, to allow shared classes across multiple plugins
  */
-final class PluginClassLoader extends URLClassLoader {
+public class PluginClassLoader extends URLClassLoader {
     private final JavaPluginLoader loader;
     private final Map<String, Class<?>> classes = new HashMap<String, Class<?>>();
-    private final PluginDescriptionFile description;
-    private final File dataFolder;
-    private final File file;
-    final JavaPlugin plugin;
-    private JavaPlugin pluginInit;
-    private IllegalStateException pluginState;
-
-    PluginClassLoader(final JavaPluginLoader loader, final ClassLoader parent, final PluginDescriptionFile description, final File dataFolder, final File file) throws InvalidPluginException, MalformedURLException {
-        super(new URL[] {file.toURI().toURL()}, parent);
+    final boolean extended = this.getClass() != PluginClassLoader.class;
+
+    /**
+     * Internal class not intended to be exposed
+     */
+    @Deprecated
+    public PluginClassLoader(final JavaPluginLoader loader, final URL[] urls, final ClassLoader parent) {
+        this(loader, urls, parent, null);
+
+        if (loader.warn) {
+            if (extended) {
+                loader.server.getLogger().log(Level.WARNING, "PluginClassLoader not intended to be extended by " + getClass() + ", and may be final in a future version of Bukkit");
+            } else {
+                loader.server.getLogger().log(Level.WARNING, "Constructor \"public PluginClassLoader(JavaPluginLoader, URL[], ClassLoader)\" is Deprecated, and may be removed in a future version of Bukkit", new AuthorNagException(""));
+            }
+            loader.warn = false;
+        }
+    }
+
+
+    PluginClassLoader(final JavaPluginLoader loader, final URL[] urls, final ClassLoader parent, final Object methodSignature) {
+        super(urls, parent);
         Validate.notNull(loader, "Loader cannot be null");
 
         this.loader = loader;
-        this.description = description;
-        this.dataFolder = dataFolder;
-        this.file = file;
-
-        try {
-            Class<?> jarClass;
-            try {
-                jarClass = Class.forName(description.getMain(), true, this);
-            } catch (ClassNotFoundException ex) {
-                throw new InvalidPluginException("Cannot find main class `" + description.getMain() + "'", ex);
-            }
-
-            Class<? extends JavaPlugin> pluginClass;
-            try {
-                pluginClass = jarClass.asSubclass(JavaPlugin.class);
-            } catch (ClassCastException ex) {
-                throw new InvalidPluginException("main class `" + description.getMain() + "' does not extend JavaPlugin", ex);
-            }
+    }
 
-            plugin = pluginClass.newInstance();
-        } catch (IllegalAccessException ex) {
-            throw new InvalidPluginException("No public constructor", ex);
-        } catch (InstantiationException ex) {
-            throw new InvalidPluginException("Abnormal plugin type", ex);
-        }
+    @Override
+    public void addURL(URL url) { // Override for access level!
+        super.addURL(url);
     }
 
     @Override
     protected Class<?> findClass(String name) throws ClassNotFoundException {
-        return findClass(name, true);
+        return extended ? findClass(name, true) : findClass0(name, true); // Don't warn on deprecation, but maintain overridability
     }
 
-    Class<?> findClass(String name, boolean checkGlobal) throws ClassNotFoundException {
+    /**
+     * @deprecated Internal method that wasn't intended to be exposed
+     */
+    @Deprecated
+    protected Class<?> findClass(String name, boolean checkGlobal) throws ClassNotFoundException {
+        if (loader.warn) {
+            loader.server.getLogger().log(Level.WARNING, "Method \"protected Class<?> findClass(String, boolean)\" is Deprecated, and may be removed in a future version of Bukkit", new AuthorNagException(""));
+            loader.warn = false;
+        }
+        return findClass0(name, checkGlobal);
+    }
+
+    Class<?> findClass0(String name, boolean checkGlobal) throws ClassNotFoundException {
         if (name.startsWith("org.bukkit.") || name.startsWith("net.minecraft.")) {
             throw new ClassNotFoundException(name);
         }
@@ -70,14 +73,18 @@ final class PluginClassLoader extends URLClassLoader {
 
         if (result == null) {
             if (checkGlobal) {
-                result = loader.getClassByName(name);
+                result = loader.extended ? loader.getClassByName(name) : loader.getClassByName0(name); // Don't warn on deprecation, but maintain overridability
             }
 
             if (result == null) {
                 result = super.findClass(name);
 
                 if (result != null) {
-                    loader.setClass(name, result);
+                    if (loader.extended) { // Don't warn on deprecation, but maintain overridability
+                        loader.setClass(name, result);
+                    } else {
+                        loader.setClass0(name, result);
+                    }
                 }
             }
 
@@ -87,20 +94,19 @@ final class PluginClassLoader extends URLClassLoader {
         return result;
     }
 
-    Set<String> getClasses() {
-        return classes.keySet();
-    }
-
-    synchronized void initialize(JavaPlugin javaPlugin) {
-        Validate.notNull(javaPlugin, "Initializing plugin cannot be null");
-        Validate.isTrue(javaPlugin.getClass().getClassLoader() == this, "Cannot initialize plugin outside of this class loader");
-        if (this.plugin != null || this.pluginInit != null) {
-            throw new IllegalArgumentException("Plugin already initialized!", pluginState);
+    /**
+     * @deprecated Internal method that wasn't intended to be exposed
+     */
+    @Deprecated
+    public Set<String> getClasses() {
+        if (loader.warn) {
+            loader.server.getLogger().log(Level.WARNING, "Method \"public Set<String> getClasses()\" is Deprecated, and may be removed in a future version of Bukkit", new AuthorNagException(""));
+            loader.warn = false;
         }
+        return getClasses0();
+    }
 
-        pluginState = new IllegalStateException("Initial initialization");
-        this.pluginInit = javaPlugin;
-
-        javaPlugin.init(loader, loader.server, description, dataFolder, file, this);
+    Set<String> getClasses0() {
+        return classes.keySet();
     }
 }
diff --git a/src/main/java/org/bukkit/plugin/messaging/ChannelNotRegisteredException.java b/src/main/java/org/bukkit/plugin/messaging/ChannelNotRegisteredException.java
index 2266f17..c3a797d 100644
--- a/src/main/java/org/bukkit/plugin/messaging/ChannelNotRegisteredException.java
+++ b/src/main/java/org/bukkit/plugin/messaging/ChannelNotRegisteredException.java
@@ -10,6 +10,6 @@ public class ChannelNotRegisteredException extends RuntimeException {
     }
 
     public ChannelNotRegisteredException(String channel) {
-        super("Attempted to send a plugin message through the unregistered channel `" + channel + "'.");
+        super("Attempted to send a plugin message through an unregistered channel ('" + channel + "'.");
     }
 }
diff --git a/src/main/java/org/bukkit/plugin/messaging/StandardMessenger.java b/src/main/java/org/bukkit/plugin/messaging/StandardMessenger.java
index a906f8d..4c171e8 100644
--- a/src/main/java/org/bukkit/plugin/messaging/StandardMessenger.java
+++ b/src/main/java/org/bukkit/plugin/messaging/StandardMessenger.java
@@ -421,7 +421,15 @@ public class StandardMessenger implements Messenger {
         Set<PluginMessageListenerRegistration> registrations = getIncomingChannelRegistrations(channel);
 
         for (PluginMessageListenerRegistration registration : registrations) {
-            registration.getListener().onPluginMessageReceived(channel, source, message);
+            // Spigot Start
+            try
+            {
+                registration.getListener().onPluginMessageReceived( channel, source, message );
+            } catch ( Throwable t )
+            {
+                org.bukkit.Bukkit.getLogger().log( java.util.logging.Level.WARNING, "Could not pass incoming plugin message to " + registration.getPlugin(), t );
+            }
+            // Spigot End
         }
     }
 
diff --git a/src/main/java/org/bukkit/util/StringUtil.java b/src/main/java/org/bukkit/util/StringUtil.java
index 4a8753f..ed309cc 100644
--- a/src/main/java/org/bukkit/util/StringUtil.java
+++ b/src/main/java/org/bukkit/util/StringUtil.java
@@ -21,7 +21,7 @@ public class StringUtil {
      * @throws IllegalArgumentException if originals contains a null element.
      *     <b>Note: the collection may be modified before this is thrown</b>
      */
-    public static <T extends Collection<? super String>> T copyPartialMatches(final String token, final Iterable<String> originals, final T collection) throws UnsupportedOperationException, IllegalArgumentException {
+    public static <T extends Collection<String>> T copyPartialMatches(final String token, final Iterable<String> originals, final T collection) throws UnsupportedOperationException, IllegalArgumentException {
         Validate.notNull(token, "Search token cannot be null");
         Validate.notNull(collection, "Collection cannot be null");
         Validate.notNull(originals, "Originals cannot be null");
@@ -36,7 +36,7 @@ public class StringUtil {
     }
 
     /**
-     * This method uses a region to check case-insensitive equality. This
+     * This method uses a substring to check case-insensitive equality. This
      * means the internal array does not need to be copied like a
      * toLowerCase() call would.
      *
@@ -52,6 +52,6 @@ public class StringUtil {
         if (string.length() < prefix.length()) {
             return false;
         }
-        return string.regionMatches(true, 0, prefix, 0, prefix.length());
+        return string.substring(0, prefix.length()).equalsIgnoreCase(prefix);
     }
 }
diff --git a/src/main/java/org/spigotmc/CustomTimingsHandler.java b/src/main/java/org/spigotmc/CustomTimingsHandler.java
new file mode 100644
index 0000000..9fca481
--- /dev/null
+++ b/src/main/java/org/spigotmc/CustomTimingsHandler.java
@@ -0,0 +1,175 @@
+package org.spigotmc;
+
+import org.bukkit.event.HandlerList;
+import org.bukkit.plugin.Plugin;
+import org.bukkit.plugin.RegisteredListener;
+import org.bukkit.plugin.TimedRegisteredListener;
+import java.io.PrintStream;
+import java.util.Collection;
+import java.util.HashSet;
+import org.bukkit.Bukkit;
+import org.bukkit.World;
+
+/**
+ * Provides custom timing sections for /timings merged.
+ */
+public class CustomTimingsHandler
+{
+
+    private static final Collection<CustomTimingsHandler> ALL_HANDLERS = new HashSet<CustomTimingsHandler>();
+    private static CustomTimingsHandler[] BAKED_HANDLERS;
+    /*========================================================================*/
+    private final String name;
+    private final CustomTimingsHandler parent;
+    private long count = 0;
+    private long start = 0;
+    private long timingDepth = 0;
+    private long totalTime = 0;
+    private long curTickTotal = 0;
+    private long violations = 0;
+
+    public CustomTimingsHandler(String name)
+    {
+        this( name, null );
+    }
+
+    public CustomTimingsHandler(String name, CustomTimingsHandler parent)
+    {
+        this.name = name;
+        this.parent = parent;
+        ALL_HANDLERS.add( this );
+        BAKED_HANDLERS = ALL_HANDLERS.toArray( new CustomTimingsHandler[ ALL_HANDLERS.size() ] );
+    }
+
+    /**
+     * Prints the timings and extra data to the given stream.
+     *
+     * @param printStream
+     */
+    public static void printTimings(PrintStream printStream)
+    {
+        printStream.println( "Minecraft" );
+        for ( CustomTimingsHandler timings : BAKED_HANDLERS )
+        {
+            long time = timings.totalTime;
+            long count = timings.count;
+            if ( count == 0 )
+            {
+                continue;
+            }
+            long avg = time / count;
+
+            printStream.println( "    " + timings.name + " Time: " + time + " Count: " + count + " Avg: " + avg + " Violations: " + timings.violations );
+        }
+        printStream.println( "# Version " + Bukkit.getVersion() );
+        int entities = 0;
+        int livingEntities = 0;
+        for ( World world : Bukkit.getWorlds() )
+        {
+            entities += world.getEntities().size();
+            livingEntities += world.getLivingEntities().size();
+        }
+        printStream.println( "# Entities " + entities );
+        printStream.println( "# LivingEntities " + livingEntities );
+    }
+
+    /**
+     * Resets all timings.
+     */
+    public static void reload()
+    {
+        if ( Bukkit.getPluginManager().useTimings() )
+        {
+            for ( CustomTimingsHandler timings : BAKED_HANDLERS )
+            {
+                timings.reset();
+            }
+        }
+    }
+
+    /**
+     * Ticked every tick by CraftBukkit to count the number of times a timer
+     * caused TPS loss.
+     */
+    public static void tick()
+    {
+        if ( Bukkit.getPluginManager().useTimings() )
+        {
+            for ( CustomTimingsHandler timings : BAKED_HANDLERS )
+            {
+                if ( timings.curTickTotal > 50000000 )
+                {
+                    timings.violations += Math.ceil( timings.curTickTotal / 50000000 );
+                }
+                timings.curTickTotal = 0;
+                timings.timingDepth = 0; // incase reset messes this up
+            }
+
+            for ( Plugin plugin : Bukkit.getPluginManager().getPlugins() )
+            {
+                for ( RegisteredListener listener : HandlerList.getRegisteredListeners( plugin ) )
+                {
+                    if ( listener instanceof TimedRegisteredListener )
+                    {
+                        TimedRegisteredListener timings = (TimedRegisteredListener) listener;
+                        if ( timings.curTickTotal > 50000000 )
+                        {
+                            timings.violations += Math.ceil( timings.curTickTotal / 50000000 );
+                        }
+                        timings.curTickTotal = 0;
+                    }
+                }
+            }
+        }
+    }
+
+    /**
+     * Starts timing to track a section of code.
+     */
+    public void startTiming()
+    {
+        // If second condtion fails we are already timing
+        if ( Bukkit.getPluginManager().useTimings() && ++timingDepth == 1 )
+        {
+            start = System.nanoTime();
+            if ( parent != null && ++parent.timingDepth == 1 )
+            {
+                parent.start = start;
+            }
+        }
+    }
+
+    /**
+     * Stops timing a section of code.
+     */
+    public void stopTiming()
+    {
+        if ( Bukkit.getPluginManager().useTimings() )
+        {
+            if ( --timingDepth != 0 || start == 0 )
+            {
+                return;
+            }
+            long diff = System.nanoTime() - start;
+            totalTime += diff;
+            curTickTotal += diff;
+            count++;
+            start = 0;
+            if ( parent != null )
+            {
+                parent.stopTiming();
+            }
+        }
+    }
+
+    /**
+     * Reset this timer, setting all values to zero.
+     */
+    public void reset()
+    {
+        count = 0;
+        violations = 0;
+        curTickTotal = 0;
+        totalTime = 0;
+    }
+}
diff --git a/src/main/java/org/spigotmc/event/entity/EntityDismountEvent.java b/src/main/java/org/spigotmc/event/entity/EntityDismountEvent.java
new file mode 100644
index 0000000..24d4942
--- /dev/null
+++ b/src/main/java/org/spigotmc/event/entity/EntityDismountEvent.java
@@ -0,0 +1,39 @@
+package org.spigotmc.event.entity;
+
+import org.bukkit.entity.Entity;
+import org.bukkit.event.HandlerList;
+import org.bukkit.event.entity.EntityEvent;
+
+/**
+ * Called when an entity stops riding another entity.
+ *
+ */
+public class EntityDismountEvent extends EntityEvent
+{
+
+    private static final HandlerList handlers = new HandlerList();
+    private boolean cancelled;
+    private final Entity dismounted;
+
+    public EntityDismountEvent(Entity what, Entity dismounted)
+    {
+        super( what );
+        this.dismounted = dismounted;
+    }
+
+    public Entity getDismounted()
+    {
+        return dismounted;
+    }
+
+    @Override
+    public HandlerList getHandlers()
+    {
+        return handlers;
+    }
+
+    public static HandlerList getHandlerList()
+    {
+        return handlers;
+    }
+}
diff --git a/src/main/java/org/spigotmc/event/entity/EntityMountEvent.java b/src/main/java/org/spigotmc/event/entity/EntityMountEvent.java
new file mode 100644
index 0000000..16aa2a7
--- /dev/null
+++ b/src/main/java/org/spigotmc/event/entity/EntityMountEvent.java
@@ -0,0 +1,52 @@
+package org.spigotmc.event.entity;
+
+import org.bukkit.entity.Entity;
+import org.bukkit.event.Cancellable;
+import org.bukkit.event.HandlerList;
+import org.bukkit.event.entity.EntityEvent;
+
+/**
+ * Called when an entity attempts to ride another entity.
+ *
+ */
+public class EntityMountEvent extends EntityEvent implements Cancellable
+{
+
+    private static final HandlerList handlers = new HandlerList();
+    private boolean cancelled;
+    private final Entity mount;
+
+    public EntityMountEvent(Entity what, Entity mount)
+    {
+        super( what );
+        this.mount = mount;
+    }
+
+    public Entity getMount()
+    {
+        return mount;
+    }
+
+    @Override
+    public boolean isCancelled()
+    {
+        return cancelled;
+    }
+
+    @Override
+    public void setCancelled(boolean cancel)
+    {
+        this.cancelled = cancel;
+    }
+
+    @Override
+    public HandlerList getHandlers()
+    {
+        return handlers;
+    }
+
+    public static HandlerList getHandlerList()
+    {
+        return handlers;
+    }
+}
diff --git a/src/test/java/org/bukkit/EffectTest.java b/src/test/java/org/bukkit/EffectTest.java
index 08aa71d..5217aec 100644
--- a/src/test/java/org/bukkit/EffectTest.java
+++ b/src/test/java/org/bukkit/EffectTest.java
@@ -9,7 +9,11 @@ public class EffectTest {
     @Test
     public void getById() {
         for (Effect effect : Effect.values()) {
-            assertThat(Effect.getById(effect.getId()), is(effect));
+            if (effect.getType() != Effect.Type.PARTICLE) {
+                assertThat(Effect.getById(effect.getId()), is(effect));
+            } else {
+                assertThat(Effect.getByName(effect.getName()), is(effect));
+            }
         }
     }
 }
diff --git a/src/test/java/org/bukkit/plugin/TimedRegisteredListenerTest.java b/src/test/java/org/bukkit/plugin/TimedRegisteredListenerTest.java
index b206b1f..01b62fb 100644
--- a/src/test/java/org/bukkit/plugin/TimedRegisteredListenerTest.java
+++ b/src/test/java/org/bukkit/plugin/TimedRegisteredListenerTest.java
@@ -15,7 +15,6 @@ import org.junit.Test;
 
 public class TimedRegisteredListenerTest {
 
-    @Test
     public void testEventClass() throws EventException {
         Listener listener = new Listener() {};
         EventExecutor executor = new EventExecutor() {
diff --git a/src/test/java/org/bukkit/util/StringUtilStartsWithTest.java b/src/test/java/org/bukkit/util/StringUtilStartsWithTest.java
deleted file mode 100644
index b85a2b2..0000000
--- a/src/test/java/org/bukkit/util/StringUtilStartsWithTest.java
+++ /dev/null
@@ -1,86 +0,0 @@
-package org.bukkit.util;
-
-import static org.hamcrest.Matchers.*;
-import static org.junit.Assert.*;
-
-import java.util.List;
-
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.Parameterized;
-import org.junit.runners.Parameterized.Parameter;
-import org.junit.runners.Parameterized.Parameters;
-
-import com.google.common.collect.ImmutableList;
-
-@RunWith(Parameterized.class)
-public class StringUtilStartsWithTest {
-
-    @Parameters(name= "{index}: {0} startsWith {1} == {2}")
-    public static List<Object[]> data() {
-        return ImmutableList.<Object[]>of(
-            new Object[] {
-                "Apple",
-                "Apples",
-                false
-            },
-            new Object[] {
-                "Apples",
-                "Apple",
-                true
-            },
-            new Object[] {
-                "Apple",
-                "Apple",
-                true
-            },
-            new Object[] {
-                "Apple",
-                "apples",
-                false
-            },
-            new Object[] {
-                "apple",
-                "Apples",
-                false
-            },
-            new Object[] {
-                "apple",
-                "apples",
-                false
-            },
-            new Object[] {
-                "Apples",
-                "apPL",
-                true
-            },
-            new Object[] {
-                "123456789",
-                "1234567",
-                true
-            },
-            new Object[] {
-                "",
-                "",
-                true
-            },
-            new Object[] {
-                "string",
-                "",
-                true
-            }
-        );
-    }
-
-    @Parameter(0)
-    public String base;
-    @Parameter(1)
-    public String prefix;
-    @Parameter(2)
-    public boolean result;
-
-    @Test
-    public void testFor() {
-        assertThat(base + " starts with " + prefix + ": " + result, StringUtil.startsWithIgnoreCase(base, prefix), is(result));
-    }
-}
diff --git a/src/test/java/org/bukkit/util/StringUtilTest.java b/src/test/java/org/bukkit/util/StringUtilTest.java
deleted file mode 100644
index 9c8444c..0000000
--- a/src/test/java/org/bukkit/util/StringUtilTest.java
+++ /dev/null
@@ -1,61 +0,0 @@
-package org.bukkit.util;
-
-import static org.hamcrest.Matchers.*;
-import static org.junit.Assert.*;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-
-import org.junit.Test;
-
-import com.google.common.collect.ImmutableList;
-
-public class StringUtilTest {
-
-    @Test(expected=NullPointerException.class)
-    public void nullPrefixTest() {
-        StringUtil.startsWithIgnoreCase("String", null);
-    }
-
-    @Test(expected=IllegalArgumentException.class)
-    public void nullStringTest() {
-        StringUtil.startsWithIgnoreCase(null, "String");
-    }
-
-    @Test(expected=IllegalArgumentException.class)
-    public void nullCollectionTest() {
-        StringUtil.copyPartialMatches("Token", ImmutableList.<String>of(), null);
-    }
-
-    @Test(expected=IllegalArgumentException.class)
-    public void nullIterableTest() {
-        StringUtil.copyPartialMatches("Token", null, new ArrayList<String>());
-    }
-
-    @Test(expected=IllegalArgumentException.class)
-    public void nullTokenTest() {
-        StringUtil.copyPartialMatches(null, ImmutableList.<String>of(), new ArrayList<String>());
-    }
-
-    @Test
-    public void copyTokenTest() {
-        String token = "ab";
-        Iterable<String> original = ImmutableList.of("ab12", "aC561", "AB5195", "Ab76", "", "a");
-        List<String> expected =     ImmutableList.of("ab12",          "AB5195", "Ab76"         );
-        List<String> list = new ArrayList<String>();
-        assertThat(StringUtil.copyPartialMatches(token, original, list), is(expected));
-        assertThat(StringUtil.copyPartialMatches(token, original, list), is(sameInstance(list)));
-        assertThat(list.size(), is(expected.size() * 2));
-    }
-
-    @Test(expected=UnsupportedOperationException.class)
-    public void copyUnsupportedTest() {
-        StringUtil.copyPartialMatches("token", ImmutableList.of("token1", "token2"), ImmutableList.of());
-    }
-
-    @Test(expected=IllegalArgumentException.class)
-    public void copyNullTest() {
-        StringUtil.copyPartialMatches("token", Arrays.asList("token1", "token2", null), new ArrayList<String>());
-    }
-}
-- 
1.8.3.2

