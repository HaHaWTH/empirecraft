From 30c6a38092fa1b4bb908cb2b8b391fba1c0027ec Mon Sep 17 00:00:00 2001
From: md_5 <md_5@bigpond.com>
Date: Thu, 19 Sep 2013 15:01:10 -0400
Subject: [PATCH] Spigot

---
 pom.xml                                            |  54 ++----
 src/main/java/org/bukkit/Effect.java               | 195 ++++++++++++++++++++-
 src/main/java/org/bukkit/OfflinePlayer.java        |   1 +
 src/main/java/org/bukkit/Rotation.java             |   1 +
 src/main/java/org/bukkit/Sound.java                |  39 ++++-
 src/main/java/org/bukkit/TravelAgent.java          |  58 ++++--
 src/main/java/org/bukkit/TreeType.java             |   1 +
 src/main/java/org/bukkit/Warning.java              |   1 +
 src/main/java/org/bukkit/World.java                |  50 ++++++
 .../org/bukkit/command/BlockCommandSender.java     |   1 +
 src/main/java/org/bukkit/command/Command.java      |   6 +-
 .../org/bukkit/command/MultipleCommandAlias.java   |   5 +
 .../java/org/bukkit/command/PluginCommand.java     |   2 +
 .../java/org/bukkit/command/SimpleCommandMap.java  |   7 +-
 .../org/bukkit/command/TabCommandExecutor.java     |   1 +
 .../org/bukkit/command/defaults/ReloadCommand.java |   1 +
 .../org/bukkit/command/defaults/SayCommand.java    |  23 ++-
 .../command/defaults/SpreadPlayersCommand.java     |  41 +++--
 .../bukkit/command/defaults/TimingsCommand.java    | 111 +++++++++++-
 .../bukkit/command/defaults/VanillaCommand.java    |   1 +
 .../InvalidConfigurationException.java             |   1 +
 .../serialization/ConfigurationSerializable.java   |   2 +
 .../serialization/SerializableAs.java              |   1 +
 .../org/bukkit/conversations/BooleanPrompt.java    |   3 +-
 .../org/bukkit/conversations/Conversation.java     |   7 +
 .../bukkit/conversations/ConversationContext.java  |   8 +
 src/main/java/org/bukkit/entity/AnimalTamer.java   |   1 +
 src/main/java/org/bukkit/entity/Arrow.java         |  20 ++-
 .../java/org/bukkit/entity/ComplexEntityPart.java  |   1 +
 src/main/java/org/bukkit/entity/Entity.java        |  18 ++
 src/main/java/org/bukkit/entity/EntityType.java    |   3 +-
 src/main/java/org/bukkit/entity/ExperienceOrb.java |   1 +
 src/main/java/org/bukkit/entity/Explosive.java     |   1 +
 src/main/java/org/bukkit/entity/Fireball.java      |   1 +
 src/main/java/org/bukkit/entity/Firework.java      |   1 +
 src/main/java/org/bukkit/entity/Ocelot.java        |   1 +
 src/main/java/org/bukkit/entity/Painting.java      |   1 +
 src/main/java/org/bukkit/entity/PigZombie.java     |   1 +
 src/main/java/org/bukkit/entity/Player.java        |  45 +++++
 src/main/java/org/bukkit/entity/Skeleton.java      |   1 +
 src/main/java/org/bukkit/entity/TNTPrimed.java     |   1 +
 src/main/java/org/bukkit/entity/Zombie.java        |   1 +
 src/main/java/org/bukkit/event/Cancellable.java    |   1 +
 src/main/java/org/bukkit/event/EventPriority.java  |   1 +
 src/main/java/org/bukkit/event/HandlerList.java    |   1 +
 .../bukkit/event/entity/CreatureSpawnEvent.java    |  36 +---
 .../event/entity/EntityCombustByBlockEvent.java    |   3 +
 .../event/entity/EntityCombustByEntityEvent.java   |   3 +
 .../org/bukkit/event/entity/EntityPortalEvent.java |  39 ++++-
 .../org/bukkit/event/entity/EntitySpawnEvent.java  |  45 +++++
 .../org/bukkit/event/entity/ItemDespawnEvent.java  |   7 +
 .../org/bukkit/event/entity/ItemSpawnEvent.java    |  40 +----
 .../org/bukkit/event/entity/SpawnerSpawnEvent.java |  22 +++
 .../java/org/bukkit/event/inventory/ClickType.java |   1 +
 .../org/bukkit/event/inventory/CraftItemEvent.java |   3 +
 .../bukkit/event/inventory/InventoryAction.java    |   2 +
 .../event/inventory/InventoryClickEvent.java       |  16 ++
 .../org/bukkit/event/inventory/InventoryType.java  |   1 +
 .../org/bukkit/event/player/PlayerBucketEvent.java |   3 +
 .../bukkit/event/player/PlayerEditBookEvent.java   |   2 +-
 .../bukkit/event/player/PlayerItemDamageEvent.java |  54 ++++++
 .../org/bukkit/event/player/PlayerLoginEvent.java  |  27 ++-
 .../org/bukkit/event/player/PlayerPortalEvent.java |  39 ++++-
 .../bukkit/event/vehicle/VehicleUpdateEvent.java   |   3 +
 .../java/org/bukkit/generator/BlockPopulator.java  |   1 +
 .../java/org/bukkit/generator/ChunkGenerator.java  |   1 +
 .../java/org/bukkit/inventory/BeaconInventory.java |   1 +
 .../java/org/bukkit/inventory/BrewerInventory.java |   1 +
 .../org/bukkit/inventory/CraftingInventory.java    |   1 +
 .../org/bukkit/inventory/DoubleChestInventory.java |   1 +
 .../org/bukkit/inventory/EnchantingInventory.java  |   1 +
 .../java/org/bukkit/inventory/EntityEquipment.java |   1 +
 .../org/bukkit/inventory/FurnaceInventory.java     |   1 +
 src/main/java/org/bukkit/inventory/Inventory.java  |  25 ++-
 .../java/org/bukkit/inventory/InventoryHolder.java |   1 +
 .../java/org/bukkit/permissions/Permissible.java   |   1 +
 .../permissions/PermissionRemovedExecutor.java     |   1 +
 .../org/bukkit/permissions/ServerOperator.java     |   1 +
 .../org/bukkit/plugin/SimplePluginManager.java     |   1 +
 .../org/bukkit/plugin/TimedRegisteredListener.java |  21 ++-
 .../org/bukkit/plugin/java/JavaPluginLoader.java   |   2 +-
 src/main/java/org/bukkit/potion/Potion.java        |  14 +-
 src/main/java/org/bukkit/potion/PotionBrewer.java  |   1 +
 src/main/java/org/bukkit/potion/PotionType.java    |   5 -
 src/main/java/org/bukkit/scheduler/BukkitTask.java |   1 -
 .../java/org/bukkit/scheduler/BukkitWorker.java    |   1 -
 src/main/java/org/bukkit/util/FileUtil.java        |   2 -
 .../bukkit/util/io/BukkitObjectInputStream.java    |   4 +-
 .../bukkit/util/io/BukkitObjectOutputStream.java   |   4 +-
 .../java/org/spigotmc/CustomTimingsHandler.java    | 175 ++++++++++++++++++
 .../spigotmc/event/entity/EntityDismountEvent.java |  39 +++++
 .../spigotmc/event/entity/EntityMountEvent.java    |  52 ++++++
 src/test/java/org/bukkit/EffectTest.java           |   6 +-
 .../bukkit/plugin/TimedRegisteredListenerTest.java |   1 -
 94 files changed, 1230 insertions(+), 205 deletions(-)
 create mode 100644 src/main/java/org/bukkit/event/entity/EntitySpawnEvent.java
 create mode 100644 src/main/java/org/bukkit/event/entity/SpawnerSpawnEvent.java
 create mode 100644 src/main/java/org/bukkit/event/player/PlayerItemDamageEvent.java
 create mode 100644 src/main/java/org/spigotmc/CustomTimingsHandler.java
 create mode 100644 src/main/java/org/spigotmc/event/entity/EntityDismountEvent.java
 create mode 100644 src/main/java/org/spigotmc/event/entity/EntityMountEvent.java

diff --git a/pom.xml b/pom.xml
index 61d07b9..8bfe7ba 100644
--- a/pom.xml
+++ b/pom.xml
@@ -1,43 +1,23 @@
 <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
     <modelVersion>4.0.0</modelVersion>
-    <groupId>org.bukkit</groupId>
-    <artifactId>bukkit</artifactId>
-    <version>1.6.2-R0.2-SNAPSHOT</version>
-    <name>Bukkit</name>
-    <url>http://www.bukkit.org</url>
+
+    <parent>
+        <groupId>org.spigotmc</groupId>
+        <artifactId>spigot-parent</artifactId>
+        <version>dev-SNAPSHOT</version>
+        <relativePath>../pom.xml</relativePath>
+    </parent>
+
+    <groupId>org.spigotmc</groupId>
+    <artifactId>spigot-api</artifactId>
+    <version>1.6.2-R1.1-SNAPSHOT</version>
+    <name>Spigot-API</name>
+    <url>http://www.spigotmc.org</url>
 
     <properties>
         <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
     </properties>
 
-    <scm>
-        <developerConnection>scm:git:git@github.com:Bukkit/Bukkit.git</developerConnection>
-        <connection>scm:git:git://github.com/Bukkit/Bukkit.git</connection>
-        <url>https://github.com/Bukkit/Bukkit/tree/master/</url>
-    </scm>
-
-    <ciManagement>
-        <system>jenkins</system>
-        <url>http://ci.bukkit.org</url>
-    </ciManagement>
-
-    <distributionManagement>
-        <site>
-            <id>jd.bukkit.org</id>
-            <url>file:///home/javadocs/public_html/</url>
-        </site>
-        <repository>
-            <id>repobo-rel</id>
-            <name>repo.bukkit.org Releases</name>
-            <url>http://repo.bukkit.org/content/repositories/releases/</url>
-        </repository>
-        <snapshotRepository>
-            <id>repobo-snap</id>
-            <name>repo.bukkit.org Snapshots</name>
-            <url>http://repo.bukkit.org/content/repositories/snapshots/</url>
-        </snapshotRepository>
-    </distributionManagement>
-
     <build>
         <plugins>
             <plugin>
@@ -98,21 +78,21 @@
         <dependency>
             <groupId>org.yaml</groupId>
             <artifactId>snakeyaml</artifactId>
-            <version>1.9</version>
+            <version>1.12</version>
             <type>jar</type>
             <scope>compile</scope>
         </dependency>
         <dependency>
             <groupId>com.googlecode.json-simple</groupId>
             <artifactId>json-simple</artifactId>
-            <version>1.1</version>
+            <version>1.1.1</version>
             <type>jar</type>
             <scope>compile</scope>
         </dependency>
         <dependency>
             <groupId>org.avaje</groupId>
             <artifactId>ebean</artifactId>
-            <version>2.7.3</version>
+            <version>2.8.1</version>
             <type>jar</type>
             <scope>compile</scope>
         </dependency>
@@ -126,7 +106,7 @@
         <dependency>
             <groupId>commons-lang</groupId>
             <artifactId>commons-lang</artifactId>
-            <version>2.3</version>
+            <version>2.6</version>
         </dependency>
 
         <!-- testing -->
diff --git a/src/main/java/org/bukkit/Effect.java b/src/main/java/org/bukkit/Effect.java
index 708bee9..62c7c11 100644
--- a/src/main/java/org/bukkit/Effect.java
+++ b/src/main/java/org/bukkit/Effect.java
@@ -5,6 +5,7 @@ import java.util.Map;
 import com.google.common.collect.Maps;
 
 import org.bukkit.block.BlockFace;
+import org.bukkit.material.MaterialData;
 import org.bukkit.potion.Potion;
 
 /**
@@ -78,27 +79,178 @@ public enum Effect {
     /**
      * The flames seen on a mobspawner; a visual effect.
      */
-    MOBSPAWNER_FLAMES(2004, Type.VISUAL);
+    MOBSPAWNER_FLAMES(2004, Type.VISUAL),
+    /**
+     * The spark that comes off a fireworks
+     */
+    FIREWORKS_SPARK("fireworksSpark", Type.PARTICLE),
+    /**
+     * Critical hit particles
+     */
+    CRIT("crit", Type.PARTICLE),
+    /**
+     * Blue critical hit particles
+     */
+    MAGIC_CRIT("magicCrit", Type.PARTICLE),
+    /**
+     * Multicolored potion effect particles
+     */
+    POTION_SWIRL("mobSpell", Type.PARTICLE),
+    /**
+     * Multicolored potion effect particles that are slightly transparent
+     */
+    POTION_SWIRL_TRANSPARENT("mobSpellAmbient", Type.PARTICLE),
+    /**
+     * A puff of white potion swirls
+     */
+    SPELL("spell", Type.PARTICLE),
+    /**
+     * A puff of white stars
+     */
+    INSTANT_SPELL("instantSpell", Type.PARTICLE),
+    /**
+     * A puff of purple particles
+     */
+    WITCH_MAGIC("witchMagic", Type.PARTICLE),
+    /**
+     * The note that appears above note blocks
+     */
+    NOTE("note", Type.PARTICLE),
+    /**
+     * The particles shown at nether portals
+     */
+    PORTAL("portal", Type.PARTICLE),
+    /**
+     * The symbols that fly towards the enchantment table
+     */
+    FLYING_GLYPH("enchantmenttable", Type.PARTICLE),
+    /**
+     * Fire particles
+     */
+    FLAME("flame", Type.PARTICLE),
+    /**
+     * The particles that pop out of lava
+     */
+    LAVA_POP("lava", Type.PARTICLE),
+    /**
+     * A small gray square
+     */
+    FOOTSTEP("footstep", Type.PARTICLE),
+    /**
+     * Water particles
+     */
+    SPLASH("splash", Type.PARTICLE),
+    /**
+     * Smoke particles
+     */
+    PARTICLE_SMOKE("smoke", Type.PARTICLE),
+    /**
+     * The biggest explosion particle effect
+     */
+    EXPLOSION_HUGE("hugeexplosion", Type.PARTICLE),
+    /**
+     * A larger version of the explode particle
+     */
+    EXPLOSION_LARGE("largeexplode", Type.PARTICLE),
+    /**
+     * Explosion particles
+     */
+    EXPLOSION("explode", Type.PARTICLE),
+    /**
+     * Small gray particles
+     */
+    VOID_FOG("depthsuspend", Type.PARTICLE),
+    /**
+     * Small gray particles
+     */
+    SMALL_SMOKE("townaura", Type.PARTICLE),
+    /**
+     * A puff of white smoke
+     */
+    CLOUD("cloud", Type.PARTICLE),
+    /**
+     * Multicolored dust particles
+     */
+    COLOURED_DUST("reddust", Type.PARTICLE),
+    /**
+     * Snowball breaking
+     */
+    SNOWBALL_BREAK("snowballpoof", Type.PARTICLE),
+    /**
+     * The water drip particle that appears on blocks under water
+     */
+    WATERDRIP("dripWater", Type.PARTICLE),
+    /**
+     * The lava drip particle that appears on blocks under lava
+     */
+    LAVADRIP("dripLava", Type.PARTICLE),
+    /**
+     * White particles
+     */
+    SNOW_SHOVEL("snowshovel", Type.PARTICLE),
+    /**
+     * The particle shown when a slime jumps
+     */
+    SLIME("slime", Type.PARTICLE),
+    /**
+     * The particle that appears when breading animals
+     */
+    HEART("heart", Type.PARTICLE),
+    /**
+     * The particle that appears when hitting a villager
+     */
+    VILLAGER_THUNDERCLOUD("angryVillager", Type.PARTICLE),
+    /**
+     * The particle that appears when trading with a villager
+     */
+    HAPPY_VILLAGER("happyVillager", Type.PARTICLE),
+    /**
+     * The particles generated when a tool breaks.
+     * This particle requires a Material so that the client can select the correct texture.
+     */
+    ITEM_BREAK("iconcrack", Type.PARTICLE, Material.class),
+    /**
+     * The particles generated while breaking a block.
+     * This particle requires a Material and data value so that the client can select the correct texture.
+     */
+    TILE_BREAK("tilecrack", Type.PARTICLE, MaterialData.class);
 
     private final int id;
     private final Type type;
     private final Class<?> data;
     private static final Map<Integer, Effect> BY_ID = Maps.newHashMap();
+    private static final Map<String, Effect> BY_NAME = Maps.newHashMap();
+    private final String particleName;
 
-    Effect(int id, Type type) {
+    private Effect(int id, Type type) {
         this(id,type,null);
     }
 
-    Effect(int id, Type type, Class<?> data) {
+    private Effect(int id, Type type, Class<?> data) {
         this.id = id;
         this.type = type;
         this.data = data;
+        particleName = null;
+    }
+
+    private Effect(String particleName, Type type, Class<?> data) {
+        this.particleName = particleName;
+        this.type = type;
+        id = 0;
+        this.data = data;
+    }
+
+    private Effect(String particleName, Type type) {
+        this.particleName = particleName;
+        this.type = type;
+        id = 0;
+        this.data = null;
     }
 
     /**
      * Gets the ID for this effect.
      *
-     * @return ID of this effect
+     * @return if this Effect isn't of type PARTICLE it returns ID of this effect
      * @deprecated Magic value
      */
     @Deprecated
@@ -107,6 +259,15 @@ public enum Effect {
     }
 
     /**
+     * Returns the effect's name. This returns null if the effect is not a particle
+     *
+     * @return The effect's name
+     */
+    public String getName() {
+        return particleName;
+    }
+
+    /**
      * @return The type of the effect.
      */
     public Type getType() {
@@ -114,7 +275,7 @@ public enum Effect {
     }
 
     /**
-     * @return The class which represents data for this effect, or null if none
+     * @return if this Effect isn't of type PARTICLE it returns the class which represents data for this effect, or null if none
      */
     public Class<?> getData() {
         return this.data;
@@ -134,12 +295,32 @@ public enum Effect {
 
     static {
         for (Effect effect : values()) {
-            BY_ID.put(effect.id, effect);
+            if (effect.type != Type.PARTICLE) {
+                BY_ID.put(effect.id, effect);
+            }
+        }
+    }
+
+    /**
+     * Gets the Effect associated with the given name.
+     *
+     * @param name name of the Effect to return
+     * @return Effect with the given name
+     */
+    public static Effect getByName(String name) {
+        return BY_NAME.get(name);
+    }
+
+    static {
+        for (Effect effect : values()) {
+            if (effect.type == Type.PARTICLE) {
+                BY_NAME.put(effect.particleName, effect);
+            }
         }
     }
 
     /**
      * Represents the type of an effect.
      */
-    public enum Type {SOUND, VISUAL}
+    public enum Type {SOUND, VISUAL, PARTICLE}
 }
diff --git a/src/main/java/org/bukkit/OfflinePlayer.java b/src/main/java/org/bukkit/OfflinePlayer.java
index 013dc0a..bf6682b 100644
--- a/src/main/java/org/bukkit/OfflinePlayer.java
+++ b/src/main/java/org/bukkit/OfflinePlayer.java
@@ -6,6 +6,7 @@ import org.bukkit.entity.Player;
 import org.bukkit.permissions.ServerOperator;
 
 public interface OfflinePlayer extends ServerOperator, AnimalTamer, ConfigurationSerializable {
+
     /**
      * Checks if this player is currently online
      *
diff --git a/src/main/java/org/bukkit/Rotation.java b/src/main/java/org/bukkit/Rotation.java
index 0244774..90df009 100644
--- a/src/main/java/org/bukkit/Rotation.java
+++ b/src/main/java/org/bukkit/Rotation.java
@@ -5,6 +5,7 @@ package org.bukkit;
  * It represents how something is viewed, as opposed to cardinal directions.
  */
 public enum Rotation {
+
     /**
      * No rotation
      */
diff --git a/src/main/java/org/bukkit/Sound.java b/src/main/java/org/bukkit/Sound.java
index d4b5ccf..90d4039 100644
--- a/src/main/java/org/bukkit/Sound.java
+++ b/src/main/java/org/bukkit/Sound.java
@@ -167,5 +167,42 @@ public enum Sound {
     DIG_SAND,
     DIG_SNOW,
     DIG_STONE,
-    DIG_WOOD
+    DIG_WOOD,
+    // Fireworks
+    FIREWORK_BLAST,
+    FIREWORK_BLAST2,
+    FIREWORK_LARGE_BLAST,
+    FIREWORK_LARGE_BLAST2,
+    FIREWORK_TWINKLE,
+    FIREWORK_TWINKLE2,
+    FIREWORK_LAUNCH,
+    SUCCESSFUL_HIT,
+    // Horses
+    HORSE_ANGRY,
+    HORSE_ARMOR,
+    HORSE_BREATHE,
+    HORSE_GALLOP,
+    HORSE_HIT,
+    HORSE_IDLE,
+    HORSE_JUMP,
+    HORSE_LAND,
+    HORSE_SADDLE,
+    HORSE_SOFT,
+    HORSE_WOOD,
+    DONKEY_ANGRY,
+    DONKEY_DEATH,
+    DONKEY_HIT,
+    DONKEY_IDLE,
+    HORSE_SKELETON_DEATH,
+    HORSE_SKELETON_IDLE,
+    HORSE_ZOMBIE_DEATH,
+    HORSE_ZOMBIE_HIT,
+    HORSE_ZOMBIE_IDLE,
+    // Villager
+    VILLAGER_DEATH,
+    VILLAGER_HAGGLE,
+    VILLAGER_HIT,
+    VILLAGER_IDLE,
+    VILLAGER_NO,
+    VILLAGER_YES,
 }
diff --git a/src/main/java/org/bukkit/TravelAgent.java b/src/main/java/org/bukkit/TravelAgent.java
index 5a545fc..2dfeffa 100644
--- a/src/main/java/org/bukkit/TravelAgent.java
+++ b/src/main/java/org/bukkit/TravelAgent.java
@@ -1,72 +1,94 @@
 package org.bukkit;
 
+/**
+ * The Travel Agent handles the creation and the research of Nether and End
+ * portals when Entities try to use one.
+ * <p>
+ * It is used in {@link org.bukkit.event.entity.EntityPortalEvent} and in
+ * {@link org.bukkit.event.player.PlayerPortalEvent} to help developers
+ * reproduce and/or modify Vanilla behaviour.
+ */
 public interface TravelAgent {
 
     /**
      * Set the Block radius to search in for available portals.
      *
-     * @param radius The radius in which to search for a portal from the location.
-     * @return This travel agent.
+     * @param radius the radius in which to search for a portal from the
+     *     location
+     * @return this travel agent
      */
     public TravelAgent setSearchRadius(int radius);
 
     /**
      * Gets the search radius value for finding an available portal.
      *
-     * @return Returns the currently set search radius.
+     * @return the currently set search radius
      */
     public int getSearchRadius();
 
     /**
      * Sets the maximum radius from the given location to create a portal.
      *
-     * @param radius The radius in which to create a portal from the location.
-     * @return This travel agent.
+     * @param radius the radius in which to create a portal from the location
+     * @return this travel agent
      */
     public TravelAgent setCreationRadius(int radius);
 
     /**
      * Gets the maximum radius from the given location to create a portal.
      *
-     * @return Returns the currently set creation radius.
+     * @return the currently set creation radius
      */
     public int getCreationRadius();
 
     /**
-     * Returns whether the TravelAgent will attempt to create a destination portal or not.
+     * Returns whether the TravelAgent will attempt to create a destination
+     * portal or not.
      *
-     * @return Return whether the TravelAgent should create a destination portal or not.
+     * @return whether the TravelAgent should create a destination portal or
+     *     not
      */
     public boolean getCanCreatePortal();
 
     /**
-     * Sets whether the TravelAgent should attempt to create a destination portal or not.
+     * Sets whether the TravelAgent should attempt to create a destination
+     * portal or not.
      *
-     * @param create Sets whether the TravelAgent should create a destination portal or not.
+     * @param create Sets whether the TravelAgent should create a destination
+     *     portal or not
      */
     public void setCanCreatePortal(boolean create);
 
     /**
-     * Attempt to find a portal near the given location, if a portal is not found it will attempt to create one.
+     * Attempt to find a portal near the given location, if a portal is not
+     * found it will attempt to create one.
      *
-     * @param location The location where the search for a portal should begin.
-     * @return Returns the location of a portal which has been found or returns the location passed to the method if unsuccessful.
+     * @param location the location where the search for a portal should begin
+     * @return the location of a portal which has been found or returns the
+     *     location passed to the method if unsuccessful
+     * @see #createPortal(Location)
      */
     public Location findOrCreate(Location location);
 
     /**
      * Attempt to find a portal near the given location.
      *
-     * @param location The desired location of the portal.
-     * @return Returns the location of the nearest portal to the location.
+     * @param location the desired location of the portal
+     * @return the location of the nearest portal to the location
      */
     public Location findPortal(Location location);
 
     /**
      * Attempt to create a portal near the given location.
+     * <p>
+     * In the case of a Nether portal teleportation, this will attempt to
+     * create a Nether portal.
+     * <p>
+     * In the case of an Ender portal teleportation, this will (re-)create the
+     * obsidian platform and clean blocks above it.
      *
-     * @param location The desired location of the portal.
-     * @return True if a nether portal was successfully created.
+     * @param location the desired location of the portal
+     * @return true if a portal was successfully created
      */
     public boolean createPortal(Location location);
-}
\ No newline at end of file
+}
diff --git a/src/main/java/org/bukkit/TreeType.java b/src/main/java/org/bukkit/TreeType.java
index 93a729f..8945e4c 100644
--- a/src/main/java/org/bukkit/TreeType.java
+++ b/src/main/java/org/bukkit/TreeType.java
@@ -4,6 +4,7 @@ package org.bukkit;
  * Tree and organic structure types.
  */
 public enum TreeType {
+
     /**
      * Regular tree, no branches
      */
diff --git a/src/main/java/org/bukkit/Warning.java b/src/main/java/org/bukkit/Warning.java
index e4187a9..fca77ce 100644
--- a/src/main/java/org/bukkit/Warning.java
+++ b/src/main/java/org/bukkit/Warning.java
@@ -20,6 +20,7 @@ public @interface Warning {
      * This represents the states that server verbose for warnings may be.
      */
     public enum WarningState {
+
         /**
          * Indicates all warnings should be printed for deprecated items.
          */
diff --git a/src/main/java/org/bukkit/World.java b/src/main/java/org/bukkit/World.java
index 62fadda..39c72c5 100644
--- a/src/main/java/org/bukkit/World.java
+++ b/src/main/java/org/bukkit/World.java
@@ -1070,6 +1070,56 @@ public interface World extends PluginMessageRecipient, Metadatable {
      */
     public boolean isGameRule(String rule);
 
+    // Spigot start
+    public class Spigot
+    {
+
+        /**
+         * Plays an effect to all players within a default radius around a given
+         * location.
+         *
+         * @param location the {@link Location} around which players must be to
+         * see the effect
+         * @param effect the {@link Effect}
+         * @throws IllegalArgumentException if the location or effect is null.
+         * It also throws when the effect requires a material or a material data
+         */
+        public void playEffect(Location location, Effect effect)
+        {
+            throw new UnsupportedOperationException( "Not supported yet." );
+        }
+
+        /**
+         * Plays an effect to all players within a default radius around a given
+         * location. The effect will use the provided material (and material
+         * data if required). The particle's position on the client will be the
+         * given location, adjusted on each axis by a normal distribution with
+         * mean 0 and standard deviation given in the offset parameters, each
+         * particle has independently calculated offsets. The effect will have
+         * the given speed and particle count if the effect is a particle. Some
+         * effect will create multiple particles.
+         *
+         * @param location the {@link Location} around which players must be to
+         * see the effect
+         * @param effect effect the {@link Effect}
+         * @param id the item/block/data id for the effect
+         * @param data the data value of the block/item for the effect
+         * @param offsetX the amount to be randomly offset by in the X axis
+         * @param offsetY the amount to be randomly offset by in the Y axis
+         * @param offsetZ the amount to be randomly offset by in the Z axis
+         * @param speed the speed of the particles
+         * @param particleCount the number of particles
+         * @param radius the radius around the location
+         */
+        public void playEffect(Location location, Effect effect, int id, int data, float offsetX, float offsetY, float offsetZ, float speed, int particleCount, int radius)
+        {
+            throw new UnsupportedOperationException( "Not supported yet." );
+        }
+    }
+
+    Spigot spigot();
+    // Spigot end
+
     /**
      * Represents various map environment types that a world may be
      */
diff --git a/src/main/java/org/bukkit/command/BlockCommandSender.java b/src/main/java/org/bukkit/command/BlockCommandSender.java
index 6dc4660..ce229d2 100644
--- a/src/main/java/org/bukkit/command/BlockCommandSender.java
+++ b/src/main/java/org/bukkit/command/BlockCommandSender.java
@@ -3,6 +3,7 @@ package org.bukkit.command;
 import org.bukkit.block.Block;
 
 public interface BlockCommandSender extends CommandSender {
+
     /**
      * Returns the block this command sender belongs to
      *
diff --git a/src/main/java/org/bukkit/command/Command.java b/src/main/java/org/bukkit/command/Command.java
index 5416c71..a04c870 100644
--- a/src/main/java/org/bukkit/command/Command.java
+++ b/src/main/java/org/bukkit/command/Command.java
@@ -78,18 +78,18 @@ public abstract class Command {
         Validate.notNull(args, "Arguments cannot be null");
         Validate.notNull(alias, "Alias cannot be null");
 
-        if (!(sender instanceof Player) || args.length == 0) {
+        if (args.length == 0) {
             return ImmutableList.of();
         }
 
         String lastWord = args[args.length - 1];
 
-        Player senderPlayer = (Player) sender;
+        Player senderPlayer = sender instanceof Player ? (Player) sender : null;
 
         ArrayList<String> matchedPlayers = new ArrayList<String>();
         for (Player player : sender.getServer().getOnlinePlayers()) {
             String name = player.getName();
-            if (senderPlayer.canSee(player) && StringUtil.startsWithIgnoreCase(name, lastWord)) {
+            if ((senderPlayer == null || senderPlayer.canSee(player)) && StringUtil.startsWithIgnoreCase(name, lastWord)) {
                 matchedPlayers.add(name);
             }
         }
diff --git a/src/main/java/org/bukkit/command/MultipleCommandAlias.java b/src/main/java/org/bukkit/command/MultipleCommandAlias.java
index 3a666d1..a0a4129 100644
--- a/src/main/java/org/bukkit/command/MultipleCommandAlias.java
+++ b/src/main/java/org/bukkit/command/MultipleCommandAlias.java
@@ -11,6 +11,11 @@ public class MultipleCommandAlias extends Command {
         this.commands = commands;
     }
 
+    /**
+     * Gets the commands associated with the multi-command alias.
+     *
+     * @return commands associated with alias
+     */
     public Command[] getCommands() {
         return commands;
     }
diff --git a/src/main/java/org/bukkit/command/PluginCommand.java b/src/main/java/org/bukkit/command/PluginCommand.java
index ec66c28..f90ee7e 100644
--- a/src/main/java/org/bukkit/command/PluginCommand.java
+++ b/src/main/java/org/bukkit/command/PluginCommand.java
@@ -75,6 +75,7 @@ public final class PluginCommand extends Command implements PluginIdentifiableCo
 
     /**
      * Sets the {@link TabCompleter} to run when tab-completing this command.
+     * <p>
      * If no TabCompleter is specified, and the command's executor implements
      * TabCompleter, then the executor will be used for tab completion.
      *
@@ -112,6 +113,7 @@ public final class PluginCommand extends Command implements PluginIdentifiableCo
      * {@link Command#tabComplete(CommandSender, String, String[])}.<br>
      * <br>
      * This method does not consider permissions.
+     *
      * @throws CommandException if the completer or executor throw an exception during the process of tab-completing.
      * @throws IllegalArgumentException if sender, alias, or args is null
      */
diff --git a/src/main/java/org/bukkit/command/SimpleCommandMap.java b/src/main/java/org/bukkit/command/SimpleCommandMap.java
index f567dc0..f716782 100644
--- a/src/main/java/org/bukkit/command/SimpleCommandMap.java
+++ b/src/main/java/org/bukkit/command/SimpleCommandMap.java
@@ -16,6 +16,7 @@ import java.util.regex.Pattern;
 import org.apache.commons.lang.Validate;
 import org.bukkit.Server;
 import org.bukkit.command.defaults.*;
+import org.bukkit.entity.Player;
 import org.bukkit.util.StringUtil;
 
 public class SimpleCommandMap implements CommandMap {
@@ -226,6 +227,8 @@ public class SimpleCommandMap implements CommandMap {
             ArrayList<String> completions = new ArrayList<String>();
             Map<String, Command> knownCommands = this.knownCommands;
 
+            final String prefix = (sender instanceof Player ? "/" : "");
+
             for (VanillaCommand command : fallbackCommands) {
                 String name = command.getName();
 
@@ -241,7 +244,7 @@ public class SimpleCommandMap implements CommandMap {
                     continue;
                 }
 
-                completions.add('/' + name);
+                completions.add(prefix + name);
             }
 
             for (Map.Entry<String, Command> commandEntry : knownCommands.entrySet()) {
@@ -254,7 +257,7 @@ public class SimpleCommandMap implements CommandMap {
                 String name = commandEntry.getKey(); // Use the alias, not command name
 
                 if (StringUtil.startsWithIgnoreCase(name, cmdLine)) {
-                    completions.add('/' + name);
+                    completions.add(prefix + name);
                 }
             }
 
diff --git a/src/main/java/org/bukkit/command/TabCommandExecutor.java b/src/main/java/org/bukkit/command/TabCommandExecutor.java
index 95efbd4..bf6ddd4 100644
--- a/src/main/java/org/bukkit/command/TabCommandExecutor.java
+++ b/src/main/java/org/bukkit/command/TabCommandExecutor.java
@@ -4,6 +4,7 @@ import java.util.List;
 
 /**
  * Represents a class which can handle command tab completion and commands
+ *
  * @deprecated Remains for plugins that would have implemented it even without functionality
  * @see TabExecutor
  */
diff --git a/src/main/java/org/bukkit/command/defaults/ReloadCommand.java b/src/main/java/org/bukkit/command/defaults/ReloadCommand.java
index fb3c90f..ffbcac1 100644
--- a/src/main/java/org/bukkit/command/defaults/ReloadCommand.java
+++ b/src/main/java/org/bukkit/command/defaults/ReloadCommand.java
@@ -20,6 +20,7 @@ public class ReloadCommand extends BukkitCommand {
     public boolean execute(CommandSender sender, String currentAlias, String[] args) {
         if (!testPermission(sender)) return true;
 
+        org.spigotmc.CustomTimingsHandler.reload(); // Spigot: TODO: Why is this here?
         Bukkit.reload();
         Command.broadcastCommandMessage(sender, ChatColor.GREEN + "Reload complete.");
 
diff --git a/src/main/java/org/bukkit/command/defaults/SayCommand.java b/src/main/java/org/bukkit/command/defaults/SayCommand.java
index 427897f..c48c5c3 100644
--- a/src/main/java/org/bukkit/command/defaults/SayCommand.java
+++ b/src/main/java/org/bukkit/command/defaults/SayCommand.java
@@ -6,6 +6,7 @@ import org.apache.commons.lang.Validate;
 import org.bukkit.Bukkit;
 import org.bukkit.ChatColor;
 import org.bukkit.command.CommandSender;
+import org.bukkit.command.ConsoleCommandSender;
 import org.bukkit.entity.Player;
 
 import com.google.common.collect.ImmutableList;
@@ -14,7 +15,7 @@ public class SayCommand extends VanillaCommand {
     public SayCommand() {
         super("say");
         this.description = "Broadcasts the given message as the console";
-        this.usageMessage = "/say <message>";
+        this.usageMessage = "/say <message ...>";
         this.setPermission("bukkit.command.say");
     }
 
@@ -27,20 +28,24 @@ public class SayCommand extends VanillaCommand {
         }
 
         StringBuilder message = new StringBuilder();
+        message.append(ChatColor.LIGHT_PURPLE).append("[");
+        if (sender instanceof ConsoleCommandSender) {
+            message.append("Server");
+        } else if (sender instanceof Player) {
+            message.append(((Player) sender).getDisplayName());
+        } else {
+            message.append(sender.getName());
+        }
+        message.append(ChatColor.LIGHT_PURPLE).append("] ");
+
         if (args.length > 0) {
             message.append(args[0]);
             for (int i = 1; i < args.length; i++) {
-                message.append(" ");
-                message.append(args[i]);
+                message.append(" ").append(args[i]);
             }
         }
 
-        if (sender instanceof Player) {
-            Bukkit.getLogger().info("[" + sender.getName() + "] " + message);
-        }
-
-        Bukkit.broadcastMessage(ChatColor.LIGHT_PURPLE + "[Server] " + message);
-
+        Bukkit.broadcastMessage(message.toString());
         return true;
     }
 
diff --git a/src/main/java/org/bukkit/command/defaults/SpreadPlayersCommand.java b/src/main/java/org/bukkit/command/defaults/SpreadPlayersCommand.java
index 506c8fe..5297cf7 100644
--- a/src/main/java/org/bukkit/command/defaults/SpreadPlayersCommand.java
+++ b/src/main/java/org/bukkit/command/defaults/SpreadPlayersCommand.java
@@ -36,25 +36,28 @@ public class SpreadPlayersCommand extends VanillaCommand {
             sender.sendMessage(ChatColor.RED + "Usage: " + usageMessage);
             return false;
         }
-        double x = getDouble(sender, args[0]);
-        double z = getDouble(sender, args[1]);
-        double distance = getDouble(sender, args[2]);
+
+        final double x = getDouble(sender, args[0], -30000000, 30000000);
+        final double z = getDouble(sender, args[1], -30000000, 30000000);
+        final double distance = getDouble(sender, args[2]);
+        final double range = getDouble(sender, args[3]);
 
         if (distance < 0.0D) {
             sender.sendMessage(ChatColor.RED + "Distance is too small.");
             return false;
         }
 
-        double range = getDouble(sender, args[3]);
         if (range < distance + 1.0D) {
             sender.sendMessage(ChatColor.RED + "Max range is too small.");
             return false;
         }
 
+        final String respectTeams = args[4];
         boolean teams = false;
-        if ("true".equalsIgnoreCase(args[4])) {
+
+        if (respectTeams.equalsIgnoreCase("true")) {
             teams = true;
-        } else if (!"false".equalsIgnoreCase(args[4])) {
+        } else if (!respectTeams.equalsIgnoreCase("false")) {
             sender.sendMessage(String.format(ChatColor.RED + "'%s' is not true or false", args[4]));
             return false;
         }
@@ -68,7 +71,7 @@ public class SpreadPlayersCommand extends VanillaCommand {
                 continue;
             }
 
-            if (world != null) {
+            if (world == null) {
                 world = player.getWorld();
             }
             players.add(player);
@@ -78,14 +81,22 @@ public class SpreadPlayersCommand extends VanillaCommand {
             return true;
         }
 
-        double xRangeMin = x - range;
-        double zRangeMin = z - range;
-        double xRangeMax = x + range;
-        double zRangeMax = z + range;
+        final double xRangeMin = x - range;
+        final double zRangeMin = z - range;
+        final double xRangeMax = x + range;
+        final double zRangeMax = z + range;
+
+        final int spreadSize = teams ? getTeams(players) : players.size();
+
+        final Location[] locations = getSpreadLocations(world, spreadSize, xRangeMin, zRangeMin, xRangeMax, zRangeMax);
+        final int rangeSpread = range(world, distance, xRangeMin, zRangeMin, xRangeMax, zRangeMax, locations);
+
+        if (rangeSpread == -1) {
+            sender.sendMessage(String.format("Could not spread %d %s around %s,%s (too many players for space - try using spread of at most %s)", spreadSize, teams ? "teams" : "players", x, z));
+            return false;
+        }
 
-        Location[] locations = getSpreadLocations(world, teams ? getTeams(players) : players.size(), xRangeMin, zRangeMin, xRangeMax, zRangeMax);
-        int rangeSpread = range(world, distance, xRangeMin, zRangeMin, xRangeMax, zRangeMax, locations);
-        double distanceSpread = spread(world, players, locations, teams);
+        final double distanceSpread = spread(world, players, locations, teams);
 
         sender.sendMessage(String.format("Succesfully spread %d %s around %s,%s", locations.length, teams ? "teams" : "players", x, z));
         if (locations.length > 1) {
@@ -96,7 +107,7 @@ public class SpreadPlayersCommand extends VanillaCommand {
 
     private int range(World world, double distance, double xRangeMin, double zRangeMin, double xRangeMax, double zRangeMax, Location[] locations) {
         boolean flag = true;
-        double max = Float.MAX_VALUE;
+        double max;
 
         int i;
 
diff --git a/src/main/java/org/bukkit/command/defaults/TimingsCommand.java b/src/main/java/org/bukkit/command/defaults/TimingsCommand.java
index 05cfcb0..ec1320f 100644
--- a/src/main/java/org/bukkit/command/defaults/TimingsCommand.java
+++ b/src/main/java/org/bukkit/command/defaults/TimingsCommand.java
@@ -19,30 +19,60 @@ import org.bukkit.util.StringUtil;
 
 import com.google.common.collect.ImmutableList;
 
+// Spigot start
+import java.io.ByteArrayOutputStream;
+import java.io.OutputStream;
+import java.net.HttpURLConnection;
+import java.net.URL;
+import java.net.URLEncoder;
+import java.util.logging.Level;
+// Spigot end
+
 public class TimingsCommand extends BukkitCommand {
     private static final List<String> TIMINGS_SUBCOMMANDS = ImmutableList.of("merged", "reset", "separate");
+    public static long timingStart = 0; // Spigot
 
     public TimingsCommand(String name) {
         super(name);
         this.description = "Records timings for all plugin events";
-        this.usageMessage = "/timings <reset|merged|separate>";
+        this.usageMessage = "/timings <reset|merged|separate|on|off> [paste]"; // Spigot
         this.setPermission("bukkit.command.timings");
     }
 
     @Override
     public boolean execute(CommandSender sender, String currentAlias, String[] args) {
         if (!testPermission(sender)) return true;
-        if (args.length != 1)  {
+        if (args.length < 1)  { // Spigot
             sender.sendMessage(ChatColor.RED + "Usage: " + usageMessage);
             return false;
         }
-        if (!sender.getServer().getPluginManager().useTimings()) {
+        /*if (!sender.getServer().getPluginManager().useTimings()) {
             sender.sendMessage("Please enable timings by setting \"settings.plugin-profiling\" to true in bukkit.yml");
             return true;
+        }*/
+
+        // Spigot start - dynamic enable
+        if ( "on".equals( args[0] ) )
+        {
+            ( (org.bukkit.plugin.SimplePluginManager) Bukkit.getPluginManager() ).useTimings( true );
+            sender.sendMessage( "Enabled Timings" );
+        } else if ( "off".equals( args[0] ) )
+        {
+            ( (org.bukkit.plugin.SimplePluginManager) Bukkit.getPluginManager() ).useTimings( false );
+            sender.sendMessage( "Disabled Timings" );
         }
+        // Spigot end
 
         boolean separate = "separate".equals(args[0]);
-        if ("reset".equals(args[0])) {
+        boolean paste = "paste".equals( args[0] ); // Spigot
+        if ("on".equals(args[0]) || "reset".equals(args[0])) { // Spigot
+            // Spigot start
+            if ( !"on".equals( args[0] ) && !Bukkit.getPluginManager().useTimings() )
+            {
+                sender.sendMessage( "Please enable timings by typing /timings on" );
+                return true;
+            }
+            // Spigot end
             for (HandlerList handlerList : HandlerList.getHandlerLists()) {
                 for (RegisteredListener listener : handlerList.getRegisteredListeners()) {
                     if (listener instanceof TimedRegisteredListener) {
@@ -50,20 +80,30 @@ public class TimingsCommand extends BukkitCommand {
                     }
                 }
             }
+            // Spigot start
+            org.spigotmc.CustomTimingsHandler.reload();
+            timingStart = System.nanoTime();
             sender.sendMessage("Timings reset");
-        } else if ("merged".equals(args[0]) || separate) {
-
+        } else if ("merged".equals(args[0]) || separate || paste) {
+            if ( !Bukkit.getPluginManager().useTimings() )
+            {
+                sender.sendMessage( "Please enable timings by typing /timings on" );
+                return true;
+            }
+            long sampleTime = System.nanoTime() - timingStart;
+            // Spigot end
             int index = 0;
             int pluginIdx = 0;
             File timingFolder = new File("timings");
             timingFolder.mkdirs();
             File timings = new File(timingFolder, "timings.txt");
             File names = null;
+            ByteArrayOutputStream bout = ( paste ) ? new ByteArrayOutputStream() : null; // Spigot
             while (timings.exists()) timings = new File(timingFolder, "timings" + (++index) + ".txt");
             PrintStream fileTimings = null;
             PrintStream fileNames = null;
             try {
-                fileTimings = new PrintStream(timings);
+                fileTimings = ( paste ) ? new PrintStream( bout ) : new PrintStream( timings );
                 if (separate) {
                     names = new File(timingFolder, "names" + index + ".txt");
                     fileNames = new PrintStream(names);
@@ -86,13 +126,25 @@ public class TimingsCommand extends BukkitCommand {
                             totalTime += time;
                             Class<? extends Event> eventClass = trl.getEventClass();
                             if (count > 0 && eventClass != null) {
-                                fileTimings.println("    " + eventClass.getSimpleName() + (trl.hasMultiple() ? " (and sub-classes)" : "") + " Time: " + time + " Count: " + count + " Avg: " + avg);
+                                fileTimings.println("    " + eventClass.getSimpleName() + (trl.hasMultiple() ? " (and sub-classes)" : "") + " Time: " + time + " Count: " + count + " Avg: " + avg + " Violations: " + trl.violations); // Spigot
                             }
                         }
                     }
                     fileTimings.println("    Total time " + totalTime + " (" + totalTime / 1000000000 + "s)");
                 }
+
+                // Spigot start
+                org.spigotmc.CustomTimingsHandler.printTimings(fileTimings);
+                fileTimings.println( "Sample time " + sampleTime + " (" + sampleTime / 1E9 + "s)" ); // Spigot
+                // Spigot start
+                if ( paste )
+                {
+                    new PasteThread( sender, bout ).start();
+                    return true;
+                }
+                // Spigot end
                 sender.sendMessage("Timings written to " + timings.getPath());
+                sender.sendMessage( "Paste contents of file into form at http://aikar.co/timings.php to read results." );
                 if (separate) sender.sendMessage("Names written to " + names.getPath());
             } catch (IOException e) {
             } finally {
@@ -118,4 +170,47 @@ public class TimingsCommand extends BukkitCommand {
         }
         return ImmutableList.of();
     }
+
+    // Spigot start
+    private static class PasteThread extends Thread
+    {
+
+        private final CommandSender sender;
+        private final ByteArrayOutputStream bout;
+
+        public PasteThread(CommandSender sender, ByteArrayOutputStream bout)
+        {
+            super( "Timings paste thread" );
+            this.sender = sender;
+            this.bout = bout;
+        }
+
+        @Override
+        public void run()
+        {
+            try
+            {
+                HttpURLConnection con = (HttpURLConnection) new URL( "http://paste.ubuntu.com/" ).openConnection();
+                con.setDoOutput( true );
+                con.setRequestMethod( "POST" );
+                con.setInstanceFollowRedirects( false );
+
+                OutputStream out = con.getOutputStream();
+                out.write( "poster=Spigot&syntax=text&content=".getBytes( "UTF-8" ) );
+                out.write( URLEncoder.encode( bout.toString( "UTF-8" ), "UTF-8" ).getBytes( "UTF-8" ) );
+                out.close();
+                con.getInputStream().close();
+
+                String location = con.getHeaderField( "Location" );
+                String pasteID = location.substring( "http://paste.ubuntu.com/".length(), location.length() - 1 );
+                sender.sendMessage( ChatColor.GREEN + "Your timings have been pasted to " + location );
+                sender.sendMessage( ChatColor.GREEN + "You can view the results at http://aikar.co/timings.php?url=" + pasteID );
+            } catch ( IOException ex )
+            {
+                sender.sendMessage( ChatColor.RED + "Error pasting timings, check your console for more information" );
+                Bukkit.getServer().getLogger().log( Level.WARNING, "Could not paste timings", ex );
+            }
+        }
+    }
+    // Spigot end
 }
diff --git a/src/main/java/org/bukkit/command/defaults/VanillaCommand.java b/src/main/java/org/bukkit/command/defaults/VanillaCommand.java
index e8ade12..9b13ac6 100644
--- a/src/main/java/org/bukkit/command/defaults/VanillaCommand.java
+++ b/src/main/java/org/bukkit/command/defaults/VanillaCommand.java
@@ -81,6 +81,7 @@ public abstract class VanillaCommand extends Command {
     public static double getDouble(CommandSender sender, String input, double min, double max) {
         double result = getDouble(sender, input);
 
+        // TODO: This should throw an exception instead.
         if (result < min) {
             result = min;
         } else if (result > max) {
diff --git a/src/main/java/org/bukkit/configuration/InvalidConfigurationException.java b/src/main/java/org/bukkit/configuration/InvalidConfigurationException.java
index c60ff56..8143213 100644
--- a/src/main/java/org/bukkit/configuration/InvalidConfigurationException.java
+++ b/src/main/java/org/bukkit/configuration/InvalidConfigurationException.java
@@ -5,6 +5,7 @@ package org.bukkit.configuration;
  */
 @SuppressWarnings("serial")
 public class InvalidConfigurationException extends Exception {
+
     /**
      * Creates a new instance of InvalidConfigurationException without a message or cause.
      */
diff --git a/src/main/java/org/bukkit/configuration/serialization/ConfigurationSerializable.java b/src/main/java/org/bukkit/configuration/serialization/ConfigurationSerializable.java
index 7eb0154..7bf4b29 100644
--- a/src/main/java/org/bukkit/configuration/serialization/ConfigurationSerializable.java
+++ b/src/main/java/org/bukkit/configuration/serialization/ConfigurationSerializable.java
@@ -16,10 +16,12 @@ import java.util.Map;
  * </ul>
  * In addition to implementing this interface, you must register the class with
  * {@link ConfigurationSerialization#registerClass(Class)}.
+ *
  * @see DelegateDeserialization
  * @see SerializableAs
  */
 public interface ConfigurationSerializable {
+
     /**
      * Creates a Map representation of this class.
      * <p>
diff --git a/src/main/java/org/bukkit/configuration/serialization/SerializableAs.java b/src/main/java/org/bukkit/configuration/serialization/SerializableAs.java
index db69dfc..4612ab3 100644
--- a/src/main/java/org/bukkit/configuration/serialization/SerializableAs.java
+++ b/src/main/java/org/bukkit/configuration/serialization/SerializableAs.java
@@ -15,6 +15,7 @@ import java.lang.annotation.Target;
  * <p>
  * Using this annotation on any other class than a {@link ConfigurationSerializable} will
  * have no effect.
+ *
  * @see ConfigurationSerialization#registerClass(Class, String)
  */
 @Retention(RetentionPolicy.RUNTIME)
diff --git a/src/main/java/org/bukkit/conversations/BooleanPrompt.java b/src/main/java/org/bukkit/conversations/BooleanPrompt.java
index 6abb354..a51e754 100644
--- a/src/main/java/org/bukkit/conversations/BooleanPrompt.java
+++ b/src/main/java/org/bukkit/conversations/BooleanPrompt.java
@@ -14,12 +14,13 @@ public abstract class BooleanPrompt extends ValidatingPrompt{
 
     @Override
     protected boolean isInputValid(ConversationContext context, String input) {
-        String[] accepted = {"true", "false", "on", "off", "yes", "no"};
+        String[] accepted = {"true", "false", "on", "off", "yes", "no" /* Spigot: */, "y", "n", "1", "0", "right", "wrong", "correct", "incorrect", "valid", "invalid"}; // Spigot
         return ArrayUtils.contains(accepted, input.toLowerCase());
     }
 
     @Override
     protected Prompt acceptValidatedInput(ConversationContext context, String input) {
+        if (input.equalsIgnoreCase("y") || input.equals("1") || input.equalsIgnoreCase("right") || input.equalsIgnoreCase("correct") || input.equalsIgnoreCase("valid")) input = "true"; // Spigot
         return acceptValidatedInput(context, BooleanUtils.toBoolean(input));
     }
 
diff --git a/src/main/java/org/bukkit/conversations/Conversation.java b/src/main/java/org/bukkit/conversations/Conversation.java
index a30745f..55c9785 100644
--- a/src/main/java/org/bukkit/conversations/Conversation.java
+++ b/src/main/java/org/bukkit/conversations/Conversation.java
@@ -193,6 +193,7 @@ public class Conversation {
      * @param input The user's chat text.
      */
     public void acceptInput(String input) {
+        try { // Spigot
         if (currentPrompt != null) {
 
             // Echo the user's input
@@ -212,6 +213,12 @@ public class Conversation {
             currentPrompt = currentPrompt.acceptInput(context, input);
             outputNextPrompt();
         }
+        // Spigot Start
+        } catch ( Throwable t )
+        {
+            org.bukkit.Bukkit.getLogger().log( java.util.logging.Level.SEVERE, "Error handling conversation prompt", t );
+        }
+        // Spigot End
     }
 
     /**
diff --git a/src/main/java/org/bukkit/conversations/ConversationContext.java b/src/main/java/org/bukkit/conversations/ConversationContext.java
index 7a5b5ed..6b4bcac 100644
--- a/src/main/java/org/bukkit/conversations/ConversationContext.java
+++ b/src/main/java/org/bukkit/conversations/ConversationContext.java
@@ -44,6 +44,14 @@ public class ConversationContext {
     }
 
     /**
+     * Gets the entire sessionData map.
+     * @return The full sessionData map.
+     */
+    public Map<Object, Object> getAllSessionData() {
+        return sessionData;
+    }
+
+    /**
      * Gets session data shared between all {@link Prompt} invocations. Use this as a way
      * to pass data through each Prompt as the conversation develops.
      *
diff --git a/src/main/java/org/bukkit/entity/AnimalTamer.java b/src/main/java/org/bukkit/entity/AnimalTamer.java
index 89a7714..a80d31a 100644
--- a/src/main/java/org/bukkit/entity/AnimalTamer.java
+++ b/src/main/java/org/bukkit/entity/AnimalTamer.java
@@ -1,6 +1,7 @@
 package org.bukkit.entity;
 
 public interface AnimalTamer {
+
     /**
      * This is the name of the specified AnimalTamer.
      *
diff --git a/src/main/java/org/bukkit/entity/Arrow.java b/src/main/java/org/bukkit/entity/Arrow.java
index 26d3473..676fe2b 100644
--- a/src/main/java/org/bukkit/entity/Arrow.java
+++ b/src/main/java/org/bukkit/entity/Arrow.java
@@ -3,4 +3,22 @@ package org.bukkit.entity;
 /**
  * Represents an arrow.
  */
-public interface Arrow extends Projectile {}
+public interface Arrow extends Projectile
+{
+
+    public class Spigot extends Entity.Spigot
+    {
+
+        public double getDamage()
+        {
+            throw new UnsupportedOperationException( "Not supported yet." );
+        }
+
+        public void setDamage(double damage)
+        {
+            throw new UnsupportedOperationException( "Not supported yet." );
+        }
+    }
+
+    Spigot spigot();
+}
diff --git a/src/main/java/org/bukkit/entity/ComplexEntityPart.java b/src/main/java/org/bukkit/entity/ComplexEntityPart.java
index 5db43e0..f4ab0bb 100644
--- a/src/main/java/org/bukkit/entity/ComplexEntityPart.java
+++ b/src/main/java/org/bukkit/entity/ComplexEntityPart.java
@@ -4,6 +4,7 @@ package org.bukkit.entity;
  * Represents a single part of a {@link ComplexLivingEntity}
  */
 public interface ComplexEntityPart extends Entity {
+
     /**
      * Gets the parent {@link ComplexLivingEntity} of this part.
      *
diff --git a/src/main/java/org/bukkit/entity/Entity.java b/src/main/java/org/bukkit/entity/Entity.java
index 72af4fa..a5b2100 100644
--- a/src/main/java/org/bukkit/entity/Entity.java
+++ b/src/main/java/org/bukkit/entity/Entity.java
@@ -280,4 +280,22 @@ public interface Entity extends Metadatable {
      * @return The current vehicle.
      */
     public Entity getVehicle();
+
+    // Spigot Start
+    public class Spigot
+    {
+
+        /**
+         * Returns whether this entity is invulnerable.
+         *         
+        * @return True if the entity is invulnerable.
+         */
+        public boolean isInvulnerable()
+        {
+            throw new UnsupportedOperationException( "Not supported yet." );
+        }
+    }
+
+    Spigot spigot();
+    // Spigot End
 }
diff --git a/src/main/java/org/bukkit/entity/EntityType.java b/src/main/java/org/bukkit/entity/EntityType.java
index 49cc01b..de3050a 100644
--- a/src/main/java/org/bukkit/entity/EntityType.java
+++ b/src/main/java/org/bukkit/entity/EntityType.java
@@ -14,10 +14,11 @@ import org.bukkit.Location;
 import org.bukkit.World;
 
 public enum EntityType {
+
     // These strings MUST match the strings in nms.EntityTypes and are case sensitive.
     /**
      * An item resting on the ground.
-     *
+     * <p>
      * Spawn with {@link World#dropItem(Location, ItemStack)}
      * or {@link World#dropItemNaturally(Location, ItemStack)}
      */
diff --git a/src/main/java/org/bukkit/entity/ExperienceOrb.java b/src/main/java/org/bukkit/entity/ExperienceOrb.java
index 40783b8..c286edf 100644
--- a/src/main/java/org/bukkit/entity/ExperienceOrb.java
+++ b/src/main/java/org/bukkit/entity/ExperienceOrb.java
@@ -4,6 +4,7 @@ package org.bukkit.entity;
  * Represents an Experience Orb.
  */
 public interface ExperienceOrb extends Entity {
+
     /**
      * Gets how much experience is contained within this orb
      *
diff --git a/src/main/java/org/bukkit/entity/Explosive.java b/src/main/java/org/bukkit/entity/Explosive.java
index bc68190..48650f6 100644
--- a/src/main/java/org/bukkit/entity/Explosive.java
+++ b/src/main/java/org/bukkit/entity/Explosive.java
@@ -4,6 +4,7 @@ package org.bukkit.entity;
  * A representation of an explosive entity
  */
 public interface Explosive extends Entity {
+
     /**
      * Set the radius affected by this explosive's explosion
      *
diff --git a/src/main/java/org/bukkit/entity/Fireball.java b/src/main/java/org/bukkit/entity/Fireball.java
index 95c60f8..88876a4 100644
--- a/src/main/java/org/bukkit/entity/Fireball.java
+++ b/src/main/java/org/bukkit/entity/Fireball.java
@@ -6,6 +6,7 @@ import org.bukkit.util.Vector;
  * Represents a Fireball.
  */
 public interface Fireball extends Projectile, Explosive {
+
     /**
      * Fireballs fly straight and do not take setVelocity(...) well.
      *
diff --git a/src/main/java/org/bukkit/entity/Firework.java b/src/main/java/org/bukkit/entity/Firework.java
index b613819..cd03b2f 100644
--- a/src/main/java/org/bukkit/entity/Firework.java
+++ b/src/main/java/org/bukkit/entity/Firework.java
@@ -3,6 +3,7 @@ package org.bukkit.entity;
 import org.bukkit.inventory.meta.FireworkMeta;
 
 public interface Firework extends Entity {
+
     /**
      * Get a copy of the fireworks meta
      *
diff --git a/src/main/java/org/bukkit/entity/Ocelot.java b/src/main/java/org/bukkit/entity/Ocelot.java
index a173778..4016d3f 100644
--- a/src/main/java/org/bukkit/entity/Ocelot.java
+++ b/src/main/java/org/bukkit/entity/Ocelot.java
@@ -5,6 +5,7 @@ package org.bukkit.entity;
  * A wild tameable cat
  */
 public interface Ocelot extends Animals, Tameable {
+
     /**
      * Gets the current type of this cat.
      *
diff --git a/src/main/java/org/bukkit/entity/Painting.java b/src/main/java/org/bukkit/entity/Painting.java
index 3326a9f..ddfa89d 100644
--- a/src/main/java/org/bukkit/entity/Painting.java
+++ b/src/main/java/org/bukkit/entity/Painting.java
@@ -7,6 +7,7 @@ import org.bukkit.event.painting.PaintingBreakEvent;
  * Represents a Painting.
  */
 public interface Painting extends Hanging {
+
     /**
      * Get the art on this painting
      *
diff --git a/src/main/java/org/bukkit/entity/PigZombie.java b/src/main/java/org/bukkit/entity/PigZombie.java
index f8b1fb7..65a3f8c 100644
--- a/src/main/java/org/bukkit/entity/PigZombie.java
+++ b/src/main/java/org/bukkit/entity/PigZombie.java
@@ -4,6 +4,7 @@ package org.bukkit.entity;
  * Represents a Pig Zombie.
  */
 public interface PigZombie extends Zombie {
+
     /**
      * Get the pig zombie's current anger level.
      *
diff --git a/src/main/java/org/bukkit/entity/Player.java b/src/main/java/org/bukkit/entity/Player.java
index 3ec374b..9ee8f5f 100644
--- a/src/main/java/org/bukkit/entity/Player.java
+++ b/src/main/java/org/bukkit/entity/Player.java
@@ -721,4 +721,49 @@ public interface Player extends HumanEntity, Conversable, CommandSender, Offline
      * @see Player#setHealthScaled(boolean)
      */
     public double getHealthScale();
+
+    // Spigot start
+    public class Spigot extends Entity.Spigot
+    {
+
+        /**
+         * Gets the connection address of this player, regardless of whether it
+         * has been spoofed or not.
+         *
+         * @return the player's connection address
+         */
+        public InetSocketAddress getRawAddress()
+        {
+            throw new UnsupportedOperationException( "Not supported yet." );
+        }
+
+        public void playEffect(Location location, Effect effect, int id, int data, float offsetX, float offsetY, float offsetZ, float speed, int particleCount, int radius)
+        {
+            throw new UnsupportedOperationException( "Not supported yet." );
+        }
+
+        /**
+         * Gets whether the player collides with entities
+         *
+         * @return the player's collision toggle state
+         */
+        public boolean getCollidesWithEntities()
+        {
+            throw new UnsupportedOperationException( "Not supported yet." );
+        }
+
+        /**
+         * Sets whether the player collides with entities
+         *
+         * @param collides whether the player should collide with entities or
+         * not.
+         */
+        public void setCollidesWithEntities(boolean collides)
+        {
+            throw new UnsupportedOperationException( "Not supported yet." );
+        }
+    }
+
+    Spigot spigot();
+    // Spigot end
 }
diff --git a/src/main/java/org/bukkit/entity/Skeleton.java b/src/main/java/org/bukkit/entity/Skeleton.java
index 0019911..02b76c3 100644
--- a/src/main/java/org/bukkit/entity/Skeleton.java
+++ b/src/main/java/org/bukkit/entity/Skeleton.java
@@ -4,6 +4,7 @@ package org.bukkit.entity;
  * Represents a Skeleton.
  */
 public interface Skeleton extends Monster {
+
     /**
      * Gets the current type of this skeleton.
      *
diff --git a/src/main/java/org/bukkit/entity/TNTPrimed.java b/src/main/java/org/bukkit/entity/TNTPrimed.java
index 3b5952c..295dcb9 100644
--- a/src/main/java/org/bukkit/entity/TNTPrimed.java
+++ b/src/main/java/org/bukkit/entity/TNTPrimed.java
@@ -4,6 +4,7 @@ package org.bukkit.entity;
  * Represents a Primed TNT.
  */
 public interface TNTPrimed extends Explosive {
+
     /**
      * Set the number of ticks until the TNT blows up after being primed.
      *
diff --git a/src/main/java/org/bukkit/entity/Zombie.java b/src/main/java/org/bukkit/entity/Zombie.java
index 7f1ffd1..59b52fd 100644
--- a/src/main/java/org/bukkit/entity/Zombie.java
+++ b/src/main/java/org/bukkit/entity/Zombie.java
@@ -4,6 +4,7 @@ package org.bukkit.entity;
  * Represents a Zombie.
  */
 public interface Zombie extends Monster {
+
     /**
      * Gets whether the zombie is a baby
      *
diff --git a/src/main/java/org/bukkit/event/Cancellable.java b/src/main/java/org/bukkit/event/Cancellable.java
index 3fc13fc..799b0b0 100644
--- a/src/main/java/org/bukkit/event/Cancellable.java
+++ b/src/main/java/org/bukkit/event/Cancellable.java
@@ -1,6 +1,7 @@
 package org.bukkit.event;
 
 public interface Cancellable {
+
     /**
      * Gets the cancellation state of this event. A cancelled event will not
      * be executed in the server, but will still pass to other plugins
diff --git a/src/main/java/org/bukkit/event/EventPriority.java b/src/main/java/org/bukkit/event/EventPriority.java
index d087dec..eb1400e 100644
--- a/src/main/java/org/bukkit/event/EventPriority.java
+++ b/src/main/java/org/bukkit/event/EventPriority.java
@@ -4,6 +4,7 @@ package org.bukkit.event;
  * Represents an event's priority in execution
  */
 public enum EventPriority {
+
     /**
      * Event call is of very low importance and should be ran first, to allow
      * other plugins to further customise the outcome
diff --git a/src/main/java/org/bukkit/event/HandlerList.java b/src/main/java/org/bukkit/event/HandlerList.java
index f6d9014..4b97a71 100644
--- a/src/main/java/org/bukkit/event/HandlerList.java
+++ b/src/main/java/org/bukkit/event/HandlerList.java
@@ -10,6 +10,7 @@ import java.util.Map.Entry;
  * A list of event handlers, stored per-event. Based on lahwran's fevents.
  */
 public class HandlerList {
+
     /**
      * Handler array. This field being an array is the key to this system's speed.
      */
diff --git a/src/main/java/org/bukkit/event/entity/CreatureSpawnEvent.java b/src/main/java/org/bukkit/event/entity/CreatureSpawnEvent.java
index 24c4ebf..303479d 100644
--- a/src/main/java/org/bukkit/event/entity/CreatureSpawnEvent.java
+++ b/src/main/java/org/bukkit/event/entity/CreatureSpawnEvent.java
@@ -4,17 +4,13 @@ import org.bukkit.Location;
 import org.bukkit.entity.CreatureType;
 import org.bukkit.entity.Entity;
 import org.bukkit.entity.LivingEntity;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
 
 /**
  * Called when a creature is spawned into a world.
  * <p>
  * If a Creature Spawn event is cancelled, the creature will not spawn.
  */
-public class CreatureSpawnEvent extends EntityEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private boolean canceled;
+public class CreatureSpawnEvent extends EntitySpawnEvent {
     private final SpawnReason spawnReason;
 
     public CreatureSpawnEvent(final LivingEntity spawnee, final SpawnReason spawnReason) {
@@ -28,29 +24,12 @@ public class CreatureSpawnEvent extends EntityEvent implements Cancellable {
         spawnReason = reason;
     }
 
-    public boolean isCancelled() {
-        return canceled;
-    }
-
-    public void setCancelled(boolean cancel) {
-        canceled = cancel;
-    }
-
     @Override
     public LivingEntity getEntity() {
         return (LivingEntity) entity;
     }
 
     /**
-     * Gets the location at which the creature is spawning.
-     *
-     * @return The location at which the creature is spawning
-     */
-    public Location getLocation() {
-        return getEntity().getLocation();
-    }
-
-    /**
      * Gets the type of creature being spawned.
      *
      * @return A CreatureType value detailing the type of creature being spawned
@@ -70,15 +49,6 @@ public class CreatureSpawnEvent extends EntityEvent implements Cancellable {
         return spawnReason;
     }
 
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-
     /**
      * An enum to specify the type of spawning
      */
@@ -148,6 +118,10 @@ public class CreatureSpawnEvent extends EntityEvent implements Cancellable {
          */
         SLIME_SPLIT,
         /**
+         * When an entity calls for reinforcements
+         */
+        REINFORCEMENTS,
+        /**
          * When a creature is spawned by plugins
          */
         CUSTOM,
diff --git a/src/main/java/org/bukkit/event/entity/EntityCombustByBlockEvent.java b/src/main/java/org/bukkit/event/entity/EntityCombustByBlockEvent.java
index 7eed8ad..c84bda9 100644
--- a/src/main/java/org/bukkit/event/entity/EntityCombustByBlockEvent.java
+++ b/src/main/java/org/bukkit/event/entity/EntityCombustByBlockEvent.java
@@ -3,6 +3,9 @@ package org.bukkit.event.entity;
 import org.bukkit.block.Block;
 import org.bukkit.entity.Entity;
 
+/**
+ * Called when a block causes an entity to combust.
+ */
 public class EntityCombustByBlockEvent extends EntityCombustEvent {
     private final Block combuster;
 
diff --git a/src/main/java/org/bukkit/event/entity/EntityCombustByEntityEvent.java b/src/main/java/org/bukkit/event/entity/EntityCombustByEntityEvent.java
index 84ca5c2..639567b 100644
--- a/src/main/java/org/bukkit/event/entity/EntityCombustByEntityEvent.java
+++ b/src/main/java/org/bukkit/event/entity/EntityCombustByEntityEvent.java
@@ -2,6 +2,9 @@ package org.bukkit.event.entity;
 
 import org.bukkit.entity.Entity;
 
+/**
+ * Called when an entity causes another entity to combust.
+ */
 public class EntityCombustByEntityEvent extends EntityCombustEvent {
     private final Entity combuster;
 
diff --git a/src/main/java/org/bukkit/event/entity/EntityPortalEvent.java b/src/main/java/org/bukkit/event/entity/EntityPortalEvent.java
index 0b4e6a9..835c054 100644
--- a/src/main/java/org/bukkit/event/entity/EntityPortalEvent.java
+++ b/src/main/java/org/bukkit/event/entity/EntityPortalEvent.java
@@ -6,9 +6,10 @@ import org.bukkit.entity.Entity;
 import org.bukkit.event.HandlerList;
 
 /**
- * Called when a non-player entity is about to teleport because it is in contact with a portal
+ * Called when a non-player entity is about to teleport because it is in
+ * contact with a portal.
  * <p>
- * For players see {@link org.bukkit.event.player.PlayerPortalEvent PlayerPortalEvent}
+ * For players see {@link org.bukkit.event.player.PlayerPortalEvent}
  */
 public class EntityPortalEvent extends EntityTeleportEvent {
     private static final HandlerList handlers = new HandlerList();
@@ -20,18 +21,52 @@ public class EntityPortalEvent extends EntityTeleportEvent {
         this.travelAgent = pta;
     }
 
+    /**
+     * Sets whether or not the Travel Agent will be used.
+     * <p>
+     * If this is set to true, the TravelAgent will try to find a Portal at
+     * the {@link #getTo()} Location, and will try to create one if there is
+     * none.
+     * <p>
+     * If this is set to false, the {@link #getEntity()} will only be
+     * teleported to the {@link #getTo()} Location.
+     *
+     * @param useTravelAgent whether to use the Travel Agent
+     */
     public void useTravelAgent(boolean useTravelAgent) {
         this.useTravelAgent = useTravelAgent;
     }
 
+    /**
+     * Gets whether or not the Travel Agent will be used.
+     * <p>
+     * If this is set to true, the TravelAgent will try to find a Portal at
+     * the {@link #getTo()} Location, and will try to create one if there is
+     * none.
+     * <p>
+     * If this is set to false, the {@link #getEntity()} will only be
+     * teleported to the {@link #getTo()} Location.
+     *
+     * @return whether to use the Travel Agent
+     */
     public boolean useTravelAgent() {
         return useTravelAgent;
     }
 
+    /**
+     * Gets the Travel Agent used (or not) in this event.
+     *
+     * @return the Travel Agent used (or not) in this event
+     */
     public TravelAgent getPortalTravelAgent() {
         return this.travelAgent;
     }
 
+    /**
+     * Sets the Travel Agent used (or not) in this event.
+     *
+     * @param travelAgent the Travel Agent used (or not) in this event
+     */
     public void setPortalTravelAgent(TravelAgent travelAgent) {
         this.travelAgent = travelAgent;
     }
diff --git a/src/main/java/org/bukkit/event/entity/EntitySpawnEvent.java b/src/main/java/org/bukkit/event/entity/EntitySpawnEvent.java
new file mode 100644
index 0000000..5dcf98f
--- /dev/null
+++ b/src/main/java/org/bukkit/event/entity/EntitySpawnEvent.java
@@ -0,0 +1,45 @@
+package org.bukkit.event.entity;
+
+import org.bukkit.Location;
+import org.bukkit.entity.Entity;
+import org.bukkit.event.HandlerList;
+
+/**
+ * Called when an entity is spawned into a world.
+ * <p>
+ * If an Entity Spawn event is cancelled, the entity will not spawn.
+ */
+public class EntitySpawnEvent extends EntityEvent implements org.bukkit.event.Cancellable {
+    private static final HandlerList handlers = new HandlerList();
+    private boolean canceled;
+
+    public EntitySpawnEvent(final Entity spawnee) {
+        super(spawnee);
+    }
+
+    public boolean isCancelled() {
+        return canceled;
+    }
+
+    public void setCancelled(boolean cancel) {
+        canceled = cancel;
+    }
+
+    /**
+     * Gets the location at which the entity is spawning.
+     *
+     * @return The location at which the entity is spawning
+     */
+    public Location getLocation() {
+        return getEntity().getLocation();
+    }
+
+    @Override
+    public HandlerList getHandlers() {
+        return handlers;
+    }
+
+    public static HandlerList getHandlerList() {
+        return handlers;
+    }
+}
diff --git a/src/main/java/org/bukkit/event/entity/ItemDespawnEvent.java b/src/main/java/org/bukkit/event/entity/ItemDespawnEvent.java
index 6f4533c..356e4bd 100644
--- a/src/main/java/org/bukkit/event/entity/ItemDespawnEvent.java
+++ b/src/main/java/org/bukkit/event/entity/ItemDespawnEvent.java
@@ -5,6 +5,13 @@ import org.bukkit.entity.Item;
 import org.bukkit.event.Cancellable;
 import org.bukkit.event.HandlerList;
 
+/**
+ * This event is called when a {@link org.bukkit.entity.Item} is removed from
+ * the world because it has existed for 5 minutes.
+ * <p>
+ * Cancelling the event results in the item being allowed to exist for 5 more
+ * minutes. This behavior is not guaranteed and may change in future versions.
+ */
 public class ItemDespawnEvent extends EntityEvent implements Cancellable {
     private static final HandlerList handlers = new HandlerList();
     private boolean canceled;
diff --git a/src/main/java/org/bukkit/event/entity/ItemSpawnEvent.java b/src/main/java/org/bukkit/event/entity/ItemSpawnEvent.java
index bafd934..776f8e7 100644
--- a/src/main/java/org/bukkit/event/entity/ItemSpawnEvent.java
+++ b/src/main/java/org/bukkit/event/entity/ItemSpawnEvent.java
@@ -1,51 +1,23 @@
 package org.bukkit.event.entity;
 
-import org.bukkit.entity.Item;
 import org.bukkit.Location;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
+import org.bukkit.entity.Item;
 
 /**
  * Called when an item is spawned into a world
  */
-public class ItemSpawnEvent extends EntityEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private final Location location;
-    private boolean canceled;
-
-    public ItemSpawnEvent(final Item spawnee, final Location loc) {
+public class ItemSpawnEvent extends EntitySpawnEvent {
+    public ItemSpawnEvent(final Item spawnee) {
         super(spawnee);
-        this.location = loc;
     }
 
-    public boolean isCancelled() {
-        return canceled;
-    }
-
-    public void setCancelled(boolean cancel) {
-        canceled = cancel;
+    @Deprecated
+    public ItemSpawnEvent(final Item spawnee, final Location loc) {
+        this(spawnee);
     }
 
     @Override
     public Item getEntity() {
         return (Item) entity;
     }
-
-    /**
-     * Gets the location at which the item is spawning.
-     *
-     * @return The location at which the item is spawning
-     */
-    public Location getLocation() {
-        return location;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
 }
diff --git a/src/main/java/org/bukkit/event/entity/SpawnerSpawnEvent.java b/src/main/java/org/bukkit/event/entity/SpawnerSpawnEvent.java
new file mode 100644
index 0000000..1acb3c4
--- /dev/null
+++ b/src/main/java/org/bukkit/event/entity/SpawnerSpawnEvent.java
@@ -0,0 +1,22 @@
+package org.bukkit.event.entity;
+
+import org.bukkit.block.CreatureSpawner;
+import org.bukkit.entity.Entity;
+
+/**
+ * Called when an entity is spawned into a world by a spawner.
+ * <p>
+ * If a Spawner Spawn event is cancelled, the entity will not spawn.
+ */
+public class SpawnerSpawnEvent extends EntitySpawnEvent {
+    private final CreatureSpawner spawner;
+
+    public SpawnerSpawnEvent(final Entity spawnee, final CreatureSpawner spawner) {
+        super(spawnee);
+        this.spawner = spawner;
+    }
+
+    public CreatureSpawner getSpawner() {
+        return spawner;
+    }
+}
diff --git a/src/main/java/org/bukkit/event/inventory/ClickType.java b/src/main/java/org/bukkit/event/inventory/ClickType.java
index dc2928c..c9e447f 100644
--- a/src/main/java/org/bukkit/event/inventory/ClickType.java
+++ b/src/main/java/org/bukkit/event/inventory/ClickType.java
@@ -4,6 +4,7 @@ package org.bukkit.event.inventory;
  * What the client did to trigger this action (not the result).
  */
 public enum ClickType {
+
     /**
      * The left (or primary) mouse button.
      */
diff --git a/src/main/java/org/bukkit/event/inventory/CraftItemEvent.java b/src/main/java/org/bukkit/event/inventory/CraftItemEvent.java
index 4ebc36b..ba3f5e5 100644
--- a/src/main/java/org/bukkit/event/inventory/CraftItemEvent.java
+++ b/src/main/java/org/bukkit/event/inventory/CraftItemEvent.java
@@ -5,6 +5,9 @@ import org.bukkit.inventory.CraftingInventory;
 import org.bukkit.inventory.InventoryView;
 import org.bukkit.inventory.Recipe;
 
+/**
+ * Called when the recipe of an Item is completed inside a crafting matrix.
+ */
 public class CraftItemEvent extends InventoryClickEvent {
     private Recipe recipe;
 
diff --git a/src/main/java/org/bukkit/event/inventory/InventoryAction.java b/src/main/java/org/bukkit/event/inventory/InventoryAction.java
index c9da022..dbdbe26 100644
--- a/src/main/java/org/bukkit/event/inventory/InventoryAction.java
+++ b/src/main/java/org/bukkit/event/inventory/InventoryAction.java
@@ -4,8 +4,10 @@ package org.bukkit.event.inventory;
  * An estimation of what the result will be.
  */
 public enum InventoryAction {
+
     /**
      * Nothing will happen from the click.
+     * <p>
      * There may be cases where nothing will happen and this is value is
      * not provided, but it is guaranteed that this value is accurate
      * when given.
diff --git a/src/main/java/org/bukkit/event/inventory/InventoryClickEvent.java b/src/main/java/org/bukkit/event/inventory/InventoryClickEvent.java
index 28198b8..3313d91 100644
--- a/src/main/java/org/bukkit/event/inventory/InventoryClickEvent.java
+++ b/src/main/java/org/bukkit/event/inventory/InventoryClickEvent.java
@@ -47,6 +47,7 @@ public class InventoryClickEvent extends InventoryInteractEvent {
     private static final HandlerList handlers = new HandlerList();
     private final ClickType click;
     private final InventoryAction action;
+    private final Inventory clickedInventory;
     private SlotType slot_type;
     private int whichSlot;
     private int rawSlot;
@@ -62,6 +63,13 @@ public class InventoryClickEvent extends InventoryInteractEvent {
         super(view);
         this.slot_type = type;
         this.rawSlot = slot;
+        if (slot < 0) {
+            this.clickedInventory = null;
+        } else if (view.getTopInventory() != null && slot < view.getTopInventory().getSize()) {
+            this.clickedInventory = view.getTopInventory();
+        } else {
+            this.clickedInventory = view.getBottomInventory();
+        }
         this.whichSlot = view.convertSlot(slot);
         this.click = click;
         this.action = action;
@@ -73,6 +81,14 @@ public class InventoryClickEvent extends InventoryInteractEvent {
     }
 
     /**
+     * Gets the inventory that was clicked, or null if outside of window
+     * @return The clicked inventory
+     */
+    public Inventory getClickedInventory() {
+        return clickedInventory;
+    }
+
+    /**
      * Gets the type of slot that was clicked.
      *
      * @return the slot type
diff --git a/src/main/java/org/bukkit/event/inventory/InventoryType.java b/src/main/java/org/bukkit/event/inventory/InventoryType.java
index 87edc42..06cabcd 100644
--- a/src/main/java/org/bukkit/event/inventory/InventoryType.java
+++ b/src/main/java/org/bukkit/event/inventory/InventoryType.java
@@ -1,6 +1,7 @@
 package org.bukkit.event.inventory;
 
 public enum InventoryType {
+
     /**
      * A chest inventory, with 0, 9, 18, 27, 36, 45, or 54 slots of type CONTAINER.
      */
diff --git a/src/main/java/org/bukkit/event/player/PlayerBucketEvent.java b/src/main/java/org/bukkit/event/player/PlayerBucketEvent.java
index e1726a2..d32c55e 100644
--- a/src/main/java/org/bukkit/event/player/PlayerBucketEvent.java
+++ b/src/main/java/org/bukkit/event/player/PlayerBucketEvent.java
@@ -7,6 +7,9 @@ import org.bukkit.entity.Player;
 import org.bukkit.event.Cancellable;
 import org.bukkit.inventory.ItemStack;
 
+/**
+ * Called when a player interacts with a Bucket
+ */
 public abstract class PlayerBucketEvent extends PlayerEvent implements Cancellable {
     private ItemStack itemStack;
     private boolean cancelled = false;
diff --git a/src/main/java/org/bukkit/event/player/PlayerEditBookEvent.java b/src/main/java/org/bukkit/event/player/PlayerEditBookEvent.java
index ed33393..da411d9 100644
--- a/src/main/java/org/bukkit/event/player/PlayerEditBookEvent.java
+++ b/src/main/java/org/bukkit/event/player/PlayerEditBookEvent.java
@@ -77,7 +77,7 @@ public class PlayerEditBookEvent extends PlayerEvent implements Cancellable {
     /**
      * Sets the book meta that will actually be added to the book.
      *
-     * @param bookMeta new book meta
+     * @param newBookMeta new book meta
      * @throws IllegalArgumentException if the new book meta is null
      */
     public void setNewBookMeta(BookMeta newBookMeta) throws IllegalArgumentException {
diff --git a/src/main/java/org/bukkit/event/player/PlayerItemDamageEvent.java b/src/main/java/org/bukkit/event/player/PlayerItemDamageEvent.java
new file mode 100644
index 0000000..38a72ab
--- /dev/null
+++ b/src/main/java/org/bukkit/event/player/PlayerItemDamageEvent.java
@@ -0,0 +1,54 @@
+package org.bukkit.event.player;
+
+import org.bukkit.entity.Player;
+import org.bukkit.event.Cancellable;
+import org.bukkit.event.HandlerList;
+import org.bukkit.inventory.ItemStack;
+
+public class PlayerItemDamageEvent extends PlayerEvent implements Cancellable {
+
+    private static final HandlerList handlers = new HandlerList();
+    private final ItemStack item;
+    private int damage;
+    private boolean cancelled = false;
+
+    public PlayerItemDamageEvent(Player player, ItemStack what, int damage) {
+        super(player);
+        this.item = what;
+        this.damage = damage;
+    }
+
+    public ItemStack getItem() {
+        return item;
+    }
+
+    /**
+     * Gets the amount of durability damage this item will be taking.
+     *
+     * @return durability change
+     */
+    public int getDamage() {
+        return damage;
+    }
+
+    public void setDamage(int damage) {
+        this.damage = damage;
+    }
+
+    public boolean isCancelled() {
+        return cancelled;
+    }
+
+    public void setCancelled(boolean cancel) {
+        this.cancelled = cancel;
+    }
+
+    @Override
+    public HandlerList getHandlers() {
+        return handlers;
+    }
+
+    public static HandlerList getHandlerList() {
+        return handlers;
+    }
+}
diff --git a/src/main/java/org/bukkit/event/player/PlayerLoginEvent.java b/src/main/java/org/bukkit/event/player/PlayerLoginEvent.java
index 60c0875..dab3c5c 100644
--- a/src/main/java/org/bukkit/event/player/PlayerLoginEvent.java
+++ b/src/main/java/org/bukkit/event/player/PlayerLoginEvent.java
@@ -14,6 +14,7 @@ public class PlayerLoginEvent extends PlayerEvent {
     private final String hostname;
     private Result result = Result.ALLOWED;
     private String message = "";
+    private final InetAddress realAddress; // Spigot
 
     /**
      * @deprecated Address should be provided in other constructor
@@ -38,10 +39,17 @@ public class PlayerLoginEvent extends PlayerEvent {
      * @param hostname The hostname that was used to connect to the server
      * @param address The address the player used to connect, provided for timing issues
      */
-    public PlayerLoginEvent(final Player player, final String hostname, final InetAddress address) {
+    public PlayerLoginEvent(final Player player, final String hostname, final InetAddress address, final InetAddress realAddress) { // Spigot
         super(player);
         this.hostname = hostname;
         this.address = address;
+        // Spigot start
+        this.realAddress = address;
+    }
+
+    public PlayerLoginEvent(final Player player, final String hostname, final InetAddress address) {
+        this(player, hostname, address, address);
+        // Spigot end
     }
 
     /**
@@ -49,7 +57,7 @@ public class PlayerLoginEvent extends PlayerEvent {
      */
     @Deprecated
     public PlayerLoginEvent(final Player player, final Result result, final String message) {
-        this(player, "", null, result, message);
+        this(player, "", null, result, message, null); // Spigot
     }
 
     /**
@@ -61,12 +69,23 @@ public class PlayerLoginEvent extends PlayerEvent {
      * @param result The result status for this event
      * @param message The message to be displayed if result denies login
      */
-    public PlayerLoginEvent(final Player player, String hostname, final InetAddress address, final Result result, final String message) {
-        this(player, hostname, address);
+    public PlayerLoginEvent(final Player player, String hostname, final InetAddress address, final Result result, final String message, final InetAddress realAddress) { // Spigot
+        this(player, hostname, address, realAddress); // Spigot
         this.result = result;
         this.message = message;
     }
 
+    // Spigot start
+    /**
+     * Gets the connection address of this player, regardless of whether it has been spoofed or not.
+     *
+     * @return the player's connection address
+     */
+    public InetAddress getRealAddress() {
+        return realAddress;
+    }
+    // Spigot end
+
     /**
      * Gets the current result of the login, as an enum
      *
diff --git a/src/main/java/org/bukkit/event/player/PlayerPortalEvent.java b/src/main/java/org/bukkit/event/player/PlayerPortalEvent.java
index 4706811..93752f7 100644
--- a/src/main/java/org/bukkit/event/player/PlayerPortalEvent.java
+++ b/src/main/java/org/bukkit/event/player/PlayerPortalEvent.java
@@ -6,7 +6,10 @@ import org.bukkit.entity.Player;
 import org.bukkit.event.HandlerList;
 
 /**
- * Called when a player is about to teleport because it is in contact with a portal
+ * Called when a player is about to teleport because it is in contact with a
+ * portal.
+ * <p>
+ * For other entities see {@link org.bukkit.event.entity.EntityPortalEvent}
  */
 public class PlayerPortalEvent extends PlayerTeleportEvent {
     private static final HandlerList handlers = new HandlerList();
@@ -23,18 +26,52 @@ public class PlayerPortalEvent extends PlayerTeleportEvent {
         this.travelAgent = pta;
     }
 
+    /**
+     * Sets whether or not the Travel Agent will be used.
+     * <p>
+     * If this is set to true, the TravelAgent will try to find a Portal at
+     * the {@link #getTo()} Location, and will try to create one if there is
+     * none.
+     * <p>
+     * If this is set to false, the {@link #getPlayer()} will only be
+     * teleported to the {@link #getTo()} Location.
+     *
+     * @param useTravelAgent whether to use the Travel Agent
+     */
     public void useTravelAgent(boolean useTravelAgent) {
         this.useTravelAgent = useTravelAgent;
     }
 
+    /**
+     * Gets whether or not the Travel Agent will be used.
+     * <p>
+     * If this is set to true, the TravelAgent will try to find a Portal at
+     * the {@link #getTo()} Location, and will try to create one if there is
+     * none.
+     * <p>
+     * If this is set to false, the {@link #getPlayer()}} will only be
+     * teleported to the {@link #getTo()} Location.
+     *
+     * @return whether to use the Travel Agent
+     */
     public boolean useTravelAgent() {
         return useTravelAgent && travelAgent != null;
     }
 
+    /**
+     * Gets the Travel Agent used (or not) in this event.
+     *
+     * @return the Travel Agent used (or not) in this event
+     */
     public TravelAgent getPortalTravelAgent() {
         return this.travelAgent;
     }
 
+    /**
+     * Sets the Travel Agent used (or not) in this event.
+     *
+     * @param travelAgent the Travel Agent used (or not) in this event
+     */
     public void setPortalTravelAgent(TravelAgent travelAgent) {
         this.travelAgent = travelAgent;
     }
diff --git a/src/main/java/org/bukkit/event/vehicle/VehicleUpdateEvent.java b/src/main/java/org/bukkit/event/vehicle/VehicleUpdateEvent.java
index d84faf4..eebfdb1 100644
--- a/src/main/java/org/bukkit/event/vehicle/VehicleUpdateEvent.java
+++ b/src/main/java/org/bukkit/event/vehicle/VehicleUpdateEvent.java
@@ -3,6 +3,9 @@ package org.bukkit.event.vehicle;
 import org.bukkit.entity.Vehicle;
 import org.bukkit.event.HandlerList;
 
+/**
+ * Called when a vehicle updates
+ */
 public class VehicleUpdateEvent extends VehicleEvent {
     private static final HandlerList handlers = new HandlerList();
 
diff --git a/src/main/java/org/bukkit/generator/BlockPopulator.java b/src/main/java/org/bukkit/generator/BlockPopulator.java
index 041dc4f..eacc829 100644
--- a/src/main/java/org/bukkit/generator/BlockPopulator.java
+++ b/src/main/java/org/bukkit/generator/BlockPopulator.java
@@ -9,6 +9,7 @@ import org.bukkit.World;
  * For example, generating glowstone inside the nether or generating dungeons full of treasure
  */
 public abstract class BlockPopulator {
+
     /**
      * Populates an area of blocks at or around the given chunk.
      * <p>
diff --git a/src/main/java/org/bukkit/generator/ChunkGenerator.java b/src/main/java/org/bukkit/generator/ChunkGenerator.java
index 24e6aae..875f276 100644
--- a/src/main/java/org/bukkit/generator/ChunkGenerator.java
+++ b/src/main/java/org/bukkit/generator/ChunkGenerator.java
@@ -14,6 +14,7 @@ import org.bukkit.block.Block;
  * For example, the nether chunk generator should shape netherrack and soulsand
  */
 public abstract class ChunkGenerator {
+
     /**
      * Interface to biome data for chunk to be generated: initialized with default values for world type and seed.
      * <p>
diff --git a/src/main/java/org/bukkit/inventory/BeaconInventory.java b/src/main/java/org/bukkit/inventory/BeaconInventory.java
index deaf183..d791f60 100644
--- a/src/main/java/org/bukkit/inventory/BeaconInventory.java
+++ b/src/main/java/org/bukkit/inventory/BeaconInventory.java
@@ -1,6 +1,7 @@
 package org.bukkit.inventory;
 
 public interface BeaconInventory extends Inventory {
+
     /**
      * Set the item powering the beacon.
      *
diff --git a/src/main/java/org/bukkit/inventory/BrewerInventory.java b/src/main/java/org/bukkit/inventory/BrewerInventory.java
index 735e86d..91cd276 100644
--- a/src/main/java/org/bukkit/inventory/BrewerInventory.java
+++ b/src/main/java/org/bukkit/inventory/BrewerInventory.java
@@ -3,6 +3,7 @@ package org.bukkit.inventory;
 import org.bukkit.block.BrewingStand;
 
 public interface BrewerInventory extends Inventory {
+
     /**
      * Get the current ingredient for brewing.
      *
diff --git a/src/main/java/org/bukkit/inventory/CraftingInventory.java b/src/main/java/org/bukkit/inventory/CraftingInventory.java
index 4b6cce4..e3b31b5 100644
--- a/src/main/java/org/bukkit/inventory/CraftingInventory.java
+++ b/src/main/java/org/bukkit/inventory/CraftingInventory.java
@@ -4,6 +4,7 @@ package org.bukkit.inventory;
  * Interface to the crafting inventories
  */
 public interface CraftingInventory extends Inventory {
+
     /**
      * Check what item is in the result slot of this crafting inventory.
      *
diff --git a/src/main/java/org/bukkit/inventory/DoubleChestInventory.java b/src/main/java/org/bukkit/inventory/DoubleChestInventory.java
index 1a20320..0e419ed 100644
--- a/src/main/java/org/bukkit/inventory/DoubleChestInventory.java
+++ b/src/main/java/org/bukkit/inventory/DoubleChestInventory.java
@@ -3,6 +3,7 @@ package org.bukkit.inventory;
 import org.bukkit.block.DoubleChest;
 
 public interface DoubleChestInventory extends Inventory {
+
     /**
      * Get the left half of this double chest.
      *
diff --git a/src/main/java/org/bukkit/inventory/EnchantingInventory.java b/src/main/java/org/bukkit/inventory/EnchantingInventory.java
index f158733..9be1ee7 100644
--- a/src/main/java/org/bukkit/inventory/EnchantingInventory.java
+++ b/src/main/java/org/bukkit/inventory/EnchantingInventory.java
@@ -1,6 +1,7 @@
 package org.bukkit.inventory;
 
 public interface EnchantingInventory extends Inventory {
+
     /**
      * Set the item being enchanted.
      *
diff --git a/src/main/java/org/bukkit/inventory/EntityEquipment.java b/src/main/java/org/bukkit/inventory/EntityEquipment.java
index 01c3528..de682a6 100644
--- a/src/main/java/org/bukkit/inventory/EntityEquipment.java
+++ b/src/main/java/org/bukkit/inventory/EntityEquipment.java
@@ -6,6 +6,7 @@ import org.bukkit.entity.Entity;
  * An interface to a creatures inventory
  */
 public interface EntityEquipment {
+
     /**
      * Gets a copy of the item the entity is currently holding
      *
diff --git a/src/main/java/org/bukkit/inventory/FurnaceInventory.java b/src/main/java/org/bukkit/inventory/FurnaceInventory.java
index f2219a6..5920083 100644
--- a/src/main/java/org/bukkit/inventory/FurnaceInventory.java
+++ b/src/main/java/org/bukkit/inventory/FurnaceInventory.java
@@ -3,6 +3,7 @@ package org.bukkit.inventory;
 import org.bukkit.block.Furnace;
 
 public interface FurnaceInventory extends Inventory {
+
     /**
      * Get the current item in the result slot.
      *
diff --git a/src/main/java/org/bukkit/inventory/Inventory.java b/src/main/java/org/bukkit/inventory/Inventory.java
index aa4373f..436e7e4 100644
--- a/src/main/java/org/bukkit/inventory/Inventory.java
+++ b/src/main/java/org/bukkit/inventory/Inventory.java
@@ -171,21 +171,28 @@ public interface Inventory extends Iterable<ItemStack> {
     public boolean contains(Material material, int amount) throws IllegalArgumentException;
 
     /**
-     * Checks if the inventory contains any ItemStacks matching the given ItemStack and at least the minimum amount specified
-     * This will only match if both the type and the amount of the stack match
+     * Checks if the inventory contains at least the minimum amount specified
+     * of exactly matching ItemStacks.
+     * <p>
+     * An ItemStack only counts if both the type and the amount of the stack
+     * match.
      *
-     * @param item The ItemStack to match against
-     * @param amount The amount of stacks to find
-     * @return false if item is null, true if amount less than 1, true if amount of exactly matching ItemStacks were found.
+     * @param item the ItemStack to match against
+     * @param amount how many identical stacks to check for
+     * @return false if item is null, true if amount less than 1, true if
+     *     amount of exactly matching ItemStacks were found
+     * @see #containsAtLeast(ItemStack, int)
      */
     public boolean contains(ItemStack item, int amount);
 
     /**
-     * Checks if the inventory contains any ItemStacks matching the given ItemStack and at least the minimum amount specified
+     * Checks if the inventory contains ItemStacks matching the given
+     * ItemStack whose amounts sum to at least the minimum amount specified.
      *
-     * @param item The ItemStack to match against
-     * @param amount The minimum amount
-     * @return false if item is null, true if amount less than 1, true if enough ItemStacks were found to add to the given amount
+     * @param item the ItemStack to match against
+     * @param amount the minimum amount
+     * @return false if item is null, true if amount less than 1, true if
+     *     enough ItemStacks were found to add to the given amount
      */
     public boolean containsAtLeast(ItemStack item, int amount);
 
diff --git a/src/main/java/org/bukkit/inventory/InventoryHolder.java b/src/main/java/org/bukkit/inventory/InventoryHolder.java
index 9d78843..9c06a3d 100644
--- a/src/main/java/org/bukkit/inventory/InventoryHolder.java
+++ b/src/main/java/org/bukkit/inventory/InventoryHolder.java
@@ -1,6 +1,7 @@
 package org.bukkit.inventory;
 
 public interface InventoryHolder {
+
     /**
      * Get the object's inventory.
      *
diff --git a/src/main/java/org/bukkit/permissions/Permissible.java b/src/main/java/org/bukkit/permissions/Permissible.java
index e094f06..66a0c81 100644
--- a/src/main/java/org/bukkit/permissions/Permissible.java
+++ b/src/main/java/org/bukkit/permissions/Permissible.java
@@ -7,6 +7,7 @@ import org.bukkit.plugin.Plugin;
  * Represents an object that may be assigned permissions
  */
 public interface Permissible extends ServerOperator {
+
     /**
      * Checks if this object contains an override for the specified permission, by fully qualified name
      *
diff --git a/src/main/java/org/bukkit/permissions/PermissionRemovedExecutor.java b/src/main/java/org/bukkit/permissions/PermissionRemovedExecutor.java
index a9543cf..aa797ee 100644
--- a/src/main/java/org/bukkit/permissions/PermissionRemovedExecutor.java
+++ b/src/main/java/org/bukkit/permissions/PermissionRemovedExecutor.java
@@ -4,6 +4,7 @@ package org.bukkit.permissions;
  * Represents a class which is to be notified when a {@link PermissionAttachment} is removed from a {@link Permissible}
  */
 public interface PermissionRemovedExecutor {
+
     /**
      * Called when a {@link PermissionAttachment} is removed from a {@link Permissible}
      *
diff --git a/src/main/java/org/bukkit/permissions/ServerOperator.java b/src/main/java/org/bukkit/permissions/ServerOperator.java
index 721c42a..e4faa87 100644
--- a/src/main/java/org/bukkit/permissions/ServerOperator.java
+++ b/src/main/java/org/bukkit/permissions/ServerOperator.java
@@ -6,6 +6,7 @@ import org.bukkit.entity.Player;
  * Represents an object that may become a server operator, such as a {@link Player}
  */
 public interface ServerOperator {
+
     /**
      * Checks if this object is a server operator
      *
diff --git a/src/main/java/org/bukkit/plugin/SimplePluginManager.java b/src/main/java/org/bukkit/plugin/SimplePluginManager.java
index 93fb4f5..a96a33b 100644
--- a/src/main/java/org/bukkit/plugin/SimplePluginManager.java
+++ b/src/main/java/org/bukkit/plugin/SimplePluginManager.java
@@ -274,6 +274,7 @@ public final class SimplePluginManager implements PluginManager {
             }
         }
 
+        org.bukkit.command.defaults.TimingsCommand.timingStart = System.nanoTime(); // Spigot
         return result.toArray(new Plugin[result.size()]);
     }
 
diff --git a/src/main/java/org/bukkit/plugin/TimedRegisteredListener.java b/src/main/java/org/bukkit/plugin/TimedRegisteredListener.java
index d86805b..4b744ea 100644
--- a/src/main/java/org/bukkit/plugin/TimedRegisteredListener.java
+++ b/src/main/java/org/bukkit/plugin/TimedRegisteredListener.java
@@ -11,6 +11,10 @@ import org.bukkit.event.Listener;
 public class TimedRegisteredListener extends RegisteredListener {
     private int count;
     private long totalTime;
+    // Spigot start
+    public long curTickTotal = 0;
+    public long violations = 0;
+    // Spigot end
     private Class<? extends Event> eventClass;
     private boolean multiple = false;
 
@@ -20,6 +24,13 @@ public class TimedRegisteredListener extends RegisteredListener {
 
     @Override
     public void callEvent(Event event) throws EventException {
+        // Spigot start
+        if ( org.bukkit.Bukkit.getServer() != null && !org.bukkit.Bukkit.getServer().getPluginManager().useTimings() )
+        {
+            super.callEvent( event );
+            return;
+        }
+        // Spigot end
         if (event.isAsynchronous()) {
             super.callEvent(event);
             return;
@@ -34,7 +45,11 @@ public class TimedRegisteredListener extends RegisteredListener {
         }
         long start = System.nanoTime();
         super.callEvent(event);
-        totalTime += System.nanoTime() - start;
+        // Spigot start
+        long diff = System.nanoTime() - start;
+        curTickTotal += diff;
+        totalTime += diff;
+        // Spigot end
     }
 
     private static Class<?> getCommonSuperclass(Class<?> class1, Class<?> class2) {
@@ -50,6 +65,10 @@ public class TimedRegisteredListener extends RegisteredListener {
     public void reset() {
         count = 0;
         totalTime = 0;
+        // Spigot start
+        curTickTotal = 0;
+        violations = 0;
+        // Spigot end
     }
 
     /**
diff --git a/src/main/java/org/bukkit/plugin/java/JavaPluginLoader.java b/src/main/java/org/bukkit/plugin/java/JavaPluginLoader.java
index ea30d83..d905435 100644
--- a/src/main/java/org/bukkit/plugin/java/JavaPluginLoader.java
+++ b/src/main/java/org/bukkit/plugin/java/JavaPluginLoader.java
@@ -430,7 +430,7 @@ public class JavaPluginLoader implements PluginLoader {
                     }
                 }
             };
-            if (useTimings) {
+            if (true) { // Spigot - TRL handles useTimings check now
                 eventSet.add(new TimedRegisteredListener(listener, executor, eh.priority(), plugin, eh.ignoreCancelled()));
             } else {
                 eventSet.add(new RegisteredListener(listener, executor, eh.priority(), plugin, eh.ignoreCancelled()));
diff --git a/src/main/java/org/bukkit/potion/Potion.java b/src/main/java/org/bukkit/potion/Potion.java
index 800a375..0d44ce0 100644
--- a/src/main/java/org/bukkit/potion/Potion.java
+++ b/src/main/java/org/bukkit/potion/Potion.java
@@ -37,7 +37,9 @@ public class Potion {
         }
     }
 
-    /** @deprecated In favour of {@link #Potion(PotionType, int)} */
+    /**
+     * @deprecated In favour of {@link #Potion(PotionType, int)}
+     */
     @SuppressWarnings("javadoc")
     @Deprecated
     public Potion(PotionType type, Tier tier) {
@@ -45,14 +47,18 @@ public class Potion {
         Validate.notNull(type, "Type cannot be null");
     }
 
-    /** @deprecated In favour of {@link #Potion(PotionType, int, boolean)} */
+    /**
+     * @deprecated In favour of {@link #Potion(PotionType, int, boolean)}
+     */
     @SuppressWarnings("javadoc")
     @Deprecated
     public Potion(PotionType type, Tier tier, boolean splash) {
         this(type, tier == Tier.TWO ? 2 : 1, splash);
     }
 
-    /** @deprecated In favour of {@link #Potion(PotionType, int, boolean, boolean)} */
+    /**
+     * @deprecated In favour of {@link #Potion(PotionType, int, boolean, boolean)}
+     */
     @SuppressWarnings("javadoc")
     @Deprecated
     public Potion(PotionType type, Tier tier, boolean splash, boolean extended) {
@@ -304,7 +310,9 @@ public class Potion {
      * item stacks.
      *
      * @return The damage value of this potion
+     * @deprecated Magic value
      */
+    @Deprecated
     public short toDamageValue() {
         short damage;
         if (type == PotionType.WATER) {
diff --git a/src/main/java/org/bukkit/potion/PotionBrewer.java b/src/main/java/org/bukkit/potion/PotionBrewer.java
index d85a1d6..ba5f20c 100644
--- a/src/main/java/org/bukkit/potion/PotionBrewer.java
+++ b/src/main/java/org/bukkit/potion/PotionBrewer.java
@@ -6,6 +6,7 @@ import java.util.Collection;
  * Represents a brewer that can create {@link PotionEffect}s.
  */
 public interface PotionBrewer {
+
     /**
      * Creates a {@link PotionEffect} from the given {@link PotionEffectType},
      * applying duration modifiers and checks.
diff --git a/src/main/java/org/bukkit/potion/PotionType.java b/src/main/java/org/bukkit/potion/PotionType.java
index 5913ad7..dab0293 100644
--- a/src/main/java/org/bukkit/potion/PotionType.java
+++ b/src/main/java/org/bukkit/potion/PotionType.java
@@ -58,11 +58,6 @@ public enum PotionType {
         return null;
     }
 
-    /**
-     *
-     * @deprecated Magic value
-     */
-    @Deprecated
     public static PotionType getByEffect(PotionEffectType effectType) {
         if (effectType == null)
             return WATER;
diff --git a/src/main/java/org/bukkit/scheduler/BukkitTask.java b/src/main/java/org/bukkit/scheduler/BukkitTask.java
index 890c731..e447e64 100644
--- a/src/main/java/org/bukkit/scheduler/BukkitTask.java
+++ b/src/main/java/org/bukkit/scheduler/BukkitTask.java
@@ -5,7 +5,6 @@ import org.bukkit.plugin.Plugin;
 /**
  * Represents a task being executed by the scheduler
  */
-
 public interface BukkitTask {
 
     /**
diff --git a/src/main/java/org/bukkit/scheduler/BukkitWorker.java b/src/main/java/org/bukkit/scheduler/BukkitWorker.java
index a889e89..4df43a6 100644
--- a/src/main/java/org/bukkit/scheduler/BukkitWorker.java
+++ b/src/main/java/org/bukkit/scheduler/BukkitWorker.java
@@ -8,7 +8,6 @@ import org.bukkit.plugin.Plugin;
  * </p>
  * Workers are used to execute async tasks.
  */
-
 public interface BukkitWorker {
 
     /**
diff --git a/src/main/java/org/bukkit/util/FileUtil.java b/src/main/java/org/bukkit/util/FileUtil.java
index 2e13767..7cabf4c 100644
--- a/src/main/java/org/bukkit/util/FileUtil.java
+++ b/src/main/java/org/bukkit/util/FileUtil.java
@@ -9,7 +9,6 @@ import java.io.IOException;
 /**
  * Class containing file utilities
  */
-
 public class FileUtil {
 
     /**
@@ -19,7 +18,6 @@ public class FileUtil {
      * @param outFile the target filename
      * @return true on success
      */
-
     public static boolean copy(File inFile, File outFile) {
         if (!inFile.exists()) {
             return false;
diff --git a/src/main/java/org/bukkit/util/io/BukkitObjectInputStream.java b/src/main/java/org/bukkit/util/io/BukkitObjectInputStream.java
index ed5675f..d4b2825 100644
--- a/src/main/java/org/bukkit/util/io/BukkitObjectInputStream.java
+++ b/src/main/java/org/bukkit/util/io/BukkitObjectInputStream.java
@@ -23,7 +23,7 @@ public class BukkitObjectInputStream extends ObjectInputStream {
      *
      * @throws IOException
      * @throws SecurityException
-     * @see {@link ObjectInputStream#ObjectInputStream()}
+     * @see ObjectInputStream#ObjectInputStream()
      */
     protected BukkitObjectInputStream() throws IOException, SecurityException {
         super();
@@ -35,7 +35,7 @@ public class BukkitObjectInputStream extends ObjectInputStream {
      *
      * @param in
      * @throws IOException
-     * @see {@link ObjectInputStream#ObjectInputStream(InputStream)}
+     * @see ObjectInputStream#ObjectInputStream(InputStream)
      */
     public BukkitObjectInputStream(InputStream in) throws IOException {
         super(in);
diff --git a/src/main/java/org/bukkit/util/io/BukkitObjectOutputStream.java b/src/main/java/org/bukkit/util/io/BukkitObjectOutputStream.java
index afdd7e3..c11e202 100644
--- a/src/main/java/org/bukkit/util/io/BukkitObjectOutputStream.java
+++ b/src/main/java/org/bukkit/util/io/BukkitObjectOutputStream.java
@@ -23,7 +23,7 @@ public class BukkitObjectOutputStream extends ObjectOutputStream {
      *
      * @throws IOException
      * @throws SecurityException
-     * @see {@link ObjectOutputStream#ObjectOutputStream()}
+     * @see ObjectOutputStream#ObjectOutputStream()
      */
     protected BukkitObjectOutputStream() throws IOException, SecurityException {
         super();
@@ -35,7 +35,7 @@ public class BukkitObjectOutputStream extends ObjectOutputStream {
      *
      * @param out
      * @throws IOException
-     * @see {@link ObjectOutputStream#ObjectOutputStream(OutputStream)}
+     * @see ObjectOutputStream#ObjectOutputStream(OutputStream)
      */
     public BukkitObjectOutputStream(OutputStream out) throws IOException {
         super(out);
diff --git a/src/main/java/org/spigotmc/CustomTimingsHandler.java b/src/main/java/org/spigotmc/CustomTimingsHandler.java
new file mode 100644
index 0000000..9fca481
--- /dev/null
+++ b/src/main/java/org/spigotmc/CustomTimingsHandler.java
@@ -0,0 +1,175 @@
+package org.spigotmc;
+
+import org.bukkit.event.HandlerList;
+import org.bukkit.plugin.Plugin;
+import org.bukkit.plugin.RegisteredListener;
+import org.bukkit.plugin.TimedRegisteredListener;
+import java.io.PrintStream;
+import java.util.Collection;
+import java.util.HashSet;
+import org.bukkit.Bukkit;
+import org.bukkit.World;
+
+/**
+ * Provides custom timing sections for /timings merged.
+ */
+public class CustomTimingsHandler
+{
+
+    private static final Collection<CustomTimingsHandler> ALL_HANDLERS = new HashSet<CustomTimingsHandler>();
+    private static CustomTimingsHandler[] BAKED_HANDLERS;
+    /*========================================================================*/
+    private final String name;
+    private final CustomTimingsHandler parent;
+    private long count = 0;
+    private long start = 0;
+    private long timingDepth = 0;
+    private long totalTime = 0;
+    private long curTickTotal = 0;
+    private long violations = 0;
+
+    public CustomTimingsHandler(String name)
+    {
+        this( name, null );
+    }
+
+    public CustomTimingsHandler(String name, CustomTimingsHandler parent)
+    {
+        this.name = name;
+        this.parent = parent;
+        ALL_HANDLERS.add( this );
+        BAKED_HANDLERS = ALL_HANDLERS.toArray( new CustomTimingsHandler[ ALL_HANDLERS.size() ] );
+    }
+
+    /**
+     * Prints the timings and extra data to the given stream.
+     *
+     * @param printStream
+     */
+    public static void printTimings(PrintStream printStream)
+    {
+        printStream.println( "Minecraft" );
+        for ( CustomTimingsHandler timings : BAKED_HANDLERS )
+        {
+            long time = timings.totalTime;
+            long count = timings.count;
+            if ( count == 0 )
+            {
+                continue;
+            }
+            long avg = time / count;
+
+            printStream.println( "    " + timings.name + " Time: " + time + " Count: " + count + " Avg: " + avg + " Violations: " + timings.violations );
+        }
+        printStream.println( "# Version " + Bukkit.getVersion() );
+        int entities = 0;
+        int livingEntities = 0;
+        for ( World world : Bukkit.getWorlds() )
+        {
+            entities += world.getEntities().size();
+            livingEntities += world.getLivingEntities().size();
+        }
+        printStream.println( "# Entities " + entities );
+        printStream.println( "# LivingEntities " + livingEntities );
+    }
+
+    /**
+     * Resets all timings.
+     */
+    public static void reload()
+    {
+        if ( Bukkit.getPluginManager().useTimings() )
+        {
+            for ( CustomTimingsHandler timings : BAKED_HANDLERS )
+            {
+                timings.reset();
+            }
+        }
+    }
+
+    /**
+     * Ticked every tick by CraftBukkit to count the number of times a timer
+     * caused TPS loss.
+     */
+    public static void tick()
+    {
+        if ( Bukkit.getPluginManager().useTimings() )
+        {
+            for ( CustomTimingsHandler timings : BAKED_HANDLERS )
+            {
+                if ( timings.curTickTotal > 50000000 )
+                {
+                    timings.violations += Math.ceil( timings.curTickTotal / 50000000 );
+                }
+                timings.curTickTotal = 0;
+                timings.timingDepth = 0; // incase reset messes this up
+            }
+
+            for ( Plugin plugin : Bukkit.getPluginManager().getPlugins() )
+            {
+                for ( RegisteredListener listener : HandlerList.getRegisteredListeners( plugin ) )
+                {
+                    if ( listener instanceof TimedRegisteredListener )
+                    {
+                        TimedRegisteredListener timings = (TimedRegisteredListener) listener;
+                        if ( timings.curTickTotal > 50000000 )
+                        {
+                            timings.violations += Math.ceil( timings.curTickTotal / 50000000 );
+                        }
+                        timings.curTickTotal = 0;
+                    }
+                }
+            }
+        }
+    }
+
+    /**
+     * Starts timing to track a section of code.
+     */
+    public void startTiming()
+    {
+        // If second condtion fails we are already timing
+        if ( Bukkit.getPluginManager().useTimings() && ++timingDepth == 1 )
+        {
+            start = System.nanoTime();
+            if ( parent != null && ++parent.timingDepth == 1 )
+            {
+                parent.start = start;
+            }
+        }
+    }
+
+    /**
+     * Stops timing a section of code.
+     */
+    public void stopTiming()
+    {
+        if ( Bukkit.getPluginManager().useTimings() )
+        {
+            if ( --timingDepth != 0 || start == 0 )
+            {
+                return;
+            }
+            long diff = System.nanoTime() - start;
+            totalTime += diff;
+            curTickTotal += diff;
+            count++;
+            start = 0;
+            if ( parent != null )
+            {
+                parent.stopTiming();
+            }
+        }
+    }
+
+    /**
+     * Reset this timer, setting all values to zero.
+     */
+    public void reset()
+    {
+        count = 0;
+        violations = 0;
+        curTickTotal = 0;
+        totalTime = 0;
+    }
+}
diff --git a/src/main/java/org/spigotmc/event/entity/EntityDismountEvent.java b/src/main/java/org/spigotmc/event/entity/EntityDismountEvent.java
new file mode 100644
index 0000000..24d4942
--- /dev/null
+++ b/src/main/java/org/spigotmc/event/entity/EntityDismountEvent.java
@@ -0,0 +1,39 @@
+package org.spigotmc.event.entity;
+
+import org.bukkit.entity.Entity;
+import org.bukkit.event.HandlerList;
+import org.bukkit.event.entity.EntityEvent;
+
+/**
+ * Called when an entity stops riding another entity.
+ *
+ */
+public class EntityDismountEvent extends EntityEvent
+{
+
+    private static final HandlerList handlers = new HandlerList();
+    private boolean cancelled;
+    private final Entity dismounted;
+
+    public EntityDismountEvent(Entity what, Entity dismounted)
+    {
+        super( what );
+        this.dismounted = dismounted;
+    }
+
+    public Entity getDismounted()
+    {
+        return dismounted;
+    }
+
+    @Override
+    public HandlerList getHandlers()
+    {
+        return handlers;
+    }
+
+    public static HandlerList getHandlerList()
+    {
+        return handlers;
+    }
+}
diff --git a/src/main/java/org/spigotmc/event/entity/EntityMountEvent.java b/src/main/java/org/spigotmc/event/entity/EntityMountEvent.java
new file mode 100644
index 0000000..16aa2a7
--- /dev/null
+++ b/src/main/java/org/spigotmc/event/entity/EntityMountEvent.java
@@ -0,0 +1,52 @@
+package org.spigotmc.event.entity;
+
+import org.bukkit.entity.Entity;
+import org.bukkit.event.Cancellable;
+import org.bukkit.event.HandlerList;
+import org.bukkit.event.entity.EntityEvent;
+
+/**
+ * Called when an entity attempts to ride another entity.
+ *
+ */
+public class EntityMountEvent extends EntityEvent implements Cancellable
+{
+
+    private static final HandlerList handlers = new HandlerList();
+    private boolean cancelled;
+    private final Entity mount;
+
+    public EntityMountEvent(Entity what, Entity mount)
+    {
+        super( what );
+        this.mount = mount;
+    }
+
+    public Entity getMount()
+    {
+        return mount;
+    }
+
+    @Override
+    public boolean isCancelled()
+    {
+        return cancelled;
+    }
+
+    @Override
+    public void setCancelled(boolean cancel)
+    {
+        this.cancelled = cancel;
+    }
+
+    @Override
+    public HandlerList getHandlers()
+    {
+        return handlers;
+    }
+
+    public static HandlerList getHandlerList()
+    {
+        return handlers;
+    }
+}
diff --git a/src/test/java/org/bukkit/EffectTest.java b/src/test/java/org/bukkit/EffectTest.java
index 08aa71d..5217aec 100644
--- a/src/test/java/org/bukkit/EffectTest.java
+++ b/src/test/java/org/bukkit/EffectTest.java
@@ -9,7 +9,11 @@ public class EffectTest {
     @Test
     public void getById() {
         for (Effect effect : Effect.values()) {
-            assertThat(Effect.getById(effect.getId()), is(effect));
+            if (effect.getType() != Effect.Type.PARTICLE) {
+                assertThat(Effect.getById(effect.getId()), is(effect));
+            } else {
+                assertThat(Effect.getByName(effect.getName()), is(effect));
+            }
         }
     }
 }
diff --git a/src/test/java/org/bukkit/plugin/TimedRegisteredListenerTest.java b/src/test/java/org/bukkit/plugin/TimedRegisteredListenerTest.java
index b206b1f..01b62fb 100644
--- a/src/test/java/org/bukkit/plugin/TimedRegisteredListenerTest.java
+++ b/src/test/java/org/bukkit/plugin/TimedRegisteredListenerTest.java
@@ -15,7 +15,6 @@ import org.junit.Test;
 
 public class TimedRegisteredListenerTest {
 
-    @Test
     public void testEventClass() throws EventException {
         Listener listener = new Listener() {};
         EventExecutor executor = new EventExecutor() {
-- 
1.8.4

