From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Aikar <aikar@aikar.co>
Date: Thu, 4 Jul 2013 21:04:26 -0400
Subject: [PATCH] Persistent and Temporary Metadata API

Entity, TileEntity, World, Chunk, Block, Inventory API's
---
 .../java/com/empireminecraft/api/API.java     |   2 +
 .../com/empireminecraft/api/Vector3i.java     |  66 ++
 .../empireminecraft/api/meta/EAPI_Meta.java   |  53 ++
 .../com/empireminecraft/api/meta/Meta.java    | 760 ++++++++++++++++++
 .../com/empireminecraft/api/meta/MetaKey.java |  51 ++
 .../com/empireminecraft/api/meta/MetaMap.java |  96 +++
 .../api/meta/PersistentKeyImpl.java           |  44 +
 .../api/meta/PersistentMetaList.java          |  73 ++
 .../api/meta/PersistentMetaMap.java           |  93 +++
 .../empireminecraft/api/meta/TempKeyImpl.java |  44 +
 .../empireminecraft/api/meta/TempMetaMap.java |  29 +
 .../BlockWithPersistentMetaClearedEvent.java  |  49 ++
 src/main/java/org/bukkit/Chunk.java           |   2 +
 .../java/org/bukkit/block/BlockState.java     |   2 +
 src/main/java/org/bukkit/entity/Entity.java   |   1 +
 .../java/org/bukkit/inventory/Inventory.java  |   1 +
 16 files changed, 1366 insertions(+)
 create mode 100644 src/main/java/com/empireminecraft/api/Vector3i.java
 create mode 100644 src/main/java/com/empireminecraft/api/meta/EAPI_Meta.java
 create mode 100644 src/main/java/com/empireminecraft/api/meta/Meta.java
 create mode 100644 src/main/java/com/empireminecraft/api/meta/MetaKey.java
 create mode 100644 src/main/java/com/empireminecraft/api/meta/MetaMap.java
 create mode 100644 src/main/java/com/empireminecraft/api/meta/PersistentKeyImpl.java
 create mode 100644 src/main/java/com/empireminecraft/api/meta/PersistentMetaList.java
 create mode 100644 src/main/java/com/empireminecraft/api/meta/PersistentMetaMap.java
 create mode 100644 src/main/java/com/empireminecraft/api/meta/TempKeyImpl.java
 create mode 100644 src/main/java/com/empireminecraft/api/meta/TempMetaMap.java
 create mode 100644 src/main/java/com/empireminecraft/customevents/BlockWithPersistentMetaClearedEvent.java

diff --git a/src/main/java/com/empireminecraft/api/API.java b/src/main/java/com/empireminecraft/api/API.java
index 237e557551ffca6574f50cbe01e03f90f8cee866..9ff1db8cd24246c80f892e2f2feb181a769c1e15 100644
--- a/src/main/java/com/empireminecraft/api/API.java
+++ b/src/main/java/com/empireminecraft/api/API.java
@@ -23,12 +23,14 @@
 
 package com.empireminecraft.api;
 
+import com.empireminecraft.api.meta.EAPI_Meta;
 import org.apache.commons.lang.exception.ExceptionUtils;
 
 public abstract class API {
 
     public static EAPI_Entity entity;
     public static EAPI_Misc misc;
+    public static EAPI_Meta meta;
 
     public static String stack() {
         return ExceptionUtils.getFullStackTrace(new Throwable());
diff --git a/src/main/java/com/empireminecraft/api/Vector3i.java b/src/main/java/com/empireminecraft/api/Vector3i.java
new file mode 100644
index 0000000000000000000000000000000000000000..75b2748e28fc4965ce3fc8d2ae2af481bdcbf44b
--- /dev/null
+++ b/src/main/java/com/empireminecraft/api/Vector3i.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright (c) 2016 Starlis LLC / Daniel Ennis (Aikar) - MIT License
+ *
+ *  Permission is hereby granted, free of charge, to any person obtaining
+ *  a copy of this software and associated documentation files (the
+ *  "Software"), to deal in the Software without restriction, including
+ *  without limitation the rights to use, copy, modify, merge, publish,
+ *  distribute, sublicense, and/or sell copies of the Software, and to
+ *  permit persons to whom the Software is furnished to do so, subject to
+ *  the following conditions:
+ *
+ *  The above copyright notice and this permission notice shall be
+ *  included in all copies or substantial portions of the Software.
+ *
+ *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ *  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ *  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ *  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ *  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ *  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ *  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.empireminecraft.api;
+
+import com.empireminecraft.api.meta.Meta;
+
+@SuppressWarnings("PublicInnerClass")
+public final class Vector3i {
+    public final int x;
+    public final int y;
+    public final int z;
+
+    public Vector3i(int x, int y, int z) {
+        this.x = x;
+        this.y = y;
+        this.z = z;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) { return true; }
+        if (o == null || getClass() != o.getClass()) { return false; }
+
+        Vector3i vector = (Vector3i) o;
+
+        return (x == vector.x && z == vector.z && y == vector.y);
+    }
+
+    @Override
+    public int hashCode() {
+        int result = x;
+        result = result * 73 + y;
+        result = result * 73 + z;
+        return result;
+    }
+
+    @Override
+    public String toString() {
+        return "BlockPos{" +
+            "x=" + x +
+            ", y=" + y +
+            ", z=" + z +
+            '}';
+    }
+}
diff --git a/src/main/java/com/empireminecraft/api/meta/EAPI_Meta.java b/src/main/java/com/empireminecraft/api/meta/EAPI_Meta.java
new file mode 100644
index 0000000000000000000000000000000000000000..8313735b1565faa3d9f8dcdb367279f4375106e0
--- /dev/null
+++ b/src/main/java/com/empireminecraft/api/meta/EAPI_Meta.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright (c) 2016 Starlis LLC / Daniel Ennis (Aikar) - MIT License
+ *
+ *  Permission is hereby granted, free of charge, to any person obtaining
+ *  a copy of this software and associated documentation files (the
+ *  "Software"), to deal in the Software without restriction, including
+ *  without limitation the rights to use, copy, modify, merge, publish,
+ *  distribute, sublicense, and/or sell copies of the Software, and to
+ *  permit persons to whom the Software is furnished to do so, subject to
+ *  the following conditions:
+ *
+ *  The above copyright notice and this permission notice shall be
+ *  included in all copies or substantial portions of the Software.
+ *
+ *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ *  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ *  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ *  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ *  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ *  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ *  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.empireminecraft.api.meta;
+
+import com.empireminecraft.api.Vector3i;
+import com.empireminecraft.api.meta.MetaKey.TempKey;
+import org.bukkit.Chunk;
+import org.bukkit.Location;
+import org.bukkit.World;
+import org.bukkit.block.Block;
+import org.bukkit.block.BlockState;
+import org.bukkit.entity.Entity;
+
+import java.util.Map;
+
+public interface EAPI_Meta {
+    PersistentMetaMap getTileEntityMetaMap(BlockState tileEntity, boolean isWrite);
+
+    PersistentMetaMap getBlockMetaMap(Location loc, boolean isWrite);
+
+    PersistentMetaMap getChunkMetaMap(Chunk chunk, boolean isWrite);
+
+    TempMetaMap getChunkTempMetaMap(Chunk chunk, boolean isWrite);
+
+    Map<Vector3i,PersistentMetaMap> getChunkMetaData(Chunk chunk);
+
+    PersistentMetaMap getEntityMetaMap(Entity entity, boolean isWrite);
+
+    PersistentMetaMap getWorldMetaMap(World world);
+
+    Map<String,Object> getBlockTempMeta(Block block, boolean b);
+}
diff --git a/src/main/java/com/empireminecraft/api/meta/Meta.java b/src/main/java/com/empireminecraft/api/meta/Meta.java
new file mode 100644
index 0000000000000000000000000000000000000000..b4d0dad5af2b464b2d63b261d038b65d9d02f42b
--- /dev/null
+++ b/src/main/java/com/empireminecraft/api/meta/Meta.java
@@ -0,0 +1,760 @@
+/*
+ * Copyright (c) 2016 Starlis LLC / Daniel Ennis (Aikar) - MIT License
+ *
+ *  Permission is hereby granted, free of charge, to any person obtaining
+ *  a copy of this software and associated documentation files (the
+ *  "Software"), to deal in the Software without restriction, including
+ *  without limitation the rights to use, copy, modify, merge, publish,
+ *  distribute, sublicense, and/or sell copies of the Software, and to
+ *  permit persons to whom the Software is furnished to do so, subject to
+ *  the following conditions:
+ *
+ *  The above copyright notice and this permission notice shall be
+ *  included in all copies or substantial portions of the Software.
+ *
+ *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ *  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ *  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ *  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ *  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ *  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ *  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.empireminecraft.api.meta;
+
+import com.empireminecraft.api.API;
+import com.empireminecraft.api.Vector3i;
+import com.empireminecraft.api.meta.MetaKey.PersistentKey;
+import com.empireminecraft.api.meta.MetaKey.TempKey;
+import org.bukkit.Chunk;
+import org.bukkit.Location;
+import org.bukkit.World;
+import org.bukkit.block.Block;
+import org.bukkit.block.BlockState;
+import org.bukkit.entity.Entity;
+import org.bukkit.inventory.Inventory;
+import org.bukkit.inventory.ItemStack;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.Map;
+
+@SuppressWarnings({"WeakerAccess", "unused"})
+public final class Meta {
+    private Meta() {}
+
+    //////////////////////////////////////////////////
+    //// UTIL & KEYS
+    //////////////////////////////////////////////////
+
+    public static TempKey createTempKey(String key) {
+        return new TempKeyImpl(key);
+    }
+    public static PersistentKey createPersistentKey(String key) {
+        return new PersistentKeyImpl(key);
+    }
+
+    /**
+     * Checks if the passed object can be stored as Meta Data
+     * @param value
+     * @return
+     */
+    public static boolean isValidPersistentMeta(Object value) {
+        return (value instanceof String) || (value instanceof Long) ||
+                (value instanceof Integer) || (value instanceof ItemStack) ||
+                (value instanceof Float) || (value instanceof Double) ||
+                (value instanceof PersistentMetaMap) || (value instanceof PersistentMetaList);
+    }
+
+    /**
+     * General method for determining if value is null to remove it, else set.
+     * Return previous value
+     *
+     * @param map
+     * @param key
+     * @param val
+     * @param <T>
+     * @return
+     */
+    private static <T, K extends MetaKey> T setMetaMapValue(MetaMap<K> map, K key, Object val) {
+        if (map == null) {
+            return null;
+        }
+        if (val == null) {
+            return (T) map.remove(key.key());
+        } else {
+            return (T) map.put(key.key(), val);
+        }
+    }
+
+
+    //////////////////////////////////////////////////
+    //// PERSISTENT WORLD META
+    //////////////////////////////////////////////////
+
+    @NotNull
+    public static PersistentMetaMap getWorldPersistentMetaMap(@NotNull World world) {
+        return API.meta.getWorldMetaMap(world);
+    }
+
+    @Nullable
+    public static <T> T getWorldMeta(@NotNull World world, @NotNull PersistentKey key) {
+        return getWorldMeta(world, key, null);
+    }
+
+    public static <T> T getWorldMeta(@NotNull World world, @NotNull PersistentKey key, @Nullable T def) {
+        final PersistentMetaMap worldMetaMap = getWorldPersistentMetaMap(world);
+        T ret = !worldMetaMap.isEmpty() ? (T) worldMetaMap.get(key.key()) : null;
+        return ret != null ? ret : def;
+    }
+
+    public static boolean hasWorldMeta(@NotNull World world, @NotNull PersistentKey key) {
+        final PersistentMetaMap worldMetaMap = getWorldPersistentMetaMap(world);
+        return !worldMetaMap.isEmpty() && worldMetaMap.containsKey(key.key());
+    }
+
+    @Nullable
+    public static <T> T setWorldMeta(@NotNull World world, @NotNull PersistentKey key, @Nullable Object val) {
+        return setMetaMapValue(getWorldPersistentMetaMap(world), key, val);
+    }
+
+    @Nullable
+    public static <T> T removeWorldMeta(@NotNull World world, @NotNull PersistentKey key) {
+        return setWorldMeta(world, key, null);
+    }
+
+    public static int getWorldMeta(@NotNull World world, @NotNull PersistentKey key, int def) {
+        Number val = getWorldMeta(world, key);
+        return val != null ? val.intValue() : def;
+    }
+
+    public static long getWorldMeta(@NotNull World world, @NotNull PersistentKey key, long def) {
+        Number val = getWorldMeta(world, key);
+        return val != null ? val.longValue() : def;
+    }
+
+    public static double getWorldMeta(@NotNull World world, @NotNull PersistentKey key, double def) {
+        Number val = getWorldMeta(world, key);
+        return val != null ? val.doubleValue() : def;
+    }
+
+    public static float getWorldMeta(@NotNull World world, @NotNull PersistentKey key, float def) {
+        Number val = getWorldMeta(world, key);
+        return val != null ? val.floatValue() : def;
+    }
+
+    public static double incrementWorldMeta(@NotNull World world, @NotNull PersistentKey key, double amount) {
+        return incrementWorldMeta(world, key, amount, 0D);
+    }
+
+    public static double incrementWorldMeta(@NotNull World world, @NotNull PersistentKey key, double amount, double start) {
+        double val = getWorldMeta(world, key, start);
+        val += amount;
+        setWorldMeta(world, key, val);
+        return val;
+    }
+
+    public static long incrementWorldMeta(@NotNull World world, @NotNull PersistentKey key, long amount) {
+        return incrementWorldMeta(world, key, amount, 0L);
+    }
+
+    public static long incrementWorldMeta(@NotNull World world, @NotNull PersistentKey key, long amount, long start) {
+        long val = getWorldMeta(world, key, start);
+        val += amount;
+        setWorldMeta(world, key, val);
+        return val;
+    }
+
+    //////////////////////////////////////////////////
+    //// PERSISTENT ENTITY META
+    //////////////////////////////////////////////////
+
+    public static PersistentMetaMap getEntityPersistentMetaMap(@NotNull Entity entity, boolean isWrite) {
+        return API.meta.getEntityMetaMap(entity, isWrite);
+    }
+
+    @Nullable
+    public static <T> T getEntityMeta(@NotNull Entity entity, @NotNull PersistentKey key) {
+        return getEntityMeta(entity, key, null);
+    }
+
+    public static <T> T getEntityMeta(@NotNull Entity entity, @NotNull PersistentKey key, @Nullable T def) {
+        final PersistentMetaMap entityMetaMap = getEntityPersistentMetaMap(entity, false);
+        T ret = entityMetaMap != null && !entityMetaMap.isEmpty() ? (T) entityMetaMap.get(key.key()) : null;
+        return ret != null ? ret : def;
+    }
+
+    public static boolean hasEntityMeta(@NotNull Entity entity, @NotNull PersistentKey key) {
+        final PersistentMetaMap entityMetaMap = getEntityPersistentMetaMap(entity, false);
+        return entityMetaMap != null && !entityMetaMap.isEmpty() && entityMetaMap.containsKey(key.key());
+    }
+
+    @Nullable
+    public static <T> T setEntityMeta(@NotNull Entity entity, @NotNull PersistentKey key, @Nullable Object val) {
+        return setMetaMapValue(getEntityPersistentMetaMap(entity, true), key, val);
+    }
+
+    @Nullable
+    public static <T> T removeEntityMeta(@NotNull Entity entity, @NotNull PersistentKey key) {
+        return setMetaMapValue(getEntityPersistentMetaMap(entity, false), key, null);
+    }
+
+    public static int getEntityMeta(@NotNull Entity entity, @NotNull PersistentKey key, int def) {
+        Number val =  getEntityMeta(entity, key);
+        return val != null ? val.intValue() : def;
+    }
+
+    public static long getEntityMeta(@NotNull Entity entity, @NotNull PersistentKey key, long def) {
+        Number val =  getEntityMeta(entity, key);
+        return val != null ? val.longValue() : def;
+    }
+
+    public static double getEntityMeta(@NotNull Entity entity, @NotNull PersistentKey key, double def) {
+        Number val =  getEntityMeta(entity, key);
+        return val != null ? val.doubleValue() : def;
+    }
+
+    public static float getEntityMeta(@NotNull Entity entity, @NotNull PersistentKey key, float def) {
+        Number val =  getEntityMeta(entity, key);
+        return val != null ? val.floatValue() : def;
+    }
+
+    public static double incrementEntityMeta(@NotNull Entity entity, @NotNull PersistentKey key, double val) {
+        return incrementEntityMeta(entity, key, val, 0D);
+    }
+
+    public static double incrementEntityMeta(@NotNull Entity entity, @NotNull PersistentKey key, double amount, double start) {
+        double val = getEntityMeta(entity, key, start);
+        val += amount;
+        setEntityMeta(entity, key, val);
+        return val;
+    }
+
+    public static long incrementEntityMeta(@NotNull Entity entity, @NotNull PersistentKey key, long val) {
+        return incrementEntityMeta(entity, key, val, 0L);
+    }
+
+    public static long incrementEntityMeta(@NotNull Entity entity, @NotNull PersistentKey key, long amount, long start) {
+        long val = getEntityMeta(entity, key, start);
+        val += amount;
+        setEntityMeta(entity, key, val);
+        return val;
+    }
+
+    //////////////////////////////////////////////////
+    //// PERSISTENT CHUNK META
+    //////////////////////////////////////////////////
+
+    /**
+     * Only provided for low level access as debug command
+     * @param chunk
+     * @return
+     */
+    @Deprecated
+    public static Map<Vector3i, PersistentMetaMap> getChunkMetaData(Chunk chunk) {
+        return API.meta.getChunkMetaData(chunk);
+    }
+
+    public static PersistentMetaMap getChunkPersistentMetaMap(@NotNull Chunk chunk, boolean isWrite) {
+        return API.meta.getChunkMetaMap(chunk, isWrite);
+    }
+
+    public static boolean hasChunkMeta(@NotNull Chunk chunk, @NotNull PersistentKey key) {
+        final PersistentMetaMap chunkMetaMap = getChunkPersistentMetaMap(chunk, false);
+        return chunkMetaMap != null && !chunkMetaMap.isEmpty() && chunkMetaMap.containsKey(key.key());
+    }
+
+    @Nullable
+    public static <T> T getChunkMeta(@NotNull Chunk chunk, @NotNull PersistentKey key) {
+        return getChunkMeta(chunk, key, null);
+    }
+
+    public static <T> T getChunkMeta(@NotNull Chunk chunk, @NotNull PersistentKey key, @Nullable T def) {
+        final PersistentMetaMap chunkMetaMap = getChunkPersistentMetaMap(chunk, false);
+        T ret = chunkMetaMap != null && !chunkMetaMap.isEmpty() ? (T) chunkMetaMap.get(key.key()) : null;
+        return ret != null ? ret : def;
+    }
+
+    @Nullable
+    public static <T> T setChunkMeta(@NotNull Chunk chunk, @NotNull PersistentKey key, @Nullable Object val) {
+        return setMetaMapValue(getChunkPersistentMetaMap(chunk, true), key, val);
+    }
+
+    @Nullable
+    public static <T> T removeChunkMeta(@NotNull Chunk chunk, @NotNull PersistentKey key) {
+        return setMetaMapValue(getChunkPersistentMetaMap(chunk, false), key, null);
+    }
+
+    public static int getChunkMeta(@NotNull Chunk chunk, @NotNull PersistentKey key, int def) {
+        Number val =  getChunkMeta(chunk, key);
+        return val != null ? val.intValue() : def;
+    }
+
+    public static long getChunkMeta(@NotNull Chunk chunk, @NotNull PersistentKey key, long def) {
+        Number val =  getChunkMeta(chunk, key);
+        return val != null ? val.longValue() : def;
+    }
+
+    public static double getChunkMeta(@NotNull Chunk chunk, @NotNull PersistentKey key, double def) {
+        Number val =  getChunkMeta(chunk, key);
+        return val != null ? val.doubleValue() : def;
+    }
+
+    public static float getChunkMeta(@NotNull Chunk chunk, @NotNull PersistentKey key, float def) {
+        Number val =  getChunkMeta(chunk, key);
+        return val != null ? val.floatValue() : def;
+    }
+
+    public static long incrementChunkMeta(@NotNull Chunk chunk, @NotNull PersistentKey key, long amount) {
+        return incrementChunkMeta(chunk, key, amount, 0L);
+    }
+    public static long incrementChunkMeta(@NotNull Chunk chunk, @NotNull PersistentKey key, long amount, long start) {
+        long val = getChunkMeta(chunk, key, start);
+        val += amount;
+        setChunkMeta(chunk, key, val);
+        return val;
+    }
+
+    public static double incrementChunkMeta(@NotNull Chunk chunk, @NotNull PersistentKey key, double amount) {
+        return incrementChunkMeta(chunk, key, amount, 0D);
+    }
+    public static double incrementChunkMeta(@NotNull Chunk chunk, @NotNull PersistentKey key, double amount, double start) {
+        double val = getChunkMeta(chunk, key, start);
+        val += amount;
+        setChunkMeta(chunk, key, val);
+        return val;
+    }
+
+    //////////////////////////////////////////////////
+    //// PERSISTENT BLOCK META
+    //////////////////////////////////////////////////
+
+    public static PersistentMetaMap getBlockPersistentMetaMap(@NotNull Location loc, boolean isWrite) {
+        return API.meta.getBlockMetaMap(loc, isWrite);
+    }
+
+    public static boolean hasBlockMeta(@NotNull Location loc, @NotNull PersistentKey key) {
+        final PersistentMetaMap blockMetaMap = getBlockPersistentMetaMap(loc, false);
+        return blockMetaMap != null && !blockMetaMap.isEmpty() && blockMetaMap.containsKey(key.key());
+    }
+
+    @Nullable
+    public static <T> T getBlockMeta(@NotNull Location loc, @NotNull PersistentKey key) {
+        return getBlockMeta(loc, key, null);
+    }
+
+    public static <T> T getBlockMeta(@NotNull Location loc, @NotNull PersistentKey key, @Nullable T def) {
+        final PersistentMetaMap blockMetaMap = getBlockPersistentMetaMap(loc, false);
+        T ret = blockMetaMap != null && !blockMetaMap.isEmpty() ? (T) blockMetaMap.get(key.key()) : null;
+        return ret != null ? ret : def;
+    }
+
+    @Nullable
+    public static <T> T setBlockMeta(@NotNull Location loc, @NotNull PersistentKey key, @Nullable Object val) {
+        return setMetaMapValue(getBlockPersistentMetaMap(loc, true), key, val);
+    }
+
+    @Nullable
+    public static <T> T removeBlockMeta(@NotNull Location loc, @NotNull PersistentKey key) {
+        return setMetaMapValue(getBlockPersistentMetaMap(loc, false), key, null);
+    }
+
+    public static int getBlockMeta(@NotNull Location loc, @NotNull PersistentKey key, int def) {
+        Number val =  getBlockMeta(loc, key);
+        return val != null ? val.intValue() : def;
+    }
+
+    public static long getBlockMeta(@NotNull Location loc, @NotNull PersistentKey key, long def) {
+        Number val =  getBlockMeta(loc, key);
+        return val != null ? val.longValue() : def;
+    }
+
+    public static double getBlockMeta(@NotNull Location loc, @NotNull PersistentKey key, double def) {
+        Number val =  getBlockMeta(loc, key);
+        return val != null ? val.doubleValue() : def;
+    }
+
+    public static float getBlockMeta(@NotNull Location loc, @NotNull PersistentKey key, float def) {
+        Number val =  getBlockMeta(loc, key);
+        return val != null ? val.floatValue() : def;
+    }
+
+    public static long incrementBlockMeta(@NotNull Location loc, @NotNull PersistentKey key, long amount) {
+        return incrementBlockMeta(loc, key, amount, 0L);
+    }
+    public static long incrementBlockMeta(@NotNull Location loc, @NotNull PersistentKey key, long amount, long start) {
+        long val = getBlockMeta(loc, key, start);
+        val += amount;
+        setBlockMeta(loc, key, val);
+        return val;
+    }
+
+    public static double incrementBlockMeta(@NotNull Location loc, @NotNull PersistentKey key, double amount) {
+        return incrementBlockMeta(loc, key, amount, 0D);
+    }
+    public static double incrementBlockMeta(@NotNull Location loc, @NotNull PersistentKey key, double amount, double start) {
+        double val = getBlockMeta(loc, key, start);
+        val += amount;
+        setBlockMeta(loc, key, val);
+        return val;
+    }
+
+    //////////////////////////////////////////////////
+    //// PERSISTENT TILE ENTITY META
+    //////////////////////////////////////////////////
+
+    public static PersistentMetaMap getTileEntityPersistentMetaMap(@NotNull Location tileEntity, boolean isWrite) {
+        return API.meta.getTileEntityMetaMap(tileEntity.getBlock().getState(), isWrite);
+    }
+
+    public static PersistentMetaMap getTileEntityPersistentMetaMap(@NotNull BlockState tileEntity, boolean isWrite) {
+        return API.meta.getTileEntityMetaMap(tileEntity, isWrite);
+    }
+
+    public static boolean hasTileEntityMeta(@NotNull Location tileEntity, @NotNull PersistentKey key) {
+        return hasTileEntityMeta(tileEntity.getBlock().getState(), key);
+    }
+
+    public static boolean hasTileEntityMeta(@NotNull BlockState tileEntity, @NotNull PersistentKey key) {
+        final PersistentMetaMap tileEntityMetaMap = getTileEntityPersistentMetaMap(tileEntity, false);
+        return tileEntityMetaMap != null && !tileEntityMetaMap.isEmpty() && tileEntityMetaMap.containsKey(key.key());
+    }
+
+    @Nullable
+    public static <T> T getTileEntityMeta(@NotNull Location tileEntity, @NotNull PersistentKey key) {
+        return getTileEntityMeta(tileEntity.getBlock().getState(), key, null);
+    }
+
+    @Nullable
+    public static <T> T getTileEntityMeta(@NotNull BlockState tileEntity, @NotNull PersistentKey key) {
+        return getTileEntityMeta(tileEntity, key, null);
+    }
+
+    public static <T> T getTileEntityMeta(@NotNull Location tileEntity, @NotNull PersistentKey key, @Nullable T def) {
+        return getTileEntityMeta(tileEntity.getBlock().getState(), key, def);
+    }
+
+    public static <T> T getTileEntityMeta(@NotNull BlockState tileEntity, @NotNull PersistentKey key, @Nullable T def) {
+        final PersistentMetaMap tileEntityMetaMap = getTileEntityPersistentMetaMap(tileEntity, false);
+        T ret = tileEntityMetaMap != null && !tileEntityMetaMap.isEmpty() ? (T) tileEntityMetaMap.get(key.key()) : null;
+        return ret != null ? ret : def;
+    }
+
+    @Nullable
+    public static <T> T setTileEntityMeta(@NotNull Location tileEntity, @NotNull PersistentKey key, @Nullable Object val) {
+        return setTileEntityMeta(tileEntity.getBlock().getState(), key, val);
+    }
+
+    @Nullable
+    public static <T> T setTileEntityMeta(@NotNull BlockState tileEntity, @NotNull PersistentKey key, @Nullable Object val) {
+        return setMetaMapValue(getTileEntityPersistentMetaMap(tileEntity, true), key, val);
+    }
+
+    @Nullable
+    public static <T> T removeTileEntityMeta(@NotNull Location tileEntity, @NotNull PersistentKey key) {
+        return removeTileEntityMeta(tileEntity.getBlock().getState(), key);
+    }
+
+    @Nullable
+    public static <T> T removeTileEntityMeta(@NotNull BlockState tileEntity, @NotNull PersistentKey key) {
+        return setMetaMapValue(getTileEntityPersistentMetaMap(tileEntity, false), key, null);
+    }
+
+    //////////////////////////////////////////////////
+    //// TEMP ENTITY META
+    //////////////////////////////////////////////////
+
+    @NotNull
+    public static TempMetaMap getEntityTempMetaMap(@NotNull Entity entity) {
+        return entity.getTempMeta();
+    }
+
+    public static boolean hasEntityMeta(@NotNull Entity entity, @NotNull TempKey key) {
+        TempMetaMap metaMap = getEntityTempMetaMap(entity);
+        return metaMap.containsKey(key.key());
+    }
+
+    @Nullable
+    public static <T> T setEntityMeta(@NotNull Entity entity, @NotNull TempKey key, @Nullable Object val) {
+        TempMetaMap metaMap = getEntityTempMetaMap(entity);
+        return (T) metaMap.put(key.key(), val);
+    }
+
+    @Nullable
+    public static <T> T removeEntityMeta(@NotNull Entity entity, @NotNull TempKey key) {
+        TempMetaMap metaMap = getEntityTempMetaMap(entity);
+        return (T) metaMap.remove(key.key());
+    }
+
+    @Nullable
+    public static <T> T getEntityMeta(@NotNull Entity entity, @NotNull TempKey key) {
+        return getEntityMeta(entity, key, null);
+    }
+
+    public static <T> T getEntityMeta(@NotNull Entity entity, @NotNull TempKey key, @Nullable T def) {
+        TempMetaMap metaMap = getEntityTempMetaMap(entity);
+        T val = (T) metaMap.get(key.key());
+        return val != null ? val : def;
+    }
+
+    public static int getEntityMeta(@NotNull Entity entity, @NotNull TempKey key, int def) {
+        Number val = getEntityMeta(entity, key);
+        return val != null ? val.intValue() : def;
+    }
+
+    public static long getEntityMeta(@NotNull Entity entity, @NotNull TempKey key, long def) {
+        Number val = getEntityMeta(entity, key);
+        return val != null ? val.longValue() : def;
+    }
+
+    public static double getEntityMeta(@NotNull Entity entity, @NotNull TempKey key, double def) {
+        Number val = getEntityMeta(entity, key);
+        return val != null ? val.doubleValue() : def;
+    }
+
+    public static float getEntityMeta(@NotNull Entity entity, @NotNull TempKey key, float def) {
+        Number val =  getEntityMeta(entity, key);
+        return val != null ? val.floatValue() : def;
+    }
+
+    public static long incrementEntityMeta(@NotNull Entity entity, @NotNull TempKey key, long amount) {
+        return incrementEntityMeta(entity, key, amount, 0L);
+    }
+    public static long incrementEntityMeta(@NotNull Entity entity, @NotNull TempKey key, long amount, long start) {
+        long val = getEntityMeta(entity, key, start);
+        val += amount;
+        setEntityMeta(entity, key, val);
+        return val;
+    }
+
+    public static double incrementEntityMeta(@NotNull Entity entity, @NotNull TempKey key, double amount) {
+        return incrementEntityMeta(entity, key, amount, 0D);
+    }
+    public static double incrementEntityMeta(@NotNull Entity entity, @NotNull TempKey key, double amount, double start) {
+        double val = getEntityMeta(entity, key, start);
+        val += amount;
+        setEntityMeta(entity, key, val);
+        return val;
+    }
+
+    //////////////////////////////////////////////////
+    //// TEMP BLOCK META
+    //////////////////////////////////////////////////
+
+    public static boolean hasBlockMeta(@NotNull Block block, @NotNull TempKey key) {
+        Map<String, Object> blockMeta = API.meta.getBlockTempMeta(block, false);
+        return blockMeta != null && blockMeta.containsKey(key.key());
+    }
+
+    @Nullable
+    public static <T> T setBlockMeta(@NotNull Block block, @NotNull TempKey key, @Nullable Object val) {
+        Map<String, Object> blockMeta = API.meta.getBlockTempMeta(block, true);
+        return (T) blockMeta.put(key.key(), val);
+    }
+
+    @Nullable
+    public static <T> T removeBlockMeta(@NotNull Block block, @NotNull TempKey key) {
+        Map<String, Object> blockMeta = API.meta.getBlockTempMeta(block, true);
+        return (T) blockMeta.remove(key.key());
+    }
+
+    @Nullable
+    public static <T> T getBlockMeta(@NotNull Block block, @NotNull TempKey key) {
+        return getBlockMeta(block, key, null);
+    }
+
+    public static <T> T getBlockMeta(@NotNull Block block, @NotNull TempKey key, @Nullable T def) {
+        Map<String, Object> blockMeta = API.meta.getBlockTempMeta(block, false);
+        T val = blockMeta != null ? (T) blockMeta.get(key.key()) : null;
+        return val != null ? val : def;
+    }
+
+    public static int getBlockMeta(@NotNull Block block, @NotNull TempKey key, int def) {
+        Number val = getBlockMeta(block, key);
+        return val != null ? val.intValue() : def;
+    }
+
+    public static long getBlockMeta(@NotNull Block block, @NotNull TempKey key, long def) {
+        Number val = getBlockMeta(block, key);
+        return val != null ? val.longValue() : def;
+    }
+
+    public static double getBlockMeta(@NotNull Block block, @NotNull TempKey key, double def) {
+        Number val = getBlockMeta(block, key);
+        return val != null ? val.doubleValue() : def;
+    }
+
+    public static float getBlockMeta(@NotNull Block block, @NotNull TempKey key, float def) {
+        Number val = getBlockMeta(block, key);
+        return val != null ? val.floatValue() : def;
+    }
+
+    public static long incrementBlockMeta(@NotNull Block block, @NotNull TempKey key, long amount) {
+        return incrementBlockMeta(block, key, amount, 0L);
+    }
+    public static long incrementBlockMeta(@NotNull Block block, @NotNull TempKey key, long amount, long start) {
+        long val = getBlockMeta(block, key, start);
+        val += amount;
+        setBlockMeta(block, key, val);
+        return val;
+    }
+
+    public static double incrementBlockMeta(@NotNull Block block, @NotNull TempKey key, double amount) {
+        return incrementBlockMeta(block, key, amount, 0D);
+    }
+    public static double incrementBlockMeta(@NotNull Block block, @NotNull TempKey key, double amount, double start) {
+        double val = getBlockMeta(block, key, start);
+        val += amount;
+        setBlockMeta(block, key, val);
+        return val;
+    }
+
+    //////////////////////////////////////////////////
+    //// TEMP CHUNK META
+    //////////////////////////////////////////////////
+
+    public static TempMetaMap getChunkTempMetaMap(@NotNull Chunk chunk, boolean isWrite) {
+        return API.meta.getChunkTempMetaMap(chunk, isWrite);
+    }
+
+    public static boolean hasChunkMeta(@NotNull Chunk chunk, @NotNull TempKey key) {
+        final TempMetaMap chunkMetaMap = getChunkTempMetaMap(chunk, false);
+        return chunkMetaMap != null && !chunkMetaMap.isEmpty() && chunkMetaMap.containsKey(key);
+    }
+
+    @Nullable
+    public static <T> T getChunkMeta(@NotNull Chunk chunk, @NotNull TempKey key) {
+        return getChunkMeta(chunk, key, null);
+    }
+
+    public static <T> T getChunkMeta(@NotNull Chunk chunk, @NotNull TempKey key, @Nullable T def) {
+        final TempMetaMap chunkMetaMap = getChunkTempMetaMap(chunk, false);
+        T ret = chunkMetaMap != null && !chunkMetaMap.isEmpty() ? (T) chunkMetaMap.get(key) : null;
+        return ret != null ? ret : def;
+    }
+
+    @Nullable
+    public static <T> T setChunkMeta(@NotNull Chunk chunk, @NotNull TempKey key, @Nullable Object val) {
+        TempMetaMap chunkMap = getChunkTempMetaMap(chunk, true);
+        return setMetaMapValue(chunkMap, key, val);
+    }
+
+    @Nullable
+    public static <T> T removeChunkMeta(@NotNull Chunk chunk, @NotNull TempKey key) {
+        TempMetaMap chunkMap = getChunkTempMetaMap(chunk, false);
+        return setMetaMapValue(chunkMap, key, null);
+    }
+
+    public static int getChunkMeta(@NotNull Chunk chunk, @NotNull TempKey key, int def) {
+        Number val = getChunkMeta(chunk, key);
+        return val != null ? val.intValue() : def;
+    }
+
+    public static long getChunkMeta(@NotNull Chunk chunk, @NotNull TempKey key, long def) {
+        Number val = getChunkMeta(chunk, key);
+        return val != null ? val.longValue() : def;
+    }
+
+    public static double getChunkMeta(@NotNull Chunk chunk, @NotNull TempKey key, double def) {
+        Number val = getChunkMeta(chunk, key);
+        return val != null ? val.doubleValue() : def;
+    }
+
+    public static float getChunkMeta(@NotNull Chunk chunk, @NotNull TempKey key, float def) {
+        Number val = getChunkMeta(chunk, key);
+        return val != null ? val.floatValue() : def;
+    }
+
+    public static long incrementChunkMeta(@NotNull Chunk chunk, @NotNull TempKey key, long amount) {
+        return incrementChunkMeta(chunk, key, amount, 0L);
+    }
+    public static long incrementChunkMeta(@NotNull Chunk chunk, @NotNull TempKey key, long amount, long start) {
+        long val = getChunkMeta(chunk, key, start);
+        val += amount;
+        setChunkMeta(chunk, key, val);
+        return val;
+    }
+
+    public static double incrementChunkMeta(@NotNull Chunk chunk, @NotNull TempKey key, double amount) {
+        return incrementChunkMeta(chunk, key, amount, 0D);
+    }
+    public static double incrementChunkMeta(@NotNull Chunk chunk, @NotNull TempKey key, double amount, double start) {
+        double val = getChunkMeta(chunk, key, start);
+        val += amount;
+        setChunkMeta(chunk, key, val);
+        return val;
+    }
+
+    //////////////////////////////////////////////////
+    //// TEMP INVENTORY META
+    //////////////////////////////////////////////////
+
+    public static boolean hasInventoryMeta(@NotNull Inventory inv, @NotNull TempKey key) {
+        return inv.getMeta().containsKey(key.key());
+    }
+
+    @Nullable
+    public static <T> T setInventoryMeta(@NotNull Inventory inv, @NotNull TempKey key, @Nullable Object val) {
+        return (T) inv.getMeta().put(key.key(), val);
+    }
+
+    @Nullable
+    public static <T> T removeInventoryMeta(@NotNull Inventory inv, @NotNull TempKey key) {
+        return (T) inv.getMeta().remove(key.key());
+    }
+
+    @Nullable
+    public static <T> T getInventoryMeta(@NotNull Inventory inv, @NotNull TempKey key) {
+        return getInventoryMeta(inv, key, null);
+    }
+
+    public static <T> T getInventoryMeta(@NotNull Inventory inv, @NotNull TempKey key, @Nullable T def) {
+        Object val = inv.getMeta().get(key.key());
+        if (val != null) {
+            return (T) val;
+        }
+        return def;
+    }
+
+    public static int getInventoryMeta(@NotNull Inventory inv, @NotNull TempKey key, int def) {
+        Number val = getInventoryMeta(inv, key);
+        return val != null ? val.intValue() : def;
+    }
+
+    public static long getInventoryMeta(@NotNull Inventory inv, @NotNull TempKey key, long def) {
+        Number val = getInventoryMeta(inv, key);
+        return val != null ? val.longValue() : def;
+    }
+
+    public static double getInventoryMeta(@NotNull Inventory inv, @NotNull TempKey key, double def) {
+        Number val = getInventoryMeta(inv, key);
+        return val != null ? val.doubleValue() : def;
+    }
+
+    public static float getInventoryMeta(@NotNull Inventory inv, @NotNull TempKey key, float def) {
+        Number val = getInventoryMeta(inv, key);
+        return val != null ? val.floatValue() : def;
+    }
+
+    public static long incrementInventoryMeta(@NotNull Inventory inv, @NotNull TempKey key, long amount) {
+        return incrementInventoryMeta(inv, key, amount, 0L);
+    }
+    public static long incrementInventoryMeta(@NotNull Inventory inv, @NotNull TempKey key, long amount, long start) {
+        long val = getInventoryMeta(inv, key, start);
+        val += amount;
+        setInventoryMeta(inv, key, val);
+        return val;
+    }
+
+    public static double incrementInventoryMeta(@NotNull Inventory inv, @NotNull TempKey key, double amount) {
+        return incrementInventoryMeta(inv, key, amount, 0D);
+    }
+    public static double incrementInventoryMeta(@NotNull Inventory inv, @NotNull TempKey key, double amount, double start) {
+        double val = getInventoryMeta(inv, key, start);
+        val += amount;
+        setInventoryMeta(inv, key, val);
+        return val;
+    }
+
+}
diff --git a/src/main/java/com/empireminecraft/api/meta/MetaKey.java b/src/main/java/com/empireminecraft/api/meta/MetaKey.java
new file mode 100644
index 0000000000000000000000000000000000000000..f0b62b481de8ffbeb0cba37295de9cf1b547457d
--- /dev/null
+++ b/src/main/java/com/empireminecraft/api/meta/MetaKey.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (c) 2016 Starlis LLC / Daniel Ennis (Aikar) - MIT License
+ *
+ *  Permission is hereby granted, free of charge, to any person obtaining
+ *  a copy of this software and associated documentation files (the
+ *  "Software"), to deal in the Software without restriction, including
+ *  without limitation the rights to use, copy, modify, merge, publish,
+ *  distribute, sublicense, and/or sell copies of the Software, and to
+ *  permit persons to whom the Software is furnished to do so, subject to
+ *  the following conditions:
+ *
+ *  The above copyright notice and this permission notice shall be
+ *  included in all copies or substantial portions of the Software.
+ *
+ *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ *  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ *  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ *  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ *  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ *  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ *  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.empireminecraft.api.meta;
+
+public interface MetaKey {
+
+    /**
+     * Key name
+     * @return The key
+     */
+    String key();
+
+    /**
+     * Represents a key used for persistent metadata
+     */
+    interface PersistentKey extends MetaKey {
+        default PersistentKey append(String key) {
+            return Meta.createPersistentKey(key() + key);
+        }
+    }
+
+    /**
+     * Represents a key used for temporary metadata
+     */
+    interface TempKey extends MetaKey {
+        default TempKey append(String key) {
+            return Meta.createTempKey(key() + key);
+        }
+    }
+}
diff --git a/src/main/java/com/empireminecraft/api/meta/MetaMap.java b/src/main/java/com/empireminecraft/api/meta/MetaMap.java
new file mode 100644
index 0000000000000000000000000000000000000000..a47f01307c86999081976ae13355be4ea7bef44e
--- /dev/null
+++ b/src/main/java/com/empireminecraft/api/meta/MetaMap.java
@@ -0,0 +1,96 @@
+/*
+ * Copyright (c) 2018 Daniel Ennis (Aikar) MIT License
+ *
+ *  Permission is hereby granted, free of charge, to any person obtaining
+ *  a copy of this software and associated documentation files (the
+ *  "Software"), to deal in the Software without restriction, including
+ *  without limitation the rights to use, copy, modify, merge, publish,
+ *  distribute, sublicense, and/or sell copies of the Software, and to
+ *  permit persons to whom the Software is furnished to do so, subject to
+ *  the following conditions:
+ *
+ *  The above copyright notice and this permission notice shall be
+ *  included in all copies or substantial portions of the Software.
+ *
+ *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ *  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ *  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ *  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ *  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ *  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ *  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.empireminecraft.api.meta;
+
+import javax.annotation.Nonnull;
+import java.util.HashMap;
+
+public class MetaMap <K extends MetaKey> extends HashMap<String, Object> {
+
+    public MetaMap() {
+        super(0);
+    }
+
+    public Integer getInteger(@Nonnull K key) {
+        return getInteger(key, null);
+    }
+    public Integer getInteger(@Nonnull K key, Integer def) {
+        Number number = (Number) get(key);
+        return number != null ? number.intValue() : def;
+    }
+    public Long getLong(@Nonnull K key) {
+        return getLong(key, null);
+    }
+    public Long getLong(@Nonnull K key, Long def) {
+        Number number = (Number) get(key);
+        return number != null ? number.longValue() : def;
+    }
+    public Double getDouble(@Nonnull K key) {
+        return getDouble(key, null);
+    }
+    public Double getDouble(@Nonnull K key, Double def) {
+        Number number = (Number) get(key);
+        return number != null ? number.doubleValue() : def;
+    }
+    public Float getFloat(@Nonnull K key) {
+        return getFloat(key, null);
+    }
+    public Float getFloat(@Nonnull K key, Float def) {
+        Number number = (Number) get(key);
+        return number != null ? number.floatValue() : def;
+    }
+    public Short getShort(@Nonnull K key) {
+        return getShort(key, null);
+    }
+    public Short getShort(@Nonnull K key, Short def) {
+        Number number = (Number) get(key);
+        return number != null ? number.shortValue() : def;
+    }
+    public Boolean getBoolean(@Nonnull K key) {
+        return getBoolean(key, null);
+    }
+    public Boolean getBoolean(@Nonnull K key, Boolean def) {
+        Number number = (Number) get(key);
+        return number != null ? number.intValue() != 0 : def;
+    }
+    public <T> T getValue(@Nonnull K key) {
+        return (T) get(key);
+    }
+    public <T> T getValue(@Nonnull K key, T def) {
+        Object value = get(key);
+        return value != null ? (T) value : def;
+    }
+
+    public Object get(K key) {
+        return get(key.key());
+    }
+
+    public Object put(MetaKey key, Object value) {
+        return put(key.key(), value);
+    }
+
+    public boolean containsKey(K key) {
+        return containsKey(key.key());
+    }
+}
diff --git a/src/main/java/com/empireminecraft/api/meta/PersistentKeyImpl.java b/src/main/java/com/empireminecraft/api/meta/PersistentKeyImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..0d62fbf070842fda709163a93c6e3aee9923bc0e
--- /dev/null
+++ b/src/main/java/com/empireminecraft/api/meta/PersistentKeyImpl.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright (c) 2016 Starlis LLC / Daniel Ennis (Aikar) - MIT License
+ *
+ *  Permission is hereby granted, free of charge, to any person obtaining
+ *  a copy of this software and associated documentation files (the
+ *  "Software"), to deal in the Software without restriction, including
+ *  without limitation the rights to use, copy, modify, merge, publish,
+ *  distribute, sublicense, and/or sell copies of the Software, and to
+ *  permit persons to whom the Software is furnished to do so, subject to
+ *  the following conditions:
+ *
+ *  The above copyright notice and this permission notice shall be
+ *  included in all copies or substantial portions of the Software.
+ *
+ *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ *  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ *  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ *  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ *  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ *  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ *  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.empireminecraft.api.meta;
+
+import com.empireminecraft.api.meta.MetaKey.PersistentKey;
+
+class PersistentKeyImpl implements PersistentKey {
+    private final String key;
+
+    PersistentKeyImpl(String key) {
+        this.key = key;
+    }
+
+    @Override
+    public final String key() {
+        return key;
+    }
+
+    @Override
+    public String toString() {
+        return key;
+    }
+}
diff --git a/src/main/java/com/empireminecraft/api/meta/PersistentMetaList.java b/src/main/java/com/empireminecraft/api/meta/PersistentMetaList.java
new file mode 100644
index 0000000000000000000000000000000000000000..e40602522bc2c5537c79692d1fd490ca9cbbaddc
--- /dev/null
+++ b/src/main/java/com/empireminecraft/api/meta/PersistentMetaList.java
@@ -0,0 +1,73 @@
+/*
+ * Copyright (c) 2016 Starlis LLC / Daniel Ennis (Aikar) - MIT License
+ *
+ *  Permission is hereby granted, free of charge, to any person obtaining
+ *  a copy of this software and associated documentation files (the
+ *  "Software"), to deal in the Software without restriction, including
+ *  without limitation the rights to use, copy, modify, merge, publish,
+ *  distribute, sublicense, and/or sell copies of the Software, and to
+ *  permit persons to whom the Software is furnished to do so, subject to
+ *  the following conditions:
+ *
+ *  The above copyright notice and this permission notice shall be
+ *  included in all copies or substantial portions of the Software.
+ *
+ *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ *  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ *  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ *  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ *  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ *  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ *  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.empireminecraft.api.meta;
+
+import java.security.InvalidParameterException;
+import java.util.ArrayList;
+import java.util.Collection;
+
+/**
+ * A type protected array for storing meta values
+ */
+@SuppressWarnings("PublicInnerClass")
+public class PersistentMetaList<T> extends ArrayList<T> {
+    public PersistentMetaList(int initialCapacity) {
+        super(initialCapacity);
+    }
+
+    public PersistentMetaList() {
+    }
+
+    public PersistentMetaList(Collection<? extends T> c) {
+        super(c);
+    }
+
+    @Override
+    public boolean add(T o) {
+        if (!Meta.isValidPersistentMeta(o)) {
+            throw new InvalidParameterException();
+        }
+        return super.add(o);
+    }
+
+    @Override
+    public T set(int index, T element) {
+        if (!Meta.isValidPersistentMeta(element)) {
+            throw new InvalidParameterException();
+        }
+        return super.set(index, element);
+    }
+
+    @Override
+    public void add(int index, T element) {
+        if (!Meta.isValidPersistentMeta(element)) {
+            throw new InvalidParameterException();
+        }
+        super.add(index, element);
+    }
+
+    public PersistentMetaList<T> clone()  {
+        return new PersistentMetaList<>(this);
+    }
+}
diff --git a/src/main/java/com/empireminecraft/api/meta/PersistentMetaMap.java b/src/main/java/com/empireminecraft/api/meta/PersistentMetaMap.java
new file mode 100644
index 0000000000000000000000000000000000000000..f45c34cca233218e96612dd69c2f4b267803cb19
--- /dev/null
+++ b/src/main/java/com/empireminecraft/api/meta/PersistentMetaMap.java
@@ -0,0 +1,93 @@
+/*
+ * Copyright (c) 2016 Starlis LLC / Daniel Ennis (Aikar) - MIT License
+ *
+ *  Permission is hereby granted, free of charge, to any person obtaining
+ *  a copy of this software and associated documentation files (the
+ *  "Software"), to deal in the Software without restriction, including
+ *  without limitation the rights to use, copy, modify, merge, publish,
+ *  distribute, sublicense, and/or sell copies of the Software, and to
+ *  permit persons to whom the Software is furnished to do so, subject to
+ *  the following conditions:
+ *
+ *  The above copyright notice and this permission notice shall be
+ *  included in all copies or substantial portions of the Software.
+ *
+ *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ *  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ *  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ *  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ *  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ *  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ *  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.empireminecraft.api.meta;
+
+import com.empireminecraft.api.meta.MetaKey.PersistentKey;
+import org.bukkit.inventory.ItemStack;
+
+import javax.annotation.Nonnull;
+import java.security.InvalidParameterException;
+import java.util.Map;
+
+/**
+ * A type protected hashmap for storing meta values
+ */
+@SuppressWarnings("PublicInnerClass")
+public class PersistentMetaMap extends MetaMap<PersistentKey> {
+
+
+    public <T extends PersistentMetaMap> T put(PersistentKey key, PersistentMetaMap value) {
+        if (!Meta.isValidPersistentMeta(value)) {
+            throw new InvalidParameterException();
+        }
+        return (T) super.put(key, value);
+    }
+    public <Z, T extends PersistentMetaList<Z>> T put(PersistentKey key, PersistentMetaList<Z> value) {
+        if (!Meta.isValidPersistentMeta(value)) {
+            throw new InvalidParameterException();
+        }
+        return (T) super.put(key, value);
+    }
+    public <T extends ItemStack> T put(PersistentKey key, ItemStack value) {
+        return (T) super.put(key, value);
+    }
+    public <T extends Number> T put(PersistentKey key, Number value) {
+        return (T) super.put(key, value);
+    }
+    public <T extends String> T put(PersistentKey key, String value) {
+        return (T) super.put(key, value);
+    }
+    public <T extends String> T put(PersistentKey key, boolean value) {
+        return (T) super.put(key, value ? 1 : 0);
+    }
+
+    public Object put(@Nonnull PersistentKey key, Object value) {
+        return put(key.key(), value);
+    }
+
+    @Override
+    public void putAll(Map<? extends String, ?> map) {
+        for (Object value : map.values()) {
+            if (!Meta.isValidPersistentMeta(value)) {
+                throw new InvalidParameterException();
+            }
+        }
+
+        super.putAll(map);
+    }
+
+    @Override
+    public Object put(String key, Object value) {
+        if (!Meta.isValidPersistentMeta(value)) {
+            throw new InvalidParameterException();
+        }
+        return super.put(key, value);
+    }
+
+    public PersistentMetaMap clone() {
+        PersistentMetaMap map = new PersistentMetaMap();
+        map.putAll(this);
+        return map;
+    }
+}
diff --git a/src/main/java/com/empireminecraft/api/meta/TempKeyImpl.java b/src/main/java/com/empireminecraft/api/meta/TempKeyImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..d3de8624a03b9c6b4d2561bec136df38c8aaf6f5
--- /dev/null
+++ b/src/main/java/com/empireminecraft/api/meta/TempKeyImpl.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright (c) 2016 Starlis LLC / Daniel Ennis (Aikar) - MIT License
+ *
+ *  Permission is hereby granted, free of charge, to any person obtaining
+ *  a copy of this software and associated documentation files (the
+ *  "Software"), to deal in the Software without restriction, including
+ *  without limitation the rights to use, copy, modify, merge, publish,
+ *  distribute, sublicense, and/or sell copies of the Software, and to
+ *  permit persons to whom the Software is furnished to do so, subject to
+ *  the following conditions:
+ *
+ *  The above copyright notice and this permission notice shall be
+ *  included in all copies or substantial portions of the Software.
+ *
+ *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ *  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ *  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ *  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ *  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ *  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ *  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.empireminecraft.api.meta;
+
+import com.empireminecraft.api.meta.MetaKey.TempKey;
+
+class TempKeyImpl implements TempKey {
+    private final String key;
+
+    TempKeyImpl(String key) {
+        this.key = key;
+    }
+
+    @Override
+    public final String key() {
+        return key;
+    }
+
+    @Override
+    public String toString() {
+        return key;
+    }
+}
diff --git a/src/main/java/com/empireminecraft/api/meta/TempMetaMap.java b/src/main/java/com/empireminecraft/api/meta/TempMetaMap.java
new file mode 100644
index 0000000000000000000000000000000000000000..8177936f3539e9542880cb4925b578aeaae103a3
--- /dev/null
+++ b/src/main/java/com/empireminecraft/api/meta/TempMetaMap.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright (c) 2018 Daniel Ennis (Aikar) MIT License
+ *
+ *  Permission is hereby granted, free of charge, to any person obtaining
+ *  a copy of this software and associated documentation files (the
+ *  "Software"), to deal in the Software without restriction, including
+ *  without limitation the rights to use, copy, modify, merge, publish,
+ *  distribute, sublicense, and/or sell copies of the Software, and to
+ *  permit persons to whom the Software is furnished to do so, subject to
+ *  the following conditions:
+ *
+ *  The above copyright notice and this permission notice shall be
+ *  included in all copies or substantial portions of the Software.
+ *
+ *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ *  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ *  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ *  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ *  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ *  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ *  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.empireminecraft.api.meta;
+
+import com.empireminecraft.api.meta.MetaKey.TempKey;
+
+public class TempMetaMap extends MetaMap<TempKey> {
+}
diff --git a/src/main/java/com/empireminecraft/customevents/BlockWithPersistentMetaClearedEvent.java b/src/main/java/com/empireminecraft/customevents/BlockWithPersistentMetaClearedEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..4963d24f2261b4d327e74f0cede1025c66503a27
--- /dev/null
+++ b/src/main/java/com/empireminecraft/customevents/BlockWithPersistentMetaClearedEvent.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (c) 2016 Starlis LLC / Daniel Ennis (Aikar) - MIT License
+ *
+ *  Permission is hereby granted, free of charge, to any person obtaining
+ *  a copy of this software and associated documentation files (the
+ *  "Software"), to deal in the Software without restriction, including
+ *  without limitation the rights to use, copy, modify, merge, publish,
+ *  distribute, sublicense, and/or sell copies of the Software, and to
+ *  permit persons to whom the Software is furnished to do so, subject to
+ *  the following conditions:
+ *
+ *  The above copyright notice and this permission notice shall be
+ *  included in all copies or substantial portions of the Software.
+ *
+ *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ *  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ *  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ *  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ *  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ *  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ *  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.empireminecraft.customevents;
+
+import org.bukkit.block.Block;
+import org.bukkit.event.Event;
+import org.bukkit.event.HandlerList;
+
+public class BlockWithPersistentMetaClearedEvent extends Event {
+    private final Block block;
+    public BlockWithPersistentMetaClearedEvent(Block block) {
+        this.block = block;
+    }
+
+    public Block getBlock() {
+        return block;
+    }
+
+    private static final HandlerList handlers = new HandlerList();
+
+    public HandlerList getHandlers() {
+        return handlers;
+    }
+
+    public static HandlerList getHandlerList() {
+        return handlers;
+    }
+}
diff --git a/src/main/java/org/bukkit/Chunk.java b/src/main/java/org/bukkit/Chunk.java
index 11b691cf59b4a72493c91055fd8c46d7681b4527..bd7f8616421df978a9defdac1922c67a1368164b 100644
--- a/src/main/java/org/bukkit/Chunk.java
+++ b/src/main/java/org/bukkit/Chunk.java
@@ -123,6 +123,8 @@ public interface Chunk {
     BlockState[] getTileEntities(boolean useSnapshot);
     // Paper end
 
+    com.empireminecraft.api.meta.TempMetaMap getTempMeta(); // EMC
+
     /**
      * Checks if the chunk is loaded.
      *
diff --git a/src/main/java/org/bukkit/block/BlockState.java b/src/main/java/org/bukkit/block/BlockState.java
index 631cbf2be51040eee00aa39a39c5ec4003f91843..de0276394998a2d4e61305879febe05fad3aae91 100644
--- a/src/main/java/org/bukkit/block/BlockState.java
+++ b/src/main/java/org/bukkit/block/BlockState.java
@@ -221,4 +221,6 @@ public interface BlockState extends Metadatable {
      *         or 'virtual' (e.g. on an itemstack)
      */
     boolean isPlaced();
+
+    boolean isTileEntity(); // EMC
 }
diff --git a/src/main/java/org/bukkit/entity/Entity.java b/src/main/java/org/bukkit/entity/Entity.java
index 8fd64b4006a829faf50d2f66a952b277e5bf6d0d..2d657e0e7f42fb6cfadfbb1c3b67abe68353180a 100644
--- a/src/main/java/org/bukkit/entity/Entity.java
+++ b/src/main/java/org/bukkit/entity/Entity.java
@@ -255,6 +255,7 @@ public interface Entity extends Metadatable, CommandSender, Nameable, Persistent
     @NotNull
     public Server getServer();
 
+    public com.empireminecraft.api.meta.TempMetaMap getTempMeta(); // EMC
     /**
      * Returns true if the entity gets persisted.
      * <p>
diff --git a/src/main/java/org/bukkit/inventory/Inventory.java b/src/main/java/org/bukkit/inventory/Inventory.java
index 730f6e0fd0e73147571321d68c47d23c3b879c68..898786c216ec2a78a97a7f49b291e4a73c7a40de 100644
--- a/src/main/java/org/bukkit/inventory/Inventory.java
+++ b/src/main/java/org/bukkit/inventory/Inventory.java
@@ -27,6 +27,7 @@ import org.jetbrains.annotations.Nullable;
  */
 public interface Inventory extends Iterable<ItemStack> {
 
+    public HashMap<String, Object> getMeta(); // EMC
     /**
      * Returns the size of the inventory
      *
