From 7ef07c6aa3adb84a96d5b5c82e982835f77cba86 Mon Sep 17 00:00:00 2001
From: Aikar <aikar@aikar.co>
Date: Thu, 4 Jul 2013 21:04:26 -0400
Subject: [PATCH] Persistent and Temporary Metadata API

Entity, TileEntity, World, Chunk, Block, Inventory API's
---
 src/main/java/com/empireminecraft/api/API.java     |   2 +
 .../java/com/empireminecraft/api/Vector3i.java     |  66 ++++
 .../com/empireminecraft/api/meta/EAPI_Meta.java    |  50 +++
 .../java/com/empireminecraft/api/meta/Meta.java    | 410 +++++++++++++++++++++
 .../java/com/empireminecraft/api/meta/MetaKey.java |  51 +++
 .../api/meta/PersistentKeyImpl.java                |  44 +++
 .../api/meta/PersistentMetaList.java               |  73 ++++
 .../api/meta/PersistentMetaMap.java                |  71 ++++
 .../com/empireminecraft/api/meta/TempKeyImpl.java  |  44 +++
 .../BlockWithPersistentMetaClearedEvent.java       |  49 +++
 src/main/java/org/bukkit/block/BlockState.java     |   2 +
 src/main/java/org/bukkit/entity/Entity.java        |   1 +
 src/main/java/org/bukkit/inventory/Inventory.java  |   1 +
 13 files changed, 864 insertions(+)
 create mode 100644 src/main/java/com/empireminecraft/api/Vector3i.java
 create mode 100644 src/main/java/com/empireminecraft/api/meta/EAPI_Meta.java
 create mode 100644 src/main/java/com/empireminecraft/api/meta/Meta.java
 create mode 100644 src/main/java/com/empireminecraft/api/meta/MetaKey.java
 create mode 100644 src/main/java/com/empireminecraft/api/meta/PersistentKeyImpl.java
 create mode 100644 src/main/java/com/empireminecraft/api/meta/PersistentMetaList.java
 create mode 100644 src/main/java/com/empireminecraft/api/meta/PersistentMetaMap.java
 create mode 100644 src/main/java/com/empireminecraft/api/meta/TempKeyImpl.java
 create mode 100644 src/main/java/com/empireminecraft/customevents/BlockWithPersistentMetaClearedEvent.java

diff --git a/src/main/java/com/empireminecraft/api/API.java b/src/main/java/com/empireminecraft/api/API.java
index 237e5575..9ff1db8c 100644
--- a/src/main/java/com/empireminecraft/api/API.java
+++ b/src/main/java/com/empireminecraft/api/API.java
@@ -23,12 +23,14 @@
 
 package com.empireminecraft.api;
 
+import com.empireminecraft.api.meta.EAPI_Meta;
 import org.apache.commons.lang.exception.ExceptionUtils;
 
 public abstract class API {
 
     public static EAPI_Entity entity;
     public static EAPI_Misc misc;
+    public static EAPI_Meta meta;
 
     public static String stack() {
         return ExceptionUtils.getFullStackTrace(new Throwable());
diff --git a/src/main/java/com/empireminecraft/api/Vector3i.java b/src/main/java/com/empireminecraft/api/Vector3i.java
new file mode 100644
index 00000000..75b2748e
--- /dev/null
+++ b/src/main/java/com/empireminecraft/api/Vector3i.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright (c) 2016 Starlis LLC / Daniel Ennis (Aikar) - MIT License
+ *
+ *  Permission is hereby granted, free of charge, to any person obtaining
+ *  a copy of this software and associated documentation files (the
+ *  "Software"), to deal in the Software without restriction, including
+ *  without limitation the rights to use, copy, modify, merge, publish,
+ *  distribute, sublicense, and/or sell copies of the Software, and to
+ *  permit persons to whom the Software is furnished to do so, subject to
+ *  the following conditions:
+ *
+ *  The above copyright notice and this permission notice shall be
+ *  included in all copies or substantial portions of the Software.
+ *
+ *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ *  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ *  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ *  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ *  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ *  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ *  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.empireminecraft.api;
+
+import com.empireminecraft.api.meta.Meta;
+
+@SuppressWarnings("PublicInnerClass")
+public final class Vector3i {
+    public final int x;
+    public final int y;
+    public final int z;
+
+    public Vector3i(int x, int y, int z) {
+        this.x = x;
+        this.y = y;
+        this.z = z;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) { return true; }
+        if (o == null || getClass() != o.getClass()) { return false; }
+
+        Vector3i vector = (Vector3i) o;
+
+        return (x == vector.x && z == vector.z && y == vector.y);
+    }
+
+    @Override
+    public int hashCode() {
+        int result = x;
+        result = result * 73 + y;
+        result = result * 73 + z;
+        return result;
+    }
+
+    @Override
+    public String toString() {
+        return "BlockPos{" +
+            "x=" + x +
+            ", y=" + y +
+            ", z=" + z +
+            '}';
+    }
+}
diff --git a/src/main/java/com/empireminecraft/api/meta/EAPI_Meta.java b/src/main/java/com/empireminecraft/api/meta/EAPI_Meta.java
new file mode 100644
index 00000000..caa02c3e
--- /dev/null
+++ b/src/main/java/com/empireminecraft/api/meta/EAPI_Meta.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright (c) 2016 Starlis LLC / Daniel Ennis (Aikar) - MIT License
+ *
+ *  Permission is hereby granted, free of charge, to any person obtaining
+ *  a copy of this software and associated documentation files (the
+ *  "Software"), to deal in the Software without restriction, including
+ *  without limitation the rights to use, copy, modify, merge, publish,
+ *  distribute, sublicense, and/or sell copies of the Software, and to
+ *  permit persons to whom the Software is furnished to do so, subject to
+ *  the following conditions:
+ *
+ *  The above copyright notice and this permission notice shall be
+ *  included in all copies or substantial portions of the Software.
+ *
+ *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ *  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ *  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ *  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ *  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ *  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ *  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.empireminecraft.api.meta;
+
+import com.empireminecraft.api.Vector3i;
+import org.bukkit.Chunk;
+import org.bukkit.Location;
+import org.bukkit.World;
+import org.bukkit.block.Block;
+import org.bukkit.block.BlockState;
+import org.bukkit.entity.Entity;
+
+import java.util.Map;
+
+public interface EAPI_Meta {
+    PersistentMetaMap getTileEntityMetaMap(BlockState tileEntity, boolean isWrite);
+
+    PersistentMetaMap getBlockMetaMap(Location loc, boolean isWrite);
+
+    PersistentMetaMap getChunkMetaMap(Chunk chunk, boolean isWrite);
+
+    Map<Vector3i,PersistentMetaMap> getChunkMetaData(Chunk chunk);
+
+    PersistentMetaMap getEntityMetaMap(Entity entity, boolean isWrite);
+
+    PersistentMetaMap getWorldMetaMap(World world);
+
+    Map<String,Object> getBlockTempMeta(Block block, boolean b);
+}
diff --git a/src/main/java/com/empireminecraft/api/meta/Meta.java b/src/main/java/com/empireminecraft/api/meta/Meta.java
new file mode 100644
index 00000000..67c77721
--- /dev/null
+++ b/src/main/java/com/empireminecraft/api/meta/Meta.java
@@ -0,0 +1,410 @@
+/*
+ * Copyright (c) 2016 Starlis LLC / Daniel Ennis (Aikar) - MIT License
+ *
+ *  Permission is hereby granted, free of charge, to any person obtaining
+ *  a copy of this software and associated documentation files (the
+ *  "Software"), to deal in the Software without restriction, including
+ *  without limitation the rights to use, copy, modify, merge, publish,
+ *  distribute, sublicense, and/or sell copies of the Software, and to
+ *  permit persons to whom the Software is furnished to do so, subject to
+ *  the following conditions:
+ *
+ *  The above copyright notice and this permission notice shall be
+ *  included in all copies or substantial portions of the Software.
+ *
+ *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ *  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ *  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ *  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ *  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ *  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ *  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.empireminecraft.api.meta;
+
+import com.empireminecraft.api.API;
+import com.empireminecraft.api.Vector3i;
+import com.empireminecraft.api.meta.MetaKey.PersistentKey;
+import com.empireminecraft.api.meta.MetaKey.TempKey;
+import org.bukkit.Chunk;
+import org.bukkit.Location;
+import org.bukkit.World;
+import org.bukkit.block.Block;
+import org.bukkit.block.BlockState;
+import org.bukkit.entity.Entity;
+import org.bukkit.inventory.Inventory;
+import org.bukkit.inventory.ItemStack;
+
+import java.util.Map;
+
+@SuppressWarnings({"WeakerAccess", "unused"})
+public final class Meta {
+    private Meta() {}
+
+    //////////////////////////////////////////////////
+    //// UTIL & KEYS
+    //////////////////////////////////////////////////
+
+    public static TempKey createTempKey(String key) {
+        return new TempKeyImpl(key);
+    }
+    public static PersistentKey createPersistentKey(String key) {
+        return new PersistentKeyImpl(key);
+    }
+
+    /**
+     * Checks if the passed object can be stored as Meta Data
+     * @param value
+     * @return
+     */
+    public static boolean isValidPersistentMeta(Object value) {
+        return (value instanceof String) || (value instanceof Long) ||
+            (value instanceof Integer) || (value instanceof ItemStack) ||
+            (value instanceof Float) || (value instanceof Double) ||
+            (value instanceof PersistentMetaMap) || (value instanceof PersistentMetaList);
+    }
+
+
+    //////////////////////////////////////////////////
+    //// PERSISTENT WORLD META
+    //////////////////////////////////////////////////
+
+    public static PersistentMetaMap getWorldPersistentMetaMap(World world) {
+        return API.meta.getWorldMetaMap(world);
+    }
+
+    public static <T> T getWorldMeta(World world, PersistentKey key) {
+        return getWorldMeta(world, key, null);
+    }
+
+    public static <T> T getWorldMeta(World world, PersistentKey key, T def) {
+        final PersistentMetaMap worldMetaMap = getWorldPersistentMetaMap(world);
+        T ret = worldMetaMap != null && !worldMetaMap.isEmpty() ? (T) worldMetaMap.get(key.key()) : null;
+        return ret != null ? ret : def;
+    }
+
+    public static boolean hasWorldMeta(World world, PersistentKey key) {
+        final PersistentMetaMap worldMetaMap = getWorldPersistentMetaMap(world);
+        return worldMetaMap != null && !worldMetaMap.isEmpty() && worldMetaMap.containsKey(key.key());
+    }
+
+    public static <T> T setWorldMeta(World world, PersistentKey key, Object val) {
+        return setMetaMapValue(getWorldPersistentMetaMap(world), key, val);
+    }
+
+    public static <T> T removeWorldMeta(World world, PersistentKey key) {
+        return setWorldMeta(world, key, null);
+    }
+
+    //////////////////////////////////////////////////
+    //// PERSISTENT ENTITY META
+    //////////////////////////////////////////////////
+
+    public static PersistentMetaMap getEntityPersistentMetaMap(Entity entity, boolean isWrite) {
+        return API.meta.getEntityMetaMap(entity, isWrite);
+    }
+
+    public static <T> T getEntityMeta(Entity entity, PersistentKey key) {
+        return getEntityMeta(entity, key, null);
+    }
+
+    public static <T> T getEntityMeta(Entity entity, PersistentKey key, T def) {
+        final PersistentMetaMap entityMetaMap = getEntityPersistentMetaMap(entity, false);
+        T ret = entityMetaMap != null && !entityMetaMap.isEmpty() ? (T) entityMetaMap.get(key.key()) : null;
+        return ret != null ? ret : def;
+    }
+
+    public static boolean hasEntityMeta(Entity entity, PersistentKey key) {
+        final PersistentMetaMap entityMetaMap = getEntityPersistentMetaMap(entity, false);
+        return entityMetaMap != null && !entityMetaMap.isEmpty() && entityMetaMap.containsKey(key.key());
+    }
+
+    public static <T> T setEntityMeta(Entity entity, PersistentKey key, Object val) {
+        return setMetaMapValue(getEntityPersistentMetaMap(entity, true), key, val);
+    }
+
+    public static <T> T removeEntityMeta(Entity entity, PersistentKey key) {
+        return setMetaMapValue(getEntityPersistentMetaMap(entity, false), key, null);
+    }
+
+
+    public static double incrementEntityMeta(Entity entity, PersistentKey key, double val) {
+        return incrementEntityMeta(entity, key, val, 0D);
+    }
+
+    public static double incrementEntityMeta(Entity entity, PersistentKey key, double val, double start) {
+        Number orig = getEntityMeta(entity, key, start);
+        setEntityMeta(entity, key, orig.doubleValue() + val);
+        return orig.doubleValue();
+    }
+
+    //////////////////////////////////////////////////
+    //// PERSISTENT CHUNK META
+    //////////////////////////////////////////////////
+
+    /**
+     * Only provided for low level access as debug command
+     * @param chunk
+     * @return
+     */
+    @Deprecated
+    public static Map<Vector3i, PersistentMetaMap> getChunkMetaData(Chunk chunk) {
+        return API.meta.getChunkMetaData(chunk);
+    }
+
+    public static PersistentMetaMap getChunkPersistentMetaMap(Chunk chunk, boolean isWrite) {
+        return API.meta.getChunkMetaMap(chunk, isWrite);
+    }
+
+    public static boolean hasChunkMeta(Chunk chunk, PersistentKey key) {
+        final PersistentMetaMap chunkMetaMap = getChunkPersistentMetaMap(chunk, false);
+        return chunkMetaMap != null && !chunkMetaMap.isEmpty() && chunkMetaMap.containsKey(key.key());
+    }
+
+    public static <T> T getChunkMeta(Chunk chunk, PersistentKey key) {
+        return getChunkMeta(chunk, key, null);
+    }
+
+    public static <T> T getChunkMeta(Chunk chunk, PersistentKey key, T def) {
+        final PersistentMetaMap chunkMetaMap = getChunkPersistentMetaMap(chunk, false);
+        T ret = chunkMetaMap != null && !chunkMetaMap.isEmpty() ? (T) getChunkPersistentMetaMap(chunk, false).get(key.key()) : null;
+        return ret != null ? ret : def;
+    }
+
+    public static <T> T setChunkMeta(Chunk chunk, PersistentKey key, Object val) {
+        return setMetaMapValue(getChunkPersistentMetaMap(chunk, true), key, val);
+    }
+
+    public static <T> T removeChunkMeta(Chunk chunk, PersistentKey key) {
+        return setMetaMapValue(getChunkPersistentMetaMap(chunk, false), key, null);
+    }
+
+    //////////////////////////////////////////////////
+    //// PERSISTENT BLOCK META
+    //////////////////////////////////////////////////
+
+    public static PersistentMetaMap getBlockPersistentMetaMap(Location loc, boolean isWrite) {
+        return API.meta.getBlockMetaMap(loc, isWrite);
+    }
+
+    public static boolean hasBlockMeta(Location loc, PersistentKey key) {
+        final PersistentMetaMap blockMetaMap = getBlockPersistentMetaMap(loc, false);
+        return blockMetaMap != null && !blockMetaMap.isEmpty() && blockMetaMap.containsKey(key.key());
+    }
+
+    public static <T> T getBlockMeta(Location loc, PersistentKey key) {
+        return getBlockMeta(loc, key, null);
+    }
+
+    public static <T> T getBlockMeta(Location loc, PersistentKey key, T def) {
+        final PersistentMetaMap blockMetaMap = getBlockPersistentMetaMap(loc, false);
+        T ret = blockMetaMap != null && !blockMetaMap.isEmpty() ? (T) blockMetaMap.get(key.key()) : null;
+        return ret != null ? ret : def;
+    }
+
+    public static <T> T setBlockMeta(Location loc, PersistentKey key, Object val) {
+        return setMetaMapValue(getBlockPersistentMetaMap(loc, true), key, val);
+    }
+
+    public static <T> T removeBlockMeta(Location loc, PersistentKey key) {
+        return setMetaMapValue(getBlockPersistentMetaMap(loc, false), key, null);
+    }
+
+    //////////////////////////////////////////////////
+    //// PERSISTENT TILE ENTITY META
+    //////////////////////////////////////////////////
+
+    public static PersistentMetaMap getTileEntityPersistentMetaMap(Location tileEntity, boolean isWrite) {
+        return API.meta.getTileEntityMetaMap(tileEntity.getBlock().getState(), isWrite);
+    }
+
+    public static PersistentMetaMap getTileEntityPersistentMetaMap(BlockState tileEntity, boolean isWrite) {
+        return API.meta.getTileEntityMetaMap(tileEntity, isWrite);
+    }
+
+    public static boolean hasTileEntityMeta(Location tileEntity, PersistentKey key) {
+        return hasTileEntityMeta(tileEntity.getBlock().getState(), key);
+    }
+
+    public static boolean hasTileEntityMeta(BlockState tileEntity, PersistentKey key) {
+        final PersistentMetaMap tileEntityMetaMap = getTileEntityPersistentMetaMap(tileEntity, false);
+        return tileEntityMetaMap != null && !tileEntityMetaMap.isEmpty() && tileEntityMetaMap.containsKey(key.key());
+    }
+
+    public static <T> T getTileEntityMeta(Location tileEntity, PersistentKey key) {
+        return getTileEntityMeta(tileEntity.getBlock().getState(), key, null);
+    }
+
+    public static <T> T getTileEntityMeta(BlockState tileEntity, PersistentKey key) {
+        return getTileEntityMeta(tileEntity, key, null);
+    }
+
+    public static <T> T getTileEntityMeta(Location tileEntity, PersistentKey key, T def) {
+        return getTileEntityMeta(tileEntity.getBlock().getState(), key, def);
+    }
+
+    public static <T> T getTileEntityMeta(BlockState tileEntity, PersistentKey key, T def) {
+        final PersistentMetaMap tileEntityMetaMap = getTileEntityPersistentMetaMap(tileEntity, false);
+        T ret = tileEntityMetaMap != null && !tileEntityMetaMap.isEmpty() ? (T) tileEntityMetaMap.get(key.key()) : null;
+        return ret != null ? ret : def;
+    }
+
+    public static <T> T setTileEntityMeta(Location tileEntity, PersistentKey key, Object val) {
+        return setTileEntityMeta(tileEntity.getBlock().getState(), key, val);
+    }
+
+    public static <T> T setTileEntityMeta(BlockState tileEntity, PersistentKey key, Object val) {
+        return setMetaMapValue(getTileEntityPersistentMetaMap(tileEntity, true), key, val);
+    }
+
+    public static <T> T removeTileEntityMeta(Location tileEntity, PersistentKey key) {
+        return removeTileEntityMeta(tileEntity.getBlock().getState(), key);
+    }
+
+    public static <T> T removeTileEntityMeta(BlockState tileEntity, PersistentKey key) {
+        return setMetaMapValue(getTileEntityPersistentMetaMap(tileEntity, false), key, null);
+    }
+
+    /**
+     * General method for determining if value is null to remove it, else set.
+     * Return previous value
+     *
+     * @param map
+     * @param key
+     * @param val
+     * @param <T>
+     * @return
+     */
+    private static <T> T setMetaMapValue(PersistentMetaMap map, PersistentKey key, Object val) {
+        if (map == null) {
+            return null;
+        }
+        if (val == null) {
+            return (T) map.remove(key.key());
+        } else {
+            return (T) map.put(key.key(), val);
+        }
+    }
+
+    //////////////////////////////////////////////////
+    //// TEMP ENTITY META
+    //////////////////////////////////////////////////
+
+    public static boolean hasEntityMeta(Entity entity, TempKey key) {
+        return entity.getTempMeta().containsKey(key.key());
+    }
+
+    public static <T> T setEntityMeta(Entity entity, TempKey key, Object val) {
+        return (T) entity.getTempMeta().put(key.key(), val);
+    }
+
+    public static <T> T removeEntityMeta(Entity entity, TempKey key) {
+        return (T) entity.getTempMeta().remove(key.key());
+    }
+
+    public static <T> T getEntityMeta(Entity entity, TempKey key) {
+        return getEntityMeta(entity, key, null);
+    }
+
+    public static <T> T getEntityMeta(Entity entity, TempKey key, T def) {
+        Object val = entity.getTempMeta().get(key.key());
+        if (val != null) {
+            return (T) val;
+        }
+        return def;
+    }
+
+    public static Long incrementEntityMeta(Entity entity, TempKey key, Long amount) {
+        return incrementEntityMeta(entity, key, amount, 0L);
+    }
+    public static Long incrementEntityMeta(Entity entity, TempKey key, Long amount, Long start) {
+        Long val = getEntityMeta(entity, key);
+        Long origVal = val;
+        if (val == null) {
+            val = start;
+        }
+        val += amount;
+        setEntityMeta(entity, key, val);
+        return origVal;
+    }
+
+    public static Double incrementEntityMeta(Entity entity, TempKey key, Double amount) {
+        return incrementEntityMeta(entity, key, amount, 0D);
+    }
+    public static Double incrementEntityMeta(Entity entity, TempKey key, Double amount, Double start) {
+        Double val = getEntityMeta(entity, key);
+        Double origVal = val;
+        if (val == null) {
+            val = start;
+        }
+        val += amount;
+        setEntityMeta(entity, key, val);
+        return origVal;
+    }
+
+
+
+    //////////////////////////////////////////////////
+    //// TEMP BLOCK META
+    //////////////////////////////////////////////////
+
+    public static boolean hasBlockMeta(Block block, TempKey key) {
+        Map<String, Object> blockMeta = API.meta.getBlockTempMeta(block, false);
+        return blockMeta != null && blockMeta.containsKey(key.key());
+    }
+
+    public static <T> T setBlockMeta(Block block, TempKey key, Object val) {
+        Map<String, Object> blockMeta = API.meta.getBlockTempMeta(block, true);
+        return (T) blockMeta.put(key.key(), val);
+    }
+
+    public static <T> T removeBlockMeta(Block block, TempKey key) {
+        Map<String, Object> blockMeta = API.meta.getBlockTempMeta(block, true);
+        return (T) blockMeta.remove(key.key());
+    }
+
+    public static <T> T getBlockMeta(Block block, TempKey key) {
+        return getBlockMeta(block, key, null);
+    }
+
+    public static <T> T getBlockMeta(Block block, TempKey key, T def) {
+        Map<String, Object> blockMeta = API.meta.getBlockTempMeta(block, false);
+        if (blockMeta == null) {
+            return null;
+        }
+        Object val = blockMeta.get(key.key());
+        if (val != null) {
+            return (T) val;
+        }
+        return def;
+    }
+
+    //////////////////////////////////////////////////
+    //// TEMP INVENTORY META
+    //////////////////////////////////////////////////
+
+    public static boolean hasInventoryMeta(Inventory inv, TempKey key) {
+        return inv.getMeta().containsKey(key.key());
+    }
+
+    public static <T> T setInventoryMeta(Inventory inv, TempKey key, Object val) {
+        return (T) inv.getMeta().put(key.key(), val);
+    }
+
+    public static <T> T removeInventoryMeta(Inventory inv, TempKey key) {
+        return (T) inv.getMeta().remove(key.key());
+    }
+
+    public static <T> T getInventoryMeta(Inventory inv, TempKey key) {
+        return getInventoryMeta(inv, key, null);
+    }
+
+    public static <T> T getInventoryMeta(Inventory inv, TempKey key, T def) {
+        Object val = inv.getMeta().get(key.key());
+        if (val != null) {
+            return (T) val;
+        }
+        return def;
+    }
+}
diff --git a/src/main/java/com/empireminecraft/api/meta/MetaKey.java b/src/main/java/com/empireminecraft/api/meta/MetaKey.java
new file mode 100644
index 00000000..f0b62b48
--- /dev/null
+++ b/src/main/java/com/empireminecraft/api/meta/MetaKey.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (c) 2016 Starlis LLC / Daniel Ennis (Aikar) - MIT License
+ *
+ *  Permission is hereby granted, free of charge, to any person obtaining
+ *  a copy of this software and associated documentation files (the
+ *  "Software"), to deal in the Software without restriction, including
+ *  without limitation the rights to use, copy, modify, merge, publish,
+ *  distribute, sublicense, and/or sell copies of the Software, and to
+ *  permit persons to whom the Software is furnished to do so, subject to
+ *  the following conditions:
+ *
+ *  The above copyright notice and this permission notice shall be
+ *  included in all copies or substantial portions of the Software.
+ *
+ *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ *  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ *  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ *  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ *  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ *  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ *  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.empireminecraft.api.meta;
+
+public interface MetaKey {
+
+    /**
+     * Key name
+     * @return The key
+     */
+    String key();
+
+    /**
+     * Represents a key used for persistent metadata
+     */
+    interface PersistentKey extends MetaKey {
+        default PersistentKey append(String key) {
+            return Meta.createPersistentKey(key() + key);
+        }
+    }
+
+    /**
+     * Represents a key used for temporary metadata
+     */
+    interface TempKey extends MetaKey {
+        default TempKey append(String key) {
+            return Meta.createTempKey(key() + key);
+        }
+    }
+}
diff --git a/src/main/java/com/empireminecraft/api/meta/PersistentKeyImpl.java b/src/main/java/com/empireminecraft/api/meta/PersistentKeyImpl.java
new file mode 100644
index 00000000..0d62fbf0
--- /dev/null
+++ b/src/main/java/com/empireminecraft/api/meta/PersistentKeyImpl.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright (c) 2016 Starlis LLC / Daniel Ennis (Aikar) - MIT License
+ *
+ *  Permission is hereby granted, free of charge, to any person obtaining
+ *  a copy of this software and associated documentation files (the
+ *  "Software"), to deal in the Software without restriction, including
+ *  without limitation the rights to use, copy, modify, merge, publish,
+ *  distribute, sublicense, and/or sell copies of the Software, and to
+ *  permit persons to whom the Software is furnished to do so, subject to
+ *  the following conditions:
+ *
+ *  The above copyright notice and this permission notice shall be
+ *  included in all copies or substantial portions of the Software.
+ *
+ *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ *  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ *  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ *  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ *  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ *  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ *  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.empireminecraft.api.meta;
+
+import com.empireminecraft.api.meta.MetaKey.PersistentKey;
+
+class PersistentKeyImpl implements PersistentKey {
+    private final String key;
+
+    PersistentKeyImpl(String key) {
+        this.key = key;
+    }
+
+    @Override
+    public final String key() {
+        return key;
+    }
+
+    @Override
+    public String toString() {
+        return key;
+    }
+}
diff --git a/src/main/java/com/empireminecraft/api/meta/PersistentMetaList.java b/src/main/java/com/empireminecraft/api/meta/PersistentMetaList.java
new file mode 100644
index 00000000..e4060252
--- /dev/null
+++ b/src/main/java/com/empireminecraft/api/meta/PersistentMetaList.java
@@ -0,0 +1,73 @@
+/*
+ * Copyright (c) 2016 Starlis LLC / Daniel Ennis (Aikar) - MIT License
+ *
+ *  Permission is hereby granted, free of charge, to any person obtaining
+ *  a copy of this software and associated documentation files (the
+ *  "Software"), to deal in the Software without restriction, including
+ *  without limitation the rights to use, copy, modify, merge, publish,
+ *  distribute, sublicense, and/or sell copies of the Software, and to
+ *  permit persons to whom the Software is furnished to do so, subject to
+ *  the following conditions:
+ *
+ *  The above copyright notice and this permission notice shall be
+ *  included in all copies or substantial portions of the Software.
+ *
+ *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ *  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ *  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ *  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ *  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ *  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ *  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.empireminecraft.api.meta;
+
+import java.security.InvalidParameterException;
+import java.util.ArrayList;
+import java.util.Collection;
+
+/**
+ * A type protected array for storing meta values
+ */
+@SuppressWarnings("PublicInnerClass")
+public class PersistentMetaList<T> extends ArrayList<T> {
+    public PersistentMetaList(int initialCapacity) {
+        super(initialCapacity);
+    }
+
+    public PersistentMetaList() {
+    }
+
+    public PersistentMetaList(Collection<? extends T> c) {
+        super(c);
+    }
+
+    @Override
+    public boolean add(T o) {
+        if (!Meta.isValidPersistentMeta(o)) {
+            throw new InvalidParameterException();
+        }
+        return super.add(o);
+    }
+
+    @Override
+    public T set(int index, T element) {
+        if (!Meta.isValidPersistentMeta(element)) {
+            throw new InvalidParameterException();
+        }
+        return super.set(index, element);
+    }
+
+    @Override
+    public void add(int index, T element) {
+        if (!Meta.isValidPersistentMeta(element)) {
+            throw new InvalidParameterException();
+        }
+        super.add(index, element);
+    }
+
+    public PersistentMetaList<T> clone()  {
+        return new PersistentMetaList<>(this);
+    }
+}
diff --git a/src/main/java/com/empireminecraft/api/meta/PersistentMetaMap.java b/src/main/java/com/empireminecraft/api/meta/PersistentMetaMap.java
new file mode 100644
index 00000000..8afef592
--- /dev/null
+++ b/src/main/java/com/empireminecraft/api/meta/PersistentMetaMap.java
@@ -0,0 +1,71 @@
+/*
+ * Copyright (c) 2016 Starlis LLC / Daniel Ennis (Aikar) - MIT License
+ *
+ *  Permission is hereby granted, free of charge, to any person obtaining
+ *  a copy of this software and associated documentation files (the
+ *  "Software"), to deal in the Software without restriction, including
+ *  without limitation the rights to use, copy, modify, merge, publish,
+ *  distribute, sublicense, and/or sell copies of the Software, and to
+ *  permit persons to whom the Software is furnished to do so, subject to
+ *  the following conditions:
+ *
+ *  The above copyright notice and this permission notice shall be
+ *  included in all copies or substantial portions of the Software.
+ *
+ *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ *  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ *  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ *  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ *  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ *  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ *  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.empireminecraft.api.meta;
+
+import com.google.common.collect.ForwardingMap;
+
+import java.security.InvalidParameterException;
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * A type protected hashmap for storing meta values
+ */
+@SuppressWarnings("PublicInnerClass")
+public class PersistentMetaMap extends ForwardingMap<String, Object> {
+    private Map<String, Object> backing;
+
+    @Override
+    protected Map<String, Object> delegate() {
+        if (backing == null) {
+            backing = new HashMap<>();
+        }
+        return backing;
+    }
+
+    @Override
+    public Object put(String key, Object value) {
+        if (!Meta.isValidPersistentMeta(value)) {
+            throw new InvalidParameterException();
+        }
+        return super.put(key, value);
+    }
+
+    @Override
+    public void putAll(Map<? extends String, ?> map) {
+        for (Object value : map.values()) {
+            if (!Meta.isValidPersistentMeta(value)) {
+                throw new InvalidParameterException();
+            }
+        }
+
+        super.putAll(map);
+    }
+
+    public PersistentMetaMap clone() {
+        PersistentMetaMap map = new PersistentMetaMap();
+        map.putAll(this);
+        return map;
+    }
+}
diff --git a/src/main/java/com/empireminecraft/api/meta/TempKeyImpl.java b/src/main/java/com/empireminecraft/api/meta/TempKeyImpl.java
new file mode 100644
index 00000000..d3de8624
--- /dev/null
+++ b/src/main/java/com/empireminecraft/api/meta/TempKeyImpl.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright (c) 2016 Starlis LLC / Daniel Ennis (Aikar) - MIT License
+ *
+ *  Permission is hereby granted, free of charge, to any person obtaining
+ *  a copy of this software and associated documentation files (the
+ *  "Software"), to deal in the Software without restriction, including
+ *  without limitation the rights to use, copy, modify, merge, publish,
+ *  distribute, sublicense, and/or sell copies of the Software, and to
+ *  permit persons to whom the Software is furnished to do so, subject to
+ *  the following conditions:
+ *
+ *  The above copyright notice and this permission notice shall be
+ *  included in all copies or substantial portions of the Software.
+ *
+ *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ *  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ *  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ *  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ *  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ *  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ *  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.empireminecraft.api.meta;
+
+import com.empireminecraft.api.meta.MetaKey.TempKey;
+
+class TempKeyImpl implements TempKey {
+    private final String key;
+
+    TempKeyImpl(String key) {
+        this.key = key;
+    }
+
+    @Override
+    public final String key() {
+        return key;
+    }
+
+    @Override
+    public String toString() {
+        return key;
+    }
+}
diff --git a/src/main/java/com/empireminecraft/customevents/BlockWithPersistentMetaClearedEvent.java b/src/main/java/com/empireminecraft/customevents/BlockWithPersistentMetaClearedEvent.java
new file mode 100644
index 00000000..4963d24f
--- /dev/null
+++ b/src/main/java/com/empireminecraft/customevents/BlockWithPersistentMetaClearedEvent.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (c) 2016 Starlis LLC / Daniel Ennis (Aikar) - MIT License
+ *
+ *  Permission is hereby granted, free of charge, to any person obtaining
+ *  a copy of this software and associated documentation files (the
+ *  "Software"), to deal in the Software without restriction, including
+ *  without limitation the rights to use, copy, modify, merge, publish,
+ *  distribute, sublicense, and/or sell copies of the Software, and to
+ *  permit persons to whom the Software is furnished to do so, subject to
+ *  the following conditions:
+ *
+ *  The above copyright notice and this permission notice shall be
+ *  included in all copies or substantial portions of the Software.
+ *
+ *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ *  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ *  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ *  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ *  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ *  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ *  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.empireminecraft.customevents;
+
+import org.bukkit.block.Block;
+import org.bukkit.event.Event;
+import org.bukkit.event.HandlerList;
+
+public class BlockWithPersistentMetaClearedEvent extends Event {
+    private final Block block;
+    public BlockWithPersistentMetaClearedEvent(Block block) {
+        this.block = block;
+    }
+
+    public Block getBlock() {
+        return block;
+    }
+
+    private static final HandlerList handlers = new HandlerList();
+
+    public HandlerList getHandlers() {
+        return handlers;
+    }
+
+    public static HandlerList getHandlerList() {
+        return handlers;
+    }
+}
diff --git a/src/main/java/org/bukkit/block/BlockState.java b/src/main/java/org/bukkit/block/BlockState.java
index 866a73d9..7417574b 100644
--- a/src/main/java/org/bukkit/block/BlockState.java
+++ b/src/main/java/org/bukkit/block/BlockState.java
@@ -203,4 +203,6 @@ public interface BlockState extends Metadatable {
      *         or 'virtual' (e.g. on an itemstack)
      */
     boolean isPlaced();
+
+    boolean isTileEntity(); // EMC
 }
diff --git a/src/main/java/org/bukkit/entity/Entity.java b/src/main/java/org/bukkit/entity/Entity.java
index 7bd723de..b48904e7 100644
--- a/src/main/java/org/bukkit/entity/Entity.java
+++ b/src/main/java/org/bukkit/entity/Entity.java
@@ -191,6 +191,7 @@ public interface Entity extends Metadatable, CommandSender, Nameable {
      */
     public Server getServer();
 
+    public java.util.Map<String, Object> getTempMeta(); // EMC
     /**
      * Gets the primary passenger of a vehicle. For vehicles that could have
      * multiple passengers, this will only return the primary passenger.
diff --git a/src/main/java/org/bukkit/inventory/Inventory.java b/src/main/java/org/bukkit/inventory/Inventory.java
index c610262f..6a11b55f 100644
--- a/src/main/java/org/bukkit/inventory/Inventory.java
+++ b/src/main/java/org/bukkit/inventory/Inventory.java
@@ -15,6 +15,7 @@ import org.bukkit.event.inventory.InventoryType;
  */
 public interface Inventory extends Iterable<ItemStack> {
 
+	public HashMap<String, Object> getMeta(); // EMC
     /**
      * Returns the size of the inventory
      *
-- 
2.13.0

