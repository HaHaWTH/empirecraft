From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Aikar <aikar@aikar.co>
Date: Wed, 27 Feb 2013 23:27:45 -0500
Subject: [PATCH] Hidden Item Meta

This adds the ability to store hidden metadata in item lore.

Simply set a line to "&&::META" and every blank line before, that line, and every line after will be hidden from view on the client.

for example, you can set &&::META on line 20, and there will not be 19 blank lines before it.
Then you can store Data on 21+

Also adds a &&::SHINY tag to send a fake enchantment aura if it does not exists.
Must be set before META
---
 .../empireminecraft/api/HiddenItemMeta.java   |  95 +++++
 .../network/PacketDataSerializer.java         |   2 +
 .../minecraft/network/chat/ChatHoverable.java | 331 ++++++++++++++++++
 .../net/minecraft/world/item/ItemStack.java   |  20 +-
 4 files changed, 447 insertions(+), 1 deletion(-)
 create mode 100644 src/main/java/com/empireminecraft/api/HiddenItemMeta.java
 create mode 100644 src/main/java/net/minecraft/network/chat/ChatHoverable.java

diff --git a/src/main/java/com/empireminecraft/api/HiddenItemMeta.java b/src/main/java/com/empireminecraft/api/HiddenItemMeta.java
new file mode 100644
index 0000000000000000000000000000000000000000..e0ea58808f4d64969b3162e78053b5317176fe44
--- /dev/null
+++ b/src/main/java/com/empireminecraft/api/HiddenItemMeta.java
@@ -0,0 +1,95 @@
+package com.empireminecraft.api;
+
+import net.minecraft.nbt.NBTTagCompound;
+import net.minecraft.nbt.NBTTagList;
+import net.minecraft.nbt.NBTTagString;
+import net.minecraft.network.chat.IChatBaseComponent;
+
+public class HiddenItemMeta {
+    public static NBTTagCompound filterItemLore(NBTTagCompound nbttagcompound, boolean storeOriginal) {
+        if (nbttagcompound != null && nbttagcompound.hasKey("display")) {
+            NBTTagCompound display = nbttagcompound.getCompound("display");
+            if (display.hasKey("Lore")) {
+                NBTTagList lore = display.getList("Lore", 8);
+                int lastLine = 0;
+                boolean hasSpecial = false;
+                boolean hasShiny = false;
+                for (int i = 0; i < lore.size(); i++) {
+                    String line = lore.getString(i);
+                    if (line.startsWith("{") && line.endsWith("}")) {
+                        IChatBaseComponent component = IChatBaseComponent.ChatSerializer.jsonToComponent(line);
+                        line = component.getString();
+                    }
+
+                    if (line.equals("&&::META")) {
+                        hasSpecial = true;
+                        break;
+                    } else if (!line.isEmpty()) {
+                        if (line.equals("&&::SHINY")) {
+                            hasShiny = true;
+                            hasSpecial = true;
+                            break;
+                        } else {
+                            lastLine = i+1;
+                        }
+                    }
+                }
+                if (hasSpecial) {
+                    NBTTagList newlore = new NBTTagList();
+                    for (int x = 0; x < lastLine; x++) {
+                        newlore.add(NBTTagString.a(lore.getString(x)));
+                    }
+
+                    nbttagcompound = (NBTTagCompound) nbttagcompound.clone();
+                    if (hasShiny && !nbttagcompound.hasKey("Enchantments")) {
+                        NBTTagList nbtbase = new NBTTagList();
+                        NBTTagCompound enchant = new NBTTagCompound();
+                        enchant.setShort("id", (short) 1);
+                        enchant.setShort("lvl", (short) 1);
+                        nbtbase.add(enchant);
+                        nbttagcompound.set("Enchantments" , nbtbase);
+                        int flags = 1;
+                        if (nbttagcompound.hasKey("HideFlags")) {
+                            flags = nbttagcompound.getInt("HideFlags");
+                            nbttagcompound.setInt("HideFlagsOrig", flags);
+                            flags &= 1;
+                        } else {
+                            nbttagcompound.remove("HideFlagsOrig");
+                        }
+                        nbttagcompound.setInt("HideFlags", flags);
+                        nbttagcompound.setInt("fakeench", 1);
+                    }
+                    display = nbttagcompound.getCompound("display");
+                    display.set("Lore", newlore);
+                    if (storeOriginal) {
+                        display.set("OriginalLore", lore);
+                    }
+                }
+            }
+        }
+        return nbttagcompound;
+    }
+
+    public static NBTTagCompound restoreItemLore(NBTTagCompound tag) {
+        if (tag.hasKey("display")) {
+            NBTTagCompound display = tag.getCompound("display");
+            if (display.hasKey("OriginalLore")) {
+                display.set("Lore", display.getList("OriginalLore", 8));
+                display.remove("OriginalLore");
+            }
+        }
+        // If shiny was used
+        if (tag.hasKey("fakeench")) {
+            int orig = tag.getInt("HideFlagsOrig");
+            if (tag.hasKey("HideFlagsOrig") && orig != 1) {
+                tag.setInt("HideFlags", orig);
+            } else {
+                tag.remove("HideFlags");
+            }
+            tag.remove("fakeench");
+            tag.remove("Enchantments");
+            tag.remove("HideFlagsOrig");
+        }
+        return tag;
+    }
+}
diff --git a/src/main/java/net/minecraft/network/PacketDataSerializer.java b/src/main/java/net/minecraft/network/PacketDataSerializer.java
index 579eb1260c7266cd41025cff177de4fb00ac0cec..45929d495c6f9f52337cf1796678f0d6ac869aba 100644
--- a/src/main/java/net/minecraft/network/PacketDataSerializer.java
+++ b/src/main/java/net/minecraft/network/PacketDataSerializer.java
@@ -318,6 +318,7 @@ public class PacketDataSerializer extends ByteBuf {
                 // Spigot end
                 nbttagcompound = itemstack.getTag();
                 // Paper start
+                nbttagcompound = com.empireminecraft.api.HiddenItemMeta.filterItemLore(nbttagcompound, true); // EMC
                 if (nbttagcompound != null && nbttagcompound.hasKeyOfType("SkullOwner", 10)) {
                     NBTTagCompound owner = nbttagcompound.getCompound("SkullOwner");
                     if (owner.hasUUID("Id")) {
@@ -346,6 +347,7 @@ public class PacketDataSerializer extends ByteBuf {
             // CraftBukkit start
             if (itemstack.getTag() != null) {
                 // Paper start - Fix skulls of same owner - restore orig ID since we changed it on send to client
+                itemstack.tag = com.empireminecraft.api.HiddenItemMeta.restoreItemLore(itemstack.tag); // EMC - get around creative menu having ultimate control of the NBT...
                 if (itemstack.tag.hasKey("SkullOwnerOrig")) {
                     NBTTagCompound owner = itemstack.tag.getCompound("SkullOwner");
                     if (itemstack.tag.hasKey("SkullOwnerOrig")) {
diff --git a/src/main/java/net/minecraft/network/chat/ChatHoverable.java b/src/main/java/net/minecraft/network/chat/ChatHoverable.java
new file mode 100644
index 0000000000000000000000000000000000000000..f340cb40abfd8fcee8bb15713b47f27dfffc1737
--- /dev/null
+++ b/src/main/java/net/minecraft/network/chat/ChatHoverable.java
@@ -0,0 +1,331 @@
+package net.minecraft.network.chat;
+
+import com.google.common.collect.ImmutableMap;
+import com.google.gson.JsonElement;
+import com.google.gson.JsonObject;
+import com.google.gson.JsonSyntaxException;
+import com.mojang.brigadier.exceptions.CommandSyntaxException;
+import java.util.Map;
+import java.util.Objects;
+import java.util.UUID;
+import java.util.function.Function;
+import java.util.stream.Stream;
+import javax.annotation.Nullable;
+import net.minecraft.core.IRegistry;
+import net.minecraft.nbt.MojangsonParser;
+import net.minecraft.nbt.NBTTagCompound;
+import net.minecraft.resources.MinecraftKey;
+import net.minecraft.util.ChatDeserializer;
+import net.minecraft.world.entity.EntityTypes;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.ItemStack;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+public class ChatHoverable {
+
+    private static final Logger LOGGER = LogManager.getLogger();
+    private final ChatHoverable.EnumHoverAction<?> action; // EMC - OBFHELPER - decompile fix
+    private final Object value; // EMC - OBFHELPER - decompile fix
+
+    public <T> ChatHoverable(ChatHoverable.EnumHoverAction<T> chathoverable_enumhoveraction, T t0) {
+        this.action = chathoverable_enumhoveraction; // EMC - decompile fix
+        this.value = t0; // EMC - decompile fix
+    }
+
+    public ChatHoverable.EnumHoverAction<?> a() {
+        return this.action; // EMC - decompile fix
+    }
+
+    @Nullable
+    public <T> T a(ChatHoverable.EnumHoverAction<T> chathoverable_enumhoveraction) {
+        return this.action == chathoverable_enumhoveraction ? chathoverable_enumhoveraction.b(this.value) : null; // EMC - decompile fix
+    }
+
+    public boolean equals(Object object) {
+        if (this == object) {
+            return true;
+        } else if (object != null && this.getClass() == object.getClass()) {
+            ChatHoverable chathoverable = (ChatHoverable) object;
+
+            return this.action == chathoverable.action && Objects.equals(this.value, chathoverable.value); // EMC - decompile fix
+        } else {
+            return false;
+        }
+    }
+
+    public String toString() {
+        return "HoverEvent{action=" + this.action + ", value='" + this.value + '\'' + '}'; // EMC - decompile fix
+    }
+
+    public int hashCode() {
+        int i = this.action.hashCode(); // EMC - decompile fix
+
+        i = 31 * i + (this.value != null ? this.value.hashCode() : 0); // EMC - decompile fix
+        return i;
+    }
+
+    @Nullable
+    public static ChatHoverable a(JsonObject jsonobject) {
+        String s = ChatDeserializer.a(jsonobject, "action", (String) null);
+
+        if (s == null) {
+            return null;
+        } else {
+            ChatHoverable.EnumHoverAction<?> chathoverable_enumhoveraction = ChatHoverable.EnumHoverAction.a(s);
+
+            if (chathoverable_enumhoveraction == null) {
+                return null;
+            } else {
+                JsonElement jsonelement = jsonobject.get("contents");
+
+                if (jsonelement != null) {
+                    return chathoverable_enumhoveraction.a(jsonelement);
+                } else {
+                    IChatMutableComponent ichatmutablecomponent = IChatBaseComponent.ChatSerializer.a(jsonobject.get("value"));
+
+                    return ichatmutablecomponent != null ? chathoverable_enumhoveraction.a((IChatBaseComponent) ichatmutablecomponent) : null;
+                }
+            }
+        }
+    }
+
+    public JsonObject b() {
+        JsonObject jsonobject = new JsonObject();
+
+        jsonobject.addProperty("action", this.action.b()); // EMC - decompile fix
+        jsonobject.add("contents", this.action.a(this.value)); // EMC - decompile fix
+        return jsonobject;
+    }
+
+    public static class EnumHoverAction<T> {
+
+        public static final ChatHoverable.EnumHoverAction<IChatBaseComponent> SHOW_TEXT = new ChatHoverable.EnumHoverAction<>("show_text", true, IChatBaseComponent.ChatSerializer::a, IChatBaseComponent.ChatSerializer::b, Function.identity());
+        public static final ChatHoverable.EnumHoverAction<ChatHoverable.c> SHOW_ITEM = new ChatHoverable.EnumHoverAction<>("show_item", true, (jsonelement) -> {
+            return ChatHoverable.c.b(jsonelement);
+        }, (object) -> {
+            return ((ChatHoverable.c) object).b();
+        }, (ichatbasecomponent) -> {
+            return ChatHoverable.c.b(ichatbasecomponent);
+        });
+        public static final ChatHoverable.EnumHoverAction<ChatHoverable.b> SHOW_ENTITY = new ChatHoverable.EnumHoverAction<>("show_entity", true, ChatHoverable.b::a, ChatHoverable.b::a, ChatHoverable.b::a);
+        private static final Map<String, ChatHoverable.EnumHoverAction> d = (Map) Stream.of(ChatHoverable.EnumHoverAction.SHOW_TEXT, ChatHoverable.EnumHoverAction.SHOW_ITEM, ChatHoverable.EnumHoverAction.SHOW_ENTITY).collect(ImmutableMap.toImmutableMap(ChatHoverable.EnumHoverAction::b, (chathoverable_enumhoveraction) -> {
+            return chathoverable_enumhoveraction;
+        }));
+        private final String e;
+        private final boolean f;
+        private final Function<JsonElement, T> g;
+        private final Function<T, JsonElement> h;
+        private final Function<IChatBaseComponent, T> i;
+
+        public EnumHoverAction(String s, boolean flag, Function<JsonElement, T> function, Function<T, JsonElement> function1, Function<IChatBaseComponent, T> function2) {
+            this.e = s;
+            this.f = flag;
+            this.g = function;
+            this.h = function1;
+            this.i = function2;
+        }
+
+        public boolean a() {
+            return this.f;
+        }
+
+        public String b() {
+            return this.e;
+        }
+
+        @Nullable
+        public static ChatHoverable.EnumHoverAction a(String s) {
+            return (ChatHoverable.EnumHoverAction) ChatHoverable.EnumHoverAction.d.get(s);
+        }
+
+        private T b(Object object) {
+            return (T) object; // EMC - decompile fix
+        }
+
+        @Nullable
+        public ChatHoverable a(JsonElement jsonelement) {
+            T t0 = this.g.apply(jsonelement);
+
+            return t0 == null ? null : new ChatHoverable(this, t0);
+        }
+
+        @Nullable
+        public ChatHoverable a(IChatBaseComponent ichatbasecomponent) {
+            T t0 = this.i.apply(ichatbasecomponent);
+
+            return t0 == null ? null : new ChatHoverable(this, t0);
+        }
+
+        public JsonElement a(Object object) {
+            return (JsonElement) this.h.apply(this.b(object));
+        }
+
+        public String toString() {
+            return "<action " + this.e + ">";
+        }
+    }
+
+    public static class c {
+
+        private final Item a;
+        private final int b;
+        @Nullable
+        private final NBTTagCompound c;
+
+        public c(Item item, int i, @Nullable NBTTagCompound nbttagcompound) { // EMC - make public
+            this.a = item;
+            this.b = i;
+            this.c = nbttagcompound;
+        }
+
+        public c(ItemStack itemstack) {
+            this(itemstack.getItem(), itemstack.getCount(), itemstack.getTag() != null ? itemstack.getTag().clone() : null);
+        }
+
+        public boolean equals(Object object) {
+            if (this == object) {
+                return true;
+            } else if (object != null && this.getClass() == object.getClass()) {
+                ChatHoverable.c chathoverable_c = (ChatHoverable.c) object;
+
+                return this.b == chathoverable_c.b && this.a.equals(chathoverable_c.a) && Objects.equals(this.c, chathoverable_c.c);
+            } else {
+                return false;
+            }
+        }
+
+        public int hashCode() {
+            int i = this.a.hashCode();
+
+            i = 31 * i + this.b;
+            i = 31 * i + (this.c != null ? this.c.hashCode() : 0);
+            return i;
+        }
+
+        private static ChatHoverable.c b(JsonElement jsonelement) {
+            if (jsonelement.isJsonPrimitive()) {
+                return new ChatHoverable.c((Item) IRegistry.ITEM.get(new MinecraftKey(jsonelement.getAsString())), 1, (NBTTagCompound) null);
+            } else {
+                JsonObject jsonobject = ChatDeserializer.m(jsonelement, "item");
+                Item item = (Item) IRegistry.ITEM.get(new MinecraftKey(ChatDeserializer.h(jsonobject, "id")));
+                int i = ChatDeserializer.a(jsonobject, "count", (int) 1);
+
+                if (jsonobject.has("tag")) {
+                    String s = ChatDeserializer.h(jsonobject, "tag");
+
+                    try {
+                        NBTTagCompound nbttagcompound = MojangsonParser.parse(s);
+
+                        return new ChatHoverable.c(item, i, nbttagcompound);
+                    } catch (CommandSyntaxException commandsyntaxexception) {
+                        ChatHoverable.LOGGER.warn("Failed to parse tag: {}", s, commandsyntaxexception);
+                    }
+                }
+
+                return new ChatHoverable.c(item, i, (NBTTagCompound) null);
+            }
+        }
+
+        @Nullable
+        private static ChatHoverable.c b(IChatBaseComponent ichatbasecomponent) {
+            try {
+                NBTTagCompound nbttagcompound = MojangsonParser.parse(ichatbasecomponent.getString());
+
+                return new ChatHoverable.c(ItemStack.a(nbttagcompound));
+            } catch (CommandSyntaxException commandsyntaxexception) {
+                ChatHoverable.LOGGER.warn("Failed to parse item tag: {}", ichatbasecomponent, commandsyntaxexception);
+                return null;
+            }
+        }
+
+        private JsonElement b() {
+            JsonObject jsonobject = new JsonObject();
+
+            jsonobject.addProperty("id", IRegistry.ITEM.getKey(this.a).toString());
+            if (this.b != 1) {
+                jsonobject.addProperty("count", this.b);
+            }
+
+            if (this.c != null) {
+                jsonobject.addProperty("tag", this.c.toString());
+            }
+
+            return jsonobject;
+        }
+    }
+
+    public static class b {
+
+        public final EntityTypes<?> a;
+        public final UUID b;
+        @Nullable
+        public final IChatBaseComponent c;
+
+        public b(EntityTypes<?> entitytypes, UUID uuid, @Nullable IChatBaseComponent ichatbasecomponent) {
+            this.a = entitytypes;
+            this.b = uuid;
+            this.c = ichatbasecomponent;
+        }
+
+        @Nullable
+        public static ChatHoverable.b a(JsonElement jsonelement) {
+            if (!jsonelement.isJsonObject()) {
+                return null;
+            } else {
+                JsonObject jsonobject = jsonelement.getAsJsonObject();
+                EntityTypes<?> entitytypes = (EntityTypes) IRegistry.ENTITY_TYPE.get(new MinecraftKey(ChatDeserializer.h(jsonobject, "type")));
+                UUID uuid = UUID.fromString(ChatDeserializer.h(jsonobject, "id"));
+                IChatMutableComponent ichatmutablecomponent = IChatBaseComponent.ChatSerializer.a(jsonobject.get("name"));
+
+                return new ChatHoverable.b(entitytypes, uuid, ichatmutablecomponent);
+            }
+        }
+
+        @Nullable
+        public static ChatHoverable.b a(IChatBaseComponent ichatbasecomponent) {
+            try {
+                NBTTagCompound nbttagcompound = MojangsonParser.parse(ichatbasecomponent.getString());
+                IChatMutableComponent ichatmutablecomponent = IChatBaseComponent.ChatSerializer.a(nbttagcompound.getString("name"));
+                EntityTypes<?> entitytypes = (EntityTypes) IRegistry.ENTITY_TYPE.get(new MinecraftKey(nbttagcompound.getString("type")));
+                UUID uuid = UUID.fromString(nbttagcompound.getString("id"));
+
+                return new ChatHoverable.b(entitytypes, uuid, ichatmutablecomponent);
+            } catch (CommandSyntaxException | JsonSyntaxException jsonsyntaxexception) {
+                return null;
+            }
+        }
+
+        public JsonElement a() {
+            JsonObject jsonobject = new JsonObject();
+
+            jsonobject.addProperty("type", IRegistry.ENTITY_TYPE.getKey(this.a).toString());
+            jsonobject.addProperty("id", this.b.toString());
+            if (this.c != null) {
+                jsonobject.add("name", IChatBaseComponent.ChatSerializer.b(this.c));
+            }
+
+            return jsonobject;
+        }
+
+        public boolean equals(Object object) {
+            if (this == object) {
+                return true;
+            } else if (object != null && this.getClass() == object.getClass()) {
+                ChatHoverable.b chathoverable_b = (ChatHoverable.b) object;
+
+                return this.a.equals(chathoverable_b.a) && this.b.equals(chathoverable_b.b) && Objects.equals(this.c, chathoverable_b.c);
+            } else {
+                return false;
+            }
+        }
+
+        public int hashCode() {
+            int i = this.a.hashCode();
+
+            i = 31 * i + this.b.hashCode();
+            i = 31 * i + (this.c != null ? this.c.hashCode() : 0);
+            return i;
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/world/item/ItemStack.java b/src/main/java/net/minecraft/world/item/ItemStack.java
index fee862951f2767d4a3c5268dff157c185378a939..e2570c74c2574eea5ea471ccfa70ea034ee6d53e 100644
--- a/src/main/java/net/minecraft/world/item/ItemStack.java
+++ b/src/main/java/net/minecraft/world/item/ItemStack.java
@@ -944,8 +944,26 @@ public final class ItemStack {
         IChatMutableComponent ichatmutablecomponent1 = ChatComponentUtils.a((IChatBaseComponent) ichatmutablecomponent);
 
         if (!this.j) {
+            // EMC start
+            NBTTagCompound nbttagcompound = this.save(new NBTTagCompound());
+            if (nbttagcompound.hasKey("tag")) {
+                NBTTagCompound tag = com.empireminecraft.api.HiddenItemMeta.filterItemLore(nbttagcompound.getCompound("tag"), false);
+                NBTTagCompound display = tag.getCompound("display");
+                if (display.hasKey("Lore")) {
+                    NBTTagList lore = display.getList("Lore", 8);
+                    NBTTagList newlore = new NBTTagList();
+                    for (int i = 0; i < lore.size(); i++) {
+                        String line = lore.getString(i);
+                        String newline = (line.isEmpty() ? " " : line);
+                        newlore.add(NBTTagString.a(newline));
+                    }
+                    display.set("Lore", newlore);
+                }
+                nbttagcompound.set("tag", tag);
+            }
+            // EMC end
             ichatmutablecomponent1.a(this.v().e).format((chatmodifier) -> {
-                return chatmodifier.setChatHoverable(new ChatHoverable(ChatHoverable.EnumHoverAction.SHOW_ITEM, new ChatHoverable.c(this)));
+                return chatmodifier.setChatHoverable(new ChatHoverable(ChatHoverable.EnumHoverAction.SHOW_ITEM, new ChatHoverable.c(this.getItem(), this.getCount(), tag))); // EMC - use different constructor
             });
         }
 
