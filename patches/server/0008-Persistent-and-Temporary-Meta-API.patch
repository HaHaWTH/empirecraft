From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Aikar <aikar@aikar.co>
Date: Mon, 4 Mar 2013 23:35:02 -0500
Subject: [PATCH] Persistent and Temporary Meta API

---
 .../empireminecraft/api/CraftEmpireAPI.java   |   3 +
 .../api/meta/CraftEAPI_Meta.java              |  80 +++
 src/main/java/net/minecraft/server/Chunk.java |   2 +
 .../minecraft/server/ChunkRegionLoader.java   |   3 +
 .../net/minecraft/server/Convertable.java     |   7 +-
 .../java/net/minecraft/server/Entity.java     |   3 +
 .../net/minecraft/server/MetaApiAccessor.java | 577 ++++++++++++++++++
 .../server/PacketPlayOutMapChunk.java         |   1 +
 .../server/PacketPlayOutTileEntityData.java   |   1 +
 .../net/minecraft/server/PlayerChunkMap.java  |   1 +
 .../java/net/minecraft/server/ProtoChunk.java |   2 +
 .../minecraft/server/ProtoChunkExtension.java |   1 +
 .../java/net/minecraft/server/TileEntity.java |   3 +
 src/main/java/net/minecraft/server/World.java |   1 +
 .../net/minecraft/server/WorldDataServer.java |   3 +-
 .../net/minecraft/server/WorldServer.java     |   2 +-
 .../org/bukkit/craftbukkit/CraftChunk.java    |   2 +
 .../org/bukkit/craftbukkit/CraftServer.java   |   3 +
 .../block/CraftBlockEntityState.java          |   7 +
 .../craftbukkit/block/CraftBlockState.java    |   7 +
 .../craftbukkit/entity/CraftEntity.java       |   2 +
 .../craftbukkit/event/CraftEventFactory.java  |   5 +
 .../craftbukkit/inventory/CraftInventory.java |  11 +
 23 files changed, 724 insertions(+), 3 deletions(-)
 create mode 100644 src/main/java/com/empireminecraft/api/meta/CraftEAPI_Meta.java
 create mode 100644 src/main/java/net/minecraft/server/MetaApiAccessor.java

diff --git a/src/main/java/com/empireminecraft/api/CraftEmpireAPI.java b/src/main/java/com/empireminecraft/api/CraftEmpireAPI.java
index 7b295bc869fd8fac878fd25fdcd3f03422fc8e63..f3c9419c8148e389f7d9f2e24a8664b1cb2bbfde 100644
--- a/src/main/java/com/empireminecraft/api/CraftEmpireAPI.java
+++ b/src/main/java/com/empireminecraft/api/CraftEmpireAPI.java
@@ -23,6 +23,8 @@
 
 package com.empireminecraft.api;
 
+import com.empireminecraft.api.meta.CraftEAPI_Meta;
+
 public final class CraftEmpireAPI extends API {
 
     private CraftEmpireAPI() {}
@@ -31,6 +33,7 @@ public final class CraftEmpireAPI extends API {
     static {
         entity = new CraftEAPI_Entity();
         misc = new CraftEAPI_Misc();
+        meta = new CraftEAPI_Meta();
     }
 
 }
diff --git a/src/main/java/com/empireminecraft/api/meta/CraftEAPI_Meta.java b/src/main/java/com/empireminecraft/api/meta/CraftEAPI_Meta.java
new file mode 100644
index 0000000000000000000000000000000000000000..a9a194b3a78401454817350f7fa7190a1980dd82
--- /dev/null
+++ b/src/main/java/com/empireminecraft/api/meta/CraftEAPI_Meta.java
@@ -0,0 +1,80 @@
+/*
+ * Copyright (c) 2016 Starlis LLC / Daniel Ennis (Aikar) - MIT License
+ *
+ *  Permission is hereby granted, free of charge, to any person obtaining
+ *  a copy of this software and associated documentation files (the
+ *  "Software"), to deal in the Software without restriction, including
+ *  without limitation the rights to use, copy, modify, merge, publish,
+ *  distribute, sublicense, and/or sell copies of the Software, and to
+ *  permit persons to whom the Software is furnished to do so, subject to
+ *  the following conditions:
+ *
+ *  The above copyright notice and this permission notice shall be
+ *  included in all copies or substantial portions of the Software.
+ *
+ *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ *  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ *  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ *  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ *  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ *  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ *  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.empireminecraft.api.meta;
+
+import com.empireminecraft.api.Vector3i;
+import net.minecraft.server.MetaApiAccessor;
+import org.bukkit.Chunk;
+import org.bukkit.Location;
+import org.bukkit.World;
+import org.bukkit.block.Block;
+import org.bukkit.block.BlockState;
+import org.bukkit.craftbukkit.CraftChunk;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.entity.Entity;
+
+import java.util.Map;
+
+public class CraftEAPI_Meta implements EAPI_Meta {
+
+    @Override
+    public PersistentMetaMap getTileEntityMetaMap(BlockState tileEntity, boolean isWrite) {
+        return MetaApiAccessor.getTileEntityMetaMap(tileEntity, isWrite);
+    }
+
+    @Override
+    public PersistentMetaMap getBlockMetaMap(Location loc, boolean isWrite) {
+        return MetaApiAccessor.getBlockMetaMap(loc, isWrite);
+    }
+
+    @Override
+    public PersistentMetaMap getChunkMetaMap(Chunk chunk, boolean isWrite) {
+        return MetaApiAccessor.getChunkMetaMap(chunk, isWrite);
+    }
+
+    @Override
+    public TempMetaMap getChunkTempMetaMap(Chunk chunk, boolean isWrite) {
+        return chunk.getTempMeta();
+    }
+
+    @Override
+    public Map<Vector3i, PersistentMetaMap> getChunkMetaData(Chunk chunk) {
+        return ((CraftChunk) chunk).getHandle().chunkMeta;
+    }
+
+    @Override
+    public PersistentMetaMap getEntityMetaMap(Entity entity, boolean isWrite) {
+        return MetaApiAccessor.getEntityMetaMap(entity, isWrite);
+    }
+
+    @Override
+    public PersistentMetaMap getWorldMetaMap(World world) {
+        return MetaApiAccessor.getWorldMetaMap((CraftWorld) world);
+    }
+
+    @Override
+    public Map<String, Object> getBlockTempMeta(Block block, boolean isWrite) {
+        return MetaApiAccessor.getChunkTempMeta(block, isWrite);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Chunk.java b/src/main/java/net/minecraft/server/Chunk.java
index af9d54ef057d5f6977cf77c57cde25b6b0d1f39d..9d38f0e5d4924891a7338752e46b8d19d9fc35b1 100644
--- a/src/main/java/net/minecraft/server/Chunk.java
+++ b/src/main/java/net/minecraft/server/Chunk.java
@@ -141,6 +141,8 @@ public class Chunk implements IChunkAccess {
         return bukkitChunk;
     }
 
+    public MetaApiAccessor.ChunkPersistentMeta chunkMeta; // EMC
+    public MetaApiAccessor.ChunkTempMeta chunkTempMeta = new MetaApiAccessor.ChunkTempMeta(); // EMC
     public boolean mustNotSave;
     public boolean needsDecoration;
 
diff --git a/src/main/java/net/minecraft/server/ChunkRegionLoader.java b/src/main/java/net/minecraft/server/ChunkRegionLoader.java
index 8e7da2c5f3852920ec5fbcdd2bff4d299e6aa499..0014e22973a0ace170941d62d1dfb7015f2ca19d 100644
--- a/src/main/java/net/minecraft/server/ChunkRegionLoader.java
+++ b/src/main/java/net/minecraft/server/ChunkRegionLoader.java
@@ -1,6 +1,7 @@
 package net.minecraft.server;
 
 import co.aikar.timings.Timings;
+import com.empireminecraft.api.API;
 import com.google.common.collect.Maps;
 import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
 import it.unimi.dsi.fastutil.longs.LongSet;
@@ -214,6 +215,7 @@ public class ChunkRegionLoader {
         }
 
         HeightMap.a((IChunkAccess) object, enumset);
+        MetaApiAccessor.loadChunkMetaNbt(nbttagcompound1, (IChunkAccess) object); // EMC
         NBTTagCompound nbttagcompound4 = nbttagcompound1.getCompound("Structures");
 
         ((IChunkAccess) object).a(a(definedstructuremanager, nbttagcompound4, worldserver.getSeed()));
@@ -404,6 +406,7 @@ public class ChunkRegionLoader {
         nbttagcompound.set("Level", nbttagcompound1);
         nbttagcompound1.setInt("xPos", chunkcoordintpair.x);
         nbttagcompound1.setInt("zPos", chunkcoordintpair.z);
+        MetaApiAccessor.saveChunkMetaNbt(nbttagcompound1, ichunkaccess); // EMC
         nbttagcompound1.setLong("LastUpdate", asyncsavedata != null ? asyncsavedata.worldTime : worldserver.getTime()); // Paper - async chunk unloading
         nbttagcompound1.setLong("InhabitedTime", ichunkaccess.getInhabitedTime());
         nbttagcompound1.setString("Status", ichunkaccess.getChunkStatus().d());
diff --git a/src/main/java/net/minecraft/server/Convertable.java b/src/main/java/net/minecraft/server/Convertable.java
index 786d90c635310788eaabc1e211975f003dd3ce22..9a1def67eae7d12af14192a0d5d16f9d1f95caf5 100644
--- a/src/main/java/net/minecraft/server/Convertable.java
+++ b/src/main/java/net/minecraft/server/Convertable.java
@@ -158,7 +158,12 @@ public class Convertable {
                 LevelVersion levelversion = LevelVersion.a(dynamic);
                 WorldSettings worldsettings = WorldSettings.a(dynamic, datapackconfiguration);
 
-                return WorldDataServer.a(dynamic, datafixer, i, nbttagcompound2, worldsettings, levelversion, (GeneratorSettings) pair.getFirst(), (Lifecycle) pair.getSecond());
+                // EMC start
+                WorldDataServer worldDataServer = WorldDataServer.a(dynamic, datafixer, i, nbttagcompound2, worldsettings, levelversion, (GeneratorSettings) pair.getFirst(),
+                    (Lifecycle) pair.getSecond());
+                MetaApiAccessor.loadWorldMeta(worldDataServer, nbttagcompound1); // Should be Data
+                return worldDataServer;
+                // EMC end
             } catch (Exception exception) {
                 Convertable.LOGGER.error("Exception reading {}", file, exception);
                 return null;
diff --git a/src/main/java/net/minecraft/server/Entity.java b/src/main/java/net/minecraft/server/Entity.java
index 36fbe16e6f06fca3eb282cce5b8c5fcc87a0166d..aaf27f9f4f90ba32aeaeae4561ec5a46883cf63b 100644
--- a/src/main/java/net/minecraft/server/Entity.java
+++ b/src/main/java/net/minecraft/server/Entity.java
@@ -53,6 +53,7 @@ import org.bukkit.plugin.PluginManager;
 public abstract class Entity implements INamableTileEntity, ICommandListener, KeyedObject { // Paper
 
     // CraftBukkit start
+    public com.empireminecraft.api.meta.PersistentMetaMap metaMap = null; // EMC
     private static final int CURRENT_LEVEL = 2;
     boolean preserveMotion = true; // Paper - keep initial motion on first setPositionRotation
     static boolean isLevelAtLeast(NBTTagCompound tag, int level) {
@@ -1540,6 +1541,7 @@ public abstract class Entity implements INamableTileEntity, ICommandListener, Ke
                 this.yaw = 0;
             }
 
+            MetaApiAccessor.saveEntityMeta(this, nbttagcompound); // EMC
             if (Float.isNaN(this.pitch)) {
                 this.pitch = 0;
             }
@@ -1768,6 +1770,7 @@ public abstract class Entity implements INamableTileEntity, ICommandListener, Ke
             // CraftBukkit end
 
             // Paper start - Restore the entity's origin location
+            MetaApiAccessor.loadEntityMeta(this, nbttagcompound); // EMC
             NBTTagList originTag = nbttagcompound.getList("Paper.Origin", 6);
             if (!originTag.isEmpty()) {
                 origin = new org.bukkit.Location(world.getWorld(), originTag.getDoubleAt(0), originTag.getDoubleAt(1), originTag.getDoubleAt(2));
diff --git a/src/main/java/net/minecraft/server/MetaApiAccessor.java b/src/main/java/net/minecraft/server/MetaApiAccessor.java
new file mode 100644
index 0000000000000000000000000000000000000000..9c70d55d904fce65493d68a98a10dc33395b1f53
--- /dev/null
+++ b/src/main/java/net/minecraft/server/MetaApiAccessor.java
@@ -0,0 +1,577 @@
+package net.minecraft.server;
+
+import org.bukkit.Bukkit;
+import com.empireminecraft.api.Vector3i;
+import com.empireminecraft.api.meta.PersistentMetaList;
+import com.empireminecraft.api.meta.PersistentMetaMap;
+import com.empireminecraft.customevents.BlockWithPersistentMetaClearedEvent;
+import org.bukkit.Location;
+import org.bukkit.block.Block;
+import org.bukkit.craftbukkit.CraftChunk;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.craftbukkit.block.CraftBlockState;
+import org.bukkit.craftbukkit.entity.CraftEntity;
+import org.bukkit.craftbukkit.inventory.CraftItemStack;
+import org.bukkit.entity.Player;
+
+import java.util.*;
+import java.util.Map.Entry;
+import java.util.regex.Pattern;
+
+public final class MetaApiAccessor {
+
+    private static final String META_MAP = "MetaMap";
+    private static final String META_TYPE = "MetaType";
+    private static final String ITEM = "Item";
+    private static final String ENTITY_META = "_EntityMeta";
+    private static final String TILEENTITY_META = "_TileEntityMeta";
+    private static final String WORLD_META = "_WorldMeta";
+    private static final String CHUNK_META_LIST = "_ChunkMetaList";
+    private static final String BLOCK_POS = "_BlockPos";
+    private static final String CHUNK_META = "_ChunkMeta";
+
+    private MetaApiAccessor() {}
+
+    public static PersistentMetaMap getWorldMetaMap(CraftWorld world) {
+        return ((WorldDataServer) world.getHandle().worldData).metaMap;
+    }
+
+    public static PersistentMetaMap getTileEntityMetaMap(org.bukkit.block.BlockState block, boolean isWrite) {
+        final CraftBlockState craftBlock = (CraftBlockState) block;
+        final TileEntity tileEntity = ((CraftWorld) craftBlock.getWorld()).getHandle().getTileEntity(MCUtil.toBlockPosition(craftBlock.getLocation()));
+        if (tileEntity == null) {
+            return null;
+        }
+        if (tileEntity.metaMap == null && isWrite) {
+            tileEntity.metaMap = new PersistentMetaMap();
+        }
+        return tileEntity.metaMap;
+    }
+
+    /**
+     * Util for getting a MetaMap by location
+     * @param loc
+     * @return
+     */
+    public static PersistentMetaMap getBlockMetaMap(org.bukkit.Location loc, boolean isWrite) {
+        return getBlockMetaMap(((CraftChunk) loc.getChunk()).getHandle(), loc.getBlockX(), loc.getBlockY(), loc.getBlockZ(), isWrite);
+    }
+
+    /**
+     * Util for getting a MetaMap for a chunk
+     * @param chunk
+     * @return
+     */
+    public static PersistentMetaMap getChunkMetaMap(org.bukkit.Chunk chunk, boolean isWrite) {
+        return getBlockMetaMap(((CraftChunk) chunk).getHandle(), 0, -1, 0, isWrite);
+    }
+
+    /**
+     * Gets the metamap for the specified coords, creating it if it doesnt exists
+     * @param handle
+     * @param x
+     * @param y
+     * @param z
+     * @return
+     */
+    private static PersistentMetaMap getBlockMetaMap(Chunk handle, int x, int y, int z, boolean isWrite) {
+        ChunkPersistentMeta meta = handle.chunkMeta;
+        if (meta == null) {
+            if (!isWrite) {
+                return null;
+            }
+            meta = handle.chunkMeta = new ChunkPersistentMeta();
+        }
+        Vector3i coords = new Vector3i(x, y, z);
+        if (!isWrite && !meta.containsKey(coords)) {
+            return null;
+        }
+        PersistentMetaMap ret = meta.get(coords);
+        if (ret == null) {
+            if (isWrite) {
+                ret = new PersistentMetaMap();
+                meta.put(coords, ret);
+            }
+        }
+        return ret;
+    }
+
+    /**
+     * Util for getting a MetaMap for an Entity
+     * @param craftentity
+     * @return
+     */
+    public static PersistentMetaMap getEntityMetaMap(org.bukkit.entity.Entity craftentity, boolean isWrite) {
+        Entity entity = ((CraftEntity) craftentity).getHandle();
+        if (entity.metaMap == null) {
+            if (isWrite) {
+                entity.metaMap = new PersistentMetaMap();
+            }
+        }
+        return entity.metaMap;
+    }
+
+    static void loadEntityMeta(Entity entity, NBTTagCompound nbt) {
+        if (nbt.hasKey(ENTITY_META)) {
+            entity.metaMap = getMetaMapFromCompound(nbt.getCompound(ENTITY_META));
+        }
+    }
+
+    static void saveEntityMeta(Entity entity, NBTTagCompound nbt) {
+        if (entity.metaMap != null && !entity.metaMap.isEmpty()) {
+            nbt.set(ENTITY_META, getNbtFromObject(entity.metaMap));
+        }
+    }
+
+    static void loadTileEntityMeta(TileEntity tileEntity, NBTTagCompound nbt) {
+        if (nbt.hasKey(TILEENTITY_META)) {
+            tileEntity.metaMap = getMetaMapFromCompound(nbt.getCompound(TILEENTITY_META));
+        }
+    }
+
+    static void saveTileEntityMeta(TileEntity tileEntity, NBTTagCompound nbt) {
+        if (tileEntity.metaMap != null && !tileEntity.metaMap.isEmpty()) {
+            nbt.set(TILEENTITY_META, getNbtFromObject(tileEntity.metaMap));
+        }
+    }
+
+    static void loadWorldMeta(WorldDataServer world, NBTTagCompound nbt) {
+        if (nbt.hasKey(WORLD_META)) {
+            NBTTagCompound nbtmeta = nbt.getCompound(WORLD_META);
+            world.metaMap = getMetaMapFromCompound(nbtmeta);
+        }
+        if (world.metaMap == null) {
+            world.metaMap = new PersistentMetaMap();
+        }
+    }
+
+    static void saveWorldMeta(WorldDataServer worldData, NBTTagCompound nbt) {
+        if (worldData.metaMap != null && !worldData.metaMap.isEmpty()) {
+            NBTBase nbtmeta = getNbtFromObject(worldData.metaMap);
+            nbt.set(WORLD_META, nbtmeta);
+        }
+    }
+
+    /**
+     * Saves this chunks Meta Data into NBT
+     * @param cmp
+     * @param chunkAccess
+     */
+    static void saveChunkMetaNbt(NBTTagCompound cmp, IChunkAccess chunkAccess) {
+        Chunk chunk = null;
+        if (chunkAccess instanceof Chunk) {
+            chunk = (Chunk) chunkAccess;
+        } else if (chunkAccess instanceof PlayerChunk) {
+            chunk = ((PlayerChunk) chunkAccess).getChunk();
+        } else if (chunkAccess instanceof ProtoChunkExtension) {
+            chunk = ((ProtoChunkExtension) chunkAccess).getChunk();
+        } else if (chunkAccess instanceof ProtoChunk) {
+            saveChunkMetaNbt(cmp, (ProtoChunk) chunkAccess);
+            return;
+        }
+        if (chunk == null) throw new IllegalArgumentException("Failed to get chunk to save meta for");
+        saveChunkMetaNbt(cmp, chunk);
+    }
+
+    /**
+     * Saves this chunks Meta Data into NBT
+     * @param cmp
+     * @param chunk
+     */
+    static void saveChunkMetaNbt(NBTTagCompound cmp, Chunk chunk) {
+        if (chunk.chunkMeta == null || chunk.chunkMeta.isEmpty()) {
+            return;
+        }
+        NBTTagList meta = new NBTTagList();
+        for (Map.Entry<Vector3i, PersistentMetaMap> entry : chunk.chunkMeta.entrySet()) {
+            PersistentMetaMap list = entry.getValue();
+            if (!list.isEmpty()) {
+                NBTTagCompound pos = serializePos(entry.getKey());
+                NBTTagCompound metacmp = getCompoundFromMetaMap(list);
+                metacmp.set(BLOCK_POS, pos);
+                meta.add(metacmp);
+            }
+        }
+
+        if (!meta.isEmpty()) {
+            cmp.set(CHUNK_META_LIST, meta);
+        }
+    }
+
+    /**
+     * Saves this protoChunk's Meta Data into NBT
+     * @param cmp
+     * @param protoChunk
+     */
+    static void saveChunkMetaNbt(NBTTagCompound cmp, ProtoChunk protoChunk) {
+        if (protoChunk.chunkMeta != null) {
+            cmp.set(CHUNK_META, protoChunk.chunkMeta);
+        } else if (protoChunk.chunkMetaList != null) {
+            cmp.set(CHUNK_META_LIST, protoChunk.chunkMetaList);
+        }
+    }
+
+    /**
+     * Loads this chunks Meta Data from NBT
+     * @param cmp
+     * @param chunkAccess
+     */
+    static void loadChunkMetaNbt(NBTTagCompound cmp, IChunkAccess chunkAccess) {
+        Chunk chunk = null;
+        if (chunkAccess instanceof Chunk) {
+            chunk = (Chunk) chunkAccess;
+        } else if (chunkAccess instanceof PlayerChunk) {
+            chunk = ((PlayerChunk) chunkAccess).getChunk();
+        } else if (chunkAccess instanceof ProtoChunkExtension) {
+            chunk = ((ProtoChunkExtension) chunkAccess).getChunk();
+        } else if (chunkAccess instanceof ProtoChunk) {
+            storeChunkMetaNbt(cmp, (ProtoChunk) chunkAccess);
+            return;
+        }
+        if (chunk == null) throw new IllegalArgumentException("Failed to get chunk to load meta for");
+        loadChunkMetaNbt(cmp, chunk);
+    }
+
+    /**
+     * Save the chunk Meta Data to be loaded later
+     * @param cmp
+     * @param protoChunk
+     */
+    static void storeChunkMetaNbt(NBTTagCompound cmp, ProtoChunk protoChunk) {
+        if (cmp.hasKey(CHUNK_META)) {
+            protoChunk.chunkMeta = cmp.getCompound(CHUNK_META);
+        } else if (cmp.hasKey(CHUNK_META_LIST)) {
+            protoChunk.chunkMetaList = cmp.getList(CHUNK_META_LIST, 10);
+        }
+    }
+
+    /**
+     * Loads this chunks Meta Data from NBT
+     * @param cmp
+     * @param chunk
+     */
+    static void loadChunkMetaNbt(NBTTagCompound cmp, Chunk chunk) {
+        if (cmp.hasKey(CHUNK_META)) {
+            loadChunkMeta(cmp.getCompound(CHUNK_META), chunk);
+        } else if (cmp.hasKey(CHUNK_META_LIST)) {
+            loadChunkMetaList(cmp.getList(CHUNK_META_LIST, 10), chunk);
+        }
+    }
+
+    /**
+     * Loads this chunks Meta Data from a ProtoChunk
+     * @param protoChunk
+     * @param chunk
+     */
+    static void loadChunkMetaNbt(ProtoChunk protoChunk, Chunk chunk) {
+        if (protoChunk.chunkMeta != null) {
+            loadChunkMeta(protoChunk.chunkMeta, chunk);
+        } else if (protoChunk.chunkMetaList != null) {
+            loadChunkMetaList(protoChunk.chunkMetaList, chunk);
+        }
+    }
+
+    private static void loadChunkMeta(NBTTagCompound chunkMeta, Chunk chunk) {
+        ChunkPersistentMeta meta = chunk.chunkMeta;
+        for (String key : chunkMeta.getKeys()) {
+            NBTTagCompound e = chunkMeta.getCompound(key);
+            meta = loadBlockMeta(meta, deserializeOldLoc(key), e);
+        }
+        chunk.chunkMeta = meta;
+    }
+
+    private static void loadChunkMetaList(NBTTagList chunkMeta, Chunk chunk) {
+        ChunkPersistentMeta meta = chunk.chunkMeta;
+        final int size = chunkMeta.size();
+        for (int i = 0; i < size; i++) {
+            NBTTagCompound e = chunkMeta.getCompound(i);
+            if (e.hasKey(BLOCK_POS)) {
+                NBTTagCompound blockPos = e.getCompound(BLOCK_POS);
+                meta = loadBlockMeta(meta, getBlockPosFromCompound(blockPos), e);
+            }
+        }
+        chunk.chunkMeta = meta;
+    }
+
+    private static ChunkPersistentMeta loadBlockMeta(ChunkPersistentMeta meta, Vector3i key, NBTTagCompound e) {
+        PersistentMetaMap map = getMetaMapFromCompound(e);
+        if (map != null && !map.isEmpty()) {
+            if (meta == null) {
+                meta = new ChunkPersistentMeta();
+            }
+            meta.put(key, map);
+        }
+        return meta;
+    }
+
+    private static Vector3i getBlockPosFromCompound(NBTTagCompound pos) {
+        return new Vector3i(pos.getInt("x"), pos.getInt("y"), pos.getInt("z"));
+    }
+
+    /**
+     * Converts an Object into NBT
+     * @param value
+     * @return
+     */
+    private static NBTBase getNbtFromObject(Object value) {
+        if (value == null) {
+            return null;
+        }
+        if (value instanceof String) {
+            return NBTTagString.a((String) value);
+        } else if (value instanceof ItemStack || value instanceof org.bukkit.inventory.ItemStack) {
+            ItemStack item;
+            if (value instanceof org.bukkit.inventory.ItemStack) {
+                item = CraftItemStack.asNMSCopy((org.bukkit.inventory.ItemStack) value);
+            } else {
+                item = (ItemStack) value;
+            }
+            if (item == null) {
+                return null;
+            }
+            NBTTagCompound itemnbt = new NBTTagCompound();
+            itemnbt.setString(META_TYPE, ITEM);
+            itemnbt.setInt("DataVersion", DataConverters.DATA_VERSION);
+            return item.save(itemnbt);
+        } else if (value instanceof Long) {
+            return NBTTagLong.a((Long) value);
+        } else if (value instanceof Integer) {
+            return NBTTagInt.a((Integer) value);
+        } else if (value instanceof Double) {
+            return NBTTagDouble.a((Double) value);
+        } else if (value instanceof Float) {
+            return NBTTagFloat.a((Float) value);
+        } else if (value instanceof PersistentMetaMap) {
+            return getCompoundFromMetaMap((PersistentMetaMap) value);
+        } else if (value instanceof PersistentMetaList) {
+            NBTTagList list = new NBTTagList();
+            for (Object obj : (Iterable<?>) value) {
+                NBTBase add = getNbtFromObject(obj);
+                if (add != null) {
+                    list.add(add);
+                }
+            }
+            return list.isEmpty() ? null : list;
+        }
+
+        return null;
+    }
+
+    /**
+     * Converts NBT into an Object
+     * @param nbt
+     * @return
+     */
+    @SuppressWarnings("RedundantCast")
+    private static Object getObjectFromNbt(NBTBase nbt) {
+        if (nbt == null) {
+            return null;
+        }
+        if (nbt instanceof NBTTagString) {
+            return (String) nbt.asString();
+            // Redundant casts added to each number so that it will fail to compile
+            // If the method names change for each type. Do not remove.
+        } else if (nbt instanceof NBTTagInt) {
+            return (Integer) ((NBTNumber) nbt).asInt();
+        } else if (nbt instanceof NBTTagLong) {
+            return (Long) ((NBTNumber) nbt).asLong();
+        } else if (nbt instanceof NBTTagFloat) {
+            return (Float) ((NBTNumber) nbt).asFloat();
+        } else if (nbt instanceof NBTTagDouble) {
+            return (Double) ((NBTNumber) nbt).asDouble();
+        } else if (nbt instanceof NBTTagList) {
+            NBTTagList nbtlist = (NBTTagList) nbt;
+            if (nbtlist.isEmpty()) {
+                return null;
+            }
+            PersistentMetaList<Object> list = new PersistentMetaList<>();
+            for (int i = 0; i < nbtlist.size(); i++) {
+                final Object obj = getObjectFromNbt(nbtlist.get(i));
+                if (obj != null) {
+                    list.add(obj);
+                }
+            }
+            return list.isEmpty() ? null : list;
+        } else if (nbt instanceof NBTTagCompound) {
+            NBTTagCompound cmp = (NBTTagCompound) nbt.clone();
+            if (cmp.hasKey(META_TYPE)) {
+                String type = cmp.getString(META_TYPE);
+                cmp.remove(META_TYPE);
+                if (ITEM.equals(type)) {
+                    int version = cmp.hasKey("DataVersion") ? cmp.getInt("DataVersion") : -1;
+                    cmp = DataConverters.convert(DataConverterTypes.ITEM_STACK, cmp, version);
+                    return CraftItemStack.asCraftMirror(ItemStack.a(cmp));
+                } else if (META_MAP.equals(type)) {
+                    final PersistentMetaMap metaMap = getMetaMapFromCompound(cmp);
+                    if (metaMap == null || metaMap.isEmpty()) {
+                        return null;
+                    }
+                    return metaMap;
+                }
+            }
+        }
+        return null;
+    }
+
+    /**
+     * Converts a NBTTagCompound to a MetaMap
+     * @param cmp
+     * @return
+     */
+    private static PersistentMetaMap getMetaMapFromCompound(NBTTagCompound cmp) {
+        if (cmp.map.isEmpty()) {
+            return null;
+        }
+        PersistentMetaMap map = new PersistentMetaMap();
+        for (Entry<String, NBTBase> entry : cmp.map.entrySet()) {
+            final Object metaData = getObjectFromNbt(entry.getValue());
+            if (metaData != null) {
+                map.put(entry.getKey(), metaData);
+            }
+        }
+        return map;
+    }
+
+    /**
+     * Converts a MetaMap into an NBTTagCompount
+     * @param map
+     * @return
+     */
+    private static NBTTagCompound getCompoundFromMetaMap(PersistentMetaMap map) {
+        NBTTagCompound cmp = new NBTTagCompound();
+        if (map.isEmpty()) {
+            return cmp;
+        }
+        cmp.setString(META_TYPE, META_MAP);
+        for (Map.Entry<String, Object> entry : map.entrySet()) {
+            NBTBase add = getNbtFromObject(entry.getValue());
+            if (add != null) {
+                cmp.set(entry.getKey(), add);
+            }
+        }
+        return cmp;
+    }
+
+    /**
+     * Translates BlockPos to a String form
+     * @param coords
+     * @return
+     */
+    private static NBTTagCompound serializePos(Vector3i coords) {
+        if (coords == null) {
+            return null;
+        }
+        NBTTagCompound cmp = new NBTTagCompound();
+        cmp.setInt("x", coords.x);
+        cmp.setInt("y", coords.y);
+        cmp.setInt("z", coords.z);
+        return cmp;
+    }
+
+    private static final Pattern COLON_SPLIT = Pattern.compile(":");
+    /**
+     * Parses a string into BlockPos
+     *
+     * @param loc
+     * @return
+     */
+    private static Vector3i deserializeOldLoc(String loc) {
+        if (loc != null)  {
+            String[] args = COLON_SPLIT.split(loc, 3);
+            if (args.length == 3) {
+                try {
+                    int x = (int) Math.floor(Float.parseFloat(args[0]));
+                    int y = (int) Math.floor(Float.parseFloat(args[1]));
+                    int z = (int) Math.floor(Float.parseFloat(args[2]));
+                    return new Vector3i(x, y, z);
+                } catch (NumberFormatException ignored) {}
+            }
+        }
+        return null;
+    }
+
+    static void processSetAir(Chunk chunk, BlockPosition pos) {
+        ChunkPersistentMeta meta = chunk.chunkMeta;
+        if (meta == null) {
+            return;
+        }
+        Vector3i coords = new Vector3i(pos.getX(), pos.getY(), pos.getZ());
+        if (meta.containsKey(coords)) {
+            new BlockWithPersistentMetaClearedEvent(MCUtil.toLocation(chunk.world, pos).getBlock()).callEvent();
+        }
+    }
+
+    static void filterTileEntityMeta(NBTTagCompound cmp) {
+        cmp.remove(TILEENTITY_META);
+    }
+
+    public static void reload() {
+        // Players are not guaranteed to be in a chunk if dead
+        for (Player player: Bukkit.getOnlinePlayers()) {
+            player.getTempMeta().clear();
+        }
+        for (WorldServer world : MinecraftServer.getServer().getWorlds()) {
+            reloadChunks(world.getChunkProvider().playerChunkMap.visibleChunks.values());
+            reloadChunks(world.getChunkProvider().playerChunkMap.updatingChunks.values());
+        }
+    }
+
+    private static void reloadChunks(Collection<PlayerChunk> playerChunks) {
+        for (PlayerChunk playerChunk : playerChunks) {
+            Chunk chunk = playerChunk.getFullChunkIfCached();
+            if (chunk == null) {
+                continue;
+            }
+            chunk.chunkTempMeta.clear();
+            chunk.getBukkitChunk().getTempMeta().clear();
+            for (List<Entity> entitySlice : chunk.entitySlices) {
+                for (Entity entity : entitySlice) {
+                    entity.getBukkitEntity().getTempMeta().clear();
+                }
+            }
+        }
+    }
+
+    public static Map<String, Object> getChunkTempMeta(Block block, boolean isWrite) {
+        Location loc = block.getLocation();
+        Chunk chunk = ((CraftChunk) block.getChunk()).getHandle();
+        Vector3i pos = new Vector3i(loc.getBlockX(), loc.getBlockY(), loc.getBlockZ());
+        Map<String, Object> map = chunk.chunkTempMeta.get(pos);
+        if (map == null) {
+            if (!isWrite) {
+                return null;
+            }
+            map = new HashMap<>(0);
+            chunk.chunkTempMeta.put(pos, map);
+        }
+        return map;
+    }
+
+    static class ChunkTempMeta extends HashMap<Vector3i, Map<String, Object>> {
+        public ChunkTempMeta() {
+            super(0);
+        }
+
+        public ChunkTempMeta(Map<? extends Vector3i, ? extends Map<String, Object>> m) {
+            super(m);
+        }
+
+        public ChunkTempMeta clone() {
+            return (ChunkTempMeta) new ChunkTempMeta(this);
+        }
+    }
+
+    static class ChunkPersistentMeta extends HashMap<Vector3i, PersistentMetaMap> {
+        ChunkPersistentMeta() {
+            super(0);
+        }
+
+        ChunkPersistentMeta(Map<? extends Vector3i, ? extends PersistentMetaMap> m) {
+            super(m);
+        }
+
+        public ChunkPersistentMeta clone() {
+            return new ChunkPersistentMeta(this);
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PacketPlayOutMapChunk.java b/src/main/java/net/minecraft/server/PacketPlayOutMapChunk.java
index b9276928a58d56ca9aac95d262d8555522946bd7..fafa652a6a8cdcfca71825d3577fa340a44772e1 100644
--- a/src/main/java/net/minecraft/server/PacketPlayOutMapChunk.java
+++ b/src/main/java/net/minecraft/server/PacketPlayOutMapChunk.java
@@ -93,6 +93,7 @@ public class PacketPlayOutMapChunk implements Packet<PacketListenerPlayOut> {
                 // Paper end
                 NBTTagCompound nbttagcompound = tileentity.b();
                 if (tileentity instanceof TileEntitySkull) { TileEntitySkull.sanitizeTileEntityUUID(nbttagcompound); } // Paper
+                MetaApiAccessor.filterTileEntityMeta(nbttagcompound); // EMC
 
                 this.g.add(nbttagcompound);
             }
diff --git a/src/main/java/net/minecraft/server/PacketPlayOutTileEntityData.java b/src/main/java/net/minecraft/server/PacketPlayOutTileEntityData.java
index 6bcb19b560116fc83dc11e779f2d4298cb7696c2..cc7fffec5328430df276e5bdf0188abefa3cbe00 100644
--- a/src/main/java/net/minecraft/server/PacketPlayOutTileEntityData.java
+++ b/src/main/java/net/minecraft/server/PacketPlayOutTileEntityData.java
@@ -11,6 +11,7 @@ public class PacketPlayOutTileEntityData implements Packet<PacketListenerPlayOut
     public PacketPlayOutTileEntityData() {}
 
     public PacketPlayOutTileEntityData(BlockPosition blockposition, int i, NBTTagCompound nbttagcompound) {
+        MetaApiAccessor.filterTileEntityMeta(nbttagcompound); // EMC
         this.a = blockposition;
         this.b = i;
         this.c = nbttagcompound;
diff --git a/src/main/java/net/minecraft/server/PlayerChunkMap.java b/src/main/java/net/minecraft/server/PlayerChunkMap.java
index 49008cdec739b19409fdaf1b0ed806a6c0e93200..22e404eaf7395f9c2905002dfb43b353530685e9 100644
--- a/src/main/java/net/minecraft/server/PlayerChunkMap.java
+++ b/src/main/java/net/minecraft/server/PlayerChunkMap.java
@@ -1284,6 +1284,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
                     chunk = ((ProtoChunkExtension) ichunkaccess).u();
                 } else {
                     chunk = new Chunk(this.world, (ProtoChunk) ichunkaccess);
+                    MetaApiAccessor.loadChunkMetaNbt((ProtoChunk) ichunkaccess, chunk); // EMC
                     playerchunk.a(new ProtoChunkExtension(chunk));
                 }
 
diff --git a/src/main/java/net/minecraft/server/ProtoChunk.java b/src/main/java/net/minecraft/server/ProtoChunk.java
index 5b0cd414ca1949ab53b289f7159f18da07d21f14..50d65d4c37309db665fbe79ede711c92b62175d7 100644
--- a/src/main/java/net/minecraft/server/ProtoChunk.java
+++ b/src/main/java/net/minecraft/server/ProtoChunk.java
@@ -47,6 +47,8 @@ public class ProtoChunk implements IChunkAccess {
     private final Map<WorldGenStage.Features, BitSet> t;
     private volatile boolean u;
     final World world; // Paper - Anti-Xray - Add world // Paper - private -> default
+    public NBTTagCompound chunkMeta; // EMC
+    public NBTTagList chunkMetaList; // EMC
 
     // Paper start - Anti-Xray - Add world
     @Deprecated public ProtoChunk(ChunkCoordIntPair chunkcoordintpair, ChunkConverter chunkconverter) { this(chunkcoordintpair, chunkconverter, null); } // Notice for updates: Please make sure this constructor isn't used anywhere
diff --git a/src/main/java/net/minecraft/server/ProtoChunkExtension.java b/src/main/java/net/minecraft/server/ProtoChunkExtension.java
index 300cbb8b01d94e7eb0cded0c8e118103c416d4b6..1f60df3cee3a8c7c0ce0a339df6f33b9ccc56381 100644
--- a/src/main/java/net/minecraft/server/ProtoChunkExtension.java
+++ b/src/main/java/net/minecraft/server/ProtoChunkExtension.java
@@ -192,6 +192,7 @@ public class ProtoChunkExtension extends ProtoChunk {
         throw (UnsupportedOperationException) SystemUtils.c((Throwable) (new UnsupportedOperationException("Meaningless in this context")));
     }
 
+    public Chunk getChunk() { return this.u(); } // EMC - OBFHELPER
     public Chunk u() {
         return this.a;
     }
diff --git a/src/main/java/net/minecraft/server/TileEntity.java b/src/main/java/net/minecraft/server/TileEntity.java
index 58d958a88ac5af5b889d719d9f1ea90ce45cf184..de8f7fe4bd0bacc43351b8ee8591711800819f7a 100644
--- a/src/main/java/net/minecraft/server/TileEntity.java
+++ b/src/main/java/net/minecraft/server/TileEntity.java
@@ -81,6 +81,7 @@ public abstract class TileEntity implements KeyedObject { // Paper
     }
 
     public void load(IBlockData iblockdata, NBTTagCompound nbttagcompound) {
+        MetaApiAccessor.loadTileEntityMeta(this, nbttagcompound); // EMC
         this.position = new BlockPosition(nbttagcompound.getInt("x"), nbttagcompound.getInt("y"), nbttagcompound.getInt("z"));
         // CraftBukkit start - read container
         this.persistentDataContainer.clear(); // Paper - clear instead of reinit
@@ -103,6 +104,7 @@ public abstract class TileEntity implements KeyedObject { // Paper
             throw new RuntimeException(this.getClass() + " is missing a mapping! This is a bug!");
         } else {
             nbttagcompound.setString("id", minecraftkey.toString());
+            MetaApiAccessor.saveTileEntityMeta(this, nbttagcompound); // EMC
             nbttagcompound.setInt("x", this.position.getX());
             nbttagcompound.setInt("y", this.position.getY());
             nbttagcompound.setInt("z", this.position.getZ());
@@ -233,6 +235,7 @@ public abstract class TileEntity implements KeyedObject { // Paper
         }
     }
 
+    com.empireminecraft.api.meta.PersistentMetaMap metaMap; // EMC
     // CraftBukkit start - add method
     // Paper start
     public InventoryHolder getOwner() {
diff --git a/src/main/java/net/minecraft/server/World.java b/src/main/java/net/minecraft/server/World.java
index 02303f00e243748b9d1c4a37719fcf5c8d271ed9..fb80f1ef5729e8be77fa48d3978c1a8209bf84fa 100644
--- a/src/main/java/net/minecraft/server/World.java
+++ b/src/main/java/net/minecraft/server/World.java
@@ -440,6 +440,7 @@ public abstract class World implements GeneratorAccess, AutoCloseable {
                     this.a(blockposition, iblockdata1, iblockdata2);
                 }
                 */
+                if (block == Blocks.AIR) MetaApiAccessor.processSetAir(chunk, blockposition); // EMC
 
                 // CraftBukkit start
                 if (!this.captureBlockStates) { // Don't notify clients or update physics while capturing blockstates
diff --git a/src/main/java/net/minecraft/server/WorldDataServer.java b/src/main/java/net/minecraft/server/WorldDataServer.java
index a7e623044aece1f46e2d039cd2dcf710120ac267..18cd4e01b4753cc423866eb9e0e01df849e45c14 100644
--- a/src/main/java/net/minecraft/server/WorldDataServer.java
+++ b/src/main/java/net/minecraft/server/WorldDataServer.java
@@ -57,6 +57,7 @@ public class WorldDataServer implements IWorldDataServer, SaveData {
     private boolean D;
     private final CustomFunctionCallbackTimerQueue<MinecraftServer> E;
     public WorldServer world; // CraftBukkit
+    public com.empireminecraft.api.meta.PersistentMetaMap metaMap = new com.empireminecraft.api.meta.PersistentMetaMap(); // EMC
 
     private WorldDataServer(@Nullable DataFixer datafixer, int i, @Nullable NBTTagCompound nbttagcompound, boolean flag, int j, int k, int l, float f, long i1, long j1, int k1, int l1, int i2, boolean flag1, int j2, boolean flag2, boolean flag3, boolean flag4, WorldBorder.c worldborder_c, int k2, int l2, @Nullable UUID uuid, LinkedHashSet<String> linkedhashset, CustomFunctionCallbackTimerQueue<MinecraftServer> customfunctioncallbacktimerqueue, @Nullable NBTTagCompound nbttagcompound1, NBTTagCompound nbttagcompound2, WorldSettings worldsettings, GeneratorSettings generatorsettings, Lifecycle lifecycle) {
         this.k = datafixer;
@@ -180,7 +181,7 @@ public class WorldDataServer implements IWorldDataServer, SaveData {
         if (this.B != null) {
             nbttagcompound.a("WanderingTraderId", this.B);
         }
-
+        MetaApiAccessor.saveWorldMeta(this, nbttagcompound); // EMC
         nbttagcompound.setString("Bukkit.Version", Bukkit.getName() + "/" + Bukkit.getVersion() + "/" + Bukkit.getBukkitVersion()); // CraftBukkit
     }
 
diff --git a/src/main/java/net/minecraft/server/WorldServer.java b/src/main/java/net/minecraft/server/WorldServer.java
index 9c50357bb5da309b7cad74fdee15697a20e2e15f..777685b8739359f1a0bf32653f95128abeea5527 100644
--- a/src/main/java/net/minecraft/server/WorldServer.java
+++ b/src/main/java/net/minecraft/server/WorldServer.java
@@ -61,7 +61,7 @@ public class WorldServer extends World implements GeneratorAccessSeed {
     public static final BlockPosition a = new BlockPosition(100, 50, 0);
     private static final Logger LOGGER = LogManager.getLogger();
     public final Int2ObjectMap<Entity> entitiesById = new Int2ObjectLinkedOpenHashMap();
-    private final Map<UUID, Entity> entitiesByUUID = Maps.newHashMap();
+    private final Map<UUID, Entity> entitiesByUUID = Maps.newHashMap(); // EMC - private -> public
     private final Queue<Entity> entitiesToAdd = Queues.newArrayDeque();
     public final List<EntityPlayer> players = Lists.newArrayList(); // Paper - private -> public
     public final ChunkProviderServer chunkProvider; // Paper - public
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftChunk.java b/src/main/java/org/bukkit/craftbukkit/CraftChunk.java
index b345b7658b7de28787cb10255d7d881bc1493003..b00250ddfc24d4ab596727a5c1e146bb3663a2e4 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftChunk.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftChunk.java
@@ -41,6 +41,8 @@ import org.bukkit.plugin.Plugin;
 
 public class CraftChunk implements Chunk {
     private WeakReference<net.minecraft.server.Chunk> weakChunk;
+    private final com.empireminecraft.api.meta.TempMetaMap tempMeta = new com.empireminecraft.api.meta.TempMetaMap(); // EMC
+    public com.empireminecraft.api.meta.TempMetaMap getTempMeta() { return tempMeta; } // EMC
     private final WorldServer worldServer;
     private final int x;
     private final int z;
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index 433a6bf61ecef959a1611d86c05f07dff8c7a060..62626f6786825bbb6d6dcd0392dc1416bf8841ce 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -941,6 +941,9 @@ public final class CraftServer implements Server {
                 "This plugin is not properly shutting down its async tasks when it is being reloaded.  This may cause conflicts with the newly loaded version of the plugin"
             ));
         }
+        // EMC start
+        net.minecraft.server.MetaApiAccessor.reload();
+        // EMC end
         loadPlugins();
         enablePlugins(PluginLoadOrder.STARTUP);
         enablePlugins(PluginLoadOrder.POSTWORLD);
diff --git a/src/main/java/org/bukkit/craftbukkit/block/CraftBlockEntityState.java b/src/main/java/org/bukkit/craftbukkit/block/CraftBlockEntityState.java
index dc0e6e49e9eb5004e53d24304bce095bcef8f4c2..f17455028793b3d744f962e3028a8d38e975d00c 100644
--- a/src/main/java/org/bukkit/craftbukkit/block/CraftBlockEntityState.java
+++ b/src/main/java/org/bukkit/craftbukkit/block/CraftBlockEntityState.java
@@ -156,4 +156,11 @@ public class CraftBlockEntityState<T extends TileEntity> extends CraftBlockState
     public PersistentDataContainer getPersistentDataContainer() {
         return this.getSnapshot().persistentDataContainer;
     }
+
+    // EMC start
+    @Override
+    public boolean isTileEntity() {
+        return tileEntity != null;
+    }
+    // EMC end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/block/CraftBlockState.java b/src/main/java/org/bukkit/craftbukkit/block/CraftBlockState.java
index 36d7de6e6540e156499edb4b69b8bbaeb0d6dc54..4e8691917909bf54b655250ada06078bcccc43e0 100644
--- a/src/main/java/org/bukkit/craftbukkit/block/CraftBlockState.java
+++ b/src/main/java/org/bukkit/craftbukkit/block/CraftBlockState.java
@@ -290,4 +290,11 @@ public class CraftBlockState implements BlockState {
             throw new IllegalStateException("The blockState must be placed to call this method");
         }
     }
+
+    // EMC start
+    @Override
+    public boolean isTileEntity() {
+        return false;
+    }
+    // EMC end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
index 475dc1aa2cba77c13033938e719a66707f358914..19a6ce4d9d70610049d61e971c3af1a97e7d2ba1 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
@@ -174,6 +174,8 @@ import org.bukkit.util.NumberConversions;
 import org.bukkit.util.Vector;
 
 public abstract class CraftEntity implements org.bukkit.entity.Entity {
+    private final com.empireminecraft.api.meta.TempMetaMap tempMeta = new com.empireminecraft.api.meta.TempMetaMap(); // EMC
+    public com.empireminecraft.api.meta.TempMetaMap getTempMeta() { return tempMeta; } // EMC
     private static PermissibleBase perm;
     private static final CraftPersistentDataTypeRegistry DATA_TYPE_REGISTRY = new CraftPersistentDataTypeRegistry();
 
diff --git a/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java b/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
index c762015e1402b59bf28dae7f947e7737fbac5c1d..70855586ee5666a2d1c40b9fcf760226740659ad 100644
--- a/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
+++ b/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
@@ -1426,6 +1426,11 @@ public class CraftEventFactory {
         InventoryCloseEvent event = new InventoryCloseEvent(human.activeContainer.getBukkitView(), reason); // Paper
         human.world.getServer().getPluginManager().callEvent(event);
         human.activeContainer.transferTo(human.defaultContainer, human.getBukkitEntity());
+        // EMC start
+        if (event.getInventory().getViewers().isEmpty()) {
+            org.bukkit.craftbukkit.inventory.CraftInventory.meta.remove(((org.bukkit.craftbukkit.inventory.CraftInventory)event.getInventory()).getInventory());
+        }
+        // EMC end
     }
 
     public static ItemStack handleEditBookEvent(EntityPlayer player, int itemInHandIndex, ItemStack itemInHand, ItemStack newBookItem) {
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftInventory.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftInventory.java
index bba9bddc1c0aacade9b7ad56afb1e630caa078fc..fa8ee88cc3a391dec95c9b4573b0417d3c2aece2 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftInventory.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftInventory.java
@@ -31,6 +31,17 @@ import org.bukkit.inventory.ItemStack;
 public class CraftInventory implements Inventory {
     protected final IInventory inventory;
 
+    // EMC start
+    public static final java.util.WeakHashMap<IInventory, HashMap<String, Object>> meta = new java.util.WeakHashMap<IInventory, HashMap<String, Object>>(64);
+    public HashMap<String, Object> getMeta() {
+        HashMap<String, Object> metaMap = meta.get(inventory);
+        if (metaMap == null) {
+            metaMap = new HashMap<String, Object>();
+            meta.put(inventory, metaMap);
+        }
+        return metaMap;
+    } // EMC end
+
     public CraftInventory(IInventory inventory) {
         this.inventory = inventory;
     }
