From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Aikar <aikar@aikar.co>
Date: Mon, 4 Mar 2013 23:35:02 -0500
Subject: [PATCH] Persistent and Temporary Meta API

---
 .../empireminecraft/api/CraftEmpireAPI.java   |   3 +
 .../api/meta/CraftEAPI_Meta.java              |  80 +++
 .../protocol/game/PacketPlayOutMapChunk.java  |   2 +
 .../game/PacketPlayOutTileEntityData.java     |   2 +
 .../net/minecraft/server/MetaApiAccessor.java | 598 ++++++++++++++++++
 .../server/level/PlayerChunkMap.java          |   2 +
 .../minecraft/server/level/WorldServer.java   |   2 +-
 .../net/minecraft/world/entity/Entity.java    |   4 +
 .../java/net/minecraft/world/level/World.java |   2 +
 .../world/level/block/entity/TileEntity.java  |   4 +
 .../minecraft/world/level/chunk/Chunk.java    |   3 +
 .../world/level/chunk/ProtoChunk.java         |   3 +
 .../level/chunk/ProtoChunkExtension.java      |   1 +
 .../chunk/storage/ChunkRegionLoader.java      |   4 +
 .../world/level/storage/Convertable.java      |   8 +-
 .../world/level/storage/WorldDataServer.java  |   4 +-
 .../org/bukkit/craftbukkit/CraftChunk.java    |   2 +
 .../org/bukkit/craftbukkit/CraftServer.java   |   3 +
 .../block/CraftBlockEntityState.java          |   7 +
 .../craftbukkit/block/CraftBlockState.java    |   7 +
 .../craftbukkit/entity/CraftEntity.java       |   2 +
 .../craftbukkit/event/CraftEventFactory.java  |   5 +
 .../craftbukkit/inventory/CraftInventory.java |  11 +
 23 files changed, 756 insertions(+), 3 deletions(-)
 create mode 100644 src/main/java/com/empireminecraft/api/meta/CraftEAPI_Meta.java
 create mode 100644 src/main/java/net/minecraft/server/MetaApiAccessor.java

diff --git a/src/main/java/com/empireminecraft/api/CraftEmpireAPI.java b/src/main/java/com/empireminecraft/api/CraftEmpireAPI.java
index 7b295bc869fd8fac878fd25fdcd3f03422fc8e63..f3c9419c8148e389f7d9f2e24a8664b1cb2bbfde 100644
--- a/src/main/java/com/empireminecraft/api/CraftEmpireAPI.java
+++ b/src/main/java/com/empireminecraft/api/CraftEmpireAPI.java
@@ -23,6 +23,8 @@
 
 package com.empireminecraft.api;
 
+import com.empireminecraft.api.meta.CraftEAPI_Meta;
+
 public final class CraftEmpireAPI extends API {
 
     private CraftEmpireAPI() {}
@@ -31,6 +33,7 @@ public final class CraftEmpireAPI extends API {
     static {
         entity = new CraftEAPI_Entity();
         misc = new CraftEAPI_Misc();
+        meta = new CraftEAPI_Meta();
     }
 
 }
diff --git a/src/main/java/com/empireminecraft/api/meta/CraftEAPI_Meta.java b/src/main/java/com/empireminecraft/api/meta/CraftEAPI_Meta.java
new file mode 100644
index 0000000000000000000000000000000000000000..a9a194b3a78401454817350f7fa7190a1980dd82
--- /dev/null
+++ b/src/main/java/com/empireminecraft/api/meta/CraftEAPI_Meta.java
@@ -0,0 +1,80 @@
+/*
+ * Copyright (c) 2016 Starlis LLC / Daniel Ennis (Aikar) - MIT License
+ *
+ *  Permission is hereby granted, free of charge, to any person obtaining
+ *  a copy of this software and associated documentation files (the
+ *  "Software"), to deal in the Software without restriction, including
+ *  without limitation the rights to use, copy, modify, merge, publish,
+ *  distribute, sublicense, and/or sell copies of the Software, and to
+ *  permit persons to whom the Software is furnished to do so, subject to
+ *  the following conditions:
+ *
+ *  The above copyright notice and this permission notice shall be
+ *  included in all copies or substantial portions of the Software.
+ *
+ *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ *  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ *  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ *  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ *  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ *  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ *  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.empireminecraft.api.meta;
+
+import com.empireminecraft.api.Vector3i;
+import net.minecraft.server.MetaApiAccessor;
+import org.bukkit.Chunk;
+import org.bukkit.Location;
+import org.bukkit.World;
+import org.bukkit.block.Block;
+import org.bukkit.block.BlockState;
+import org.bukkit.craftbukkit.CraftChunk;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.entity.Entity;
+
+import java.util.Map;
+
+public class CraftEAPI_Meta implements EAPI_Meta {
+
+    @Override
+    public PersistentMetaMap getTileEntityMetaMap(BlockState tileEntity, boolean isWrite) {
+        return MetaApiAccessor.getTileEntityMetaMap(tileEntity, isWrite);
+    }
+
+    @Override
+    public PersistentMetaMap getBlockMetaMap(Location loc, boolean isWrite) {
+        return MetaApiAccessor.getBlockMetaMap(loc, isWrite);
+    }
+
+    @Override
+    public PersistentMetaMap getChunkMetaMap(Chunk chunk, boolean isWrite) {
+        return MetaApiAccessor.getChunkMetaMap(chunk, isWrite);
+    }
+
+    @Override
+    public TempMetaMap getChunkTempMetaMap(Chunk chunk, boolean isWrite) {
+        return chunk.getTempMeta();
+    }
+
+    @Override
+    public Map<Vector3i, PersistentMetaMap> getChunkMetaData(Chunk chunk) {
+        return ((CraftChunk) chunk).getHandle().chunkMeta;
+    }
+
+    @Override
+    public PersistentMetaMap getEntityMetaMap(Entity entity, boolean isWrite) {
+        return MetaApiAccessor.getEntityMetaMap(entity, isWrite);
+    }
+
+    @Override
+    public PersistentMetaMap getWorldMetaMap(World world) {
+        return MetaApiAccessor.getWorldMetaMap((CraftWorld) world);
+    }
+
+    @Override
+    public Map<String, Object> getBlockTempMeta(Block block, boolean isWrite) {
+        return MetaApiAccessor.getChunkTempMeta(block, isWrite);
+    }
+}
diff --git a/src/main/java/net/minecraft/network/protocol/game/PacketPlayOutMapChunk.java b/src/main/java/net/minecraft/network/protocol/game/PacketPlayOutMapChunk.java
index 3047cf8c4ec1b664d6b790f18d2b1657e4b00435..9cf4ba94495ab36800d1f445372df7a300ee6b27 100644
--- a/src/main/java/net/minecraft/network/protocol/game/PacketPlayOutMapChunk.java
+++ b/src/main/java/net/minecraft/network/protocol/game/PacketPlayOutMapChunk.java
@@ -14,6 +14,7 @@ import net.minecraft.nbt.NBTTagCompound;
 import net.minecraft.nbt.NBTTagLongArray;
 import net.minecraft.network.PacketDataSerializer;
 import net.minecraft.network.protocol.Packet;
+import net.minecraft.server.MetaApiAccessor;
 import net.minecraft.world.level.ChunkCoordIntPair;
 import net.minecraft.world.level.block.entity.TileEntity;
 import net.minecraft.world.level.block.entity.TileEntitySkull;
@@ -106,6 +107,7 @@ public class PacketPlayOutMapChunk implements Packet<PacketListenerPlayOut> {
                 // Paper end
                 NBTTagCompound nbttagcompound = tileentity.b();
                 if (tileentity instanceof TileEntitySkull) { TileEntitySkull.sanitizeTileEntityUUID(nbttagcompound); } // Paper
+                MetaApiAccessor.filterTileEntityMeta(nbttagcompound); // EMC
 
                 this.g.add(nbttagcompound);
             }
diff --git a/src/main/java/net/minecraft/network/protocol/game/PacketPlayOutTileEntityData.java b/src/main/java/net/minecraft/network/protocol/game/PacketPlayOutTileEntityData.java
index ec4c658c8aad8b63e4545a5e7d71c9c5bd0ad874..b9fdaa49fe5a96b4a10dfbc96194cbcbc3bb7acb 100644
--- a/src/main/java/net/minecraft/network/protocol/game/PacketPlayOutTileEntityData.java
+++ b/src/main/java/net/minecraft/network/protocol/game/PacketPlayOutTileEntityData.java
@@ -5,6 +5,7 @@ import net.minecraft.core.BlockPosition;
 import net.minecraft.nbt.NBTTagCompound;
 import net.minecraft.network.PacketDataSerializer;
 import net.minecraft.network.protocol.Packet;
+import net.minecraft.server.MetaApiAccessor;
 
 public class PacketPlayOutTileEntityData implements Packet<PacketListenerPlayOut> {
 
@@ -15,6 +16,7 @@ public class PacketPlayOutTileEntityData implements Packet<PacketListenerPlayOut
     public PacketPlayOutTileEntityData() {}
 
     public PacketPlayOutTileEntityData(BlockPosition blockposition, int i, NBTTagCompound nbttagcompound) {
+        MetaApiAccessor.filterTileEntityMeta(nbttagcompound); // EMC
         this.a = blockposition;
         this.b = i;
         this.c = nbttagcompound;
diff --git a/src/main/java/net/minecraft/server/MetaApiAccessor.java b/src/main/java/net/minecraft/server/MetaApiAccessor.java
new file mode 100644
index 0000000000000000000000000000000000000000..06ab716f527cfa0f016a77600953b0dec1d69b69
--- /dev/null
+++ b/src/main/java/net/minecraft/server/MetaApiAccessor.java
@@ -0,0 +1,598 @@
+package net.minecraft.server;
+
+import net.minecraft.core.BlockPosition;
+import net.minecraft.nbt.NBTBase;
+import net.minecraft.nbt.NBTNumber;
+import net.minecraft.nbt.NBTTagCompound;
+import net.minecraft.nbt.NBTTagDouble;
+import net.minecraft.nbt.NBTTagFloat;
+import net.minecraft.nbt.NBTTagInt;
+import net.minecraft.nbt.NBTTagList;
+import net.minecraft.nbt.NBTTagLong;
+import net.minecraft.nbt.NBTTagString;
+import net.minecraft.server.level.PlayerChunk;
+import net.minecraft.server.level.WorldServer;
+import net.minecraft.util.datafix.fixes.DataConverterTypes;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.level.block.entity.TileEntity;
+import net.minecraft.world.level.chunk.Chunk;
+import net.minecraft.world.level.chunk.IChunkAccess;
+import net.minecraft.world.level.chunk.ProtoChunk;
+import net.minecraft.world.level.chunk.ProtoChunkExtension;
+import net.minecraft.world.level.storage.WorldDataServer;
+import org.bukkit.Bukkit;
+import com.empireminecraft.api.Vector3i;
+import com.empireminecraft.api.meta.PersistentMetaList;
+import com.empireminecraft.api.meta.PersistentMetaMap;
+import com.empireminecraft.customevents.BlockWithPersistentMetaClearedEvent;
+import org.bukkit.Location;
+import org.bukkit.block.Block;
+import org.bukkit.craftbukkit.CraftChunk;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.craftbukkit.block.CraftBlockState;
+import org.bukkit.craftbukkit.entity.CraftEntity;
+import org.bukkit.craftbukkit.inventory.CraftItemStack;
+import org.bukkit.entity.Player;
+
+import java.util.*;
+import java.util.Map.Entry;
+import java.util.regex.Pattern;
+
+public final class MetaApiAccessor {
+
+    private static final String META_MAP = "MetaMap";
+    private static final String META_TYPE = "MetaType";
+    private static final String ITEM = "Item";
+    private static final String ENTITY_META = "_EntityMeta";
+    private static final String TILEENTITY_META = "_TileEntityMeta";
+    private static final String WORLD_META = "_WorldMeta";
+    private static final String CHUNK_META_LIST = "_ChunkMetaList";
+    private static final String BLOCK_POS = "_BlockPos";
+    private static final String CHUNK_META = "_ChunkMeta";
+
+    private MetaApiAccessor() {}
+
+    public static PersistentMetaMap getWorldMetaMap(CraftWorld world) {
+        return ((WorldDataServer) world.getHandle().worldData).metaMap;
+    }
+
+    public static PersistentMetaMap getTileEntityMetaMap(org.bukkit.block.BlockState block, boolean isWrite) {
+        final CraftBlockState craftBlock = (CraftBlockState) block;
+        final TileEntity tileEntity = ((CraftWorld) craftBlock.getWorld()).getHandle().getTileEntity(MCUtil.toBlockPosition(craftBlock.getLocation()));
+        if (tileEntity == null) {
+            return null;
+        }
+        if (tileEntity.metaMap == null && isWrite) {
+            tileEntity.metaMap = new PersistentMetaMap();
+        }
+        return tileEntity.metaMap;
+    }
+
+    /**
+     * Util for getting a MetaMap by location
+     * @param loc
+     * @return
+     */
+    public static PersistentMetaMap getBlockMetaMap(org.bukkit.Location loc, boolean isWrite) {
+        return getBlockMetaMap(((CraftChunk) loc.getChunk()).getHandle(), loc.getBlockX(), loc.getBlockY(), loc.getBlockZ(), isWrite);
+    }
+
+    /**
+     * Util for getting a MetaMap for a chunk
+     * @param chunk
+     * @return
+     */
+    public static PersistentMetaMap getChunkMetaMap(org.bukkit.Chunk chunk, boolean isWrite) {
+        return getBlockMetaMap(((CraftChunk) chunk).getHandle(), 0, -1, 0, isWrite);
+    }
+
+    /**
+     * Gets the metamap for the specified coords, creating it if it doesnt exists
+     * @param handle
+     * @param x
+     * @param y
+     * @param z
+     * @return
+     */
+    private static PersistentMetaMap getBlockMetaMap(Chunk handle, int x, int y, int z, boolean isWrite) {
+        ChunkPersistentMeta meta = handle.chunkMeta;
+        if (meta == null) {
+            if (!isWrite) {
+                return null;
+            }
+            meta = handle.chunkMeta = new ChunkPersistentMeta();
+        }
+        Vector3i coords = new Vector3i(x, y, z);
+        if (!isWrite && !meta.containsKey(coords)) {
+            return null;
+        }
+        PersistentMetaMap ret = meta.get(coords);
+        if (ret == null) {
+            if (isWrite) {
+                ret = new PersistentMetaMap();
+                meta.put(coords, ret);
+            }
+        }
+        return ret;
+    }
+
+    /**
+     * Util for getting a MetaMap for an Entity
+     * @param craftentity
+     * @return
+     */
+    public static PersistentMetaMap getEntityMetaMap(org.bukkit.entity.Entity craftentity, boolean isWrite) {
+        Entity entity = ((CraftEntity) craftentity).getHandle();
+        if (entity.metaMap == null) {
+            if (isWrite) {
+                entity.metaMap = new PersistentMetaMap();
+            }
+        }
+        return entity.metaMap;
+    }
+
+    public static void loadEntityMeta(Entity entity, NBTTagCompound nbt) {
+        if (nbt.hasKey(ENTITY_META)) {
+            entity.metaMap = getMetaMapFromCompound(nbt.getCompound(ENTITY_META));
+        }
+    }
+
+    public static void saveEntityMeta(Entity entity, NBTTagCompound nbt) {
+        if (entity.metaMap != null && !entity.metaMap.isEmpty()) {
+            nbt.set(ENTITY_META, getNbtFromObject(entity.metaMap));
+        }
+    }
+
+    public static void loadTileEntityMeta(TileEntity tileEntity, NBTTagCompound nbt) {
+        if (nbt.hasKey(TILEENTITY_META)) {
+            tileEntity.metaMap = getMetaMapFromCompound(nbt.getCompound(TILEENTITY_META));
+        }
+    }
+
+    public static void saveTileEntityMeta(TileEntity tileEntity, NBTTagCompound nbt) {
+        if (tileEntity.metaMap != null && !tileEntity.metaMap.isEmpty()) {
+            nbt.set(TILEENTITY_META, getNbtFromObject(tileEntity.metaMap));
+        }
+    }
+
+    public static void loadWorldMeta(WorldDataServer world, NBTTagCompound nbt) {
+        if (nbt.hasKey(WORLD_META)) {
+            NBTTagCompound nbtmeta = nbt.getCompound(WORLD_META);
+            world.metaMap = getMetaMapFromCompound(nbtmeta);
+        }
+        if (world.metaMap == null) {
+            world.metaMap = new PersistentMetaMap();
+        }
+    }
+
+    public static void saveWorldMeta(WorldDataServer worldData, NBTTagCompound nbt) {
+        if (worldData.metaMap != null && !worldData.metaMap.isEmpty()) {
+            NBTBase nbtmeta = getNbtFromObject(worldData.metaMap);
+            nbt.set(WORLD_META, nbtmeta);
+        }
+    }
+
+    /**
+     * Saves this chunks Meta Data into NBT
+     * @param cmp
+     * @param chunkAccess
+     */
+    public static void saveChunkMetaNbt(NBTTagCompound cmp, IChunkAccess chunkAccess) {
+        Chunk chunk = null;
+        if (chunkAccess instanceof Chunk) {
+            chunk = (Chunk) chunkAccess;
+        } else if (chunkAccess instanceof PlayerChunk) {
+            chunk = ((PlayerChunk) chunkAccess).getChunk();
+        } else if (chunkAccess instanceof ProtoChunkExtension) {
+            chunk = ((ProtoChunkExtension) chunkAccess).getChunk();
+        } else if (chunkAccess instanceof ProtoChunk) {
+            saveChunkMetaNbt(cmp, (ProtoChunk) chunkAccess);
+            return;
+        }
+        if (chunk == null) throw new IllegalArgumentException("Failed to get chunk to save meta for");
+        saveChunkMetaNbt(cmp, chunk);
+    }
+
+    /**
+     * Saves this chunks Meta Data into NBT
+     * @param cmp
+     * @param chunk
+     */
+    static void saveChunkMetaNbt(NBTTagCompound cmp, Chunk chunk) {
+        if (chunk.chunkMeta == null || chunk.chunkMeta.isEmpty()) {
+            return;
+        }
+        NBTTagList meta = new NBTTagList();
+        for (Map.Entry<Vector3i, PersistentMetaMap> entry : chunk.chunkMeta.entrySet()) {
+            PersistentMetaMap list = entry.getValue();
+            if (!list.isEmpty()) {
+                NBTTagCompound pos = serializePos(entry.getKey());
+                NBTTagCompound metacmp = getCompoundFromMetaMap(list);
+                metacmp.set(BLOCK_POS, pos);
+                meta.add(metacmp);
+            }
+        }
+
+        if (!meta.isEmpty()) {
+            cmp.set(CHUNK_META_LIST, meta);
+        }
+    }
+
+    /**
+     * Saves this protoChunk's Meta Data into NBT
+     * @param cmp
+     * @param protoChunk
+     */
+    static void saveChunkMetaNbt(NBTTagCompound cmp, ProtoChunk protoChunk) {
+        if (protoChunk.chunkMeta != null) {
+            cmp.set(CHUNK_META, protoChunk.chunkMeta);
+        } else if (protoChunk.chunkMetaList != null) {
+            cmp.set(CHUNK_META_LIST, protoChunk.chunkMetaList);
+        }
+    }
+
+    /**
+     * Loads this chunks Meta Data from NBT
+     * @param cmp
+     * @param chunkAccess
+     */
+    public static void loadChunkMetaNbt(NBTTagCompound cmp, IChunkAccess chunkAccess) {
+        Chunk chunk = null;
+        if (chunkAccess instanceof Chunk) {
+            chunk = (Chunk) chunkAccess;
+        } else if (chunkAccess instanceof PlayerChunk) {
+            chunk = ((PlayerChunk) chunkAccess).getChunk();
+        } else if (chunkAccess instanceof ProtoChunkExtension) {
+            chunk = ((ProtoChunkExtension) chunkAccess).getChunk();
+        } else if (chunkAccess instanceof ProtoChunk) {
+            storeChunkMetaNbt(cmp, (ProtoChunk) chunkAccess);
+            return;
+        }
+        if (chunk == null) throw new IllegalArgumentException("Failed to get chunk to load meta for");
+        loadChunkMetaNbt(cmp, chunk);
+    }
+
+    /**
+     * Save the chunk Meta Data to be loaded later
+     * @param cmp
+     * @param protoChunk
+     */
+    static void storeChunkMetaNbt(NBTTagCompound cmp, ProtoChunk protoChunk) {
+        if (cmp.hasKey(CHUNK_META)) {
+            protoChunk.chunkMeta = cmp.getCompound(CHUNK_META);
+        } else if (cmp.hasKey(CHUNK_META_LIST)) {
+            protoChunk.chunkMetaList = cmp.getList(CHUNK_META_LIST, 10);
+        }
+    }
+
+    /**
+     * Loads this chunks Meta Data from NBT
+     * @param cmp
+     * @param chunk
+     */
+    static void loadChunkMetaNbt(NBTTagCompound cmp, Chunk chunk) {
+        if (cmp.hasKey(CHUNK_META)) {
+            loadChunkMeta(cmp.getCompound(CHUNK_META), chunk);
+        } else if (cmp.hasKey(CHUNK_META_LIST)) {
+            loadChunkMetaList(cmp.getList(CHUNK_META_LIST, 10), chunk);
+        }
+    }
+
+    /**
+     * Loads this chunks Meta Data from a ProtoChunk
+     * @param protoChunk
+     * @param chunk
+     */
+    public static void loadChunkMetaNbt(ProtoChunk protoChunk, Chunk chunk) {
+        if (protoChunk.chunkMeta != null) {
+            loadChunkMeta(protoChunk.chunkMeta, chunk);
+        } else if (protoChunk.chunkMetaList != null) {
+            loadChunkMetaList(protoChunk.chunkMetaList, chunk);
+        }
+    }
+
+    private static void loadChunkMeta(NBTTagCompound chunkMeta, Chunk chunk) {
+        ChunkPersistentMeta meta = chunk.chunkMeta;
+        for (String key : chunkMeta.getKeys()) {
+            NBTTagCompound e = chunkMeta.getCompound(key);
+            meta = loadBlockMeta(meta, deserializeOldLoc(key), e);
+        }
+        chunk.chunkMeta = meta;
+    }
+
+    private static void loadChunkMetaList(NBTTagList chunkMeta, Chunk chunk) {
+        ChunkPersistentMeta meta = chunk.chunkMeta;
+        final int size = chunkMeta.size();
+        for (int i = 0; i < size; i++) {
+            NBTTagCompound e = chunkMeta.getCompound(i);
+            if (e.hasKey(BLOCK_POS)) {
+                NBTTagCompound blockPos = e.getCompound(BLOCK_POS);
+                meta = loadBlockMeta(meta, getBlockPosFromCompound(blockPos), e);
+            }
+        }
+        chunk.chunkMeta = meta;
+    }
+
+    private static ChunkPersistentMeta loadBlockMeta(ChunkPersistentMeta meta, Vector3i key, NBTTagCompound e) {
+        PersistentMetaMap map = getMetaMapFromCompound(e);
+        if (map != null && !map.isEmpty()) {
+            if (meta == null) {
+                meta = new ChunkPersistentMeta();
+            }
+            meta.put(key, map);
+        }
+        return meta;
+    }
+
+    private static Vector3i getBlockPosFromCompound(NBTTagCompound pos) {
+        return new Vector3i(pos.getInt("x"), pos.getInt("y"), pos.getInt("z"));
+    }
+
+    /**
+     * Converts an Object into NBT
+     * @param value
+     * @return
+     */
+    private static NBTBase getNbtFromObject(Object value) {
+        if (value == null) {
+            return null;
+        }
+        if (value instanceof String) {
+            return NBTTagString.a((String) value);
+        } else if (value instanceof ItemStack || value instanceof org.bukkit.inventory.ItemStack) {
+            ItemStack item;
+            if (value instanceof org.bukkit.inventory.ItemStack) {
+                item = CraftItemStack.asNMSCopy((org.bukkit.inventory.ItemStack) value);
+            } else {
+                item = (ItemStack) value;
+            }
+            if (item == null) {
+                return null;
+            }
+            NBTTagCompound itemnbt = new NBTTagCompound();
+            itemnbt.setString(META_TYPE, ITEM);
+            itemnbt.setInt("DataVersion", DataConverters.DATA_VERSION);
+            return item.save(itemnbt);
+        } else if (value instanceof Long) {
+            return NBTTagLong.a((Long) value);
+        } else if (value instanceof Integer) {
+            return NBTTagInt.a((Integer) value);
+        } else if (value instanceof Double) {
+            return NBTTagDouble.a((Double) value);
+        } else if (value instanceof Float) {
+            return NBTTagFloat.a((Float) value);
+        } else if (value instanceof PersistentMetaMap) {
+            return getCompoundFromMetaMap((PersistentMetaMap) value);
+        } else if (value instanceof PersistentMetaList) {
+            NBTTagList list = new NBTTagList();
+            for (Object obj : (Iterable<?>) value) {
+                NBTBase add = getNbtFromObject(obj);
+                if (add != null) {
+                    list.add(add);
+                }
+            }
+            return list.isEmpty() ? null : list;
+        }
+
+        return null;
+    }
+
+    /**
+     * Converts NBT into an Object
+     * @param nbt
+     * @return
+     */
+    @SuppressWarnings("RedundantCast")
+    private static Object getObjectFromNbt(NBTBase nbt) {
+        if (nbt == null) {
+            return null;
+        }
+        if (nbt instanceof NBTTagString) {
+            return (String) nbt.asString();
+            // Redundant casts added to each number so that it will fail to compile
+            // If the method names change for each type. Do not remove.
+        } else if (nbt instanceof NBTTagInt) {
+            return (Integer) ((NBTNumber) nbt).asInt();
+        } else if (nbt instanceof NBTTagLong) {
+            return (Long) ((NBTNumber) nbt).asLong();
+        } else if (nbt instanceof NBTTagFloat) {
+            return (Float) ((NBTNumber) nbt).asFloat();
+        } else if (nbt instanceof NBTTagDouble) {
+            return (Double) ((NBTNumber) nbt).asDouble();
+        } else if (nbt instanceof NBTTagList) {
+            NBTTagList nbtlist = (NBTTagList) nbt;
+            if (nbtlist.isEmpty()) {
+                return null;
+            }
+            PersistentMetaList<Object> list = new PersistentMetaList<>();
+            for (int i = 0; i < nbtlist.size(); i++) {
+                final Object obj = getObjectFromNbt(nbtlist.get(i));
+                if (obj != null) {
+                    list.add(obj);
+                }
+            }
+            return list.isEmpty() ? null : list;
+        } else if (nbt instanceof NBTTagCompound) {
+            NBTTagCompound cmp = (NBTTagCompound) nbt.clone();
+            if (cmp.hasKey(META_TYPE)) {
+                String type = cmp.getString(META_TYPE);
+                cmp.remove(META_TYPE);
+                if (ITEM.equals(type)) {
+                    int version = cmp.hasKey("DataVersion") ? cmp.getInt("DataVersion") : -1;
+                    cmp = DataConverters.convert(DataConverterTypes.ITEM_STACK, cmp, version);
+                    return CraftItemStack.asCraftMirror(ItemStack.a(cmp));
+                } else if (META_MAP.equals(type)) {
+                    final PersistentMetaMap metaMap = getMetaMapFromCompound(cmp);
+                    if (metaMap == null || metaMap.isEmpty()) {
+                        return null;
+                    }
+                    return metaMap;
+                }
+            }
+        }
+        return null;
+    }
+
+    /**
+     * Converts a NBTTagCompound to a MetaMap
+     * @param cmp
+     * @return
+     */
+    private static PersistentMetaMap getMetaMapFromCompound(NBTTagCompound cmp) {
+        if (cmp.map.isEmpty()) {
+            return null;
+        }
+        PersistentMetaMap map = new PersistentMetaMap();
+        for (Entry<String, NBTBase> entry : cmp.map.entrySet()) {
+            final Object metaData = getObjectFromNbt(entry.getValue());
+            if (metaData != null) {
+                map.put(entry.getKey(), metaData);
+            }
+        }
+        return map;
+    }
+
+    /**
+     * Converts a MetaMap into an NBTTagCompount
+     * @param map
+     * @return
+     */
+    private static NBTTagCompound getCompoundFromMetaMap(PersistentMetaMap map) {
+        NBTTagCompound cmp = new NBTTagCompound();
+        if (map.isEmpty()) {
+            return cmp;
+        }
+        cmp.setString(META_TYPE, META_MAP);
+        for (Map.Entry<String, Object> entry : map.entrySet()) {
+            NBTBase add = getNbtFromObject(entry.getValue());
+            if (add != null) {
+                cmp.set(entry.getKey(), add);
+            }
+        }
+        return cmp;
+    }
+
+    /**
+     * Translates BlockPos to a String form
+     * @param coords
+     * @return
+     */
+    private static NBTTagCompound serializePos(Vector3i coords) {
+        if (coords == null) {
+            return null;
+        }
+        NBTTagCompound cmp = new NBTTagCompound();
+        cmp.setInt("x", coords.x);
+        cmp.setInt("y", coords.y);
+        cmp.setInt("z", coords.z);
+        return cmp;
+    }
+
+    private static final Pattern COLON_SPLIT = Pattern.compile(":");
+    /**
+     * Parses a string into BlockPos
+     *
+     * @param loc
+     * @return
+     */
+    private static Vector3i deserializeOldLoc(String loc) {
+        if (loc != null)  {
+            String[] args = COLON_SPLIT.split(loc, 3);
+            if (args.length == 3) {
+                try {
+                    int x = (int) Math.floor(Float.parseFloat(args[0]));
+                    int y = (int) Math.floor(Float.parseFloat(args[1]));
+                    int z = (int) Math.floor(Float.parseFloat(args[2]));
+                    return new Vector3i(x, y, z);
+                } catch (NumberFormatException ignored) {}
+            }
+        }
+        return null;
+    }
+
+    public static void processSetAir(Chunk chunk, BlockPosition pos) {
+        ChunkPersistentMeta meta = chunk.chunkMeta;
+        if (meta == null) {
+            return;
+        }
+        Vector3i coords = new Vector3i(pos.getX(), pos.getY(), pos.getZ());
+        if (meta.containsKey(coords)) {
+            new BlockWithPersistentMetaClearedEvent(MCUtil.toLocation(chunk.world, pos).getBlock()).callEvent();
+        }
+    }
+
+    public static void filterTileEntityMeta(NBTTagCompound cmp) {
+        cmp.remove(TILEENTITY_META);
+    }
+
+    public static void reload() {
+        // Players are not guaranteed to be in a chunk if dead
+        for (Player player: Bukkit.getOnlinePlayers()) {
+            player.getTempMeta().clear();
+        }
+        for (WorldServer world : MinecraftServer.getServer().getWorlds()) {
+            reloadChunks(world.getChunkProvider().playerChunkMap.visibleChunks.values());
+            reloadChunks(world.getChunkProvider().playerChunkMap.updatingChunks.values());
+        }
+    }
+
+    private static void reloadChunks(Collection<PlayerChunk> playerChunks) {
+        for (PlayerChunk playerChunk : playerChunks) {
+            Chunk chunk = playerChunk.getFullChunkIfCached();
+            if (chunk == null) {
+                continue;
+            }
+            chunk.chunkTempMeta.clear();
+            chunk.getBukkitChunk().getTempMeta().clear();
+            for (List<Entity> entitySlice : chunk.entitySlices) {
+                for (Entity entity : entitySlice) {
+                    entity.getBukkitEntity().getTempMeta().clear();
+                }
+            }
+        }
+    }
+
+    public static Map<String, Object> getChunkTempMeta(Block block, boolean isWrite) {
+        Location loc = block.getLocation();
+        Chunk chunk = ((CraftChunk) block.getChunk()).getHandle();
+        Vector3i pos = new Vector3i(loc.getBlockX(), loc.getBlockY(), loc.getBlockZ());
+        Map<String, Object> map = chunk.chunkTempMeta.get(pos);
+        if (map == null) {
+            if (!isWrite) {
+                return null;
+            }
+            map = new HashMap<>(0);
+            chunk.chunkTempMeta.put(pos, map);
+        }
+        return map;
+    }
+
+    public static class ChunkTempMeta extends HashMap<Vector3i, Map<String, Object>> {
+        public ChunkTempMeta() {
+            super(0);
+        }
+
+        public ChunkTempMeta(Map<? extends Vector3i, ? extends Map<String, Object>> m) {
+            super(m);
+        }
+
+        public ChunkTempMeta clone() {
+            return (ChunkTempMeta) new ChunkTempMeta(this);
+        }
+    }
+
+    public static class ChunkPersistentMeta extends HashMap<Vector3i, PersistentMetaMap> {
+        ChunkPersistentMeta() {
+            super(0);
+        }
+
+        ChunkPersistentMeta(Map<? extends Vector3i, ? extends PersistentMetaMap> m) {
+            super(m);
+        }
+
+        public ChunkPersistentMeta clone() {
+            return new ChunkPersistentMeta(this);
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/level/PlayerChunkMap.java b/src/main/java/net/minecraft/server/level/PlayerChunkMap.java
index 300884804bf9ac3fba7c30a04d8adf52e3dd2e3e..f60b2d85401055233b017c07b1fa53b35b1fd8ce 100644
--- a/src/main/java/net/minecraft/server/level/PlayerChunkMap.java
+++ b/src/main/java/net/minecraft/server/level/PlayerChunkMap.java
@@ -64,6 +64,7 @@ import net.minecraft.network.protocol.game.PacketPlayOutMount;
 import net.minecraft.network.protocol.game.PacketPlayOutViewCentre;
 import net.minecraft.network.protocol.game.PacketPlayOutViewDistance;
 import net.minecraft.server.MCUtil;
+import net.minecraft.server.MetaApiAccessor;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.level.progress.WorldLoadListener;
 import net.minecraft.server.network.PlayerConnection;
@@ -1339,6 +1340,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
                     chunk = ((ProtoChunkExtension) ichunkaccess).u();
                 } else {
                     chunk = new Chunk(this.world, (ProtoChunk) ichunkaccess);
+                    MetaApiAccessor.loadChunkMetaNbt((ProtoChunk) ichunkaccess, chunk); // EMC
                     playerchunk.a(new ProtoChunkExtension(chunk));
                 }
 
diff --git a/src/main/java/net/minecraft/server/level/WorldServer.java b/src/main/java/net/minecraft/server/level/WorldServer.java
index 0a698a5a4a6502a488c9afb0ad97165e60030896..f6b85e3a9c0ac179845a5f07dc1b25d5634ece47 100644
--- a/src/main/java/net/minecraft/server/level/WorldServer.java
+++ b/src/main/java/net/minecraft/server/level/WorldServer.java
@@ -174,7 +174,7 @@ public class WorldServer extends World implements GeneratorAccessSeed {
     public static final BlockPosition a = new BlockPosition(100, 50, 0);
     private static final Logger LOGGER = LogManager.getLogger();
     public final Int2ObjectMap<Entity> entitiesById = new Int2ObjectLinkedOpenHashMap();
-    private final Map<UUID, Entity> entitiesByUUID = Maps.newHashMap();
+    private final Map<UUID, Entity> entitiesByUUID = Maps.newHashMap(); // EMC - private -> public
     private final Queue<Entity> entitiesToAdd = Queues.newArrayDeque();
     public final List<EntityPlayer> players = Lists.newArrayList(); // Paper - private -> public
     public final ChunkProviderServer chunkProvider; // Paper - public
diff --git a/src/main/java/net/minecraft/world/entity/Entity.java b/src/main/java/net/minecraft/world/entity/Entity.java
index 429f0591c6a55f6c5d08a0755f7d39da676468bc..2b50ec68f9895e1c1250e5eba6976f4202f06d00 100644
--- a/src/main/java/net/minecraft/world/entity/Entity.java
+++ b/src/main/java/net/minecraft/world/entity/Entity.java
@@ -47,6 +47,7 @@ import net.minecraft.network.syncher.DataWatcherRegistry;
 import net.minecraft.resources.MinecraftKey;
 import net.minecraft.resources.ResourceKey;
 import net.minecraft.server.MCUtil;
+import net.minecraft.server.MetaApiAccessor;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.level.ChunkProviderServer;
 import net.minecraft.server.level.EntityPlayer;
@@ -145,6 +146,7 @@ import org.bukkit.plugin.PluginManager;
 public abstract class Entity implements INamableTileEntity, ICommandListener, net.minecraft.server.KeyedObject { // Paper
 
     // CraftBukkit start
+    public com.empireminecraft.api.meta.PersistentMetaMap metaMap = null; // EMC
     private static final int CURRENT_LEVEL = 2;
     boolean preserveMotion = true; // Paper - keep initial motion on first setPositionRotation
     static boolean isLevelAtLeast(NBTTagCompound tag, int level) {
@@ -1633,6 +1635,7 @@ public abstract class Entity implements INamableTileEntity, ICommandListener, ne
                 this.yaw = 0;
             }
 
+            MetaApiAccessor.saveEntityMeta(this, nbttagcompound); // EMC
             if (Float.isNaN(this.pitch)) {
                 this.pitch = 0;
             }
@@ -1861,6 +1864,7 @@ public abstract class Entity implements INamableTileEntity, ICommandListener, ne
             // CraftBukkit end
 
             // Paper start - Restore the entity's origin location
+            MetaApiAccessor.loadEntityMeta(this, nbttagcompound); // EMC
             NBTTagList originTag = nbttagcompound.getList("Paper.Origin", 6);
             if (!originTag.isEmpty()) {
                 origin = new org.bukkit.Location(world.getWorld(), originTag.getDoubleAt(0), originTag.getDoubleAt(1), originTag.getDoubleAt(2));
diff --git a/src/main/java/net/minecraft/world/level/World.java b/src/main/java/net/minecraft/world/level/World.java
index 78dcba08d6d796d5d97c8304bf1f1e7d1e650d5d..7c742458fea205c6db10dfca7e6c216314d2e93d 100644
--- a/src/main/java/net/minecraft/world/level/World.java
+++ b/src/main/java/net/minecraft/world/level/World.java
@@ -29,6 +29,7 @@ import net.minecraft.network.protocol.Packet;
 import net.minecraft.resources.MinecraftKey;
 import net.minecraft.resources.ResourceKey;
 import net.minecraft.server.MCUtil;
+import net.minecraft.server.MetaApiAccessor;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.level.EntityPlayer;
 import net.minecraft.server.level.PlayerChunk;
@@ -500,6 +501,7 @@ public abstract class World implements GeneratorAccess, AutoCloseable {
                     this.a(blockposition, iblockdata1, iblockdata2);
                 }
                 */
+                if (block == Blocks.AIR) MetaApiAccessor.processSetAir(chunk, blockposition); // EMC
 
                 // CraftBukkit start
                 if (!this.captureBlockStates) { // Don't notify clients or update physics while capturing blockstates
diff --git a/src/main/java/net/minecraft/world/level/block/entity/TileEntity.java b/src/main/java/net/minecraft/world/level/block/entity/TileEntity.java
index f1e586754396439dfb70a4d63e3b8b34fb36ebf4..1ea93764204863ad0eba9d74d161cf8774c8644a 100644
--- a/src/main/java/net/minecraft/world/level/block/entity/TileEntity.java
+++ b/src/main/java/net/minecraft/world/level/block/entity/TileEntity.java
@@ -7,6 +7,7 @@ import net.minecraft.core.IRegistry;
 import net.minecraft.nbt.NBTTagCompound;
 import net.minecraft.network.protocol.game.PacketPlayOutTileEntityData;
 import net.minecraft.resources.MinecraftKey;
+import net.minecraft.server.MetaApiAccessor;
 import net.minecraft.world.level.World;
 import net.minecraft.world.level.block.EnumBlockMirror;
 import net.minecraft.world.level.block.EnumBlockRotation;
@@ -95,6 +96,7 @@ public abstract class TileEntity implements net.minecraft.server.KeyedObject { /
     }
 
     public void load(IBlockData iblockdata, NBTTagCompound nbttagcompound) {
+        MetaApiAccessor.loadTileEntityMeta(this, nbttagcompound); // EMC
         this.position = new BlockPosition(nbttagcompound.getInt("x"), nbttagcompound.getInt("y"), nbttagcompound.getInt("z"));
         // CraftBukkit start - read container
         this.persistentDataContainer.clear(); // Paper - clear instead of reinit
@@ -117,6 +119,7 @@ public abstract class TileEntity implements net.minecraft.server.KeyedObject { /
             throw new RuntimeException(this.getClass() + " is missing a mapping! This is a bug!");
         } else {
             nbttagcompound.setString("id", minecraftkey.toString());
+            MetaApiAccessor.saveTileEntityMeta(this, nbttagcompound); // EMC
             nbttagcompound.setInt("x", this.position.getX());
             nbttagcompound.setInt("y", this.position.getY());
             nbttagcompound.setInt("z", this.position.getZ());
@@ -247,6 +250,7 @@ public abstract class TileEntity implements net.minecraft.server.KeyedObject { /
         }
     }
 
+    public com.empireminecraft.api.meta.PersistentMetaMap metaMap; // EMC
     // CraftBukkit start - add method
     // Paper start
     public InventoryHolder getOwner() {
diff --git a/src/main/java/net/minecraft/world/level/chunk/Chunk.java b/src/main/java/net/minecraft/world/level/chunk/Chunk.java
index 34a9f7b2f998f77b1279516cd09397ab6c2ac1cc..76a501c14556f5c82cc5570efdc5460d08fd4f13 100644
--- a/src/main/java/net/minecraft/world/level/chunk/Chunk.java
+++ b/src/main/java/net/minecraft/world/level/chunk/Chunk.java
@@ -26,6 +26,7 @@ import net.minecraft.ReportedException;
 import net.minecraft.core.BlockPosition;
 import net.minecraft.core.IRegistry;
 import net.minecraft.nbt.NBTTagCompound;
+import net.minecraft.server.MetaApiAccessor;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.level.ChunkProviderServer;
 import net.minecraft.network.protocol.Packet;
@@ -187,6 +188,8 @@ public class Chunk implements IChunkAccess {
         return bukkitChunk;
     }
 
+    public MetaApiAccessor.ChunkPersistentMeta chunkMeta; // EMC
+    public MetaApiAccessor.ChunkTempMeta chunkTempMeta = new MetaApiAccessor.ChunkTempMeta(); // EMC
     public boolean mustNotSave;
     public boolean needsDecoration;
 
diff --git a/src/main/java/net/minecraft/world/level/chunk/ProtoChunk.java b/src/main/java/net/minecraft/world/level/chunk/ProtoChunk.java
index 7bfac4e852c4a6697435647dab173913df6034e9..dd37a3718e21de928ef7eeaf3b1fc0363e079d6b 100644
--- a/src/main/java/net/minecraft/world/level/chunk/ProtoChunk.java
+++ b/src/main/java/net/minecraft/world/level/chunk/ProtoChunk.java
@@ -20,6 +20,7 @@ import java.util.stream.Stream;
 import javax.annotation.Nullable;
 import net.minecraft.core.BlockPosition;
 import net.minecraft.nbt.NBTTagCompound;
+import net.minecraft.nbt.NBTTagList;
 import net.minecraft.world.entity.Entity;
 import net.minecraft.world.level.ChunkCoordIntPair;
 import net.minecraft.world.level.IBlockAccess;
@@ -65,6 +66,8 @@ public class ProtoChunk implements IChunkAccess {
     private final Map<WorldGenStage.Features, BitSet> t;
     private volatile boolean u;
     final World world; // Paper - Anti-Xray - Add world // Paper - private -> default
+    public NBTTagCompound chunkMeta; // EMC
+    public NBTTagList chunkMetaList; // EMC
 
     // Paper start - Anti-Xray - Add world
     @Deprecated public ProtoChunk(ChunkCoordIntPair chunkcoordintpair, ChunkConverter chunkconverter) { this(chunkcoordintpair, chunkconverter, null); } // Notice for updates: Please make sure this constructor isn't used anywhere
diff --git a/src/main/java/net/minecraft/world/level/chunk/ProtoChunkExtension.java b/src/main/java/net/minecraft/world/level/chunk/ProtoChunkExtension.java
index 7a82d43d51d80a3054e0871bf4b9aa7635920efc..25196a7fe231c99624e0cdaaaf1d74f6f7c140de 100644
--- a/src/main/java/net/minecraft/world/level/chunk/ProtoChunkExtension.java
+++ b/src/main/java/net/minecraft/world/level/chunk/ProtoChunkExtension.java
@@ -208,6 +208,7 @@ public class ProtoChunkExtension extends ProtoChunk {
         throw (UnsupportedOperationException) SystemUtils.c((Throwable) (new UnsupportedOperationException("Meaningless in this context")));
     }
 
+    public Chunk getChunk() { return this.u(); } // EMC - OBFHELPER
     public Chunk u() {
         return this.a;
     }
diff --git a/src/main/java/net/minecraft/world/level/chunk/storage/ChunkRegionLoader.java b/src/main/java/net/minecraft/world/level/chunk/storage/ChunkRegionLoader.java
index 4eaf497d048324a85ce49fc1c6e9559991c20df7..13c3643fa01ed44b7564e260aa54c6a66d202d6a 100644
--- a/src/main/java/net/minecraft/world/level/chunk/storage/ChunkRegionLoader.java
+++ b/src/main/java/net/minecraft/world/level/chunk/storage/ChunkRegionLoader.java
@@ -1,6 +1,7 @@
 package net.minecraft.world.level.chunk.storage;
 
 import co.aikar.timings.Timings;
+import com.empireminecraft.api.API;
 import com.google.common.collect.Maps;
 import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
 import it.unimi.dsi.fastutil.longs.LongSet;
@@ -27,6 +28,7 @@ import net.minecraft.nbt.NBTTagCompound;
 import net.minecraft.nbt.NBTTagList;
 import net.minecraft.nbt.NBTTagLongArray;
 import net.minecraft.nbt.NBTTagShort;
+import net.minecraft.server.MetaApiAccessor;
 import net.minecraft.server.level.ChunkProviderServer;
 import net.minecraft.server.level.EntityPlayer;
 import net.minecraft.server.level.LightEngineThreaded;
@@ -258,6 +260,7 @@ public class ChunkRegionLoader {
         }
 
         HeightMap.a((IChunkAccess) object, enumset);
+        MetaApiAccessor.loadChunkMetaNbt(nbttagcompound1, (IChunkAccess) object); // EMC
         NBTTagCompound nbttagcompound4 = nbttagcompound1.getCompound("Structures");
 
         ((IChunkAccess) object).a(a(definedstructuremanager, nbttagcompound4, worldserver.getSeed()));
@@ -448,6 +451,7 @@ public class ChunkRegionLoader {
         nbttagcompound.set("Level", nbttagcompound1);
         nbttagcompound1.setInt("xPos", chunkcoordintpair.x);
         nbttagcompound1.setInt("zPos", chunkcoordintpair.z);
+        MetaApiAccessor.saveChunkMetaNbt(nbttagcompound1, ichunkaccess); // EMC
         nbttagcompound1.setLong("LastUpdate", asyncsavedata != null ? asyncsavedata.worldTime : worldserver.getTime()); // Paper - async chunk unloading
         nbttagcompound1.setLong("InhabitedTime", ichunkaccess.getInhabitedTime());
         nbttagcompound1.setString("Status", ichunkaccess.getChunkStatus().d());
diff --git a/src/main/java/net/minecraft/world/level/storage/Convertable.java b/src/main/java/net/minecraft/world/level/storage/Convertable.java
index 7475a833425d8edc488f8d7b8c68f71592783d33..8f496fe799e462bbc21f2bcfbaea65d8f5e0cac9 100644
--- a/src/main/java/net/minecraft/world/level/storage/Convertable.java
+++ b/src/main/java/net/minecraft/world/level/storage/Convertable.java
@@ -32,6 +32,7 @@ import net.minecraft.nbt.NBTCompressedStreamTools;
 import net.minecraft.nbt.NBTTagCompound;
 import net.minecraft.resources.RegistryLookupCodec;
 import net.minecraft.resources.ResourceKey;
+import net.minecraft.server.MetaApiAccessor;
 import net.minecraft.util.IProgressUpdate;
 import net.minecraft.util.SessionLock;
 import net.minecraft.util.datafix.DataConverterRegistry;
@@ -185,7 +186,12 @@ public class Convertable {
                 LevelVersion levelversion = LevelVersion.a(dynamic);
                 WorldSettings worldsettings = WorldSettings.a(dynamic, datapackconfiguration);
 
-                return WorldDataServer.a(dynamic, datafixer, i, nbttagcompound2, worldsettings, levelversion, (GeneratorSettings) pair.getFirst(), (Lifecycle) pair.getSecond());
+                // EMC start
+                WorldDataServer worldDataServer = WorldDataServer.a(dynamic, datafixer, i, nbttagcompound2, worldsettings, levelversion, (GeneratorSettings) pair.getFirst(),
+                    (Lifecycle) pair.getSecond());
+                MetaApiAccessor.loadWorldMeta(worldDataServer, nbttagcompound1); // Should be Data
+                return worldDataServer;
+                // EMC end
             } catch (Exception exception) {
                 Convertable.LOGGER.error("Exception reading {}", file, exception);
                 return null;
diff --git a/src/main/java/net/minecraft/world/level/storage/WorldDataServer.java b/src/main/java/net/minecraft/world/level/storage/WorldDataServer.java
index 202d0aea445003a6dc3355ff2f2663cc675d4504..d7c2dfe6063223917293185b4001be7d0cca971f 100644
--- a/src/main/java/net/minecraft/world/level/storage/WorldDataServer.java
+++ b/src/main/java/net/minecraft/world/level/storage/WorldDataServer.java
@@ -24,6 +24,7 @@ import net.minecraft.nbt.NBTTagCompound;
 import net.minecraft.nbt.NBTTagList;
 import net.minecraft.nbt.NBTTagString;
 import net.minecraft.resources.RegistryWriteOps;
+import net.minecraft.server.MetaApiAccessor;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.util.datafix.DataFixTypes;
 import net.minecraft.world.EnumDifficulty;
@@ -85,6 +86,7 @@ public class WorldDataServer implements IWorldDataServer, SaveData {
     private boolean D;
     private final CustomFunctionCallbackTimerQueue<MinecraftServer> E;
     public WorldServer world; // CraftBukkit
+    public com.empireminecraft.api.meta.PersistentMetaMap metaMap = new com.empireminecraft.api.meta.PersistentMetaMap(); // EMC
 
     private WorldDataServer(@Nullable DataFixer datafixer, int i, @Nullable NBTTagCompound nbttagcompound, boolean flag, int j, int k, int l, float f, long i1, long j1, int k1, int l1, int i2, boolean flag1, int j2, boolean flag2, boolean flag3, boolean flag4, WorldBorder.c worldborder_c, int k2, int l2, @Nullable UUID uuid, LinkedHashSet<String> linkedhashset, CustomFunctionCallbackTimerQueue<MinecraftServer> customfunctioncallbacktimerqueue, @Nullable NBTTagCompound nbttagcompound1, NBTTagCompound nbttagcompound2, WorldSettings worldsettings, GeneratorSettings generatorsettings, Lifecycle lifecycle) {
         this.k = datafixer;
@@ -208,7 +210,7 @@ public class WorldDataServer implements IWorldDataServer, SaveData {
         if (this.B != null) {
             nbttagcompound.a("WanderingTraderId", this.B);
         }
-
+        MetaApiAccessor.saveWorldMeta(this, nbttagcompound); // EMC
         nbttagcompound.setString("Bukkit.Version", Bukkit.getName() + "/" + Bukkit.getVersion() + "/" + Bukkit.getBukkitVersion()); // CraftBukkit
     }
 
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftChunk.java b/src/main/java/org/bukkit/craftbukkit/CraftChunk.java
index 98ab124b4dca9387b4793cef68a33c67aed64e21..52d0e76f675d8c22768c3c2bb08afe970d088c7a 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftChunk.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftChunk.java
@@ -41,6 +41,8 @@ import org.bukkit.plugin.Plugin;
 
 public class CraftChunk implements Chunk {
     private WeakReference<net.minecraft.world.level.chunk.Chunk> weakChunk;
+    private final com.empireminecraft.api.meta.TempMetaMap tempMeta = new com.empireminecraft.api.meta.TempMetaMap(); // EMC
+    public com.empireminecraft.api.meta.TempMetaMap getTempMeta() { return tempMeta; } // EMC
     private final WorldServer worldServer;
     private final int x;
     private final int z;
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index 33a6ab394e4eba83e49f8ad070a36eb7b06a260b..0bea5494195d1dfb24bfc2be1a10bcbcb7f1eda7 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -945,6 +945,9 @@ public final class CraftServer implements Server {
             ));
             if (console.isDebugging()) TraceUtil.dumpTraceForThread(worker.getThread(), "still running"); // Paper
         }
+        // EMC start
+        net.minecraft.server.MetaApiAccessor.reload();
+        // EMC end
         loadPlugins();
         enablePlugins(PluginLoadOrder.STARTUP);
         enablePlugins(PluginLoadOrder.POSTWORLD);
diff --git a/src/main/java/org/bukkit/craftbukkit/block/CraftBlockEntityState.java b/src/main/java/org/bukkit/craftbukkit/block/CraftBlockEntityState.java
index a4bd0d352c2babdbb31cdf49d63e2db3af4de146..aa531887bda6ca9918b1da9f62805076bffd4581 100644
--- a/src/main/java/org/bukkit/craftbukkit/block/CraftBlockEntityState.java
+++ b/src/main/java/org/bukkit/craftbukkit/block/CraftBlockEntityState.java
@@ -156,4 +156,11 @@ public class CraftBlockEntityState<T extends TileEntity> extends CraftBlockState
     public PersistentDataContainer getPersistentDataContainer() {
         return this.getSnapshot().persistentDataContainer;
     }
+
+    // EMC start
+    @Override
+    public boolean isTileEntity() {
+        return tileEntity != null;
+    }
+    // EMC end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/block/CraftBlockState.java b/src/main/java/org/bukkit/craftbukkit/block/CraftBlockState.java
index 1960f01b5e4d7bff96d466e9a48f1d5300f261d1..791f4c3f62872a3b42a39e6302f78f3f0f0bf538 100644
--- a/src/main/java/org/bukkit/craftbukkit/block/CraftBlockState.java
+++ b/src/main/java/org/bukkit/craftbukkit/block/CraftBlockState.java
@@ -290,4 +290,11 @@ public class CraftBlockState implements BlockState {
             throw new IllegalStateException("The blockState must be placed to call this method");
         }
     }
+
+    // EMC start
+    @Override
+    public boolean isTileEntity() {
+        return false;
+    }
+    // EMC end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
index 295ffab08672d77d88aca368cb5b56f80bc4f1b5..3584558d7005e43343e2299061f462fdbf30207d 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
@@ -178,6 +178,8 @@ import org.bukkit.util.NumberConversions;
 import org.bukkit.util.Vector;
 
 public abstract class CraftEntity implements org.bukkit.entity.Entity {
+    private final com.empireminecraft.api.meta.TempMetaMap tempMeta = new com.empireminecraft.api.meta.TempMetaMap(); // EMC
+    public com.empireminecraft.api.meta.TempMetaMap getTempMeta() { return tempMeta; } // EMC
     private static PermissibleBase perm;
     private static final CraftPersistentDataTypeRegistry DATA_TYPE_REGISTRY = new CraftPersistentDataTypeRegistry();
 
diff --git a/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java b/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
index 926440e846eff2c1aaa262aa2b3975b7dd225332..3bdd6c4c46f43ae571ef93c84afc0cbfaec5ee55 100644
--- a/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
+++ b/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
@@ -1447,6 +1447,11 @@ public class CraftEventFactory {
         InventoryCloseEvent event = new InventoryCloseEvent(human.activeContainer.getBukkitView(), reason); // Paper
         human.world.getServer().getPluginManager().callEvent(event);
         human.activeContainer.transferTo(human.defaultContainer, human.getBukkitEntity());
+        // EMC start
+        if (event.getInventory().getViewers().isEmpty()) {
+            org.bukkit.craftbukkit.inventory.CraftInventory.meta.remove(((org.bukkit.craftbukkit.inventory.CraftInventory)event.getInventory()).getInventory());
+        }
+        // EMC end
     }
 
     public static ItemStack handleEditBookEvent(EntityPlayer player, int itemInHandIndex, ItemStack itemInHand, ItemStack newBookItem) {
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftInventory.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftInventory.java
index c3fa97ac34e1fc61ae02f224f8afe5a0b486fb4d..10360ab39f025137cf8116498a90d6a0c274fabe 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftInventory.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftInventory.java
@@ -32,6 +32,17 @@ import org.bukkit.inventory.ItemStack;
 public class CraftInventory implements Inventory {
     protected final IInventory inventory;
 
+    // EMC start
+    public static final java.util.WeakHashMap<IInventory, HashMap<String, Object>> meta = new java.util.WeakHashMap<IInventory, HashMap<String, Object>>(64);
+    public HashMap<String, Object> getMeta() {
+        HashMap<String, Object> metaMap = meta.get(inventory);
+        if (metaMap == null) {
+            metaMap = new HashMap<String, Object>();
+            meta.put(inventory, metaMap);
+        }
+        return metaMap;
+    } // EMC end
+
     public CraftInventory(IInventory inventory) {
         this.inventory = inventory;
     }
