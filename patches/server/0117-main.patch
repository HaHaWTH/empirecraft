From 6ce0fca6e1ec677b9ee07283111235cc26c90d00 Mon Sep 17 00:00:00 2001
From: Aikar <aikar@aikar.co>
Date: Tue, 31 Mar 2020 01:26:28 -0400
Subject: [PATCH] main

---
 .../java/net/minecraft/server/PlayerChunk.java    | 15 +++++++++------
 .../java/net/minecraft/server/PlayerChunkMap.java |  1 +
 2 files changed, 10 insertions(+), 6 deletions(-)

diff --git a/src/main/java/net/minecraft/server/PlayerChunk.java b/src/main/java/net/minecraft/server/PlayerChunk.java
index e94d21f7a9..d532278136 100644
--- a/src/main/java/net/minecraft/server/PlayerChunk.java
+++ b/src/main/java/net/minecraft/server/PlayerChunk.java
@@ -56,6 +56,12 @@ public class PlayerChunk {
             this.urgentNeighbors.add(neighbor);
         }
     }
+    public void onNeighborsDone() {
+        for (PlayerChunk urgentNeighbor : this.urgentNeighbors) {
+            urgentNeighbor.clearChunkUrgent();
+        }
+        this.urgentNeighbors.clear();
+    }
 
     public void markChunkUrgent(ChunkStatus targetStatus) {
         if (!this.isUrgent) {
@@ -76,7 +82,7 @@ public class PlayerChunk {
             }
 
             CompletableFuture<Either<IChunkAccess, PlayerChunk.Failure>> fastCheck = this.getStatusFutureUnchecked(nextStatus);
-            if (fastCheck == null || fastCheck.getNow(null) == null || fastCheck.getNow(null).right().isPresent()) {
+            if (fastCheck == UNLOADED_CHUNK_ACCESS_FUTURE) {
                 // neighbours have not been queued, so we don't need to worry about prioritising them here
                 return;
             }
@@ -115,7 +121,7 @@ public class PlayerChunk {
                     if (nextStatus == ChunkStatus.LIGHT || !neighborCurrentStatus.isAtLeastStatus(neededStatus)) {
                         // we don't need to gen neighbours if our current chunk's status has already gone through the gen
                         // light is always an exception, no matter what if we go through light we need its neighbours - the light engine requires them
-                        neighbor.markChunkUrgent(neededStatus);
+                        this.onNeighborRequest(neighbor, neededStatus);
                     }
                 }
             }
@@ -127,10 +133,7 @@ public class PlayerChunk {
             this.chunkPriority = this.lastChunkPriority;
             this.lastChunkPriority = -1;
             this.isUrgent = false;
-            for (PlayerChunk urgentNeighbor : this.urgentNeighbors) {
-                urgentNeighbor.clearChunkUrgent();
-            }
-            this.urgentNeighbors.clear();
+            this.onNeighborsDone();
         }
     }
     // Paper end
diff --git a/src/main/java/net/minecraft/server/PlayerChunkMap.java b/src/main/java/net/minecraft/server/PlayerChunkMap.java
index a97ecabf72..1984f596d5 100644
--- a/src/main/java/net/minecraft/server/PlayerChunkMap.java
+++ b/src/main/java/net/minecraft/server/PlayerChunkMap.java
@@ -790,6 +790,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
                 return CompletableFuture.completedFuture(Either.right(playerchunk_failure));
             });
         }, (runnable) -> {
+            playerchunk.onNeighborsDone(); // Paper
             this.mailboxWorldGen.a(ChunkTaskQueueSorter.a(playerchunk, runnable)); // CraftBukkit - decompile error
         });
     }
-- 
2.25.1

