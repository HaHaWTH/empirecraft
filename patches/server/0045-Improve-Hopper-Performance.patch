From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Aikar <aikar@aikar.co>
Date: Fri, 29 May 2015 21:58:24 -0400
Subject: [PATCH] Improve Hopper Performance

Only do an item "suck in" action once per second
---
 .../world/entity/item/EntityItem.java         |  17 ++
 .../entity/vehicle/EntityMinecartHopper.java  | 183 ++++++++++++++++++
 .../world/level/block/entity/IHopper.java     |   1 +
 .../level/block/entity/TileEntityHopper.java  |  21 +-
 4 files changed, 221 insertions(+), 1 deletion(-)
 create mode 100644 src/main/java/net/minecraft/world/entity/vehicle/EntityMinecartHopper.java

diff --git a/src/main/java/net/minecraft/world/entity/item/EntityItem.java b/src/main/java/net/minecraft/world/entity/item/EntityItem.java
index 6c1f08141f585e4680c239c7d099b8d8d6ba9209..f19918bd5cea905d776d16132b403ed9e0a28ae8 100644
--- a/src/main/java/net/minecraft/world/entity/item/EntityItem.java
+++ b/src/main/java/net/minecraft/world/entity/item/EntityItem.java
@@ -25,10 +25,12 @@ import net.minecraft.world.entity.Entity;
 import net.minecraft.world.entity.EntityTypes;
 import net.minecraft.world.entity.EnumMoveType;
 import net.minecraft.world.entity.player.EntityHuman;
+import net.minecraft.world.entity.vehicle.EntityMinecartHopper;
 import net.minecraft.world.item.Item;
 import net.minecraft.world.item.ItemStack;
 import net.minecraft.world.item.Items;
 import net.minecraft.world.level.World;
+import net.minecraft.world.phys.AxisAlignedBB;
 import net.minecraft.world.phys.Vec3D;
 
 // CraftBukkit start
@@ -173,10 +175,24 @@ public class EntityItem extends Entity {
                 // CraftBukkit end
                 this.die();
             }
+            markHopperCarts(); // EMC
 
         }
     }
 
+    // EMC start
+    private void markHopperCarts() {
+        if (!this.dead && this.onGround && this.age < 20 * 60 && this.age % 20 == 0) {
+            AxisAlignedBB aabb = this.getBoundingBox().grow(32, 4, 32);
+            for (Entity entity : this.world.getEntities(this, aabb)) {
+                if (entity instanceof EntityMinecartHopper) {
+                    ((EntityMinecartHopper) entity).pickupImmunity = MinecraftServer.currentTick + 200;
+                }
+            }
+        }
+    }
+    // EMC end
+
     // Spigot start - copied from above
     @Override
     public void inactiveTick() {
@@ -197,6 +213,7 @@ public class EntityItem extends Entity {
             // CraftBukkit end
             this.die();
         }
+        markHopperCarts(); // EMC
     }
     // Spigot end
 
diff --git a/src/main/java/net/minecraft/world/entity/vehicle/EntityMinecartHopper.java b/src/main/java/net/minecraft/world/entity/vehicle/EntityMinecartHopper.java
new file mode 100644
index 0000000000000000000000000000000000000000..93022cb6026862e9e5498f776169a909c5b988c0
--- /dev/null
+++ b/src/main/java/net/minecraft/world/entity/vehicle/EntityMinecartHopper.java
@@ -0,0 +1,183 @@
+package net.minecraft.world.entity.vehicle;
+
+import java.util.List;
+import net.minecraft.core.BlockPosition;
+import net.minecraft.nbt.NBTTagCompound;
+import net.minecraft.world.IInventory;
+import net.minecraft.world.damagesource.DamageSource;
+import net.minecraft.world.entity.EntityTypes;
+import net.minecraft.world.entity.IEntitySelector;
+import net.minecraft.world.entity.item.EntityItem;
+import net.minecraft.world.entity.player.PlayerInventory;
+import net.minecraft.world.inventory.Container;
+import net.minecraft.world.inventory.ContainerHopper;
+import net.minecraft.world.level.GameRules;
+import net.minecraft.world.level.IMaterial;
+import net.minecraft.world.level.World;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.entity.IHopper;
+import net.minecraft.world.level.block.entity.TileEntityHopper;
+import net.minecraft.world.level.block.state.IBlockData;
+
+public class EntityMinecartHopper extends EntityMinecartContainer implements IHopper {
+
+    private boolean d = true;
+    private int e = -1;
+    private final BlockPosition f;
+    public int pickupImmunity = 0; // EMC
+
+    public EntityMinecartHopper(EntityTypes<? extends EntityMinecartHopper> entitytypes, World world) {
+        super(entitytypes, world);
+        this.f = BlockPosition.ZERO;
+    }
+
+    public EntityMinecartHopper(World world, double d0, double d1, double d2) {
+        super(EntityTypes.HOPPER_MINECART, d0, d1, d2, world);
+        this.f = BlockPosition.ZERO;
+    }
+
+    @Override
+    public EntityMinecartAbstract.EnumMinecartType getMinecartType() {
+        return EntityMinecartAbstract.EnumMinecartType.HOPPER;
+    }
+
+    @Override
+    public IBlockData q() {
+        return Blocks.HOPPER.getBlockData();
+    }
+
+    @Override
+    public int s() {
+        return 1;
+    }
+
+    @Override
+    public int getSize() {
+        return 5;
+    }
+
+    @Override
+    public void a(int i, int j, int k, boolean flag) {
+        boolean flag1 = !flag;
+
+        if (flag1 != this.isEnabled()) {
+            this.setEnabled(flag1);
+        }
+
+    }
+
+    public boolean isEnabled() {
+        return this.d;
+    }
+
+    public void setEnabled(boolean flag) {
+        this.d = flag;
+    }
+
+    @Override
+    public World getWorld() {
+        return this.world;
+    }
+
+    @Override
+    public double x() {
+        return this.locX();
+    }
+
+    @Override
+    public double z() {
+        return this.locY() + 0.5D;
+    }
+
+    @Override
+    public double A() {
+        return this.locZ();
+    }
+
+    @Override
+    public void tick() {
+        super.tick();
+        if (!this.world.isClientSide && this.isAlive() && this.isEnabled()) {
+            BlockPosition blockposition = this.getChunkCoordinates();
+
+            if (blockposition.equals(this.f)) {
+                --this.e;
+            } else {
+                this.setCooldown(0);
+            }
+
+            if (!this.C()) {
+                this.setCooldown(0);
+                if (this.B()) {
+                    this.setCooldown(4);
+                    this.update();
+                }
+            }
+        }
+
+    }
+
+    public boolean B() {
+        if (TileEntityHopper.a((IHopper) this)) {
+            return true;
+        } else {
+            List<EntityItem> list = this.world.a(EntityItem.class, this.getBoundingBox().grow(0.25D, 0.0D, 0.25D), IEntitySelector.a);
+
+            if (!list.isEmpty()) {
+                TileEntityHopper.a((IInventory) this, (EntityItem) list.get(0));
+            }
+
+            return false;
+        }
+    }
+
+    @Override
+    public void a(DamageSource damagesource) {
+        super.a(damagesource);
+        if (this.world.getGameRules().getBoolean(GameRules.DO_ENTITY_DROPS)) {
+            this.a((IMaterial) Blocks.HOPPER);
+        }
+
+    }
+
+    @Override
+    protected void saveData(NBTTagCompound nbttagcompound) {
+        super.saveData(nbttagcompound);
+        nbttagcompound.setInt("TransferCooldown", this.e);
+        nbttagcompound.setBoolean("Enabled", this.d);
+    }
+
+    @Override
+    protected void loadData(NBTTagCompound nbttagcompound) {
+        super.loadData(nbttagcompound);
+        this.e = nbttagcompound.getInt("TransferCooldown");
+        this.d = nbttagcompound.hasKey("Enabled") ? nbttagcompound.getBoolean("Enabled") : true;
+    }
+
+    public void setCooldown(int i) {
+        this.e = i;
+    }
+
+    public boolean C() {
+        return this.e > 0;
+    }
+
+    @Override
+    public Container a(int i, PlayerInventory playerinventory) {
+        return new ContainerHopper(i, playerinventory, this);
+    }
+
+    // EMC start - fix compile
+    @Override
+    public org.bukkit.Location getLocation() {
+        //noinspection RedundantCast
+        return new org.bukkit.Location(getWorld().getWorld(), ((IHopper) this).getX(),((IHopper) this).getY(),((IHopper) this).getZ());
+    }
+
+    private long tickAttempts = 0;
+    @Override
+    public long getAndIncrementAttemptCounter() {
+        return tickAttempts++;
+    }
+    // EMC stop
+}
diff --git a/src/main/java/net/minecraft/world/level/block/entity/IHopper.java b/src/main/java/net/minecraft/world/level/block/entity/IHopper.java
index 1db7b7bfe98658d0b20800a4178556f8daaf881a..94269603d4dd2c9d319904e2a60f091d5b45d898 100644
--- a/src/main/java/net/minecraft/world/level/block/entity/IHopper.java
+++ b/src/main/java/net/minecraft/world/level/block/entity/IHopper.java
@@ -21,6 +21,7 @@ public interface IHopper extends IInventory {
     //@Nullable // Paper - it's annoying
     World getWorld();
     default BlockPosition getBlockPosition() { return new BlockPosition(getX(), getY(), getZ()); } // Paper
+    long getAndIncrementAttemptCounter(); // EMC
 
     double x(); default double getX() { return this.x(); } // Paper - OBFHELPER
 
diff --git a/src/main/java/net/minecraft/world/level/block/entity/TileEntityHopper.java b/src/main/java/net/minecraft/world/level/block/entity/TileEntityHopper.java
index 0d718be20eb592d36fd126d48da54ce45d43c858..b003891632a5436aa10fcc9d11fb7a7761ecca48 100644
--- a/src/main/java/net/minecraft/world/level/block/entity/TileEntityHopper.java
+++ b/src/main/java/net/minecraft/world/level/block/entity/TileEntityHopper.java
@@ -12,6 +12,7 @@ import net.minecraft.core.NonNullList;
 import net.minecraft.nbt.NBTTagCompound;
 import net.minecraft.network.chat.ChatMessage;
 import net.minecraft.network.chat.IChatBaseComponent;
+import net.minecraft.server.MinecraftServer;
 import net.minecraft.world.ContainerUtil;
 import net.minecraft.world.IInventory;
 import net.minecraft.world.IInventoryHolder;
@@ -119,6 +120,23 @@ public class TileEntityHopper extends TileEntityLootable implements IHopper, ITi
         return ContainerUtil.a(this.f(), i, j);
     }
 
+    // EMC start
+    private long tickAttempts = 0;
+    @Override
+    public long getAndIncrementAttemptCounter() {
+        return tickAttempts++;
+    }
+
+    private static boolean shouldSuckin(IHopper hopper) {
+        if (hopper instanceof EntityMinecartHopper && ((EntityMinecartHopper) hopper).pickupImmunity > MinecraftServer.currentTick) {
+            return true;
+        }
+
+        final int hopperId = (int) hopper.getX() + (int) hopper.getY() + (int) hopper.getZ();
+        return (hopper.getAndIncrementAttemptCounter() + hopperId) % 20 == 0;
+    }
+    // EMC end
+
     @Override
     public void setItem(int i, ItemStack itemstack) {
         this.d((EntityHuman) null);
@@ -480,7 +498,7 @@ public class TileEntityHopper extends TileEntityLootable implements IHopper, ITi
                 }
             });
             // Paper end
-        } else {
+        } else if (shouldSuckin(ihopper)) { // EMC
             Iterator iterator = c(ihopper).iterator();
 
             EntityItem entityitem;
@@ -495,6 +513,7 @@ public class TileEntityHopper extends TileEntityLootable implements IHopper, ITi
 
             return true;
         }
+        return false; // EMC
     }
 
     private static boolean a(IHopper ihopper, IInventory iinventory, int i, EnumDirection enumdirection) {// Paper - method unused as logic is inlined above
