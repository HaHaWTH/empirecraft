From eb3a655440c2e40f78840bfab3f8e86b5a2281a3 Mon Sep 17 00:00:00 2001
From: Aikar <aikar@aikar.co>
Date: Mon, 4 Mar 2013 23:35:02 -0500
Subject: [PATCH] Persistent Meta API

This adds an API for getting and setting PERSISTENT Metadata
Meta data can be stored on Worlds, Entities, Chunks and at a Block level.
Meta is is provided in a simple Map/List setup and does not expose raw NBT access.
---
 .../java/com/empireminecraft/metaapi/MetaApi.java  | 196 ++++++++++++++
 src/main/java/net/minecraft/server/Chunk.java      |   1 +
 .../net/minecraft/server/ChunkRegionLoader.java    |   2 +
 src/main/java/net/minecraft/server/Entity.java     |   3 +
 .../java/net/minecraft/server/MetaApiAccessor.java | 294 +++++++++++++++++++++
 .../java/net/minecraft/server/WorldNBTStorage.java |   5 +
 6 files changed, 501 insertions(+)
 create mode 100644 src/main/java/com/empireminecraft/metaapi/MetaApi.java
 create mode 100644 src/main/java/net/minecraft/server/MetaApiAccessor.java

diff --git a/src/main/java/com/empireminecraft/metaapi/MetaApi.java b/src/main/java/com/empireminecraft/metaapi/MetaApi.java
new file mode 100644
index 0000000..11d47e1
--- /dev/null
+++ b/src/main/java/com/empireminecraft/metaapi/MetaApi.java
@@ -0,0 +1,196 @@
+package com.empireminecraft.metaapi;
+
+import net.minecraft.server.MetaApiAccessor;
+import org.bukkit.Chunk;
+import org.bukkit.Location;
+import org.bukkit.World;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.entity.Entity;
+import org.bukkit.inventory.ItemStack;
+
+import java.security.InvalidParameterException;
+import java.util.ArrayList;
+import java.util.HashMap;
+
+public class MetaApi {
+
+    //////////////////////////////////////////////////
+    //// WORLD META
+    //////////////////////////////////////////////////
+
+    public static MetaMap getWorldMetaMap(World world) {
+        return MetaApiAccessor.getWorldMetaMap((CraftWorld) world);
+    }
+
+    public static <T> T getWorldMeta(World world, String key) {
+        final MetaMap worldMetaMap = getWorldMetaMap(world);
+        return worldMetaMap != null && !worldMetaMap.isEmpty() ? (T) worldMetaMap.get(key) : null;
+    }
+
+    public static boolean hasWorldMeta(World world, String key) {
+        final MetaMap worldMetaMap = getWorldMetaMap(world);
+        return worldMetaMap != null && !worldMetaMap.isEmpty() && worldMetaMap.containsKey(key);
+    }
+
+    public static <T> T setWorldMeta(World world, String key, Object val) {
+        return setMetaMapValue(getWorldMetaMap(world), key, val);
+    }
+
+    public static <T> T removeWorldMeta(World world, String key) {
+        return setWorldMeta(world, key, null);
+    }
+    
+    //////////////////////////////////////////////////
+    //// ENTITY META
+    //////////////////////////////////////////////////
+
+    private static MetaMap getEntityMetaMap(Entity entity, boolean isWrite) {
+        return MetaApiAccessor.getEntityMetaMap(entity, isWrite);
+    }
+
+    public static <T> T getEntityMeta(Entity entity, String key) {
+        final MetaMap entityMetaMap = getEntityMetaMap(entity, false);
+        return entityMetaMap != null && !entityMetaMap.isEmpty() ? (T) entityMetaMap.get(key) : null;
+    }
+
+    public static boolean hasEntityMeta(Entity entity, String key) {
+        final MetaMap entityMetaMap = getEntityMetaMap(entity, false);
+        return entityMetaMap != null && !entityMetaMap.isEmpty() && entityMetaMap.containsKey(key);
+    }
+
+    public static <T> T setEntityMeta(Entity entity, String key, Object val) {
+        return setMetaMapValue(getEntityMetaMap(entity, true), key, val);
+    }
+
+    public static <T> T removeEntityMeta(Entity entity, String key) {
+        return setEntityMeta(entity, key, null);
+    }
+
+    //////////////////////////////////////////////////
+    //// CHUNK META
+    //////////////////////////////////////////////////
+
+    private static MetaMap getChunkMetaMap(Chunk chunk, boolean isWrite) {
+        return MetaApiAccessor.getChunkMetaMap(chunk, isWrite);
+    }
+
+    public static boolean hasChunkMeta(Chunk chunk, String key) {
+        final MetaMap chunkMetaMap = getChunkMetaMap(chunk, false);
+        return chunkMetaMap != null && !chunkMetaMap.isEmpty() && chunkMetaMap.containsKey(key);
+    }
+
+    public static <T> T getChunkMeta(Chunk chunk, String key) {
+        final MetaMap chunkMetaMap = getChunkMetaMap(chunk, false);
+        return chunkMetaMap != null && !chunkMetaMap.isEmpty() ? (T) getChunkMetaMap(chunk, false).get(key) : null;
+    }
+
+    public static <T> T setChunkMeta(Chunk chunk, String key, Object val) {
+        return setMetaMapValue(getChunkMetaMap(chunk, true), key, val);
+    }
+
+    public static <T> T removeChunkMeta(Chunk chunk, String key) {
+        return setChunkMeta(chunk, key, null);
+    }
+
+    //////////////////////////////////////////////////
+    //// BLOCK META
+    //////////////////////////////////////////////////
+
+    private static MetaMap getBlockMetaMap(Location loc, boolean isWrite) {
+        return MetaApiAccessor.getBlockMetaMap(loc, isWrite);
+    }
+
+    public static boolean hasBlockMeta(Location loc, String key) {
+        final MetaMap blockMetaMap = getBlockMetaMap(loc, false);
+        return blockMetaMap != null && !blockMetaMap.isEmpty() && blockMetaMap.containsKey(key);
+    }
+
+    public static <T> T getBlockMeta(Location loc, String key) {
+        final MetaMap blockMetaMap = getBlockMetaMap(loc, false);
+        return blockMetaMap != null && !blockMetaMap.isEmpty() ? (T) blockMetaMap.get(key) : null;
+    }
+
+    public static <T> T setBlockMeta(Location loc, String key, Object val) {
+        return setMetaMapValue(getBlockMetaMap(loc, true), key, val);
+    }
+
+    public static <T> T removeBlockMeta(Location loc, String key) {
+        return setBlockMeta(loc, key, null);
+    }
+
+    //////////////////////////////////////////////////
+    //// UTIL / CLASSES
+    //////////////////////////////////////////////////
+
+    /**
+     * General method for determining if value is null to remove it, else set.
+     * Return previous value
+     *
+     * @param map
+     * @param key
+     * @param val
+     * @param <T>
+     * @return
+     */
+    private static <T> T setMetaMapValue(MetaMap map, String key, Object val) {
+        if (val == null) {
+            return (T) map.remove(key);
+        } else {
+            return (T) map.put(key, val);
+        }
+    }
+
+    /**
+     * Checks if the passed object can be stored as Meta Data
+     * @param value
+     * @return
+     */
+    public static boolean isValidMeta(Object value) {
+        return (value instanceof String) || (value instanceof Long) ||
+            (value instanceof Integer) || (value instanceof ItemStack) ||
+            (value instanceof Float) || (value instanceof Double) ||
+            (value instanceof MetaMap) || (value instanceof MetaList);
+    }
+
+    /**
+     * A type protected array for storing meta values
+     */
+    public static class MetaList<T> extends ArrayList<T> {
+        @Override
+        public boolean add(T o) {
+            if (!isValidMeta(o)) {
+                throw new InvalidParameterException();
+            }
+            return super.add(o);
+        }
+
+        @Override
+        public T set(int index, T element) {
+            if (!isValidMeta(element)) {
+                throw new InvalidParameterException();
+            }
+            return super.set(index, element);
+        }
+
+        @Override
+        public void add(int index, T element) {
+            if (!isValidMeta(element)) {
+                throw new InvalidParameterException();
+            }
+            super.add(index, element);
+        }
+    }
+
+    /**
+     * A type protected hashmap for storing meta values
+     */
+    public static class MetaMap extends HashMap<String, Object> {
+        @Override
+        public Object put(String key, Object value) {
+            if (!isValidMeta(value)) {
+                throw new InvalidParameterException();
+            }
+            return super.put(key, value);
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Chunk.java b/src/main/java/net/minecraft/server/Chunk.java
index 8c98f3e..f4ee7d9 100644
--- a/src/main/java/net/minecraft/server/Chunk.java
+++ b/src/main/java/net/minecraft/server/Chunk.java
@@ -63,6 +63,7 @@ public class Chunk {
 
     public org.bukkit.Chunk bukkitChunk;
     public boolean mustSave;
+    public MetaApiAccessor.ChunkMeta chunkMeta = new MetaApiAccessor.ChunkMeta(); // EMC
     // CraftBukkit end
 
     public Chunk(World world, byte[] abyte, int i, int j) {
diff --git a/src/main/java/net/minecraft/server/ChunkRegionLoader.java b/src/main/java/net/minecraft/server/ChunkRegionLoader.java
index 0b086a2..1875494 100644
--- a/src/main/java/net/minecraft/server/ChunkRegionLoader.java
+++ b/src/main/java/net/minecraft/server/ChunkRegionLoader.java
@@ -198,6 +198,7 @@ public class ChunkRegionLoader implements IAsyncChunkSaver, IChunkLoader {
     private void a(Chunk chunk, World world, NBTTagCompound nbttagcompound) {
         nbttagcompound.setInt("xPos", chunk.x);
         nbttagcompound.setInt("zPos", chunk.z);
+        MetaApiAccessor.saveChunkMetaNbt(nbttagcompound, chunk); // EMC
         nbttagcompound.setLong("LastUpdate", world.getTime());
         nbttagcompound.setIntArray("HeightMap", chunk.heightMap);
         nbttagcompound.setBoolean("TerrainPopulated", chunk.done);
@@ -298,6 +299,7 @@ public class ChunkRegionLoader implements IAsyncChunkSaver, IChunkLoader {
         Chunk chunk = new Chunk(world, i, j);
 
         chunk.heightMap = nbttagcompound.getIntArray("HeightMap");
+        MetaApiAccessor.loadChunkMetaNbt(nbttagcompound, chunk); // EMC
         chunk.done = nbttagcompound.getBoolean("TerrainPopulated");
         chunk.q = nbttagcompound.getLong("InhabitedTime");
         NBTTagList nbttaglist = nbttagcompound.getList("Sections");
diff --git a/src/main/java/net/minecraft/server/Entity.java b/src/main/java/net/minecraft/server/Entity.java
index d87bd3f..9b805d5 100644
--- a/src/main/java/net/minecraft/server/Entity.java
+++ b/src/main/java/net/minecraft/server/Entity.java
@@ -33,6 +33,7 @@ import org.bukkit.plugin.PluginManager;
 public abstract class Entity {
 
     // CraftBukkit start
+    public com.empireminecraft.metaapi.MetaApi.MetaMap metaMap = null; // EMC
     private static final int CURRENT_LEVEL = 2;
     static boolean isLevelAtLeast(NBTTagCompound tag, int level) {
         return tag.hasKey("Bukkit.updateLevel") && tag.getInt("Bukkit.updateLevel") >= level;
@@ -1088,6 +1089,7 @@ public abstract class Entity {
                 this.yaw = 0;
             }
 
+            MetaApiAccessor.saveEntityMeta(this, nbttagcompound); // EMC
             if (Float.isNaN(this.pitch)) {
                 this.pitch = 0;
             }
@@ -1134,6 +1136,7 @@ public abstract class Entity {
             this.motX = ((NBTTagDouble) nbttaglist1.get(0)).data;
             this.motY = ((NBTTagDouble) nbttaglist1.get(1)).data;
             this.motZ = ((NBTTagDouble) nbttaglist1.get(2)).data;
+            MetaApiAccessor.loadEntityMeta(this, nbttagcompound); // EMC
             /* CraftBukkit start - Moved section down
             if (Math.abs(this.motX) > 10.0D) {
                 this.motX = 0.0D;
diff --git a/src/main/java/net/minecraft/server/MetaApiAccessor.java b/src/main/java/net/minecraft/server/MetaApiAccessor.java
new file mode 100644
index 0000000..c387b9a
--- /dev/null
+++ b/src/main/java/net/minecraft/server/MetaApiAccessor.java
@@ -0,0 +1,294 @@
+package net.minecraft.server;
+
+import org.bukkit.craftbukkit.CraftChunk;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.craftbukkit.entity.CraftEntity;
+import org.bukkit.craftbukkit.inventory.CraftItemStack;
+
+import java.util.*;
+
+import static com.empireminecraft.metaapi.MetaApi.*;
+
+public class MetaApiAccessor {
+
+    public static MetaMap getWorldMetaMap(CraftWorld world) {
+        return ((WorldNBTStorage)world.getHandle().dataManager).metaMap;
+    }
+    /**
+     * Util for getting a MetaMap by location
+     * @param loc
+     * @return
+     */
+    public static MetaMap getBlockMetaMap(org.bukkit.Location loc, boolean isWrite) {
+        ChunkMeta meta = ((CraftChunk)loc.getChunk()).getHandle().chunkMeta;
+        return getBlockMetaMap(meta, loc.getBlockX(), loc.getBlockY(), loc.getBlockZ(), isWrite);
+    }
+
+    /**
+     * Util for getting a MetaMap for a chunk
+     * @param chunk
+     * @return
+     */
+    public static MetaMap getChunkMetaMap(org.bukkit.Chunk chunk, boolean isWrite) {
+        ChunkMeta meta = ((CraftChunk) chunk).getHandle().chunkMeta;
+        return getBlockMetaMap(meta, 0, -1, 0, isWrite);
+    }
+
+    /**
+     * Gets the metamap for the specified coords, creating it if it doesnt exists
+     * @param meta
+     * @param x
+     * @param y
+     * @param z
+     * @return
+     */
+    public static MetaMap getBlockMetaMap(ChunkMeta meta, int x, int y, int z, boolean isWrite) {
+        ChunkCoordinates coords = new ChunkCoordinates(x, y,  z);
+        MetaMap ret = meta.get(coords);
+        if (ret == null) {
+            if (isWrite) {
+                ret = new MetaMap();
+                meta.put(coords, ret);
+            }
+        }
+        return ret;
+    }
+
+    /**
+     * Util for getting a MetaMap for an Entity
+     * @param craftentity
+     * @return
+     */
+    public static MetaMap getEntityMetaMap(org.bukkit.entity.Entity craftentity, boolean isWrite) {
+        Entity entity = ((CraftEntity) craftentity).getHandle();
+        if (entity.metaMap == null) {
+            if (isWrite) {
+                entity.metaMap = new MetaMap();
+            }
+        }
+        return entity.metaMap;
+    }
+
+    public static void loadEntityMeta(Entity entity, NBTTagCompound nbt) {
+        if (nbt.hasKey("_EntityMeta")) {
+            NBTTagCompound nbtmeta = nbt.getCompound("_EntityMeta");
+            entity.metaMap = getMetaMapFromCompound(nbtmeta);
+        }
+        if (entity.metaMap == null) {
+            entity.metaMap = new MetaMap();
+        }
+    }
+    public static void saveEntityMeta(Entity entity, NBTTagCompound nbt) {
+        if (entity.metaMap != null && entity.metaMap.size() > 0) {
+            NBTBase nbtmeta = getNbtFromObject(entity.metaMap);
+            nbt.set("_EntityMeta", nbtmeta);
+        }
+    }
+
+    public static void loadWorldMeta(WorldNBTStorage world, NBTTagCompound nbt) {
+        if (nbt.hasKey("_WorldMeta")) {
+            NBTTagCompound nbtmeta = nbt.getCompound("_WorldMeta");
+            world.metaMap = getMetaMapFromCompound(nbtmeta);
+        }
+        if (world.metaMap == null) {
+            world.metaMap = new MetaMap();
+        }
+    }
+
+    public static void saveWorldMeta(WorldNBTStorage world, NBTTagCompound nbt) {
+        if (world.metaMap != null && world.metaMap.size() > 0) {
+            NBTBase nbtmeta = getNbtFromObject(world.metaMap);
+            nbt.set("_WorldMeta", nbtmeta);
+        }
+    }
+
+    /**
+     * Saves this chunks Meta Data into NBT
+     * @param cmp
+     * @param chunk
+     */
+    static void saveChunkMetaNbt(NBTTagCompound cmp, Chunk chunk) {
+        NBTTagCompound meta = new NBTTagCompound();
+        for (Map.Entry<ChunkCoordinates, MetaMap> entry : chunk.chunkMeta.entrySet()) {
+            ChunkCoordinates coords = entry.getKey();
+            MetaMap list = entry.getValue();
+            NBTTagCompound metalist = getCompoundFromMetaMap(list);
+            if (!metalist.isEmpty()) {
+                meta.set(getCoordAsStr(coords), metalist);
+            }
+        }
+
+        if (!meta.isEmpty()) {
+            cmp.set("_ChunkMeta", meta);
+        }
+    }
+
+    /**
+     * Loads this chunks Meta Data from NBT
+     * @param cmp
+     * @param chunk
+     */
+    static void loadChunkMetaNbt(NBTTagCompound cmp, Chunk chunk) {
+        ChunkMeta meta = chunk.chunkMeta;
+        if (cmp.hasKey("_ChunkMeta")) {
+            NBTTagCompound chunkMeta = cmp.getCompound("_ChunkMeta");
+            for (NBTTagCompound e : (Collection <NBTTagCompound>) chunkMeta.c()) {
+                MetaMap metalist = getMetaMapFromCompound(e);
+                if (!metalist.isEmpty()) {
+                    meta.put(getStrAsCoord(e.getName()), metalist);
+                }
+            }
+        }
+    }
+
+    /**
+     * Converts an Object into NBT
+     * @param value
+     * @return
+     */
+    private static NBTBase getNbtFromObject(Object value) {
+        if (value instanceof String) {
+            return new NBTTagString("string", (String) value);
+        } else if (value instanceof ItemStack || value instanceof org.bukkit.inventory.ItemStack) {
+            ItemStack item;
+            if (value instanceof org.bukkit.inventory.ItemStack) {
+                item = CraftItemStack.asNMSCopy((org.bukkit.inventory.ItemStack) value);
+            } else {
+                item = (ItemStack) value;
+            }
+            NBTTagCompound itemnbt = new NBTTagCompound();
+            itemnbt.setString("MetaType", "Item");
+            return item.save(itemnbt);
+        } else if (value instanceof Long) {
+            return new NBTTagLong("long", (Long) value);
+        } else if (value instanceof Integer) {
+            return new NBTTagInt("int", (Integer) value);
+        } else if (value instanceof Double) {
+            return new NBTTagDouble("double", (Double) value);
+        } else if (value instanceof Float) {
+            return new NBTTagFloat("float", (Float) value);
+        } else if (value instanceof MetaMap) {
+            return getCompoundFromMetaMap((MetaMap) value);
+        } else if (value instanceof MetaList) {
+            NBTTagList list = new NBTTagList();
+            for (Object obj : (List) value) {
+                NBTBase add = getNbtFromObject(obj);
+                if (add != null) {
+                    list.add(add);
+                }
+            }
+            return list;
+        }
+
+        return null;
+    }
+
+    /**
+     * Converts NBT into an Object
+     * @param nbt
+     * @return
+     */
+    private static Object getObjectFromNbt(NBTBase nbt) {
+        if (nbt instanceof NBTTagString) {
+            return ((NBTTagString) nbt).data;
+        } else if (nbt instanceof NBTTagInt) {
+            return ((NBTTagInt) nbt).data;
+        } else if (nbt instanceof NBTTagLong) {
+            return ((NBTTagLong) nbt).data;
+        } else if (nbt instanceof NBTTagFloat) {
+            return ((NBTTagFloat) nbt).data;
+        } else if (nbt instanceof NBTTagDouble) {
+            return ((NBTTagDouble) nbt).data;
+        } else if (nbt instanceof NBTTagList) {
+            MetaList<Object> list = new MetaList<Object>();
+            NBTTagList nbtlist = (NBTTagList) nbt;
+            for (int i = 0; i < nbtlist.size(); i++) {
+                final Object obj = getObjectFromNbt(nbtlist.get(i));
+                if (obj != null) {
+                    list.add(obj);
+                }
+            }
+            return list;
+        } else if (nbt instanceof NBTTagCompound) {
+            NBTTagCompound cmp = (NBTTagCompound) nbt;
+            if (cmp.hasKey("MetaType")) {
+                String type = cmp.getString("MetaType");
+                if ("Item".equals(type)) {
+                    return CraftItemStack.asBukkitCopy(ItemStack.createStack(cmp));
+                } else if ("MetaMap".equals(type)) {
+                    return getMetaMapFromCompound(cmp);
+                }
+            }
+        }
+        return null;
+    }
+
+    /**
+     * Converts a NBTTagCompound to a MetaMap
+     * @param cmp
+     * @return
+     */
+    private static MetaMap getMetaMapFromCompound(NBTTagCompound cmp) {
+        MetaMap list = new MetaMap();
+        for (Object entryobj : cmp.c()) {
+            NBTBase nbt = (NBTBase) entryobj;
+            if (nbt != null) {
+                list.put(nbt.getName(), getObjectFromNbt(nbt));
+            }
+        }
+        return list;
+    }
+
+    /**
+     * Converts a MetaMap into an NBTTagCompount
+     * @param map
+     * @return
+     */
+    private static NBTTagCompound getCompoundFromMetaMap(MetaMap map) {
+        NBTTagCompound cmp = new NBTTagCompound();
+        cmp.setString("MetaType", "MetaMap");
+        for (Map.Entry<String, Object> entry : map.entrySet()) {
+            NBTBase add = getNbtFromObject(entry.getValue());
+            if (add != null) {
+                cmp.set(entry.getKey(), add);
+            }
+        }
+        return cmp;
+    }
+
+    /**
+     * Translates ChunkCoordinates to a String form
+     * @param coords
+     * @return
+     */
+    static String getCoordAsStr(ChunkCoordinates coords) {
+        if (coords == null) {
+            return null;
+        }
+        return "" + coords.x + ":" + coords.y + ":" + coords.z;
+    }
+
+    /**
+     * Parses a string into ChunkCoordinates
+     * @param loc
+     * @return
+     */
+    static ChunkCoordinates getStrAsCoord(String loc) {
+        if (loc != null)  {
+            String[] args = loc.split(":", 3);
+            if (args.length == 3) {
+                try {
+                    int x = (int) Math.floor(Float.parseFloat(args[0]));
+                    int y = (int) Math.floor(Float.parseFloat(args[1]));
+                    int z = (int) Math.floor(Float.parseFloat(args[2]));
+                    return new ChunkCoordinates(x, y, z);
+                } catch (NumberFormatException e) {
+
+                }
+            }
+        }
+        return null;
+    }
+
+    public static class ChunkMeta extends HashMap<ChunkCoordinates, MetaMap> {}
+}
diff --git a/src/main/java/net/minecraft/server/WorldNBTStorage.java b/src/main/java/net/minecraft/server/WorldNBTStorage.java
index 321f65b..1d20196 100644
--- a/src/main/java/net/minecraft/server/WorldNBTStorage.java
+++ b/src/main/java/net/minecraft/server/WorldNBTStorage.java
@@ -12,6 +12,7 @@ import java.io.OutputStream;
 // CraftBukkit start
 import java.util.UUID;
 
+import com.empireminecraft.metaapi.MetaApi; // EMC
 import org.bukkit.craftbukkit.entity.CraftPlayer;
 // CraftBukkit end
 
@@ -23,6 +24,7 @@ public class WorldNBTStorage implements IDataManager, IPlayerFileData {
     private final long sessionId = MinecraftServer.aq();
     private final String e;
     private UUID uuid = null; // CraftBukkit
+    public MetaApi.MetaMap metaMap = new MetaApi.MetaMap(); // EMC
 
     public WorldNBTStorage(File file1, String s, boolean flag) {
         this.baseDir = new File(file1, s);
@@ -88,6 +90,7 @@ public class WorldNBTStorage implements IDataManager, IPlayerFileData {
             try {
                 nbttagcompound = NBTCompressedStreamTools.a((InputStream) (new FileInputStream(file1)));
                 nbttagcompound1 = nbttagcompound.getCompound("Data");
+                MetaApiAccessor.loadWorldMeta(this, nbttagcompound1); // EMC
                 return new WorldData(nbttagcompound1);
             } catch (Exception exception) {
                 exception.printStackTrace();
@@ -99,6 +102,7 @@ public class WorldNBTStorage implements IDataManager, IPlayerFileData {
             try {
                 nbttagcompound = NBTCompressedStreamTools.a((InputStream) (new FileInputStream(file1)));
                 nbttagcompound1 = nbttagcompound.getCompound("Data");
+                MetaApiAccessor.loadWorldMeta(this, nbttagcompound1); // EMC
                 return new WorldData(nbttagcompound1);
             } catch (Exception exception1) {
                 exception1.printStackTrace();
@@ -112,6 +116,7 @@ public class WorldNBTStorage implements IDataManager, IPlayerFileData {
         NBTTagCompound nbttagcompound1 = worlddata.a(nbttagcompound);
         NBTTagCompound nbttagcompound2 = new NBTTagCompound();
 
+        MetaApiAccessor.saveWorldMeta(this, nbttagcompound1); // EMC
         nbttagcompound2.set("Data", nbttagcompound1);
 
         try {
-- 
1.8.4.4

