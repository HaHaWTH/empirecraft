From 86a87e8c383c7952b21cd0c9d36a7dce6bbeaca3 Mon Sep 17 00:00:00 2001
From: md_5 <md_5@bigpond.com>
Date: Sun, 24 Nov 2013 19:45:49 -0500
Subject: [PATCH] Spigot

---
 dependency-reduced-pom.xml                         | 262 +++++++++
 nb-configuration.xml                               |  31 +
 nbactions.xml                                      |  40 ++
 pom.xml                                            |  99 ++--
 src/main/java/net/minecraft/server/Block.java      |  20 +-
 .../net/minecraft/server/BlockBrewingStand.java    | 115 ++++
 .../java/net/minecraft/server/BlockCactus.java     |   2 +-
 src/main/java/net/minecraft/server/BlockCrops.java |   2 +-
 src/main/java/net/minecraft/server/BlockGrass.java |   3 +-
 .../java/net/minecraft/server/BlockMushroom.java   |   2 +-
 src/main/java/net/minecraft/server/BlockMycel.java |   3 +-
 .../net/minecraft/server/BlockRedstoneTorch.java   |   2 +-
 src/main/java/net/minecraft/server/BlockReed.java  |   2 +-
 .../java/net/minecraft/server/BlockSapling.java    |   2 +-
 src/main/java/net/minecraft/server/BlockStem.java  |   2 +-
 src/main/java/net/minecraft/server/BlockTNT.java   |  85 +++
 .../java/net/minecraft/server/ChatMessage.java     | 273 +++++++++
 src/main/java/net/minecraft/server/Chunk.java      |  51 ++
 .../net/minecraft/server/ChunkProviderServer.java  |   2 +
 .../net/minecraft/server/ChunkRegionLoader.java    |  59 +-
 .../java/net/minecraft/server/ChunkSection.java    |  26 +-
 src/main/java/net/minecraft/server/Connection.java | 324 +++++++++++
 .../java/net/minecraft/server/DedicatedServer.java |  19 +-
 .../minecraft/server/DispenseBehaviorBonemeal.java |   7 +-
 src/main/java/net/minecraft/server/Entity.java     |  33 +-
 .../java/net/minecraft/server/EntityAgeable.java   |  25 +
 .../java/net/minecraft/server/EntityArrow.java     |   4 +-
 .../net/minecraft/server/EntityFallingBlock.java   |   2 +
 .../java/net/minecraft/server/EntityHuman.java     |   8 +-
 src/main/java/net/minecraft/server/EntityItem.java |  19 +-
 .../java/net/minecraft/server/EntityLiving.java    |  11 +-
 .../minecraft/server/EntityMinecartContainer.java  |   6 +
 .../java/net/minecraft/server/EntityPlayer.java    |  28 +-
 .../java/net/minecraft/server/EntityTracker.java   |   3 +
 .../net/minecraft/server/EntityTrackerEntry.java   |   4 +-
 src/main/java/net/minecraft/server/Explosion.java  |   1 +
 .../java/net/minecraft/server/INetworkManager.java |  26 +
 src/main/java/net/minecraft/server/IRecipe.java    |   2 +
 src/main/java/net/minecraft/server/ItemStack.java  |  28 +-
 .../java/net/minecraft/server/LocaleLanguage.java  |  73 +++
 .../java/net/minecraft/server/MinecraftServer.java |  89 +--
 .../net/minecraft/server/MobSpawnerAbstract.java   |  25 +-
 .../java/net/minecraft/server/NetworkManager.java  |   4 +-
 .../net/minecraft/server/NextTickListEntry.java    |  56 ++
 .../java/net/minecraft/server/NibbleArray.java     | 158 +++++
 .../java/net/minecraft/server/OldChunkLoader.java  | 122 ++++
 src/main/java/net/minecraft/server/Packet.java     | 126 +++-
 .../net/minecraft/server/Packet0KeepAlive.java     |  44 ++
 .../net/minecraft/server/Packet100OpenWindow.java  |  60 ++
 .../net/minecraft/server/Packet101CloseWindow.java |  32 +
 .../net/minecraft/server/Packet102WindowClick.java |  43 ++
 .../net/minecraft/server/Packet103SetSlot.java     |  40 ++
 .../net/minecraft/server/Packet104WindowItems.java |  53 ++
 .../server/Packet105CraftProgressBar.java          |  40 ++
 .../net/minecraft/server/Packet106Transaction.java |  40 ++
 .../minecraft/server/Packet107SetCreativeSlot.java |  31 +
 .../net/minecraft/server/Packet108ButtonClick.java |  31 +
 .../java/net/minecraft/server/Packet10Flying.java  |  44 ++
 .../minecraft/server/Packet11PlayerPosition.java   |  32 +
 .../net/minecraft/server/Packet12PlayerLook.java   |  28 +
 .../net/minecraft/server/Packet130UpdateSign.java  |  60 ++
 .../net/minecraft/server/Packet131ItemData.java    |  41 ++
 .../minecraft/server/Packet132TileEntityData.java  |  51 ++
 .../minecraft/server/Packet133OpenTileEntity.java  |  42 ++
 .../minecraft/server/Packet13PlayerLookMove.java   |  48 ++
 .../net/minecraft/server/Packet14BlockDig.java     |  40 ++
 .../java/net/minecraft/server/Packet15Place.java   |  81 +++
 .../minecraft/server/Packet16BlockItemSwitch.java  |  40 ++
 .../server/Packet17EntityLocationAction.java       |  44 ++
 .../net/minecraft/server/Packet18ArmAnimation.java |  36 ++
 .../net/minecraft/server/Packet19EntityAction.java |  34 ++
 .../java/net/minecraft/server/Packet1Login.java    |  65 +++
 .../net/minecraft/server/Packet200Statistic.java   |  54 ++
 .../net/minecraft/server/Packet201PlayerInfo.java  |  40 ++
 .../net/minecraft/server/Packet202Abilities.java   | 117 ++++
 .../net/minecraft/server/Packet203TabComplete.java |  46 ++
 .../server/Packet204LocaleAndViewDistance.java     |  78 +++
 .../minecraft/server/Packet205ClientCommand.java   |  28 +
 .../server/Packet206SetScoreboardObjective.java    |  40 ++
 .../server/Packet207SetScoreboardScore.java        |  55 ++
 .../Packet208SetScoreboardDisplayObjective.java    |  40 ++
 .../server/Packet209SetScoreboardTeam.java         |  97 ++++
 .../minecraft/server/Packet20NamedEntitySpawn.java |  15 +-
 .../java/net/minecraft/server/Packet22Collect.java |  36 ++
 .../net/minecraft/server/Packet23VehicleSpawn.java |  99 ++++
 .../net/minecraft/server/Packet24MobSpawn.java     |  96 +++
 .../minecraft/server/Packet250CustomPayload.java   |  50 ++
 .../net/minecraft/server/Packet252KeyResponse.java |  46 ++
 .../net/minecraft/server/Packet253KeyRequest.java  |  41 ++
 .../net/minecraft/server/Packet254GetInfo.java     |  32 +
 .../minecraft/server/Packet255KickDisconnect.java  |  40 ++
 .../minecraft/server/Packet25EntityPainting.java   |  47 ++
 .../net/minecraft/server/Packet26AddExpOrb.java    |  44 ++
 .../net/minecraft/server/Packet27PlayerInput.java  |  53 ++
 .../minecraft/server/Packet28EntityVelocity.java   |  84 +++
 .../minecraft/server/Packet29DestroyEntity.java    |  40 ++
 .../net/minecraft/server/Packet2Handshake.java     |  49 +-
 .../java/net/minecraft/server/Packet30Entity.java  |  52 ++
 .../minecraft/server/Packet31RelEntityMove.java    |  35 ++
 .../net/minecraft/server/Packet32EntityLook.java   |  35 ++
 .../server/Packet33RelEntityMoveLook.java          |  44 ++
 .../minecraft/server/Packet34EntityTeleport.java   |  71 +++
 .../server/Packet35EntityHeadRotation.java         |  50 ++
 .../net/minecraft/server/Packet38EntityStatus.java |  36 ++
 .../net/minecraft/server/Packet39AttachEntity.java |  50 ++
 .../java/net/minecraft/server/Packet3Chat.java     |  57 ++
 .../minecraft/server/Packet40EntityMetadata.java   |  41 ++
 .../net/minecraft/server/Packet41MobEffect.java    |  58 ++
 .../minecraft/server/Packet42RemoveMobEffect.java  |  36 ++
 .../minecraft/server/Packet43SetExperience.java    |  48 ++
 .../minecraft/server/Packet44UpdateAttributes.java |  81 +++
 .../net/minecraft/server/Packet4UpdateTime.java    |  54 ++
 .../net/minecraft/server/Packet51MapChunk.java     | 199 +++++++
 .../minecraft/server/Packet52MultiBlockChange.java |  90 +++
 .../net/minecraft/server/Packet53BlockChange.java  |  47 ++
 .../minecraft/server/Packet54PlayNoteBlock.java    |  47 ++
 .../server/Packet55BlockBreakAnimation.java        |  54 ++
 .../net/minecraft/server/Packet56MapChunkBulk.java |  24 +-
 .../minecraft/server/Packet5EntityEquipment.java   |  50 ++
 .../net/minecraft/server/Packet60Explosion.java    |  74 +++
 .../net/minecraft/server/Packet61WorldEvent.java   |  52 ++
 .../minecraft/server/Packet62NamedSoundEffect.java |  59 ++
 .../minecraft/server/Packet63WorldParticles.java   |  65 +++
 .../net/minecraft/server/Packet6SpawnPosition.java |  52 ++
 .../java/net/minecraft/server/Packet70Bed.java     |  43 ++
 .../java/net/minecraft/server/Packet71Weather.java |  46 ++
 .../net/minecraft/server/Packet7UseEntity.java     |  31 +
 .../net/minecraft/server/Packet8UpdateHealth.java  |  48 ++
 .../java/net/minecraft/server/Packet9Respawn.java  |  49 ++
 .../java/net/minecraft/server/PacketCounter.java   |  28 +
 .../net/minecraft/server/PacketLoginRequest.java   |  40 ++
 .../net/minecraft/server/PacketLoginSuccess.java   |  48 ++
 .../java/net/minecraft/server/PacketPingTime.java  |  45 ++
 .../net/minecraft/server/PacketStatusRequest.java  |  38 ++
 .../server/PathfinderGoalMeleeAttack.java          |  75 ++-
 .../net/minecraft/server/PendingConnection.java    | 146 +++--
 .../java/net/minecraft/server/PlayerChunkMap.java  |   2 +-
 .../net/minecraft/server/PlayerConnection.java     |  88 ++-
 .../minecraft/server/PlayerInteractManager.java    |   1 +
 src/main/java/net/minecraft/server/PlayerList.java |  52 +-
 .../java/net/minecraft/server/PropertyManager.java |   2 +-
 .../java/net/minecraft/server/RegionFileCache.java |  67 +++
 .../java/net/minecraft/server/ShapedRecipes.java   |   9 +-
 .../net/minecraft/server/ShapelessRecipes.java     |   9 +-
 .../java/net/minecraft/server/SpawnerCreature.java |  35 +-
 .../net/minecraft/server/StructureGenerator.java   | 224 +++++++
 .../net/minecraft/server/ThreadCommandReader.java  |   1 +
 .../net/minecraft/server/ThreadLoginVerifier.java  |  44 +-
 src/main/java/net/minecraft/server/TileEntity.java |   2 +
 .../net/minecraft/server/TileEntityHopper.java     |  17 +-
 src/main/java/net/minecraft/server/World.java      | 228 ++++++--
 .../net/minecraft/server/WorldMapHumanTracker.java |  24 +-
 .../java/net/minecraft/server/WorldServer.java     | 229 +++++---
 .../java/org/bukkit/craftbukkit/CraftChunk.java    |  44 +-
 .../java/org/bukkit/craftbukkit/CraftEffect.java   |   2 +
 .../java/org/bukkit/craftbukkit/CraftServer.java   |  47 +-
 .../java/org/bukkit/craftbukkit/CraftWorld.java    |  99 +++-
 src/main/java/org/bukkit/craftbukkit/Main.java     |  21 +
 .../java/org/bukkit/craftbukkit/SpigotTimings.java | 128 ++++
 .../org/bukkit/craftbukkit/block/CraftSign.java    |   8 +-
 .../craftbukkit/command/TicksPerSecondCommand.java |  35 ++
 .../org/bukkit/craftbukkit/entity/CraftArrow.java  |  22 +
 .../org/bukkit/craftbukkit/entity/CraftEntity.java |  16 +
 .../org/bukkit/craftbukkit/entity/CraftPlayer.java | 108 +++-
 .../craftbukkit/event/CraftEventFactory.java       |  17 +
 .../craftbukkit/inventory/CraftInventoryAnvil.java |  22 +
 .../craftbukkit/inventory/CraftMetaFirework.java   |   4 +-
 .../org/bukkit/craftbukkit/map/CraftMapView.java   |   2 +-
 .../craftbukkit/scheduler/CraftScheduler.java      |   2 +-
 .../bukkit/craftbukkit/scheduler/CraftTask.java    |  22 +-
 .../java/org/bukkit/craftbukkit/util/LongHash.java |   2 +-
 .../org/bukkit/craftbukkit/util/LongHashSet.java   |  33 +-
 .../bukkit/craftbukkit/util/LongObjectHashMap.java |  15 +
 .../org/bukkit/craftbukkit/util/Versioning.java    |   2 +-
 src/main/java/org/spigotmc/ActivationRange.java    | 296 ++++++++++
 src/main/java/org/spigotmc/AntiXray.java           | 204 +++++++
 src/main/java/org/spigotmc/ChatConverter.java      | 197 +++++++
 src/main/java/org/spigotmc/FlatMap.java            |  64 ++
 src/main/java/org/spigotmc/LogFilter.java          |  24 +
 src/main/java/org/spigotmc/Metrics.java            | 645 +++++++++++++++++++++
 src/main/java/org/spigotmc/RestartCommand.java     | 111 ++++
 src/main/java/org/spigotmc/SpamHaus.java           |  44 ++
 src/main/java/org/spigotmc/SpigotConfig.java       | 293 ++++++++++
 src/main/java/org/spigotmc/SpigotWorldConfig.java  | 236 ++++++++
 src/main/java/org/spigotmc/TrackingRange.java      |  45 ++
 src/main/java/org/spigotmc/WatchdogThread.java     | 121 ++++
 src/main/java/org/spigotmc/netty/CipherBase.java   |  73 +++
 .../java/org/spigotmc/netty/CipherDecoder.java     |  24 +
 .../java/org/spigotmc/netty/CipherEncoder.java     |  23 +
 .../java/org/spigotmc/netty/KickStringWriter.java  |  20 +
 .../java/org/spigotmc/netty/LegacyDecoder.java     |  40 ++
 .../org/spigotmc/netty/NettyNetworkManager.java    | 314 ++++++++++
 .../org/spigotmc/netty/NettyServerConnection.java  | 176 ++++++
 .../org/spigotmc/netty/NettySocketAdaptor.java     | 294 ++++++++++
 .../java/org/spigotmc/netty/PacketDecoder.java     |  76 +++
 .../java/org/spigotmc/netty/PacketEncoder.java     |  46 ++
 .../java/org/spigotmc/netty/PacketListener.java    | 112 ++++
 src/main/java/org/spigotmc/netty/Protocol.java     | 311 ++++++++++
 src/main/java/org/spigotmc/netty/ReadState.java    |  17 +
 src/main/java/org/spigotmc/netty/ServerPing.java   |  39 ++
 .../org/spigotmc/netty/Varint21FrameDecoder.java   |  48 ++
 .../netty/Varint21LengthFieldPrepender.java        |  44 ++
 202 files changed, 12039 insertions(+), 534 deletions(-)
 create mode 100644 dependency-reduced-pom.xml
 create mode 100644 nb-configuration.xml
 create mode 100644 nbactions.xml
 create mode 100644 src/main/java/net/minecraft/server/BlockBrewingStand.java
 create mode 100644 src/main/java/net/minecraft/server/BlockTNT.java
 create mode 100644 src/main/java/net/minecraft/server/ChatMessage.java
 create mode 100644 src/main/java/net/minecraft/server/Connection.java
 create mode 100644 src/main/java/net/minecraft/server/INetworkManager.java
 create mode 100644 src/main/java/net/minecraft/server/LocaleLanguage.java
 create mode 100644 src/main/java/net/minecraft/server/NextTickListEntry.java
 create mode 100644 src/main/java/net/minecraft/server/NibbleArray.java
 create mode 100644 src/main/java/net/minecraft/server/OldChunkLoader.java
 create mode 100644 src/main/java/net/minecraft/server/Packet0KeepAlive.java
 create mode 100644 src/main/java/net/minecraft/server/Packet100OpenWindow.java
 create mode 100644 src/main/java/net/minecraft/server/Packet101CloseWindow.java
 create mode 100644 src/main/java/net/minecraft/server/Packet102WindowClick.java
 create mode 100644 src/main/java/net/minecraft/server/Packet103SetSlot.java
 create mode 100644 src/main/java/net/minecraft/server/Packet104WindowItems.java
 create mode 100644 src/main/java/net/minecraft/server/Packet105CraftProgressBar.java
 create mode 100644 src/main/java/net/minecraft/server/Packet106Transaction.java
 create mode 100644 src/main/java/net/minecraft/server/Packet107SetCreativeSlot.java
 create mode 100644 src/main/java/net/minecraft/server/Packet108ButtonClick.java
 create mode 100644 src/main/java/net/minecraft/server/Packet10Flying.java
 create mode 100644 src/main/java/net/minecraft/server/Packet11PlayerPosition.java
 create mode 100644 src/main/java/net/minecraft/server/Packet12PlayerLook.java
 create mode 100644 src/main/java/net/minecraft/server/Packet130UpdateSign.java
 create mode 100644 src/main/java/net/minecraft/server/Packet131ItemData.java
 create mode 100644 src/main/java/net/minecraft/server/Packet132TileEntityData.java
 create mode 100644 src/main/java/net/minecraft/server/Packet133OpenTileEntity.java
 create mode 100644 src/main/java/net/minecraft/server/Packet13PlayerLookMove.java
 create mode 100644 src/main/java/net/minecraft/server/Packet14BlockDig.java
 create mode 100644 src/main/java/net/minecraft/server/Packet15Place.java
 create mode 100644 src/main/java/net/minecraft/server/Packet16BlockItemSwitch.java
 create mode 100644 src/main/java/net/minecraft/server/Packet17EntityLocationAction.java
 create mode 100644 src/main/java/net/minecraft/server/Packet18ArmAnimation.java
 create mode 100644 src/main/java/net/minecraft/server/Packet19EntityAction.java
 create mode 100644 src/main/java/net/minecraft/server/Packet1Login.java
 create mode 100644 src/main/java/net/minecraft/server/Packet200Statistic.java
 create mode 100644 src/main/java/net/minecraft/server/Packet201PlayerInfo.java
 create mode 100644 src/main/java/net/minecraft/server/Packet202Abilities.java
 create mode 100644 src/main/java/net/minecraft/server/Packet203TabComplete.java
 create mode 100644 src/main/java/net/minecraft/server/Packet204LocaleAndViewDistance.java
 create mode 100644 src/main/java/net/minecraft/server/Packet205ClientCommand.java
 create mode 100644 src/main/java/net/minecraft/server/Packet206SetScoreboardObjective.java
 create mode 100644 src/main/java/net/minecraft/server/Packet207SetScoreboardScore.java
 create mode 100644 src/main/java/net/minecraft/server/Packet208SetScoreboardDisplayObjective.java
 create mode 100644 src/main/java/net/minecraft/server/Packet209SetScoreboardTeam.java
 create mode 100644 src/main/java/net/minecraft/server/Packet22Collect.java
 create mode 100644 src/main/java/net/minecraft/server/Packet23VehicleSpawn.java
 create mode 100644 src/main/java/net/minecraft/server/Packet24MobSpawn.java
 create mode 100644 src/main/java/net/minecraft/server/Packet250CustomPayload.java
 create mode 100644 src/main/java/net/minecraft/server/Packet252KeyResponse.java
 create mode 100644 src/main/java/net/minecraft/server/Packet253KeyRequest.java
 create mode 100644 src/main/java/net/minecraft/server/Packet254GetInfo.java
 create mode 100644 src/main/java/net/minecraft/server/Packet255KickDisconnect.java
 create mode 100644 src/main/java/net/minecraft/server/Packet25EntityPainting.java
 create mode 100644 src/main/java/net/minecraft/server/Packet26AddExpOrb.java
 create mode 100644 src/main/java/net/minecraft/server/Packet27PlayerInput.java
 create mode 100644 src/main/java/net/minecraft/server/Packet28EntityVelocity.java
 create mode 100644 src/main/java/net/minecraft/server/Packet29DestroyEntity.java
 create mode 100644 src/main/java/net/minecraft/server/Packet30Entity.java
 create mode 100644 src/main/java/net/minecraft/server/Packet31RelEntityMove.java
 create mode 100644 src/main/java/net/minecraft/server/Packet32EntityLook.java
 create mode 100644 src/main/java/net/minecraft/server/Packet33RelEntityMoveLook.java
 create mode 100644 src/main/java/net/minecraft/server/Packet34EntityTeleport.java
 create mode 100644 src/main/java/net/minecraft/server/Packet35EntityHeadRotation.java
 create mode 100644 src/main/java/net/minecraft/server/Packet38EntityStatus.java
 create mode 100644 src/main/java/net/minecraft/server/Packet39AttachEntity.java
 create mode 100644 src/main/java/net/minecraft/server/Packet3Chat.java
 create mode 100644 src/main/java/net/minecraft/server/Packet40EntityMetadata.java
 create mode 100644 src/main/java/net/minecraft/server/Packet41MobEffect.java
 create mode 100644 src/main/java/net/minecraft/server/Packet42RemoveMobEffect.java
 create mode 100644 src/main/java/net/minecraft/server/Packet43SetExperience.java
 create mode 100644 src/main/java/net/minecraft/server/Packet44UpdateAttributes.java
 create mode 100644 src/main/java/net/minecraft/server/Packet4UpdateTime.java
 create mode 100644 src/main/java/net/minecraft/server/Packet51MapChunk.java
 create mode 100644 src/main/java/net/minecraft/server/Packet52MultiBlockChange.java
 create mode 100644 src/main/java/net/minecraft/server/Packet53BlockChange.java
 create mode 100644 src/main/java/net/minecraft/server/Packet54PlayNoteBlock.java
 create mode 100644 src/main/java/net/minecraft/server/Packet55BlockBreakAnimation.java
 create mode 100644 src/main/java/net/minecraft/server/Packet5EntityEquipment.java
 create mode 100644 src/main/java/net/minecraft/server/Packet60Explosion.java
 create mode 100644 src/main/java/net/minecraft/server/Packet61WorldEvent.java
 create mode 100644 src/main/java/net/minecraft/server/Packet62NamedSoundEffect.java
 create mode 100644 src/main/java/net/minecraft/server/Packet63WorldParticles.java
 create mode 100644 src/main/java/net/minecraft/server/Packet6SpawnPosition.java
 create mode 100644 src/main/java/net/minecraft/server/Packet70Bed.java
 create mode 100644 src/main/java/net/minecraft/server/Packet71Weather.java
 create mode 100644 src/main/java/net/minecraft/server/Packet7UseEntity.java
 create mode 100644 src/main/java/net/minecraft/server/Packet8UpdateHealth.java
 create mode 100644 src/main/java/net/minecraft/server/Packet9Respawn.java
 create mode 100644 src/main/java/net/minecraft/server/PacketCounter.java
 create mode 100644 src/main/java/net/minecraft/server/PacketLoginRequest.java
 create mode 100644 src/main/java/net/minecraft/server/PacketLoginSuccess.java
 create mode 100644 src/main/java/net/minecraft/server/PacketPingTime.java
 create mode 100644 src/main/java/net/minecraft/server/PacketStatusRequest.java
 create mode 100644 src/main/java/net/minecraft/server/RegionFileCache.java
 create mode 100644 src/main/java/net/minecraft/server/StructureGenerator.java
 create mode 100644 src/main/java/org/bukkit/craftbukkit/SpigotTimings.java
 create mode 100644 src/main/java/org/bukkit/craftbukkit/command/TicksPerSecondCommand.java
 create mode 100644 src/main/java/org/spigotmc/ActivationRange.java
 create mode 100644 src/main/java/org/spigotmc/AntiXray.java
 create mode 100644 src/main/java/org/spigotmc/ChatConverter.java
 create mode 100644 src/main/java/org/spigotmc/FlatMap.java
 create mode 100644 src/main/java/org/spigotmc/LogFilter.java
 create mode 100644 src/main/java/org/spigotmc/Metrics.java
 create mode 100644 src/main/java/org/spigotmc/RestartCommand.java
 create mode 100644 src/main/java/org/spigotmc/SpamHaus.java
 create mode 100644 src/main/java/org/spigotmc/SpigotConfig.java
 create mode 100644 src/main/java/org/spigotmc/SpigotWorldConfig.java
 create mode 100644 src/main/java/org/spigotmc/TrackingRange.java
 create mode 100644 src/main/java/org/spigotmc/WatchdogThread.java
 create mode 100644 src/main/java/org/spigotmc/netty/CipherBase.java
 create mode 100644 src/main/java/org/spigotmc/netty/CipherDecoder.java
 create mode 100644 src/main/java/org/spigotmc/netty/CipherEncoder.java
 create mode 100644 src/main/java/org/spigotmc/netty/KickStringWriter.java
 create mode 100644 src/main/java/org/spigotmc/netty/LegacyDecoder.java
 create mode 100644 src/main/java/org/spigotmc/netty/NettyNetworkManager.java
 create mode 100644 src/main/java/org/spigotmc/netty/NettyServerConnection.java
 create mode 100644 src/main/java/org/spigotmc/netty/NettySocketAdaptor.java
 create mode 100644 src/main/java/org/spigotmc/netty/PacketDecoder.java
 create mode 100644 src/main/java/org/spigotmc/netty/PacketEncoder.java
 create mode 100644 src/main/java/org/spigotmc/netty/PacketListener.java
 create mode 100644 src/main/java/org/spigotmc/netty/Protocol.java
 create mode 100644 src/main/java/org/spigotmc/netty/ReadState.java
 create mode 100644 src/main/java/org/spigotmc/netty/ServerPing.java
 create mode 100644 src/main/java/org/spigotmc/netty/Varint21FrameDecoder.java
 create mode 100644 src/main/java/org/spigotmc/netty/Varint21LengthFieldPrepender.java

diff --git a/dependency-reduced-pom.xml b/dependency-reduced-pom.xml
new file mode 100644
index 0000000..41ac837
--- /dev/null
+++ b/dependency-reduced-pom.xml
@@ -0,0 +1,262 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <parent>
+    <artifactId>spigot-parent</artifactId>
+    <groupId>org.spigotmc</groupId>
+    <version>dev-SNAPSHOT</version>
+  </parent>
+  <modelVersion>4.0.0</modelVersion>
+  <groupId>org.spigotmc</groupId>
+  <artifactId>spigot</artifactId>
+  <name>Spigot</name>
+  <version>1.6.4-R1.1-SNAPSHOT</version>
+  <url>http://www.spigotmc.org</url>
+  <build>
+    <defaultGoal>install</defaultGoal>
+    <pluginManagement>
+      <plugins>
+        <plugin>
+          <groupId>org.eclipse.m2e</groupId>
+          <artifactId>lifecycle-mapping</artifactId>
+          <version>1.0.0</version>
+          <configuration>
+            <lifecycleMappingMetadata>
+              <pluginExecutions>
+                <pluginExecution>
+                  <pluginExecutionFilter>
+                    <groupId>com.lukegb.mojo</groupId>
+                    <artifactId>gitdescribe-maven-plugin</artifactId>
+                    <versionRange>[1.3,)</versionRange>
+                    <goals>
+                      <goal>gitdescribe</goal>
+                    </goals>
+                  </pluginExecutionFilter>
+                  <action>
+                    <ignore />
+                  </action>
+                </pluginExecution>
+              </pluginExecutions>
+            </lifecycleMappingMetadata>
+          </configuration>
+        </plugin>
+      </plugins>
+    </pluginManagement>
+    <plugins>
+      <plugin>
+        <groupId>com.lukegb.mojo</groupId>
+        <artifactId>gitdescribe-maven-plugin</artifactId>
+        <version>1.3</version>
+        <executions>
+          <execution>
+            <phase>compile</phase>
+            <goals>
+              <goal>gitdescribe</goal>
+            </goals>
+          </execution>
+        </executions>
+        <configuration>
+          <outputPrefix>git-Spigot-</outputPrefix>
+          <outputPostfix />
+        </configuration>
+      </plugin>
+      <plugin>
+        <artifactId>maven-jar-plugin</artifactId>
+        <version>2.1</version>
+        <configuration>
+          <archive>
+            <manifestEntries>
+              <Main-Class>org.bukkit.craftbukkit.Main</Main-Class>
+              <Implementation-Title>CraftBukkit</Implementation-Title>
+              <Implementation-Version>${describe}</Implementation-Version>
+              <Implementation-Vendor>Bukkit Team</Implementation-Vendor>
+              <Specification-Title>Bukkit</Specification-Title>
+              <Specification-Version>${api.version}</Specification-Version>
+              <Specification-Vendor>Bukkit Team</Specification-Vendor>
+              <Sealed>true</Sealed>
+            </manifestEntries>
+            <manifestSections>
+              <manifestSection>
+                <name>net/bukkit/</name>
+                <manifestEntries>
+                  <Sealed>true</Sealed>
+                </manifestEntries>
+              </manifestSection>
+              <manifestSection>
+                <name>com/bukkit/</name>
+                <manifestEntries>
+                  <Sealed>true</Sealed>
+                </manifestEntries>
+              </manifestSection>
+              <manifestSection>
+                <name>org/bukkit/</name>
+                <manifestEntries>
+                  <Sealed>true</Sealed>
+                </manifestEntries>
+              </manifestSection>
+            </manifestSections>
+          </archive>
+        </configuration>
+      </plugin>
+      <plugin>
+        <artifactId>maven-shade-plugin</artifactId>
+        <version>2.0</version>
+        <executions>
+          <execution>
+            <phase>package</phase>
+            <goals>
+              <goal>shade</goal>
+            </goals>
+            <configuration>
+              <relocations>
+                <relocation>
+                  <pattern>org.bouncycastle</pattern>
+                  <shadedPattern>net.minecraft.v${minecraft_version}.org.bouncycastle</shadedPattern>
+                </relocation>
+                <relocation>
+                  <pattern>joptsimple</pattern>
+                  <shadedPattern>org.bukkit.craftbukkit.libs.joptsimple</shadedPattern>
+                </relocation>
+                <relocation>
+                  <pattern>jline</pattern>
+                  <shadedPattern>org.bukkit.craftbukkit.libs.jline</shadedPattern>
+                </relocation>
+                <relocation>
+                  <pattern>org.ibex</pattern>
+                  <shadedPattern>org.bukkit.craftbukkit.libs.org.ibex</shadedPattern>
+                </relocation>
+                <relocation>
+                  <pattern>org.gjt</pattern>
+                  <shadedPattern>org.bukkit.craftbukkit.libs.org.gjt</shadedPattern>
+                </relocation>
+                <relocation>
+                  <pattern>com.google.gson</pattern>
+                  <shadedPattern>org.bukkit.craftbukkit.libs.com.google.gson</shadedPattern>
+                </relocation>
+                <relocation>
+                  <pattern>org.bukkit.craftbukkit</pattern>
+                  <shadedPattern>org.bukkit.craftbukkit.v${minecraft_version}</shadedPattern>
+                  <excludes>
+                    <exclude>org.bukkit.craftbukkit.Main*</exclude>
+                  </excludes>
+                </relocation>
+                <relocation>
+                  <pattern>net.minecraft.server</pattern>
+                  <shadedPattern>net.minecraft.server.v${minecraft_version}</shadedPattern>
+                </relocation>
+              </relocations>
+            </configuration>
+          </execution>
+        </executions>
+      </plugin>
+      <plugin>
+        <artifactId>maven-compiler-plugin</artifactId>
+        <version>2.3.2</version>
+        <configuration>
+          <source>1.6</source>
+          <target>1.6</target>
+        </configuration>
+      </plugin>
+      <plugin>
+        <artifactId>maven-surefire-plugin</artifactId>
+        <version>2.11</version>
+        <configuration>
+          <workingDirectory>${basedir}/target/test-server</workingDirectory>
+          <excludes>
+            <exclude>org/bukkit/craftbukkit/updater/BukkitDLUpdaterServiceTest.java</exclude>
+            <exclude>org/bukkit/craftbukkit/inventory/ItemStack*Test.java</exclude>
+          </excludes>
+        </configuration>
+      </plugin>
+      <plugin>
+        <artifactId>maven-resources-plugin</artifactId>
+        <version>2.4.3</version>
+        <executions>
+          <execution>
+            <id>maps-file</id>
+            <phase>package</phase>
+            <goals>
+              <goal>copy-resources</goal>
+            </goals>
+            <configuration>
+              <outputDirectory>${basedir}/target</outputDirectory>
+              <resources>
+                <resource>
+                  <directory>${basedir}</directory>
+                  <filtering>true</filtering>
+                  <includes>
+                    <include>maps.yml</include>
+                  </includes>
+                </resource>
+              </resources>
+            </configuration>
+          </execution>
+        </executions>
+      </plugin>
+      <plugin>
+        <groupId>com.wolvereness</groupId>
+        <artifactId>overmapped</artifactId>
+        <version>0.0.2</version>
+        <executions>
+          <execution>
+            <phase>package</phase>
+            <goals>
+              <goal>map</goal>
+            </goals>
+            <configuration>
+              <maps>${basedir}/target/maps.yml</maps>
+              <input>${basedir}/target/${project.artifactId}-${project.version}.jar</input>
+              <original>${basedir}/target/unmapped-${project.artifactId}-${project.version}.jar</original>
+            </configuration>
+          </execution>
+        </executions>
+      </plugin>
+    </plugins>
+  </build>
+  <repositories>
+    <repository>
+      <id>repobo-snap</id>
+      <url>http://repo.bukkit.org/content/groups/public</url>
+    </repository>
+  </repositories>
+  <pluginRepositories>
+    <pluginRepository>
+      <id>bukkit-plugins</id>
+      <url>http://repo.bukkit.org/content/groups/public</url>
+    </pluginRepository>
+  </pluginRepositories>
+  <dependencies>
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <version>4.11</version>
+      <scope>test</scope>
+      <exclusions>
+        <exclusion>
+          <artifactId>hamcrest-core</artifactId>
+          <groupId>org.hamcrest</groupId>
+        </exclusion>
+      </exclusions>
+    </dependency>
+    <dependency>
+      <groupId>org.hamcrest</groupId>
+      <artifactId>hamcrest-library</artifactId>
+      <version>1.3</version>
+      <scope>test</scope>
+      <exclusions>
+        <exclusion>
+          <artifactId>hamcrest-core</artifactId>
+          <groupId>org.hamcrest</groupId>
+        </exclusion>
+      </exclusions>
+    </dependency>
+  </dependencies>
+  <properties>
+    <minecraft_version>1_6_R3</minecraft_version>
+    <buildtag.prefix>git-Bukkit-</buildtag.prefix>
+    <api.version>unknown</api.version>
+    <minecraft.version>1.6.4</minecraft.version>
+    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
+    <junit.version>4.11</junit.version>
+  </properties>
+</project>
+
diff --git a/nb-configuration.xml b/nb-configuration.xml
new file mode 100644
index 0000000..7e46592
--- /dev/null
+++ b/nb-configuration.xml
@@ -0,0 +1,31 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project-shared-configuration>
+    <!--
+    This file contains additional configuration written by modules in the NetBeans IDE.
+    The configuration is intended to be shared among all the users of project and
+    therefore it is assumed to be part of version control checkout.
+    Without this configuration present, some functionality in the IDE may be limited or fail altogether.
+    -->
+    <properties xmlns="http://www.netbeans.org/ns/maven-properties-data/1">
+        <!--
+        Properties that influence various parts of the IDE, especially code formatting and the like. 
+        You can copy and paste the single properties, into the pom.xml file and the IDE will pick them up.
+        That way multiple projects can share the same settings (useful for formatting rules for example).
+        Any value defined here will override the pom.xml file value but is only applicable to the current project.
+        -->
+        <org-netbeans-modules-editor-indent.CodeStyle.usedProfile>project</org-netbeans-modules-editor-indent.CodeStyle.usedProfile>
+        <org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.classDeclBracePlacement>NEW_LINE</org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.classDeclBracePlacement>
+        <org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.otherBracePlacement>NEW_LINE</org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.otherBracePlacement>
+        <org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.methodDeclBracePlacement>NEW_LINE</org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.methodDeclBracePlacement>
+        <org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.spaceWithinMethodCallParens>true</org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.spaceWithinMethodCallParens>
+        <org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.spaceWithinSwitchParens>true</org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.spaceWithinSwitchParens>
+        <org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.spaceWithinCatchParens>true</org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.spaceWithinCatchParens>
+        <org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.spaceWithinTryParens>true</org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.spaceWithinTryParens>
+        <org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.spaceWithinSynchronizedParens>true</org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.spaceWithinSynchronizedParens>
+        <org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.spaceWithinArrayInitBrackets>true</org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.spaceWithinArrayInitBrackets>
+        <org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.spaceWithinParens>true</org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.spaceWithinParens>
+        <org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.spaceWithinWhileParens>true</org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.spaceWithinWhileParens>
+        <org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.spaceWithinIfParens>true</org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.spaceWithinIfParens>
+        <org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.spaceWithinForParens>true</org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.spaceWithinForParens>
+    </properties>
+</project-shared-configuration>
diff --git a/nbactions.xml b/nbactions.xml
new file mode 100644
index 0000000..fc56fd0
--- /dev/null
+++ b/nbactions.xml
@@ -0,0 +1,40 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<actions>
+        <action>
+            <actionName>run</actionName>
+            <goals>
+                <goal>process-classes</goal>
+                <goal>org.codehaus.mojo:exec-maven-plugin:1.2.1:exec</goal>
+            </goals>
+            <properties>
+                <exec.args>-classpath %classpath org.bukkit.craftbukkit.Main</exec.args>
+                <exec.executable>java</exec.executable>
+                <exec.workingdir>/mnt/data/Minecraft Servers/spigot</exec.workingdir>
+            </properties>
+        </action>
+        <action>
+            <actionName>debug</actionName>
+            <goals>
+                <goal>process-classes</goal>
+                <goal>org.codehaus.mojo:exec-maven-plugin:1.2.1:exec</goal>
+            </goals>
+            <properties>
+                <exec.args>-Xdebug -Xrunjdwp:transport=dt_socket,server=n,address=${jpda.address} -classpath %classpath org.bukkit.craftbukkit.Main</exec.args>
+                <exec.executable>java</exec.executable>
+                <jpda.listen>true</jpda.listen>
+                <exec.workingdir>/mnt/data/Minecraft Servers/spigot</exec.workingdir>
+            </properties>
+        </action>
+        <action>
+            <actionName>profile</actionName>
+            <goals>
+                <goal>process-classes</goal>
+                <goal>org.codehaus.mojo:exec-maven-plugin:1.2.1:exec</goal>
+            </goals>
+            <properties>
+                <exec.args>${profiler.args} -classpath %classpath org.bukkit.craftbukkit.Main</exec.args>
+                <exec.executable>${profiler.java}</exec.executable>
+                <exec.workingdir>/mnt/data/Minecraft Servers/spigot</exec.workingdir>
+            </properties>
+        </action>
+    </actions>
diff --git a/pom.xml b/pom.xml
index b56b26c..b7af2a5 100644
--- a/pom.xml
+++ b/pom.xml
@@ -1,12 +1,20 @@
 <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
   <modelVersion>4.0.0</modelVersion>
-  <groupId>org.bukkit</groupId>
-  <artifactId>craftbukkit</artifactId>
+
+  <parent>
+    <groupId>org.spigotmc</groupId>
+    <artifactId>spigot-parent</artifactId>
+    <version>dev-SNAPSHOT</version>
+    <relativePath>../pom.xml</relativePath>
+  </parent>
+
+  <groupId>org.spigotmc</groupId>
+  <artifactId>spigot</artifactId>
   <packaging>jar</packaging>
   <version>1.6.4-R2.1-SNAPSHOT</version>
-  <name>CraftBukkit</name>
-  <url>http://www.bukkit.org</url>
+  <name>Spigot</name>
+  <url>http://www.spigotmc.org</url>
 
   <properties>
     <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
@@ -18,25 +26,6 @@
     <buildtag.suffix></buildtag.suffix>
   </properties>
 
-  <scm>
-    <connection>scm:git:git://github.com/Bukkit/CraftBukkit.git</connection>
-    <developerConnection>scm:git:ssh://git@github.com/Bukkit/CraftBukkit.git</developerConnection>
-    <url>https://github.com/Bukkit/CraftBukkit</url>
-  </scm>
-
-  <distributionManagement>
-    <repository>
-      <id>repobo-rel</id>
-      <name>repo.bukkit.org Releases</name>
-      <url>http://repo.bukkit.org/content/repositories/releases/</url>
-    </repository>
-    <snapshotRepository>
-      <id>repobo-snap</id>
-      <name>repo.bukkit.org Snapshots</name>
-      <url>http://repo.bukkit.org/content/repositories/snapshots/</url>
-    </snapshotRepository>
-  </distributionManagement>
-
   <repositories>
     <repository>
       <id>repobo-snap</id>
@@ -53,8 +42,8 @@
 
   <dependencies>
     <dependency>
-      <groupId>org.bukkit</groupId>
-      <artifactId>bukkit</artifactId>
+      <groupId>org.spigotmc</groupId>
+      <artifactId>spigot-api</artifactId>
       <version>${project.version}</version>
       <type>jar</type>
       <scope>compile</scope>
@@ -107,33 +96,6 @@
       <artifactId>gson</artifactId>
       <version>2.1</version>
     </dependency>
-    <dependency>
-      <groupId>org.avaje</groupId>
-      <artifactId>ebean</artifactId>
-      <version>2.7.3</version>
-      <type>jar</type>
-      <scope>provided</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.yaml</groupId>
-      <artifactId>snakeyaml</artifactId>
-      <version>1.9</version>
-      <type>jar</type>
-      <scope>provided</scope>
-    </dependency>
-    <dependency>
-      <groupId>com.google.guava</groupId>
-      <artifactId>guava</artifactId>
-      <version>10.0</version>
-      <type>jar</type>
-      <scope>provided</scope>
-    </dependency>
-    <dependency>
-        <groupId>commons-lang</groupId>
-        <artifactId>commons-lang</artifactId>
-        <version>2.3</version>
-        <scope>provided</scope>
-    </dependency>
     <!-- testing -->
     <dependency>
       <groupId>junit</groupId>
@@ -147,19 +109,44 @@
       <version>1.3</version>
       <scope>test</scope>
     </dependency>
+    <dependency>
+      <groupId>net.sf.trove4j</groupId>
+      <artifactId>trove4j</artifactId>
+      <version>3.0.3</version>
+    </dependency>
+    <dependency>
+      <groupId>io.netty</groupId>
+      <artifactId>netty-codec</artifactId>
+      <version>4.0.9.Final</version>
+    </dependency>
+    <dependency>
+      <groupId>io.netty</groupId>
+      <artifactId>netty-handler</artifactId>
+      <version>4.0.9.Final</version>
+    </dependency>
+    <dependency>
+      <groupId>org.javassist</groupId>
+      <artifactId>javassist</artifactId>
+      <version>3.18.0-GA</version>
+    </dependency>
+    <dependency>
+      <groupId>org.projectlombok</groupId>
+      <artifactId>lombok</artifactId>
+      <version>1.12.2</version>
+    </dependency>
   </dependencies>
 
   <!-- This builds a completely 'ready to start' jar with all dependencies inside -->
   <build>
-    <defaultGoal>clean install</defaultGoal>
+    <defaultGoal>install</defaultGoal>
     <plugins>
       <plugin>
         <groupId>com.lukegb.mojo</groupId>
         <artifactId>gitdescribe-maven-plugin</artifactId>
         <version>1.3</version>
         <configuration>
-          <outputPrefix>${buildtag.prefix}</outputPrefix>
-          <outputPostfix>${buildtag.suffix}</outputPostfix>
+          <outputPrefix>git-Spigot-</outputPrefix>
+          <outputPostfix></outputPostfix>
         </configuration>
         <executions>
           <execution>
@@ -212,7 +199,7 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-shade-plugin</artifactId>
-        <version>1.4</version>
+        <version>2.0</version>
         <executions>
           <execution>
             <phase>package</phase>
diff --git a/src/main/java/net/minecraft/server/Block.java b/src/main/java/net/minecraft/server/Block.java
index 2a85c1c..8fc6c12 100644
--- a/src/main/java/net/minecraft/server/Block.java
+++ b/src/main/java/net/minecraft/server/Block.java
@@ -342,9 +342,13 @@ public class Block {
         return 10;
     }
 
-    public void onPlace(World world, int i, int j, int k) {}
+    public void onPlace(World world, int i, int j, int k) {
+        if (Thread.currentThread() != MinecraftServer.getServer().primaryThread) throw new IllegalStateException("Asynchronous block onPlace!"); // Spigot
+    }
 
-    public void remove(World world, int i, int j, int k, int l, int i1) {}
+    public void remove(World world, int i, int j, int k, int l, int i1) {
+        if (Thread.currentThread() != MinecraftServer.getServer().primaryThread) throw new IllegalStateException("Asynchronous block remove!"); // Spigot
+    }
 
     public int a(Random random) {
         return 1;
@@ -781,4 +785,16 @@ public class Block {
         return 0;
     }
     // CraftBukkit end
+
+    // Spigot start
+    public static float range(float min, float value, float max) {
+        if (value < min) {
+            return min;
+        }
+        if (value > max) {
+            return max;
+        }
+        return value;
+    }
+    // Spigot end
 }
diff --git a/src/main/java/net/minecraft/server/BlockBrewingStand.java b/src/main/java/net/minecraft/server/BlockBrewingStand.java
new file mode 100644
index 0000000..308207a
--- /dev/null
+++ b/src/main/java/net/minecraft/server/BlockBrewingStand.java
@@ -0,0 +1,115 @@
+package net.minecraft.server;
+
+import java.util.List;
+import java.util.Random;
+
+public class BlockBrewingStand extends BlockContainer {
+
+    private Random a = new Random();
+
+    public BlockBrewingStand(int i) {
+        super(i, Material.ORE);
+    }
+
+    public boolean c() {
+        return false;
+    }
+
+    public int d() {
+        return 25;
+    }
+
+    public TileEntity b(World world) {
+        return new TileEntityBrewingStand();
+    }
+
+    public boolean b() {
+        return false;
+    }
+
+    public void a(World world, int i, int j, int k, AxisAlignedBB axisalignedbb, List list, Entity entity) {
+        this.a(0.4375F, 0.0F, 0.4375F, 0.5625F, 0.875F, 0.5625F);
+        super.a(world, i, j, k, axisalignedbb, list, entity);
+        this.g();
+        super.a(world, i, j, k, axisalignedbb, list, entity);
+    }
+
+    public void g() {
+        this.a(0.0F, 0.0F, 0.0F, 1.0F, 0.125F, 1.0F);
+    }
+
+    public boolean interact(World world, int i, int j, int k, EntityHuman entityhuman, int l, float f, float f1, float f2) {
+        if (world.isStatic) {
+            return true;
+        } else {
+            TileEntityBrewingStand tileentitybrewingstand = (TileEntityBrewingStand) world.getTileEntity(i, j, k);
+
+            if (tileentitybrewingstand != null) {
+                entityhuman.openBrewingStand(tileentitybrewingstand);
+            }
+
+            return true;
+        }
+    }
+
+    public void postPlace(World world, int i, int j, int k, EntityLiving entityliving, ItemStack itemstack) {
+        if (itemstack.hasName()) {
+            ((TileEntityBrewingStand) world.getTileEntity(i, j, k)).a(itemstack.getName());
+        }
+    }
+
+    public void remove(World world, int i, int j, int k, int l, int i1) {
+        TileEntity tileentity = world.getTileEntity(i, j, k);
+
+        if (tileentity instanceof TileEntityBrewingStand) {
+            TileEntityBrewingStand tileentitybrewingstand = (TileEntityBrewingStand) tileentity;
+
+            for (int j1 = 0; j1 < tileentitybrewingstand.getSize(); ++j1) {
+                ItemStack itemstack = tileentitybrewingstand.getItem(j1);
+
+                if (itemstack != null) {
+                    float f = this.a.nextFloat() * 0.8F + 0.1F;
+                    float f1 = this.a.nextFloat() * 0.8F + 0.1F;
+                    float f2 = this.a.nextFloat() * 0.8F + 0.1F;
+
+                    while (itemstack.count > 0) {
+                        int k1 = this.a.nextInt(21) + 10;
+
+                        if (k1 > itemstack.count) {
+                            k1 = itemstack.count;
+                        }
+
+                        itemstack.count -= k1;
+                        EntityItem entityitem = new EntityItem(world, (double) ((float) i + f), (double) ((float) j + f1), (double) ((float) k + f2), new ItemStack(itemstack.id, k1, itemstack.getData()));
+                        float f3 = 0.05F;
+
+                        entityitem.motX = (double) ((float) this.a.nextGaussian() * f3);
+                        entityitem.motY = (double) ((float) this.a.nextGaussian() * f3 + 0.2F);
+                        entityitem.motZ = (double) ((float) this.a.nextGaussian() * f3);
+                        // Spigot Start
+                        if ( itemstack.hasTag() )
+                        {
+                            entityitem.getItemStack().setTag( (NBTTagCompound) itemstack.getTag().clone() );
+                        }
+                        // Spigot End
+                        world.addEntity( entityitem );
+                    }
+                }
+            }
+        }
+
+        super.remove(world, i, j, k, l, i1);
+    }
+
+    public int getDropType(int i, Random random, int j) {
+        return Item.BREWING_STAND.id;
+    }
+
+    public boolean q_() {
+        return true;
+    }
+
+    public int b_(World world, int i, int j, int k, int l) {
+        return Container.b((IInventory) world.getTileEntity(i, j, k));
+    }
+}
diff --git a/src/main/java/net/minecraft/server/BlockCactus.java b/src/main/java/net/minecraft/server/BlockCactus.java
index 03eece7..758ab84 100644
--- a/src/main/java/net/minecraft/server/BlockCactus.java
+++ b/src/main/java/net/minecraft/server/BlockCactus.java
@@ -23,7 +23,7 @@ public class BlockCactus extends Block {
             if (l < 3) {
                 int i1 = world.getData(i, j, k);
 
-                if (i1 == 15) {
+                if (i1 >= (byte) range(3, (world.growthOdds / world.spigotConfig.cactusModifier * 15) + 0.5F, 15)) { // Spigot
                     org.bukkit.craftbukkit.event.CraftEventFactory.handleBlockGrowEvent(world, i, j + 1, k, this.id, 0); // CraftBukkit
                     world.setData(i, j, k, 0, 4);
                     this.doPhysics(world, i, j + 1, k, this.id);
diff --git a/src/main/java/net/minecraft/server/BlockCrops.java b/src/main/java/net/minecraft/server/BlockCrops.java
index e157fbe..84a809b 100644
--- a/src/main/java/net/minecraft/server/BlockCrops.java
+++ b/src/main/java/net/minecraft/server/BlockCrops.java
@@ -28,7 +28,7 @@ public class BlockCrops extends BlockFlower {
             if (l < 7) {
                 float f = this.k(world, i, j, k);
 
-                if (random.nextInt((int) (25.0F / f) + 1) == 0) {
+                if (random.nextInt((int) (world.growthOdds / world.spigotConfig.wheatModifier * (25.0F / f)) + 1) == 0) { // Spigot
                     org.bukkit.craftbukkit.event.CraftEventFactory.handleBlockGrowEvent(world, i, j, k, this.id, ++l); // CraftBukkit
                 }
             }
diff --git a/src/main/java/net/minecraft/server/BlockGrass.java b/src/main/java/net/minecraft/server/BlockGrass.java
index 6f9301d..2ccc0b8 100644
--- a/src/main/java/net/minecraft/server/BlockGrass.java
+++ b/src/main/java/net/minecraft/server/BlockGrass.java
@@ -32,7 +32,8 @@ public class BlockGrass extends Block {
                 }
                 // CraftBukkit end
             } else if (world.getLightLevel(i, j + 1, k) >= 9) {
-                for (int l = 0; l < 4; ++l) {
+                int numGrowth = Math.min(4, Math.max(20, (int) (4 * 100F / world.growthOdds))); // Spigot
+                for (int l = 0; l < numGrowth; ++l) { // Spigot
                     int i1 = i + random.nextInt(3) - 1;
                     int j1 = j + random.nextInt(5) - 3;
                     int k1 = k + random.nextInt(3) - 1;
diff --git a/src/main/java/net/minecraft/server/BlockMushroom.java b/src/main/java/net/minecraft/server/BlockMushroom.java
index 796527d..b4a6800 100644
--- a/src/main/java/net/minecraft/server/BlockMushroom.java
+++ b/src/main/java/net/minecraft/server/BlockMushroom.java
@@ -24,7 +24,7 @@ public class BlockMushroom extends BlockFlower {
 
     public void a(World world, int i, int j, int k, Random random) {
         final int sourceX = i, sourceY = j, sourceZ = k; // CraftBukkit
-        if (random.nextInt(25) == 0) {
+        if (random.nextInt(Math.max(1, (int) world.growthOdds / world.spigotConfig.mushroomModifier * 25)) == 0) { // Spigot
             byte b0 = 4;
             int l = 5;
 
diff --git a/src/main/java/net/minecraft/server/BlockMycel.java b/src/main/java/net/minecraft/server/BlockMycel.java
index 1de8c83..fa11d1c 100644
--- a/src/main/java/net/minecraft/server/BlockMycel.java
+++ b/src/main/java/net/minecraft/server/BlockMycel.java
@@ -32,7 +32,8 @@ public class BlockMycel extends Block {
                 }
                 // CraftBukkit end
             } else if (world.getLightLevel(i, j + 1, k) >= 9) {
-                for (int l = 0; l < 4; ++l) {
+                int numGrowth = Math.min(4, Math.max(20, (int) (4 * 100F / world.growthOdds))); // Spigot
+                for (int l = 0; l < numGrowth; ++l) { // Spigot
                     int i1 = i + random.nextInt(3) - 1;
                     int j1 = j + random.nextInt(5) - 3;
                     int k1 = k + random.nextInt(3) - 1;
diff --git a/src/main/java/net/minecraft/server/BlockRedstoneTorch.java b/src/main/java/net/minecraft/server/BlockRedstoneTorch.java
index f176e66..d4f3c51 100644
--- a/src/main/java/net/minecraft/server/BlockRedstoneTorch.java
+++ b/src/main/java/net/minecraft/server/BlockRedstoneTorch.java
@@ -11,7 +11,7 @@ import org.bukkit.event.block.BlockRedstoneEvent; // CraftBukkit
 public class BlockRedstoneTorch extends BlockTorch {
 
     private boolean isOn;
-    private static Map b = new HashMap();
+    private static Map b = new java.util.WeakHashMap(); // Spigot
 
     private boolean a(World world, int i, int j, int k, boolean flag) {
         if (!b.containsKey(world)) {
diff --git a/src/main/java/net/minecraft/server/BlockReed.java b/src/main/java/net/minecraft/server/BlockReed.java
index 8657860..cf52501 100644
--- a/src/main/java/net/minecraft/server/BlockReed.java
+++ b/src/main/java/net/minecraft/server/BlockReed.java
@@ -23,7 +23,7 @@ public class BlockReed extends Block {
             if (l < 3) {
                 int i1 = world.getData(i, j, k);
 
-                if (i1 == 15) {
+                if (i1 >= (byte) range(3, (world.growthOdds / world.spigotConfig.caneModifier * 15) + 0.5F, 15)) { // Spigot
                     org.bukkit.craftbukkit.event.CraftEventFactory.handleBlockGrowEvent(world, i, j + 1, k, this.id, 0); // CraftBukkit
                     world.setData(i, j, k, 0, 4);
                 } else {
diff --git a/src/main/java/net/minecraft/server/BlockSapling.java b/src/main/java/net/minecraft/server/BlockSapling.java
index 706d6c9..fe675b3 100644
--- a/src/main/java/net/minecraft/server/BlockSapling.java
+++ b/src/main/java/net/minecraft/server/BlockSapling.java
@@ -25,7 +25,7 @@ public class BlockSapling extends BlockFlower {
     public void a(World world, int i, int j, int k, Random random) {
         if (!world.isStatic) {
             super.a(world, i, j, k, random);
-            if (world.getLightLevel(i, j + 1, k) >= 9 && random.nextInt(7) == 0) {
+            if (world.getLightLevel(i, j + 1, k) >= 9 && (random.nextInt(Math.max(2, (int) ((world.growthOdds / world.spigotConfig.saplingModifier * 7) + 0.5F))) == 0)) { // Spigot
                 this.grow(world, i, j, k, random, false, null, null); // CraftBukkit - added bonemeal, player and itemstack
             }
         }
diff --git a/src/main/java/net/minecraft/server/BlockStem.java b/src/main/java/net/minecraft/server/BlockStem.java
index f2d4e57..5fe0a81 100644
--- a/src/main/java/net/minecraft/server/BlockStem.java
+++ b/src/main/java/net/minecraft/server/BlockStem.java
@@ -27,7 +27,7 @@ public class BlockStem extends BlockFlower {
         if (world.getLightLevel(i, j + 1, k) >= 9) {
             float f = this.m(world, i, j, k);
 
-            if (random.nextInt((int) (25.0F / f) + 1) == 0) {
+            if (random.nextInt((int) (world.growthOdds / (this.id == Block.PUMPKIN_STEM.id ? world.spigotConfig.pumpkinModifier : world.spigotConfig.melonModifier) * (25.0F / f)) + 1) == 0) { // Spigot
                 int l = world.getData(i, j, k);
 
                 if (l < 7) {
diff --git a/src/main/java/net/minecraft/server/BlockTNT.java b/src/main/java/net/minecraft/server/BlockTNT.java
new file mode 100644
index 0000000..312b4c8
--- /dev/null
+++ b/src/main/java/net/minecraft/server/BlockTNT.java
@@ -0,0 +1,85 @@
+package net.minecraft.server;
+
+import java.util.Random;
+
+public class BlockTNT extends Block {
+
+    public BlockTNT(int i) {
+        super(i, Material.TNT);
+        this.a(CreativeModeTab.d);
+    }
+
+    public void onPlace(World world, int i, int j, int k) {
+        super.onPlace(world, i, j, k);
+        if (world.isBlockIndirectlyPowered(i, j, k)) {
+            this.postBreak(world, i, j, k, 1);
+            world.setAir(i, j, k);
+        }
+    }
+
+    public void doPhysics(World world, int i, int j, int k, int l) {
+        if (world.isBlockIndirectlyPowered(i, j, k)) {
+            this.postBreak(world, i, j, k, 1);
+            world.setAir(i, j, k);
+        }
+    }
+
+    public int a(Random random) {
+        return 1;
+    }
+
+    public void wasExploded(World world, int i, int j, int k, Explosion explosion) {
+        if (!world.isStatic) {
+            EntityTNTPrimed entitytntprimed = new EntityTNTPrimed(world, (double) ((float) i + 0.5F), (double) ((float) j + 0.5F), (double) ((float) k + 0.5F), explosion.c());
+
+            entitytntprimed.fuseTicks = world.random.nextInt(entitytntprimed.fuseTicks / 4) + entitytntprimed.fuseTicks / 8;
+            world.addEntity(entitytntprimed);
+        }
+    }
+
+    public void postBreak(World world, int i, int j, int k, int l) {
+        this.a(world, i, j, k, l, (EntityLiving) null);
+    }
+
+    public void a(World world, int i, int j, int k, int l, EntityLiving entityliving) {
+        if (!world.isStatic) {
+            if ((l & 1) == 1) {
+                EntityTNTPrimed entitytntprimed = new EntityTNTPrimed(world, (double) ((float) i + 0.5F), (double) ((float) j + 0.5F), (double) ((float) k + 0.5F), entityliving);
+
+                world.addEntity(entitytntprimed);
+                world.makeSound(entitytntprimed, "random.fuse", 1.0F, 1.0F);
+            }
+        }
+    }
+
+    public boolean interact(World world, int i, int j, int k, EntityHuman entityhuman, int l, float f, float f1, float f2) {
+        if (entityhuman.by() != null && entityhuman.by().id == Item.FLINT_AND_STEEL.id) {
+            this.a(world, i, j, k, 1, (EntityLiving) entityhuman); // Spigot - Fix decompile error!
+            world.setAir(i, j, k);
+            entityhuman.by().damage(1, entityhuman);
+            return true;
+        } else {
+            return super.interact(world, i, j, k, entityhuman, l, f, f1, f2);
+        }
+    }
+
+    public void a(World world, int i, int j, int k, Entity entity) {
+        if (entity instanceof EntityArrow && !world.isStatic) {
+            EntityArrow entityarrow = (EntityArrow) entity;
+
+            if (entityarrow.isBurning()) {
+                // CraftBukkit start
+                if (org.bukkit.craftbukkit.event.CraftEventFactory.callEntityChangeBlockEvent(entityarrow, i, j, k, 0, 0).isCancelled()) {
+                    return;
+                }
+                // CraftBukkit end
+                this.a(world, i, j, k, 1, entityarrow.shooter instanceof EntityLiving ? (EntityLiving) entityarrow.shooter : null);
+                world.setAir(i, j, k);
+            }
+        }
+    }
+
+    public boolean a(Explosion explosion) {
+        return false;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/ChatMessage.java b/src/main/java/net/minecraft/server/ChatMessage.java
new file mode 100644
index 0000000..8093e68
--- /dev/null
+++ b/src/main/java/net/minecraft/server/ChatMessage.java
@@ -0,0 +1,273 @@
+package net.minecraft.server;
+
+import com.google.common.collect.Lists;
+import com.google.gson.Gson;
+import com.google.gson.GsonBuilder;
+import java.util.Iterator;
+import java.util.List;
+
+public class ChatMessage {
+
+    private static final Gson a = (new GsonBuilder()).registerTypeAdapter(ChatMessage.class, new ChatSerializer()).create();
+    private EnumChatFormat b;
+    private Boolean c;
+    private Boolean d;
+    private Boolean e;
+    private Boolean f;
+    private String g;
+    private String h;
+    private List i;
+
+    public ChatMessage() {}
+
+    public ChatMessage(ChatMessage chatmessage) {
+        this.b = chatmessage.b;
+        this.c = chatmessage.c;
+        this.d = chatmessage.d;
+        this.e = chatmessage.e;
+        this.f = chatmessage.f;
+        this.g = chatmessage.g;
+        this.h = chatmessage.h;
+        this.i = chatmessage.i == null ? null : Lists.newArrayList(chatmessage.i);
+    }
+
+    public ChatMessage a(EnumChatFormat enumchatformat) {
+        if (enumchatformat != null && !enumchatformat.c()) {
+            throw new IllegalArgumentException("Argument is not a valid color!");
+        } else {
+            this.b = enumchatformat;
+            return this;
+        }
+    }
+
+    public EnumChatFormat a() {
+        return this.b;
+    }
+
+    public ChatMessage a(Boolean obool) {
+        this.c = obool;
+        return this;
+    }
+
+    public Boolean b() {
+        return this.c;
+    }
+
+    public ChatMessage b(Boolean obool) {
+        this.d = obool;
+        return this;
+    }
+
+    public Boolean c() {
+        return this.d;
+    }
+
+    public ChatMessage c(Boolean obool) {
+        this.e = obool;
+        return this;
+    }
+
+    public Boolean d() {
+        return this.e;
+    }
+
+    public ChatMessage d(Boolean obool) {
+        this.f = obool;
+        return this;
+    }
+
+    public Boolean e() {
+        return this.f;
+    }
+
+    protected String f() {
+        return this.g;
+    }
+
+    protected String g() {
+        return this.h;
+    }
+
+    protected List h() {
+        return this.i;
+    }
+
+    public ChatMessage a(ChatMessage chatmessage) {
+        if (this.g == null && this.h == null) {
+            if (this.i != null) {
+                this.i.add(chatmessage);
+            } else {
+                this.i = Lists.newArrayList(new ChatMessage[] { chatmessage});
+            }
+        } else {
+            this.i = Lists.newArrayList(new ChatMessage[] { new ChatMessage(this), chatmessage});
+            this.g = null;
+            this.h = null;
+        }
+
+        return this;
+    }
+
+    public ChatMessage a(String s) {
+        if (this.g == null && this.h == null) {
+            if (this.i != null) {
+                this.i.add(d(s));
+            } else {
+                this.g = s;
+            }
+        } else {
+            this.i = Lists.newArrayList(new ChatMessage[] { new ChatMessage(this), d(s)});
+            this.g = null;
+            this.h = null;
+        }
+
+        return this;
+    }
+
+    public ChatMessage b(String s) {
+        if (this.g == null && this.h == null) {
+            if (this.i != null) {
+                this.i.add(e(s));
+            } else {
+                this.h = s;
+            }
+        } else {
+            this.i = Lists.newArrayList(new ChatMessage[] { new ChatMessage(this), e(s)});
+            this.g = null;
+            this.h = null;
+        }
+
+        return this;
+    }
+
+    public ChatMessage a(String s, Object... aobject) {
+        if (this.g == null && this.h == null) {
+            if (this.i != null) {
+                this.i.add(b(s, aobject));
+            } else {
+                this.h = s;
+                this.i = Lists.newArrayList();
+                Object[] aobject1 = aobject;
+                int i = aobject.length;
+
+                for (int j = 0; j < i; ++j) {
+                    Object object = aobject1[j];
+
+                    if (object instanceof ChatMessage) {
+                        this.i.add((ChatMessage) object);
+                    } else {
+                        this.i.add(d(object.toString()));
+                    }
+                }
+            }
+        } else {
+            this.i = Lists.newArrayList(new ChatMessage[] { new ChatMessage(this), b(s, aobject)});
+            this.g = null;
+            this.h = null;
+        }
+
+        return this;
+    }
+
+    public String toString() {
+        return this.a(false);
+    }
+
+    public String a(boolean flag) {
+        return this.a(flag, (EnumChatFormat) null, false, false, false, false);
+    }
+
+    public String a(boolean flag, EnumChatFormat enumchatformat, boolean flag1, boolean flag2, boolean flag3, boolean flag4) {
+        StringBuilder stringbuilder = new StringBuilder();
+        EnumChatFormat enumchatformat1 = this.b == null ? enumchatformat : this.b;
+        boolean flag5 = this.c == null ? flag1 : this.c.booleanValue();
+        boolean flag6 = this.d == null ? flag2 : this.d.booleanValue();
+        boolean flag7 = this.e == null ? flag3 : this.e.booleanValue();
+        boolean flag8 = this.f == null ? flag4 : this.f.booleanValue();
+
+        if (this.h != null) {
+            if (flag) {
+                a(stringbuilder, enumchatformat1, flag5, flag6, flag7, flag8);
+            }
+
+            if (this.i != null) {
+                String[] astring = new String[this.i.size()];
+
+                for (int i = 0; i < this.i.size(); ++i) {
+                    astring[i] = ((ChatMessage) this.i.get(i)).a(flag, enumchatformat1, flag5, flag6, flag7, flag8);
+                }
+
+                stringbuilder.append(LocaleI18n.get(this.h, astring));
+            } else {
+                stringbuilder.append(LocaleI18n.get(this.h));
+            }
+        } else if (this.g != null) {
+            if (flag) {
+                a(stringbuilder, enumchatformat1, flag5, flag6, flag7, flag8);
+            }
+
+            stringbuilder.append(this.g);
+        } else {
+            ChatMessage chatmessage;
+
+            if (this.i != null) {
+                for (Iterator iterator = this.i.iterator(); iterator.hasNext(); stringbuilder.append(chatmessage.a(flag, enumchatformat1, flag5, flag6, flag7, flag8))) {
+                    chatmessage = (ChatMessage) iterator.next();
+                    if (flag) {
+                        a(stringbuilder, enumchatformat1, flag5, flag6, flag7, flag8);
+                    }
+                }
+            }
+        }
+
+        return stringbuilder.toString();
+    }
+
+    private static void a(StringBuilder stringbuilder, EnumChatFormat enumchatformat, boolean flag, boolean flag1, boolean flag2, boolean flag3) {
+        if (enumchatformat != null) {
+            stringbuilder.append(enumchatformat);
+        } else if (flag || flag1 || flag2 || flag3) {
+            stringbuilder.append(EnumChatFormat.RESET);
+        }
+
+        if (flag) {
+            stringbuilder.append(EnumChatFormat.BOLD);
+        }
+
+        if (flag1) {
+            stringbuilder.append(EnumChatFormat.ITALIC);
+        }
+
+        if (flag2) {
+            stringbuilder.append(EnumChatFormat.UNDERLINE);
+        }
+
+        if (flag3) {
+            stringbuilder.append(EnumChatFormat.RANDOM);
+        }
+    }
+
+    public static ChatMessage d(String s) {
+        ChatMessage chatmessage = new ChatMessage();
+
+        chatmessage.a(s);
+        return chatmessage;
+    }
+
+    public static ChatMessage e(String s) {
+        ChatMessage chatmessage = new ChatMessage();
+
+        chatmessage.b(s);
+        return chatmessage;
+    }
+
+    public static ChatMessage b(String s, Object... aobject)
+    {
+        return ChatMessage.d( LocaleLanguage.a().a( s, aobject ) );
+    }
+
+    public String i()
+    {
+        return a.toJson( this );
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Chunk.java b/src/main/java/net/minecraft/server/Chunk.java
index 3fa774f..8c98f3e 100644
--- a/src/main/java/net/minecraft/server/Chunk.java
+++ b/src/main/java/net/minecraft/server/Chunk.java
@@ -33,6 +33,7 @@ public class Chunk {
     public int p;
     public long q;
     private int u;
+    protected gnu.trove.map.hash.TObjectIntHashMap<Class> entityCount = new gnu.trove.map.hash.TObjectIntHashMap<Class>(); // Spigot
 
     public Chunk(World world, int i, int j) {
         this.sections = new ChunkSection[16];
@@ -552,6 +553,22 @@ public class Chunk {
         entity.ak = k;
         entity.al = this.z;
         this.entitySlices[k].add(entity);
+        // Spigot start - increment creature type count
+        // Keep this synced up with World.a(Class)
+        if (entity instanceof EntityInsentient) {
+            EntityInsentient entityinsentient = (EntityInsentient) entity;
+            if (entityinsentient.isTypeNotPersistent() && entityinsentient.isPersistent()) {
+                return;
+            }
+        }
+        for ( EnumCreatureType creatureType : EnumCreatureType.values() )
+        {
+            if ( creatureType.a().isAssignableFrom( entity.getClass() ) )
+            {
+                this.entityCount.adjustOrPutValue( creatureType.a(), 1, 1 );
+            }
+        }
+        // Spigot end
     }
 
     public void b(Entity entity) {
@@ -568,6 +585,22 @@ public class Chunk {
         }
 
         this.entitySlices[i].remove(entity);
+        // Spigot start - decrement creature type count
+        // Keep this synced up with World.a(Class)
+        if (entity instanceof EntityInsentient) {
+            EntityInsentient entityinsentient = (EntityInsentient) entity;
+            if (entityinsentient.isTypeNotPersistent() && entityinsentient.isPersistent()) {
+                return;
+            }
+        }
+        for ( EnumCreatureType creatureType : EnumCreatureType.values() )
+        {
+            if ( creatureType.a().isAssignableFrom( entity.getClass() ) )
+            {
+                this.entityCount.adjustValue( creatureType.a(), -1 );
+            }
+        }
+        // Spigot end
     }
 
     public boolean d(int i, int j, int k) {
@@ -671,6 +704,15 @@ public class Chunk {
 
         while (iterator.hasNext()) {
             TileEntity tileentity = (TileEntity) iterator.next();
+            // Spigot Start
+            if ( tileentity instanceof IInventory )
+            {
+                for ( org.bukkit.craftbukkit.entity.CraftHumanEntity h : new ArrayList<org.bukkit.craftbukkit.entity.CraftHumanEntity>( (List) ( (IInventory) tileentity ).getViewers() ) )
+                {
+                    h.getHandle().closeInventory();
+                }
+            }
+            // Spigot End
 
             this.world.a(tileentity);
         }
@@ -680,6 +722,15 @@ public class Chunk {
             java.util.Iterator<Object> iter = this.entitySlices[i].iterator();
             while (iter.hasNext()) {
                 Entity entity = (Entity) iter.next();
+                // Spigot Start
+                if ( entity instanceof IInventory )
+                {
+                    for ( org.bukkit.craftbukkit.entity.CraftHumanEntity h : new ArrayList<org.bukkit.craftbukkit.entity.CraftHumanEntity>( (List) ( (IInventory) entity ).getViewers() ) )
+                    {
+                        h.getHandle().closeInventory();
+                    }
+                }
+                // Spigot End
 
                 // Do not pass along players, as doing so can get them stuck outside of time.
                 // (which for example disables inventory icon updates and prevents block breaking)
diff --git a/src/main/java/net/minecraft/server/ChunkProviderServer.java b/src/main/java/net/minecraft/server/ChunkProviderServer.java
index b73f69c..17934c0 100644
--- a/src/main/java/net/minecraft/server/ChunkProviderServer.java
+++ b/src/main/java/net/minecraft/server/ChunkProviderServer.java
@@ -102,6 +102,7 @@ public class ChunkProviderServer implements IChunkProvider {
         // CraftBukkit end
 
         if (chunk == null) {
+            org.bukkit.craftbukkit.SpigotTimings.syncChunkLoadTimer.startTiming(); // Spigot
             chunk = this.loadChunk(i, j);
             if (chunk == null) {
                 if (this.chunkProvider == null) {
@@ -140,6 +141,7 @@ public class ChunkProviderServer implements IChunkProvider {
             // CraftBukkit end
 
             chunk.a(this, this, i, j);
+            org.bukkit.craftbukkit.SpigotTimings.syncChunkLoadTimer.stopTiming(); // Spigot
         }
 
         // CraftBukkit start - If we didn't need to load the chunk run the callback now
diff --git a/src/main/java/net/minecraft/server/ChunkRegionLoader.java b/src/main/java/net/minecraft/server/ChunkRegionLoader.java
index 8a21f35..0b086a2 100644
--- a/src/main/java/net/minecraft/server/ChunkRegionLoader.java
+++ b/src/main/java/net/minecraft/server/ChunkRegionLoader.java
@@ -13,8 +13,7 @@ import java.util.Set;
 
 public class ChunkRegionLoader implements IAsyncChunkSaver, IChunkLoader {
 
-    private List a = new ArrayList();
-    private Set b = new HashSet();
+    private java.util.LinkedHashMap<ChunkCoordIntPair, PendingChunkToSave> pendingSaves = new java.util.LinkedHashMap<ChunkCoordIntPair, PendingChunkToSave>(); // Spigot
     private Object c = new Object();
     private final File d;
 
@@ -27,13 +26,11 @@ public class ChunkRegionLoader implements IAsyncChunkSaver, IChunkLoader {
         ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(i, j);
 
         synchronized (this.c) {
-            if (this.b.contains(chunkcoordintpair)) {
-                for (int k = 0; k < this.a.size(); ++k) {
-                    if (((PendingChunkToSave) this.a.get(k)).a.equals(chunkcoordintpair)) {
-                        return true;
-                    }
-                }
-            }
+            // Spigot start
+            if (pendingSaves.containsKey(chunkcoordintpair)) {
+                return true;
+             }
+            // Spigot end
         }
 
         return RegionFileCache.a(this.d, i, j).chunkExists(i & 31, j & 31);
@@ -60,14 +57,12 @@ public class ChunkRegionLoader implements IAsyncChunkSaver, IChunkLoader {
         Object object = this.c;
 
         synchronized (this.c) {
-            if (this.b.contains(chunkcoordintpair)) {
-                for (int k = 0; k < this.a.size(); ++k) {
-                    if (((PendingChunkToSave) this.a.get(k)).a.equals(chunkcoordintpair)) {
-                        nbttagcompound = ((PendingChunkToSave) this.a.get(k)).b;
-                        break;
-                    }
-                }
+            // Spigot start
+            PendingChunkToSave pendingchunktosave = pendingSaves.get(chunkcoordintpair);
+            if (pendingchunktosave != null) {
+                nbttagcompound = pendingchunktosave.b;
             }
+            // Spigot end
         }
 
         if (nbttagcompound == null) {
@@ -148,17 +143,11 @@ public class ChunkRegionLoader implements IAsyncChunkSaver, IChunkLoader {
         Object object = this.c;
 
         synchronized (this.c) {
-            if (this.b.contains(chunkcoordintpair)) {
-                for (int i = 0; i < this.a.size(); ++i) {
-                    if (((PendingChunkToSave) this.a.get(i)).a.equals(chunkcoordintpair)) {
-                        this.a.set(i, new PendingChunkToSave(chunkcoordintpair, nbttagcompound));
-                        return;
-                    }
-                }
+            // Spigot start
+            if (this.pendingSaves.put(chunkcoordintpair, new PendingChunkToSave(chunkcoordintpair, nbttagcompound)) != null) {
+                return;
             }
-
-            this.a.add(new PendingChunkToSave(chunkcoordintpair, nbttagcompound));
-            this.b.add(chunkcoordintpair);
+            // Spigot end
             FileIOThread.a.a(this);
         }
     }
@@ -168,12 +157,14 @@ public class ChunkRegionLoader implements IAsyncChunkSaver, IChunkLoader {
         Object object = this.c;
 
         synchronized (this.c) {
-            if (this.a.isEmpty()) {
+            // Spigot start
+            if (this.pendingSaves.isEmpty()) {
                 return false;
             }
 
-            pendingchunktosave = (PendingChunkToSave) this.a.remove(0);
-            this.b.remove(pendingchunktosave.a);
+            pendingchunktosave = this.pendingSaves.values().iterator().next();
+            this.pendingSaves.remove(pendingchunktosave.a);
+            // Spigot end
         }
 
         if (pendingchunktosave != null) {
@@ -227,15 +218,15 @@ public class ChunkRegionLoader implements IAsyncChunkSaver, IChunkLoader {
                 nbttagcompound1.setByte("Y", (byte) (chunksection.getYPosition() >> 4 & 255));
                 nbttagcompound1.setByteArray("Blocks", chunksection.getIdArray());
                 if (chunksection.getExtendedIdArray() != null) {
-                    nbttagcompound1.setByteArray("Add", chunksection.getExtendedIdArray().a);
+                    nbttagcompound1.setByteArray("Add", chunksection.getExtendedIdArray().getValueArray()); // Spigot
                 }
 
-                nbttagcompound1.setByteArray("Data", chunksection.getDataArray().a);
-                nbttagcompound1.setByteArray("BlockLight", chunksection.getEmittedLightArray().a);
+                nbttagcompound1.setByteArray("Data", chunksection.getDataArray().getValueArray()); // Spigot
+                nbttagcompound1.setByteArray("BlockLight", chunksection.getEmittedLightArray().getValueArray()); // Spigot
                 if (flag) {
-                    nbttagcompound1.setByteArray("SkyLight", chunksection.getSkyLightArray().a);
+                    nbttagcompound1.setByteArray("SkyLight", chunksection.getSkyLightArray().getValueArray()); // Spigot
                 } else {
-                    nbttagcompound1.setByteArray("SkyLight", new byte[chunksection.getEmittedLightArray().a.length]);
+                    nbttagcompound1.setByteArray("SkyLight", new byte[chunksection.getEmittedLightArray().getValueArray().length]); // Spigot
                 }
 
                 nbttaglist.add(nbttagcompound1);
diff --git a/src/main/java/net/minecraft/server/ChunkSection.java b/src/main/java/net/minecraft/server/ChunkSection.java
index 3f67a19..e69afba 100644
--- a/src/main/java/net/minecraft/server/ChunkSection.java
+++ b/src/main/java/net/minecraft/server/ChunkSection.java
@@ -134,7 +134,8 @@ public class ChunkSection {
                 }
             }
         } else {
-            byte[] ext = this.extBlockIds.a;
+            this.extBlockIds.forceToNonTrivialArray(); // Spigot
+            byte[] ext = this.extBlockIds.getValueArray();
             for (int off = 0, off2 = 0; off < blkIds.length;) {
                 byte extid = ext[off2];
                 int l = (blkIds[off] & 0xFF) | ((extid & 0xF) << 8); // Even data
@@ -165,6 +166,12 @@ public class ChunkSection {
                 off++;
                 off2++;
             }
+            // Spigot start
+            this.extBlockIds.detectAndProcessTrivialArray();
+            if (this.extBlockIds.isTrivialArray() && (this.extBlockIds.getTrivialArrayValue() == 0)) {
+                this.extBlockIds = null;
+            }
+            // Spigot end
         }
         this.nonEmptyBlockCount = cntNonEmpty;
         this.tickingBlockCount = cntTicking;
@@ -225,12 +232,11 @@ public class ChunkSection {
     public void setExtendedIdArray(NibbleArray nibblearray) {
         // CraftBukkit start - Don't hang on to an empty nibble array
         boolean empty = true;
-        for (int i = 0; i < nibblearray.a.length; i++) {
-            if (nibblearray.a[i] != 0) {
-                empty = false;
-                break;
-            }
+        // Spigot start
+        if ((!nibblearray.isTrivialArray()) || (nibblearray.getTrivialArrayValue() != 0)) {
+            empty = false;
         }
+        // Spigot end
 
         if (empty) {
             return;
@@ -254,11 +260,11 @@ public class ChunkSection {
 
     // CraftBukkit start - Validate array lengths
     private NibbleArray validateNibbleArray(NibbleArray nibbleArray) {
-        if (nibbleArray != null && nibbleArray.a.length < 2048) {
-            byte[] newArray = new byte[2048];
-            System.arraycopy(nibbleArray.a, 0, newArray, 0, ((nibbleArray.a.length > 2048) ? 2048 : nibbleArray.a.length));
-            nibbleArray = new NibbleArray(newArray, 4);
+        // Spigot start - fix for more awesome nibble arrays
+        if (nibbleArray != null && nibbleArray.getByteLength() < 2048) {
+            nibbleArray.resizeArray(2048);
         }
+        // Spigot end
 
         return nibbleArray;
     }
diff --git a/src/main/java/net/minecraft/server/Connection.java b/src/main/java/net/minecraft/server/Connection.java
new file mode 100644
index 0000000..70afa00
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Connection.java
@@ -0,0 +1,324 @@
+package net.minecraft.server;
+
+public abstract class Connection {
+
+    public Connection() {}
+
+    public abstract boolean a();
+
+    public void a(Packet51MapChunk packet51mapchunk) {}
+
+    public void onUnhandledPacket(Packet packet) {}
+
+    public void a(String s, Object[] aobject) {}
+
+    public void a(Packet255KickDisconnect packet255kickdisconnect) {
+        this.onUnhandledPacket(packet255kickdisconnect);
+    }
+
+    public void a(Packet1Login packet1login) {
+        this.onUnhandledPacket(packet1login);
+    }
+        public void a(PacketStatusRequest request) {
+        this.onUnhandledPacket(request);
+    }
+    public void a(PacketLoginRequest request)
+    {
+        this.onUnhandledPacket( request );
+    }
+    public void a(PacketPingTime time) {
+        this.onUnhandledPacket(time);
+    }
+
+    public void a(Packet10Flying packet10flying) {
+        this.onUnhandledPacket(packet10flying);
+    }
+
+    public void a(Packet52MultiBlockChange packet52multiblockchange) {
+        this.onUnhandledPacket(packet52multiblockchange);
+    }
+
+    public void a(Packet14BlockDig packet14blockdig) {
+        this.onUnhandledPacket(packet14blockdig);
+    }
+
+    public void a(Packet53BlockChange packet53blockchange) {
+        this.onUnhandledPacket(packet53blockchange);
+    }
+
+    public void a(Packet20NamedEntitySpawn packet20namedentityspawn) {
+        this.onUnhandledPacket(packet20namedentityspawn);
+    }
+
+    public void a(Packet30Entity packet30entity) {
+        this.onUnhandledPacket(packet30entity);
+    }
+
+    public void a(Packet34EntityTeleport packet34entityteleport) {
+        this.onUnhandledPacket(packet34entityteleport);
+    }
+
+    public void a(Packet15Place packet15place) {
+        this.onUnhandledPacket(packet15place);
+    }
+
+    public void a(Packet16BlockItemSwitch packet16blockitemswitch) {
+        this.onUnhandledPacket(packet16blockitemswitch);
+    }
+
+    public void a(Packet29DestroyEntity packet29destroyentity) {
+        this.onUnhandledPacket(packet29destroyentity);
+    }
+
+    public void a(Packet22Collect packet22collect) {
+        this.onUnhandledPacket(packet22collect);
+    }
+
+    public void a(Packet3Chat packet3chat) {
+        this.onUnhandledPacket(packet3chat);
+    }
+
+    public void a(Packet23VehicleSpawn packet23vehiclespawn) {
+        this.onUnhandledPacket(packet23vehiclespawn);
+    }
+
+    public void a(Packet18ArmAnimation packet18armanimation) {
+        this.onUnhandledPacket(packet18armanimation);
+    }
+
+    public void a(Packet19EntityAction packet19entityaction) {
+        this.onUnhandledPacket(packet19entityaction);
+    }
+
+    public void a(Packet2Handshake packet2handshake) {
+        this.onUnhandledPacket(packet2handshake);
+    }
+
+    public void a(Packet253KeyRequest packet253keyrequest) {
+        this.onUnhandledPacket(packet253keyrequest);
+    }
+
+    public void a(Packet252KeyResponse packet252keyresponse) {
+        this.onUnhandledPacket(packet252keyresponse);
+    }
+
+    public void a(Packet24MobSpawn packet24mobspawn) {
+        this.onUnhandledPacket(packet24mobspawn);
+    }
+
+    public void a(Packet4UpdateTime packet4updatetime) {
+        this.onUnhandledPacket(packet4updatetime);
+    }
+
+    public void a(Packet6SpawnPosition packet6spawnposition) {
+        this.onUnhandledPacket(packet6spawnposition);
+    }
+
+    public void a(Packet28EntityVelocity packet28entityvelocity) {
+        this.onUnhandledPacket(packet28entityvelocity);
+    }
+
+    public void a(Packet40EntityMetadata packet40entitymetadata) {
+        this.onUnhandledPacket(packet40entitymetadata);
+    }
+
+    public void a(Packet39AttachEntity packet39attachentity) {
+        this.onUnhandledPacket(packet39attachentity);
+    }
+
+    public void a(Packet7UseEntity packet7useentity) {
+        this.onUnhandledPacket(packet7useentity);
+    }
+
+    public void a(Packet38EntityStatus packet38entitystatus) {
+        this.onUnhandledPacket(packet38entitystatus);
+    }
+
+    public void a(Packet8UpdateHealth packet8updatehealth) {
+        this.onUnhandledPacket(packet8updatehealth);
+    }
+
+    public void a(Packet9Respawn packet9respawn) {
+        this.onUnhandledPacket(packet9respawn);
+    }
+
+    public void a(Packet60Explosion packet60explosion) {
+        this.onUnhandledPacket(packet60explosion);
+    }
+
+    public void a(Packet100OpenWindow packet100openwindow) {
+        this.onUnhandledPacket(packet100openwindow);
+    }
+
+    public void handleContainerClose(Packet101CloseWindow packet101closewindow) {
+        this.onUnhandledPacket(packet101closewindow);
+    }
+
+    public void a(Packet102WindowClick packet102windowclick) {
+        this.onUnhandledPacket(packet102windowclick);
+    }
+
+    public void a(Packet103SetSlot packet103setslot) {
+        this.onUnhandledPacket(packet103setslot);
+    }
+
+    public void a(Packet104WindowItems packet104windowitems) {
+        this.onUnhandledPacket(packet104windowitems);
+    }
+
+    public void a(Packet130UpdateSign packet130updatesign) {
+        this.onUnhandledPacket(packet130updatesign);
+    }
+
+    public void a(Packet105CraftProgressBar packet105craftprogressbar) {
+        this.onUnhandledPacket(packet105craftprogressbar);
+    }
+
+    public void a(Packet5EntityEquipment packet5entityequipment) {
+        this.onUnhandledPacket(packet5entityequipment);
+    }
+
+    public void a(Packet106Transaction packet106transaction) {
+        this.onUnhandledPacket(packet106transaction);
+    }
+
+    public void a(Packet25EntityPainting packet25entitypainting) {
+        this.onUnhandledPacket(packet25entitypainting);
+    }
+
+    public void a(Packet54PlayNoteBlock packet54playnoteblock) {
+        this.onUnhandledPacket(packet54playnoteblock);
+    }
+
+    public void a(Packet200Statistic packet200statistic) {
+        this.onUnhandledPacket(packet200statistic);
+    }
+
+    public void a(Packet17EntityLocationAction packet17entitylocationaction) {
+        this.onUnhandledPacket(packet17entitylocationaction);
+    }
+
+    public void a(Packet27PlayerInput packet27playerinput) {
+        this.onUnhandledPacket(packet27playerinput);
+    }
+
+    public void a(Packet70Bed packet70bed) {
+        this.onUnhandledPacket(packet70bed);
+    }
+
+    public void a(Packet71Weather packet71weather) {
+        this.onUnhandledPacket(packet71weather);
+    }
+
+    public void a(Packet131ItemData packet131itemdata) {
+        this.onUnhandledPacket(packet131itemdata);
+    }
+
+    public void a(Packet61WorldEvent packet61worldevent) {
+        this.onUnhandledPacket(packet61worldevent);
+    }
+
+    public void a(Packet254GetInfo packet254getinfo) {
+        this.onUnhandledPacket(packet254getinfo);
+    }
+
+    public void a(Packet41MobEffect packet41mobeffect) {
+        this.onUnhandledPacket(packet41mobeffect);
+    }
+
+    public void a(Packet42RemoveMobEffect packet42removemobeffect) {
+        this.onUnhandledPacket(packet42removemobeffect);
+    }
+
+    public void a(Packet201PlayerInfo packet201playerinfo) {
+        this.onUnhandledPacket(packet201playerinfo);
+    }
+
+    public void a(Packet0KeepAlive packet0keepalive) {
+        this.onUnhandledPacket(packet0keepalive);
+    }
+
+    public void a(Packet43SetExperience packet43setexperience) {
+        this.onUnhandledPacket(packet43setexperience);
+    }
+
+    public void a(Packet107SetCreativeSlot packet107setcreativeslot) {
+        this.onUnhandledPacket(packet107setcreativeslot);
+    }
+
+    public void a(Packet26AddExpOrb packet26addexporb) {
+        this.onUnhandledPacket(packet26addexporb);
+    }
+
+    public void a(Packet108ButtonClick packet108buttonclick) {}
+
+    public void a(Packet250CustomPayload packet250custompayload) {}
+
+    public void a(Packet35EntityHeadRotation packet35entityheadrotation) {
+        this.onUnhandledPacket(packet35entityheadrotation);
+    }
+
+    public void a(Packet132TileEntityData packet132tileentitydata) {
+        this.onUnhandledPacket(packet132tileentitydata);
+    }
+
+    public void a(Packet202Abilities packet202abilities) {
+        this.onUnhandledPacket(packet202abilities);
+    }
+
+    public void a(Packet203TabComplete packet203tabcomplete) {
+        this.onUnhandledPacket(packet203tabcomplete);
+    }
+
+    public void a(Packet204LocaleAndViewDistance packet204localeandviewdistance) {
+        this.onUnhandledPacket(packet204localeandviewdistance);
+    }
+
+    public void a(Packet62NamedSoundEffect packet62namedsoundeffect) {
+        this.onUnhandledPacket(packet62namedsoundeffect);
+    }
+
+    public void a(Packet55BlockBreakAnimation packet55blockbreakanimation) {
+        this.onUnhandledPacket(packet55blockbreakanimation);
+    }
+
+    public void a(Packet205ClientCommand packet205clientcommand) {}
+
+    public void a(Packet56MapChunkBulk packet56mapchunkbulk) {
+        this.onUnhandledPacket(packet56mapchunkbulk);
+    }
+
+    public boolean b() {
+        return false;
+    }
+
+    public void a(Packet206SetScoreboardObjective packet206setscoreboardobjective) {
+        this.onUnhandledPacket(packet206setscoreboardobjective);
+    }
+
+    public void a(Packet207SetScoreboardScore packet207setscoreboardscore) {
+        this.onUnhandledPacket(packet207setscoreboardscore);
+    }
+
+    public void a(Packet208SetScoreboardDisplayObjective packet208setscoreboarddisplayobjective) {
+        this.onUnhandledPacket(packet208setscoreboarddisplayobjective);
+    }
+
+    public void a(Packet209SetScoreboardTeam packet209setscoreboardteam) {
+        this.onUnhandledPacket(packet209setscoreboardteam);
+    }
+
+    public void a(Packet63WorldParticles packet63worldparticles) {
+        this.onUnhandledPacket(packet63worldparticles);
+    }
+
+    public void a(Packet44UpdateAttributes packet44updateattributes) {
+        this.onUnhandledPacket(packet44updateattributes);
+    }
+
+    public void a(Packet133OpenTileEntity packet133opentileentity) {}
+
+    public boolean c() {
+        return false;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/DedicatedServer.java b/src/main/java/net/minecraft/server/DedicatedServer.java
index f871b73..32f0e75 100644
--- a/src/main/java/net/minecraft/server/DedicatedServer.java
+++ b/src/main/java/net/minecraft/server/DedicatedServer.java
@@ -34,7 +34,7 @@ public class DedicatedServer extends MinecraftServer implements IMinecraftServer
         super(options);
         // CraftBukkit end
         this.m = new ConsoleLogManager("Minecraft-Server", (String) null, (String) null); // CraftBukkit - null last argument
-        new ThreadSleepForever(this);
+        // new ThreadSleepForever(this);
     }
 
     protected boolean init() throws java.net.UnknownHostException { // CraftBukkit - throws UnknownHostException
@@ -90,13 +90,22 @@ public class DedicatedServer extends MinecraftServer implements IMinecraftServer
         if (this.I() < 0) {
             this.setPort(this.propertyManager.getInt("server-port", 25565));
         }
+        // Spigot start
+        this.a((PlayerList) (new DedicatedPlayerList(this)));
+        org.spigotmc.SpigotConfig.init();
+        org.spigotmc.SpigotConfig.registerCommands();
+        // Spigot end
 
         this.getLogger().info("Generating keypair");
         this.a(MinecraftEncryption.b());
         this.getLogger().info("Starting Minecraft server on " + (this.getServerIp().length() == 0 ? "*" : this.getServerIp()) + ":" + this.I());
 
         try {
-            this.s = new DedicatedServerConnection(this, inetaddress, this.I());
+            // Spigot start
+            this.s = ( org.spigotmc.SpigotConfig.listeners.get( 0 ).netty )
+                    ? new org.spigotmc.netty.NettyServerConnection( this, inetaddress, this.I() )
+                    : new DedicatedServerConnection( this, inetaddress, this.I() );
+            // Spigot end
         } catch (Throwable ioexception) { // CraftBukkit - IOException -> Throwable
             this.getLogger().warning("**** FAILED TO BIND TO PORT!");
             this.getLogger().warning("The exception was: {0}", new Object[] { ioexception.toString()});
@@ -104,7 +113,11 @@ public class DedicatedServer extends MinecraftServer implements IMinecraftServer
             return false;
         }
 
-        this.a((PlayerList) (new DedicatedPlayerList(this))); // CraftBukkit
+        // Spigot Start - Move DedicatedPlayerList up and bring plugin loading from CraftServer to here
+        // this.a((PlayerList) (new DedicatedPlayerList(this)));
+        server.loadPlugins();
+        server.enablePlugins(org.bukkit.plugin.PluginLoadOrder.STARTUP);
+        // Spigot End
 
         if (!this.getOnlineMode()) {
             this.getLogger().warning("**** SERVER IS RUNNING IN OFFLINE/INSECURE MODE!");
diff --git a/src/main/java/net/minecraft/server/DispenseBehaviorBonemeal.java b/src/main/java/net/minecraft/server/DispenseBehaviorBonemeal.java
index 1a58814..b83a803 100644
--- a/src/main/java/net/minecraft/server/DispenseBehaviorBonemeal.java
+++ b/src/main/java/net/minecraft/server/DispenseBehaviorBonemeal.java
@@ -20,9 +20,8 @@ final class DispenseBehaviorBonemeal extends DispenseBehaviorItem {
             int k = isourceblock.getBlockZ() + enumfacing.e();
 
             // CraftBukkit start
-            ItemStack itemstack1 = itemstack.a(1);
             org.bukkit.block.Block block = world.getWorld().getBlockAt(isourceblock.getBlockX(), isourceblock.getBlockY(), isourceblock.getBlockZ());
-            CraftItemStack craftItem = CraftItemStack.asCraftMirror(itemstack1);
+            CraftItemStack craftItem = CraftItemStack.asNewCraftStack(itemstack.getItem());
 
             BlockDispenseEvent event = new BlockDispenseEvent(block, craftItem.clone(), new org.bukkit.util.Vector(0, 0, 0));
             if (!BlockDispenser.eventFired) {
@@ -30,12 +29,10 @@ final class DispenseBehaviorBonemeal extends DispenseBehaviorItem {
             }
 
             if (event.isCancelled()) {
-                itemstack.count++;
                 return itemstack;
             }
 
             if (!event.getItem().equals(craftItem)) {
-                itemstack.count++;
                 // Chain to handler for new item
                 ItemStack eventStack = CraftItemStack.asNMSCopy(event.getItem());
                 IDispenseBehavior idispensebehavior = (IDispenseBehavior) BlockDispenser.a.a(eventStack.getItem());
@@ -46,7 +43,7 @@ final class DispenseBehaviorBonemeal extends DispenseBehaviorItem {
             }
             // CraftBukkit end
 
-            if (ItemDye.a(itemstack1, world, i, j, k)) { // CraftBukkit - itemstack -> itemstack1
+            if (ItemDye.a(itemstack, world, i, j, k)) {
                 if (!world.isStatic) {
                     world.triggerEffect(2005, i, j, k, 0);
                 }
diff --git a/src/main/java/net/minecraft/server/Entity.java b/src/main/java/net/minecraft/server/Entity.java
index 2158088..92d7dc4 100644
--- a/src/main/java/net/minecraft/server/Entity.java
+++ b/src/main/java/net/minecraft/server/Entity.java
@@ -14,6 +14,7 @@ import org.bukkit.block.BlockFace;
 import org.bukkit.entity.LivingEntity;
 import org.bukkit.entity.Painting;
 import org.bukkit.entity.Vehicle;
+import org.spigotmc.CustomTimingsHandler; // Spigot
 import org.bukkit.event.entity.EntityCombustByEntityEvent;
 import org.bukkit.event.painting.PaintingBreakByEntityEvent;
 import org.bukkit.event.vehicle.VehicleBlockCollisionEvent;
@@ -87,7 +88,7 @@ public abstract class Entity {
     public int ticksLived;
     public int maxFireTicks;
     public int fireTicks; // CraftBukkit - private -> public
-    protected boolean inWater;
+    public boolean inWater; // Spigot - protected -> public
     public int noDamageTicks;
     private boolean justCreated;
     protected boolean fireProof;
@@ -110,6 +111,15 @@ public abstract class Entity {
     public EnumEntitySize at;
     public boolean valid; // CraftBukkit
 
+    // Spigot start
+    public CustomTimingsHandler tickTimer = org.bukkit.craftbukkit.SpigotTimings.getEntityTimings(this); // Spigot
+
+    public final byte activationType = org.spigotmc.ActivationRange.initializeEntityActivationType(this);
+    public final boolean defaultActivationState;
+    public long activatedTick = 0;
+    public void inactiveTick() { }
+    // Spigot end
+
     public Entity(World world) {
         this.id = entityCount++;
         this.l = 1.0D;
@@ -122,13 +132,18 @@ public abstract class Entity {
         this.maxFireTicks = 1;
         this.justCreated = true;
         this.datawatcher = new DataWatcher();
-        this.uniqueID = UUID.randomUUID();
+        this.uniqueID = new UUID(random.nextLong(), random.nextLong()); // Spigot
         this.at = EnumEntitySize.SIZE_2;
         this.world = world;
         this.setPosition(0.0D, 0.0D, 0.0D);
         if (world != null) {
             this.dimension = world.worldProvider.dimension;
+            // Spigot start
+            this.defaultActivationState = org.spigotmc.ActivationRange.initializeEntityActivationState(this, world.spigotConfig);
+        } else {
+            this.defaultActivationState = false;
         }
+        // Spigot end
 
         this.datawatcher.a(0, Byte.valueOf((byte) 0));
         this.datawatcher.a(1, Short.valueOf((short) 300));
@@ -405,6 +420,7 @@ public abstract class Entity {
         }
         // CraftBukkit end
 
+        org.bukkit.craftbukkit.SpigotTimings.entityMoveTimer.startTiming(); // Spigot
         if (this.Z) {
             this.boundingBox.d(d0, d1, d2);
             this.locX = (this.boundingBox.a + this.boundingBox.d) / 2.0D;
@@ -713,6 +729,7 @@ public abstract class Entity {
 
             this.world.methodProfiler.b();
         }
+        org.bukkit.craftbukkit.SpigotTimings.entityMoveTimer.stopTiming(); // Spigot
     }
 
     protected void D() {
@@ -1410,6 +1427,7 @@ public abstract class Entity {
                     }
                 }
                 // CraftBukkit end
+                pluginManager.callEvent( new org.spigotmc.event.entity.EntityDismountEvent( this.getBukkitEntity(), this.vehicle.getBukkitEntity() ) ); // Spigot
 
                 this.setPositionRotation(this.vehicle.locX, this.vehicle.boundingBox.b + (double) this.vehicle.length, this.vehicle.locZ, this.yaw, this.pitch);
                 this.vehicle.passenger = null;
@@ -1445,6 +1463,17 @@ public abstract class Entity {
                 }
             }
             // CraftBukkit end
+            // Spigot Start
+            if ( entity.world.isChunkLoaded( (int) entity.locX >> 4, (int) entity.locZ >> 4 ) )
+            {
+                org.spigotmc.event.entity.EntityMountEvent event = new org.spigotmc.event.entity.EntityMountEvent( this.getBukkitEntity(), entity.getBukkitEntity() );
+                pluginManager.callEvent( event );
+                if ( event.isCancelled() )
+                {
+                    return;
+                }
+            }
+            // Spigot End
 
             if (this.vehicle != null) {
                 this.vehicle.passenger = null;
diff --git a/src/main/java/net/minecraft/server/EntityAgeable.java b/src/main/java/net/minecraft/server/EntityAgeable.java
index 5ba19f3..4c73a5f 100644
--- a/src/main/java/net/minecraft/server/EntityAgeable.java
+++ b/src/main/java/net/minecraft/server/EntityAgeable.java
@@ -6,6 +6,31 @@ public abstract class EntityAgeable extends EntityCreature {
     private float bq;
     public boolean ageLocked = false; // CraftBukkit
 
+    // Spigot start
+    @Override
+    public void inactiveTick()
+    {
+        super.inactiveTick();
+        if ( this.world.isStatic || this.ageLocked )
+        { // CraftBukkit
+            this.a( this.isBaby() );
+        } else
+        {
+            int i = this.getAge();
+
+            if ( i < 0 )
+            {
+                ++i;
+                this.setAge( i );
+            } else if ( i > 0 )
+            {
+                --i;
+                this.setAge( i );
+            }
+        }
+    }
+    // Spigot end
+
     public EntityAgeable(World world) {
         super(world);
     }
diff --git a/src/main/java/net/minecraft/server/EntityArrow.java b/src/main/java/net/minecraft/server/EntityArrow.java
index c9ec78a..75fe81b 100644
--- a/src/main/java/net/minecraft/server/EntityArrow.java
+++ b/src/main/java/net/minecraft/server/EntityArrow.java
@@ -14,7 +14,7 @@ public class EntityArrow extends Entity implements IProjectile {
     private int f = -1;
     private int g;
     private int h;
-    private boolean inGround;
+    public boolean inGround = false; // Spigot - private -> public
     public int fromPlayer;
     public int shake;
     public Entity shooter;
@@ -142,7 +142,7 @@ public class EntityArrow extends Entity implements IProjectile {
 
             if (j == this.g && k == this.h) {
                 ++this.j;
-                if (this.j == 1200) {
+                if (this.j == world.spigotConfig.arrowDespawnRate) { // Spigot
                     this.die();
                 }
             } else {
diff --git a/src/main/java/net/minecraft/server/EntityFallingBlock.java b/src/main/java/net/minecraft/server/EntityFallingBlock.java
index b552421..8617474 100644
--- a/src/main/java/net/minecraft/server/EntityFallingBlock.java
+++ b/src/main/java/net/minecraft/server/EntityFallingBlock.java
@@ -86,6 +86,7 @@ public class EntityFallingBlock extends Entity {
                     }
 
                     this.world.setAir(i, j, k);
+                    world.spigotConfig.antiXrayInstance.updateNearbyBlocks(world, i, j, k); // Spigot
                 }
 
                 if (this.onGround) {
@@ -101,6 +102,7 @@ public class EntityFallingBlock extends Entity {
                             }
                             this.world.setTypeIdAndData(i, j, k, this.id, this.data, 3);
                             // CraftBukkit end
+                            world.spigotConfig.antiXrayInstance.updateNearbyBlocks(world, i, j, k); // Spigot
 
                             if (Block.byId[this.id] instanceof BlockSand) {
                                 ((BlockSand) Block.byId[this.id]).a_(this.world, i, j, k, this.data);
diff --git a/src/main/java/net/minecraft/server/EntityHuman.java b/src/main/java/net/minecraft/server/EntityHuman.java
index e4fe770..05b36c1 100644
--- a/src/main/java/net/minecraft/server/EntityHuman.java
+++ b/src/main/java/net/minecraft/server/EntityHuman.java
@@ -38,6 +38,7 @@ public abstract class EntityHuman extends EntityLiving implements ICommandListen
     public boolean sleeping; // protected -> public
     public boolean fauxSleeping;
     public String spawnWorld = "";
+    public String playerUUID; // Spigot
 
     @Override
     public CraftHumanEntity getBukkitEntity() {
@@ -258,6 +259,10 @@ public abstract class EntityHuman extends EntityLiving implements ICommandListen
                 // Update client
                 if (this instanceof EntityPlayer) {
                     ((EntityPlayer) this).playerConnection.sendPacket(new Packet103SetSlot((byte) 0, activeContainer.a((IInventory) this.inventory, this.inventory.itemInHandIndex).index, this.f));
+                    // Spigot Start
+                    ((EntityPlayer) this).getBukkitEntity().updateInventory();
+                    ((EntityPlayer) this).getBukkitEntity().updateScaledHealth();
+                    // Spigot End
                 }
                 return;
             }
@@ -304,6 +309,7 @@ public abstract class EntityHuman extends EntityLiving implements ICommandListen
     public void setPassengerOf(Entity entity) {
         // CraftBukkit end
         if (this.vehicle != null && entity == null) {
+            world.getServer().getPluginManager().callEvent( new org.spigotmc.event.entity.EntityDismountEvent( this.getBukkitEntity(), this.vehicle.getBukkitEntity() ) ); // Spigot
             // CraftBukkit start - use parent method instead to correctly fire VehicleExitEvent
             Entity originalVehicle = this.vehicle;
             // First statement moved down, second statement handled in parent method.
@@ -410,7 +416,7 @@ public abstract class EntityHuman extends EntityLiving implements ICommandListen
 
             List list = this.world.getEntities(this, axisalignedbb);
 
-            if (list != null) {
+            if (list != null && this.L()) { // Spigot: Add this.L() condition
                 for (int i = 0; i < list.size(); ++i) {
                     Entity entity = (Entity) list.get(i);
 
diff --git a/src/main/java/net/minecraft/server/EntityItem.java b/src/main/java/net/minecraft/server/EntityItem.java
index 584102e..52878ff 100644
--- a/src/main/java/net/minecraft/server/EntityItem.java
+++ b/src/main/java/net/minecraft/server/EntityItem.java
@@ -100,7 +100,7 @@ public class EntityItem extends Entity {
         }
 
         // ++this.age; // CraftBukkit - Moved up
-        if (!this.world.isStatic && this.age >= 6000) {
+        if (!this.world.isStatic && this.age >= world.spigotConfig.itemDespawnRate) {
             // CraftBukkit start
             if (org.bukkit.craftbukkit.event.CraftEventFactory.callItemDespawnEvent(this).isCancelled()) {
                 this.age = 0;
@@ -112,7 +112,10 @@ public class EntityItem extends Entity {
     }
 
     private void e() {
-        Iterator iterator = this.world.a(EntityItem.class, this.boundingBox.grow(0.5D, 0.0D, 0.5D)).iterator();
+        // Spigot start
+        double radius = world.spigotConfig.itemMerge;
+        Iterator iterator = this.world.a(EntityItem.class, this.boundingBox.grow(radius, radius, radius)).iterator();
+        // Spigot end
 
         while (iterator.hasNext()) {
             EntityItem entityitem = (EntityItem) iterator.next();
@@ -141,11 +144,13 @@ public class EntityItem extends Entity {
             } else if (itemstack1.count + itemstack.count > itemstack1.getMaxStackSize()) {
                 return false;
             } else {
-                itemstack1.count += itemstack.count;
-                entityitem.pickupDelay = Math.max(entityitem.pickupDelay, this.pickupDelay);
-                entityitem.age = Math.min(entityitem.age, this.age);
-                entityitem.setItemStack(itemstack1);
-                this.die();
+                // Spigot start
+                itemstack.count += itemstack1.count;
+                this.pickupDelay = Math.max(entityitem.pickupDelay, this.pickupDelay);
+                this.age = Math.min(entityitem.age, this.age);
+                this.setItemStack(itemstack);
+                entityitem.die();
+                // Spigot end
                 return true;
             }
         } else {
diff --git a/src/main/java/net/minecraft/server/EntityLiving.java b/src/main/java/net/minecraft/server/EntityLiving.java
index 16a16cf..f2601ca 100644
--- a/src/main/java/net/minecraft/server/EntityLiving.java
+++ b/src/main/java/net/minecraft/server/EntityLiving.java
@@ -78,6 +78,13 @@ public abstract class EntityLiving extends Entity {
     public int expToDrop;
     public int maxAirTicks = 300;
     // CraftBukkit end
+    // Spigot start
+    public void inactiveTick()
+    {
+        super.inactiveTick();
+        ++this.aV;
+    }
+    // Spigot end
 
     public EntityLiving(World world) {
         super(world);
@@ -972,7 +979,7 @@ public abstract class EntityLiving extends Entity {
             this.av = -1;
             this.au = true;
             if (this.world instanceof WorldServer) {
-                ((WorldServer) this.world).getTracker().a((Entity) this, (Packet) (new Packet18ArmAnimation(this, 1)));
+                ((WorldServer) this.world).getTracker().a((Entity) this, (Packet) (new Packet18ArmAnimation(this, 0)));
             }
         }
     }
@@ -1456,7 +1463,7 @@ public abstract class EntityLiving extends Entity {
     protected void bj() {
         List list = this.world.getEntities(this, this.boundingBox.grow(0.20000000298023224D, 0.0D, 0.20000000298023224D));
 
-        if (list != null && !list.isEmpty()) {
+        if (this.L() && list != null && !list.isEmpty()) { // Spigot: Add this.L() condition
             for (int i = 0; i < list.size(); ++i) {
                 Entity entity = (Entity) list.get(i);
 
diff --git a/src/main/java/net/minecraft/server/EntityMinecartContainer.java b/src/main/java/net/minecraft/server/EntityMinecartContainer.java
index e89b106..f58cd7e 100644
--- a/src/main/java/net/minecraft/server/EntityMinecartContainer.java
+++ b/src/main/java/net/minecraft/server/EntityMinecartContainer.java
@@ -149,6 +149,12 @@ public abstract class EntityMinecartContainer extends EntityMinecartAbstract imp
     }
 
     public void b(int i) {
+        // Spigot Start
+        for ( HumanEntity human : new java.util.ArrayList<HumanEntity>( transaction ) )
+        {
+            human.closeInventory();
+        }
+        // Spigot End
         this.b = false;
         super.b(i);
     }
diff --git a/src/main/java/net/minecraft/server/EntityPlayer.java b/src/main/java/net/minecraft/server/EntityPlayer.java
index 2e234f1..6ebb23c 100644
--- a/src/main/java/net/minecraft/server/EntityPlayer.java
+++ b/src/main/java/net/minecraft/server/EntityPlayer.java
@@ -54,7 +54,23 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
     public int newTotalExp = 0;
     public boolean keepLevel = false;
     public double maxHealthCache;
+    public int lastPing = -1; // Spigot
     // CraftBukkit end
+    // Spigot start
+    public boolean collidesWithEntities = true;
+
+    @Override
+    public boolean L()
+    {
+        return this.collidesWithEntities && super.L();
+    }
+
+    @Override
+    public boolean M()
+    {
+        return this.collidesWithEntities && super.M();
+    }
+    // Spigot end
 
     public EntityPlayer(MinecraftServer minecraftserver, World world, String s, PlayerInteractManager playerinteractmanager) {
         super(world, s);
@@ -443,7 +459,7 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
         EnumBedResult enumbedresult = super.a(i, j, k);
 
         if (enumbedresult == EnumBedResult.OK) {
-            Packet17EntityLocationAction packet17entitylocationaction = new Packet17EntityLocationAction(this, 0, i, j, k);
+            Packet17EntityLocationAction packet17entitylocationaction = new Packet17EntityLocationAction(this, i, j, k);
 
             this.p().getTracker().a((Entity) this, (Packet) packet17entitylocationaction);
             this.playerConnection.a(this.locX, this.locY, this.locZ, this.yaw, this.pitch);
@@ -457,7 +473,7 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
         if (this.fauxSleeping && !this.sleeping) return; // CraftBukkit - Can't leave bed if not in one!
 
         if (this.isSleeping()) {
-            this.p().getTracker().sendPacketToEntity(this, new Packet18ArmAnimation(this, 3));
+            this.p().getTracker().sendPacketToEntity(this, new Packet18ArmAnimation(this, 2));
         }
 
         super.a(flag, flag1, flag2);
@@ -777,7 +793,7 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
     public void a(ItemStack itemstack, int i) {
         super.a(itemstack, i);
         if (itemstack != null && itemstack.getItem() != null && itemstack.getItem().c_(itemstack) == EnumAnimation.EAT) {
-            this.p().getTracker().sendPacketToEntity(this, new Packet18ArmAnimation(this, 5));
+            this.p().getTracker().sendPacketToEntity(this, new Packet18ArmAnimation(this, 3));
         }
     }
 
@@ -809,11 +825,11 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
     }
 
     public void b(Entity entity) {
-        this.p().getTracker().sendPacketToEntity(this, new Packet18ArmAnimation(entity, 6));
+        this.p().getTracker().sendPacketToEntity(this, new Packet18ArmAnimation(entity, 4));
     }
 
     public void c(Entity entity) {
-        this.p().getTracker().sendPacketToEntity(this, new Packet18ArmAnimation(entity, 7));
+        this.p().getTracker().sendPacketToEntity(this, new Packet18ArmAnimation(entity, 5));
     }
 
     public void updateAbilities() {
@@ -942,7 +958,7 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
         this.expTotal = this.newTotalExp;
         this.exp = 0;
         this.deathTicks = 0;
-        this.aJ(); // Should be removeAllEffects.
+        this.aK(); // Should be removeAllEffects.
         this.updateEffects = true;
         this.activeContainer = this.defaultContainer;
         this.killer = null;
diff --git a/src/main/java/net/minecraft/server/EntityTracker.java b/src/main/java/net/minecraft/server/EntityTracker.java
index 1d9203b..e833454 100644
--- a/src/main/java/net/minecraft/server/EntityTracker.java
+++ b/src/main/java/net/minecraft/server/EntityTracker.java
@@ -87,6 +87,8 @@ public class EntityTracker {
     }
 
     public void addEntity(Entity entity, int i, int j, boolean flag) {
+        if (Thread.currentThread() != MinecraftServer.getServer().primaryThread) throw new IllegalStateException("Asynchronous entity track!"); // Spigot
+        i = org.spigotmc.TrackingRange.getEntityTrackingRange(entity, i); // Spigot
         if (i > this.d) {
             i = this.d;
         }
@@ -122,6 +124,7 @@ public class EntityTracker {
     }
 
     public void untrackEntity(Entity entity) {
+        if (Thread.currentThread() != MinecraftServer.getServer().primaryThread) throw new IllegalStateException("Asynchronous entity untrack!"); // Spigot
         if (entity instanceof EntityPlayer) {
             EntityPlayer entityplayer = (EntityPlayer) entity;
             Iterator iterator = this.b.iterator();
diff --git a/src/main/java/net/minecraft/server/EntityTrackerEntry.java b/src/main/java/net/minecraft/server/EntityTrackerEntry.java
index baa5b55..2182ff8 100644
--- a/src/main/java/net/minecraft/server/EntityTrackerEntry.java
+++ b/src/main/java/net/minecraft/server/EntityTrackerEntry.java
@@ -297,6 +297,7 @@ public class EntityTrackerEntry {
     }
 
     public void updatePlayer(EntityPlayer entityplayer) {
+        if (Thread.currentThread() != MinecraftServer.getServer().primaryThread) throw new IllegalStateException("Asynchronous player tracker update!"); // Spigot
         if (entityplayer != this.tracker) {
             double d0 = entityplayer.locX - (double) (this.xLoc / 32);
             double d1 = entityplayer.locZ - (double) (this.zLoc / 32);
@@ -371,7 +372,7 @@ public class EntityTrackerEntry {
                         EntityHuman entityhuman = (EntityHuman) this.tracker;
 
                         if (entityhuman.isSleeping()) {
-                            entityplayer.playerConnection.sendPacket(new Packet17EntityLocationAction(this.tracker, 0, MathHelper.floor(this.tracker.locX), MathHelper.floor(this.tracker.locY), MathHelper.floor(this.tracker.locZ)));
+                            entityplayer.playerConnection.sendPacket(new Packet17EntityLocationAction(this.tracker, MathHelper.floor(this.tracker.locX), MathHelper.floor(this.tracker.locY), MathHelper.floor(this.tracker.locZ)));
                         }
                     }
 
@@ -513,6 +514,7 @@ public class EntityTrackerEntry {
     }
 
     public void clear(EntityPlayer entityplayer) {
+        if (Thread.currentThread() != MinecraftServer.getServer().primaryThread) throw new IllegalStateException("Asynchronous player tracker clear!"); // Spigot
         if (this.trackedPlayers.contains(entityplayer)) {
             this.trackedPlayers.remove(entityplayer);
             entityplayer.removeQueue.add(Integer.valueOf(this.tracker.id));
diff --git a/src/main/java/net/minecraft/server/Explosion.java b/src/main/java/net/minecraft/server/Explosion.java
index 758d447..1d1c88c 100644
--- a/src/main/java/net/minecraft/server/Explosion.java
+++ b/src/main/java/net/minecraft/server/Explosion.java
@@ -240,6 +240,7 @@ public class Explosion {
                 j = chunkposition.y;
                 k = chunkposition.z;
                 l = this.world.getTypeId(i, j, k);
+                world.spigotConfig.antiXrayInstance.updateNearbyBlocks(world, i, j, k); // Spigot
                 if (flag) {
                     double d0 = (double) ((float) i + this.world.random.nextFloat());
                     double d1 = (double) ((float) j + this.world.random.nextFloat());
diff --git a/src/main/java/net/minecraft/server/INetworkManager.java b/src/main/java/net/minecraft/server/INetworkManager.java
new file mode 100644
index 0000000..6fcc5d7
--- /dev/null
+++ b/src/main/java/net/minecraft/server/INetworkManager.java
@@ -0,0 +1,26 @@
+package net.minecraft.server;
+
+import java.net.SocketAddress;
+
+public interface INetworkManager {
+
+    void a(Connection connection);
+
+    void queue(Packet packet);
+
+    void a();
+
+    void b();
+
+    SocketAddress getSocketAddress();
+
+    void d();
+
+    int e();
+
+    void a(String s, Object... aobject);
+    
+    java.net.Socket getSocket(); // Spigot
+    
+    void setSocketAddress(java.net.SocketAddress address); // Spigot
+}
diff --git a/src/main/java/net/minecraft/server/IRecipe.java b/src/main/java/net/minecraft/server/IRecipe.java
index bb28c12..c0836e4 100644
--- a/src/main/java/net/minecraft/server/IRecipe.java
+++ b/src/main/java/net/minecraft/server/IRecipe.java
@@ -11,4 +11,6 @@ public interface IRecipe {
     ItemStack b();
 
     org.bukkit.inventory.Recipe toBukkitRecipe(); // CraftBukkit
+
+    java.util.List<ItemStack> getIngredients(); // Spigot
 }
diff --git a/src/main/java/net/minecraft/server/ItemStack.java b/src/main/java/net/minecraft/server/ItemStack.java
index 808860e..3bbe9f6 100644
--- a/src/main/java/net/minecraft/server/ItemStack.java
+++ b/src/main/java/net/minecraft/server/ItemStack.java
@@ -3,6 +3,8 @@ package net.minecraft.server;
 import com.google.common.collect.HashMultimap;
 import com.google.common.collect.Multimap;
 import java.text.DecimalFormat;
+import java.util.Arrays;
+import java.util.Collection;
 import java.util.Random;
 
 public final class ItemStack {
@@ -39,9 +41,16 @@ public final class ItemStack {
         this(item.id, i, j);
     }
 
+    private final Collection<Integer> blackListedItems = Arrays.asList( 26, 34, 36, 55, 59, 63, 64, 68, 71, 74, 75, 83, 92, 93, 94, 104, 105, 115, 117, 118, 124, 132, 140, 144, 149, 150 );
     public ItemStack(int i, int j, int k) {
         this.id = i;
         this.count = j;
+
+        if ( (Block.byId[i] == null && Item.byId[i] == null) || blackListedItems.contains( i) )
+        {
+            this.id = 1;
+            return;
+        }
         // CraftBukkit start - Pass to setData to do filtering
         this.setData(k);
         //this.damage = k;
@@ -178,7 +187,13 @@ public final class ItemStack {
         return Item.byId[this.id].getMaxDurability();
     }
 
+    // Spigot start
     public boolean isDamaged(int i, Random random) {
+        return isDamaged(i, random, null);
+    }
+
+    public boolean isDamaged(int i, Random random, EntityLiving entityliving) {
+        // Spigot end
         if (!this.g()) {
             return false;
         } else {
@@ -193,7 +208,16 @@ public final class ItemStack {
                 }
 
                 i -= k;
-                if (i <= 0) {
+                // Spigot start
+                if (entityliving instanceof EntityPlayer) {
+                    org.bukkit.craftbukkit.inventory.CraftItemStack item = org.bukkit.craftbukkit.inventory.CraftItemStack.asCraftMirror(this);
+                    org.bukkit.event.player.PlayerItemDamageEvent event = new org.bukkit.event.player.PlayerItemDamageEvent((org.bukkit.entity.Player) entityliving.getBukkitEntity(), item, i);
+                    org.bukkit.Bukkit.getServer().getPluginManager().callEvent(event);
+                    if (event.isCancelled()) return false;
+                    i = event.getDamage();
+                }
+                // Spigot end
+                if (i <= 0 ) {
                     return false;
                 }
             }
@@ -206,7 +230,7 @@ public final class ItemStack {
     public void damage(int i, EntityLiving entityliving) {
         if (!(entityliving instanceof EntityHuman) || !((EntityHuman) entityliving).abilities.canInstantlyBuild) {
             if (this.g()) {
-                if (this.isDamaged(i, entityliving.aD())) {
+                if (this.isDamaged(i, entityliving.aD(), entityliving)) {
                     entityliving.a(this);
                     --this.count;
                     if (entityliving instanceof EntityHuman) {
diff --git a/src/main/java/net/minecraft/server/LocaleLanguage.java b/src/main/java/net/minecraft/server/LocaleLanguage.java
new file mode 100644
index 0000000..aa937fb
--- /dev/null
+++ b/src/main/java/net/minecraft/server/LocaleLanguage.java
@@ -0,0 +1,73 @@
+package net.minecraft.server;
+
+import com.google.common.base.Splitter;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Maps;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.IllegalFormatException;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.regex.Pattern;
+import org.apache.commons.io.Charsets;
+import org.apache.commons.io.IOUtils;
+
+public class LocaleLanguage {
+
+    private static final Pattern a = Pattern.compile("%(\\d+\\$)?[\\d\\.]*[df]");
+    private static final Splitter b = Splitter.on('=').limit(2);
+    private static LocaleLanguage c = new LocaleLanguage();
+    private Map d = Maps.newHashMap();
+
+    public LocaleLanguage() {
+        try {
+            InputStream inputstream = LocaleLanguage.class.getResourceAsStream("/assets/minecraft/lang/en_US.lang");
+            Iterator iterator = IOUtils.readLines(inputstream, Charsets.UTF_8).iterator();
+
+            while (iterator.hasNext()) {
+                String s = (String) iterator.next();
+
+                if (!s.isEmpty() && s.charAt(0) != 35) {
+                    String[] astring = (String[]) Iterables.toArray(b.split(s), String.class);
+
+                    if (astring != null && astring.length == 2) {
+                        String s1 = astring[0];
+                        String s2 = a.matcher(astring[1]).replaceAll("%$1s");
+
+                        this.d.put(s1, s2);
+                    }
+                }
+            }
+        } catch (IOException ioexception) {
+            ;
+        }
+    }
+
+    static LocaleLanguage a() {
+        return c;
+    }
+
+    public synchronized String a(String s) {
+        return this.c(s);
+    }
+
+    public synchronized String a(String s, Object... aobject) {
+        String s1 = this.c(s);
+
+        try {
+            return String.format(s1, aobject);
+        } catch (IllegalFormatException illegalformatexception) {
+            return "Format error: " + s1;
+        }
+    }
+
+    private String c(String s) {
+        String s1 = (String) this.d.get(s);
+
+        return s1 == null ? s : s1;
+    }
+
+    public synchronized boolean b(String s) {
+        return this.d.containsKey(s);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index 029131d..0ba3468 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -1,5 +1,7 @@
 package net.minecraft.server;
 
+import com.google.common.io.BaseEncoding;
+import com.google.common.io.Files;
 import java.awt.GraphicsEnvironment;
 import java.io.File;
 import java.net.Proxy;
@@ -7,7 +9,6 @@ import java.security.KeyPair;
 import java.text.SimpleDateFormat;
 import java.util.ArrayList;
 import java.util.Date;
-import java.util.Iterator;
 import java.util.List;
 import java.util.concurrent.Callable;
 import java.util.logging.Level;
@@ -20,6 +21,7 @@ import jline.console.ConsoleReader;
 import joptsimple.OptionSet;
 
 import org.bukkit.World.Environment;
+import org.bukkit.craftbukkit.SpigotTimings; // Spigot
 import org.bukkit.craftbukkit.util.Waitable;
 import org.bukkit.event.server.RemoteServerCommandEvent;
 import org.bukkit.event.world.WorldSaveEvent;
@@ -87,8 +89,22 @@ public abstract class MinecraftServer implements ICommandListener, Runnable, IMo
     public java.util.Queue<Runnable> processQueue = new java.util.concurrent.ConcurrentLinkedQueue<Runnable>();
     public int autosavePeriod;
     // CraftBukkit end
-
+    // Spigot start
+    private static final int TPS = 20;
+    private static final int TICK_TIME = 1000000000 / TPS;
+    public static double currentTPS = 0;
+    private static long catchupTime = 0;
+    // Spigot end
+public String favicon;
     public MinecraftServer(OptionSet options) { // CraftBukkit - signature file -> OptionSet
+        try{
+            File fav = new File( "server-icon.png" );
+        if ( fav.exists() )
+        {
+
+            favicon = "data:image/png;base64," + BaseEncoding.base64().encode( Files.toByteArray( fav ) );
+        }} catch (IOException ex){}
+        
         this.c = Proxy.NO_PROXY;
         this.E = 0;
         this.f = new long[100];
@@ -391,39 +407,27 @@ public abstract class MinecraftServer implements ICommandListener, Runnable, IMo
     public void run() {
         try {
             if (this.init()) {
-                long i = aq();
-
-                for (long j = 0L; this.isRunning; this.R = true) {
-                    long k = aq();
-                    long l = k - i;
-
-                    if (l > 2000L && i - this.S >= 15000L) {
-                        if (this.server.getWarnOnOverload()) // CraftBukkit - Added option to suppress warning messages
-                        this.getLogger().warning("Can\'t keep up! Did the system time change, or is the server overloaded?");
-                        l = 2000L;
-                        this.S = i;
-                    }
-
-                    if (l < 0L) {
-                        this.getLogger().warning("Time ran backwards! Did the system time change?");
-                        l = 0L;
-                    }
-
-                    j += l;
-                    i = k;
-                    if (this.worlds.get(0).everyoneDeeplySleeping()) { // CraftBukkit
-                        this.s();
-                        j = 0L;
+                // Spigot start
+                for (long lastTick = 0L; this.isRunning; this.R = true) {
+                    long curTime = System.nanoTime();
+                    long wait = TICK_TIME - (curTime - lastTick) - catchupTime;
+                    if (wait > 0) {
+                        Thread.sleep(wait / 1000000);
+                        catchupTime = 0;
+                        continue;
                     } else {
-                        while (j > 50L) {
-                            MinecraftServer.currentTick = (int) (System.currentTimeMillis() / 50); // CraftBukkit
-                            j -= 50L;
-                            this.s();
-                        }
+                        catchupTime = Math.min(TICK_TIME * TPS, Math.abs(wait));
                     }
-
-                    Thread.sleep(1L);
+                    currentTPS = (currentTPS * 0.95) + (1E9 / (curTime - lastTick) * 0.05);
+                    lastTick = curTime;
+                    MinecraftServer.currentTick++;
+                    SpigotTimings.serverTickTimer.startTiming();
+                    this.s();
+                    SpigotTimings.serverTickTimer.stopTiming();
+                    org.spigotmc.CustomTimingsHandler.tick();
+                    org.spigotmc.WatchdogThread.tick();
                 }
+                // Spigot end
             } else {
                 this.a((CrashReport) null);
             }
@@ -449,6 +453,7 @@ public abstract class MinecraftServer implements ICommandListener, Runnable, IMo
             this.a(crashreport);
         } finally {
             try {
+                org.spigotmc.WatchdogThread.doStop();
                 this.stop();
                 this.isStopped = true;
             } catch (Throwable throwable1) {
@@ -505,11 +510,11 @@ public abstract class MinecraftServer implements ICommandListener, Runnable, IMo
         this.I = Packet.p;
         this.methodProfiler.b();
         this.methodProfiler.a("snooper");
-        if (!this.n.d() && this.ticks > 100) {
+        if (getSnooperEnabled() && !this.n.d() && this.ticks > 100) { // Spigot
             this.n.a();
         }
 
-        if (this.ticks % 6000 == 0) {
+        if (getSnooperEnabled() && this.ticks % 6000 == 0) { // Spigot
             this.n.b();
         }
 
@@ -520,6 +525,7 @@ public abstract class MinecraftServer implements ICommandListener, Runnable, IMo
     public void t() {
         this.methodProfiler.a("levels");
 
+        SpigotTimings.schedulerTimer.startTiming(); // Spigot
         // CraftBukkit start
         this.server.getScheduler().mainThreadHeartbeat(this.ticks);
 
@@ -528,7 +534,10 @@ public abstract class MinecraftServer implements ICommandListener, Runnable, IMo
             processQueue.remove().run();
         }
 
+        SpigotTimings.schedulerTimer.stopTiming(); // Spigot
+        SpigotTimings.chunkIOTickTimer.startTiming(); // Spigot
         org.bukkit.craftbukkit.chunkio.ChunkIOExecutor.tick();
+        SpigotTimings.chunkIOTickTimer.stopTiming(); // Spigot
 
         // Send time updates to everyone, it will get the right time from the world the player is in.
         if (this.ticks % 20 == 0) {
@@ -580,7 +589,9 @@ public abstract class MinecraftServer implements ICommandListener, Runnable, IMo
 
                 this.methodProfiler.b();
                 this.methodProfiler.a("tracker");
+                worldserver.timings.tracker.startTiming(); // Spigot
                 worldserver.getTracker().updatePlayers();
+                worldserver.timings.tracker.stopTiming(); // Spigot
                 this.methodProfiler.b();
                 this.methodProfiler.b();
             // } // CraftBukkit
@@ -589,14 +600,20 @@ public abstract class MinecraftServer implements ICommandListener, Runnable, IMo
         }
 
         this.methodProfiler.c("connection");
+        SpigotTimings.connectionTimer.startTiming(); // Spigot
         this.ag().b();
+        SpigotTimings.connectionTimer.stopTiming(); // Spigot
         this.methodProfiler.c("players");
+        SpigotTimings.playerListTimer.startTiming(); // Spigot
         this.t.tick();
+        SpigotTimings.playerListTimer.stopTiming(); // Spigot
         this.methodProfiler.c("tickables");
 
+        SpigotTimings.tickablesTimer.startTiming(); // Spigot
         for (i = 0; i < this.p.size(); ++i) {
             ((IUpdatePlayerListBox) this.p.get(i)).a();
         }
+        SpigotTimings.tickablesTimer.stopTiming(); // Spigot
 
         this.methodProfiler.b();
     }
@@ -757,7 +774,7 @@ public abstract class MinecraftServer implements ICommandListener, Runnable, IMo
     }
 
     public String getVersion() {
-        return "1.6.4";
+        return "1.7.2";
     }
 
     public int A() {
@@ -912,7 +929,7 @@ public abstract class MinecraftServer implements ICommandListener, Runnable, IMo
     }
 
     public void sendMessage(ChatMessage chatmessage) {
-        this.getLogger().info(chatmessage.toString());
+        this.console.sendMessage(chatmessage.toString()); // Spigot - we want coloured and pretty messages too!
     }
 
     public boolean a(int i, String s) {
diff --git a/src/main/java/net/minecraft/server/MobSpawnerAbstract.java b/src/main/java/net/minecraft/server/MobSpawnerAbstract.java
index 108b375..4edd5e3 100644
--- a/src/main/java/net/minecraft/server/MobSpawnerAbstract.java
+++ b/src/main/java/net/minecraft/server/MobSpawnerAbstract.java
@@ -5,7 +5,11 @@ import java.util.Collection;
 import java.util.Iterator;
 import java.util.List;
 
-import org.bukkit.event.entity.CreatureSpawnEvent; // CraftBukkit
+// CraftBukkit start
+import org.bukkit.craftbukkit.event.CraftEventFactory;
+import org.bukkit.event.entity.CreatureSpawnEvent;
+import org.bukkit.event.entity.SpawnerSpawnEvent;
+// CraftBukkit end
 
 public abstract class MobSpawnerAbstract {
 
@@ -127,7 +131,12 @@ public abstract class MobSpawnerAbstract {
 
             entity.f(nbttagcompound);
             if (entity.world != null) {
-                entity.world.addEntity(entity, CreatureSpawnEvent.SpawnReason.SPAWNER); // CraftBukkit
+                // CraftBukkit start - call SpawnerSpawnEvent, abort if cancelled
+                SpawnerSpawnEvent event = CraftEventFactory.callSpawnerSpawnEvent(entity, this.b(), this.c(), this.d());
+                if (!event.isCancelled()) {
+                    entity.world.addEntity(entity, CreatureSpawnEvent.SpawnReason.SPAWNER); // CraftBukkit
+                }
+                // CraftBukkit end
             }
 
             NBTTagCompound nbttagcompound1;
@@ -150,6 +159,11 @@ public abstract class MobSpawnerAbstract {
 
                     entity2.f(nbttagcompound2);
                     entity2.setPositionRotation(entity1.locX, entity1.locY, entity1.locZ, entity1.yaw, entity1.pitch);
+                    // CraftBukkit start - call SpawnerSpawnEvent, skip if cancelled
+                    SpawnerSpawnEvent event = CraftEventFactory.callSpawnerSpawnEvent(entity2, this.b(), this.c(), this.d());
+                    if (event.isCancelled()) {
+                        continue;
+                    }
                     if (entity.world != null) {
                         entity.world.addEntity(entity2, CreatureSpawnEvent.SpawnReason.SPAWNER); // CraftBukkit
                     }
@@ -161,7 +175,12 @@ public abstract class MobSpawnerAbstract {
             }
         } else if (entity instanceof EntityLiving && entity.world != null) {
             ((EntityInsentient) entity).a((GroupDataEntity) null);
-            this.a().addEntity(entity, CreatureSpawnEvent.SpawnReason.SPAWNER); // CraftBukkit
+            // CraftBukkit start - call SpawnerSpawnEvent, abort if cancelled
+            SpawnerSpawnEvent event = CraftEventFactory.callSpawnerSpawnEvent(entity, this.b(), this.c(), this.d());
+            if (!event.isCancelled()) {
+                this.a().addEntity(entity, CreatureSpawnEvent.SpawnReason.SPAWNER); // CraftBukkit
+            }
+            // CraftBukkit end
         }
 
         return entity;
diff --git a/src/main/java/net/minecraft/server/NetworkManager.java b/src/main/java/net/minecraft/server/NetworkManager.java
index a2bdfa3..fd6acab 100644
--- a/src/main/java/net/minecraft/server/NetworkManager.java
+++ b/src/main/java/net/minecraft/server/NetworkManager.java
@@ -27,7 +27,7 @@ public class NetworkManager implements INetworkManager {
     private final Object h = new Object();
     private final IConsoleLogManager i;
     public Socket socket; // CraftBukkit - private -> public
-    private final SocketAddress k;
+    private SocketAddress k; // Spigot - remove final
     private volatile DataInputStream input;
     private volatile DataOutputStream output;
     private volatile boolean n = true;
@@ -374,4 +374,6 @@ public class NetworkManager implements INetworkManager {
     static Thread h(NetworkManager networkmanager) {
         return networkmanager.u;
     }
+
+    public void setSocketAddress(SocketAddress address) { k = address; } // Spigot
 }
diff --git a/src/main/java/net/minecraft/server/NextTickListEntry.java b/src/main/java/net/minecraft/server/NextTickListEntry.java
new file mode 100644
index 0000000..1e3e0f8
--- /dev/null
+++ b/src/main/java/net/minecraft/server/NextTickListEntry.java
@@ -0,0 +1,56 @@
+package net.minecraft.server;
+
+public class NextTickListEntry implements Comparable {
+
+    private static long g;
+    public int a;
+    public int b;
+    public int c;
+    public int d;
+    public long e;
+    public int f;
+    private long h;
+
+    public NextTickListEntry(int i, int j, int k, int l) {
+        this.h = (long) (g++);
+        this.a = i;
+        this.b = j;
+        this.c = k;
+        this.d = l;
+    }
+
+    public boolean equals(Object object) {
+        if (!(object instanceof NextTickListEntry)) {
+            return false;
+        } else {
+            NextTickListEntry nextticklistentry = (NextTickListEntry) object;
+
+            return this.a == nextticklistentry.a && this.b == nextticklistentry.b && this.c == nextticklistentry.c && Block.b(this.d, nextticklistentry.d);
+        }
+    }
+
+    public int hashCode() {
+        return (this.a * 257) ^ this.b ^ (this.c * 60217); // Spigot - better hash
+    }
+
+    public NextTickListEntry a(long i) {
+        this.e = i;
+        return this;
+    }
+
+    public void a(int i) {
+        this.f = i;
+    }
+
+    public int compareTo(NextTickListEntry nextticklistentry) {
+        return this.e < nextticklistentry.e ? -1 : (this.e > nextticklistentry.e ? 1 : (this.f != nextticklistentry.f ? this.f - nextticklistentry.f : (this.h < nextticklistentry.h ? -1 : (this.h > nextticklistentry.h ? 1 : 0))));
+    }
+
+    public String toString() {
+        return this.d + ": (" + this.a + ", " + this.b + ", " + this.c + "), " + this.e + ", " + this.f + ", " + this.h;
+    }
+
+    public int compareTo(Object object) {
+        return this.compareTo((NextTickListEntry) object);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/NibbleArray.java b/src/main/java/net/minecraft/server/NibbleArray.java
new file mode 100644
index 0000000..c9bc20c
--- /dev/null
+++ b/src/main/java/net/minecraft/server/NibbleArray.java
@@ -0,0 +1,158 @@
+package net.minecraft.server;
+
+import java.util.Arrays; // Spigot
+
+public class NibbleArray {
+
+    private byte[] a; // Spigot - remove final, make private (anyone directly accessing this is broken already)
+    private final int b;
+    private final int c;
+    // Spigot start
+    private byte trivialValue;
+    private byte trivialByte;
+    private int length;
+    private static final int LEN2K = 2048; // Universal length used right now - optimize around this
+    private static final byte[][] TrivLen2k;
+
+    static {
+        TrivLen2k = new byte[16][];
+        for (int i = 0; i < 16; i++) {
+            TrivLen2k[i] = new byte[LEN2K];
+            Arrays.fill(TrivLen2k[i], (byte) (i | (i << 4)));
+        }
+    }
+
+    // Try to convert array to trivial array
+    public void detectAndProcessTrivialArray() {
+        trivialValue = (byte) (a[0] & 0xF);
+        trivialByte = (byte) (trivialValue | (trivialValue << 4));
+        for (int i = 0; i < a.length; i++) {
+            if (a[i] != trivialByte) return;
+        }
+        // All values matches, so array is trivial
+        this.length = a.length;
+        this.a = null;
+    }
+
+    // Force array to non-trivial state
+    public void forceToNonTrivialArray() {
+        if (this.a == null) {
+            this.a = new byte[this.length];
+            if (this.trivialByte != 0) {
+                Arrays.fill(this.a, this.trivialByte);
+            }
+        }
+    }
+
+    // Test if array is in trivial state
+    public boolean isTrivialArray() {
+        return (this.a == null);
+    }
+
+    // Get value of all elements (only valid if array is in trivial state)
+    public int getTrivialArrayValue() {
+        return this.trivialValue;
+    }
+
+    // Get logical length of byte array for nibble data (whether trivial or non-trivial)
+    public int getByteLength() {
+        if (this.a == null) {
+            return this.length;
+        } else {
+            return this.a.length;
+        }
+    }
+
+    // Return byte encoding of array (whether trivial or non-trivial) - returns read-only array if trivial (do not modify!)
+    public byte[] getValueArray() {
+        if (this.a != null) {
+            return this.a;
+        } else {
+            byte[] rslt;
+
+            if (this.length == LEN2K) {  // All current uses are 2k long, but be safe
+                rslt = TrivLen2k[this.trivialValue];
+            } else {
+                rslt = new byte[this.length];
+                if (this.trivialByte != 0) {
+                    Arrays.fill(rslt, this.trivialByte);
+                }
+            }
+            return rslt;
+        }
+    }
+
+    // Copy byte representation of array to given offset in given byte array
+    public int copyToByteArray(byte[] dest, int off) {
+        if (this.a == null) {
+            Arrays.fill(dest, off, off + this.length, this.trivialByte);
+            return off + this.length;
+        } else {
+            System.arraycopy(this.a, 0, dest, off, this.a.length);
+            return off + this.a.length;
+        }
+    }
+
+    // Resize array to given byte length
+    public void resizeArray(int len) {
+        if (this.a == null) {
+            this.length = len;
+        } else if (this.a.length != len) {
+            byte[] newa = new byte[len];
+            System.arraycopy(this.a, 0, newa, 0, ((this.a.length > len) ? len : this.a.length));
+            this.a = newa;
+        }
+    }
+    // Spigot end
+
+    public NibbleArray(int i, int j) {
+        // Spigot start
+        //this.a = new byte[i >> 1];
+        this.a = null; // Start off as trivial value (all same zero value)
+        this.length = i >> 1;
+        this.trivialByte = this.trivialValue = 0;
+        // Spigot end
+        this.b = j;
+        this.c = j + 4;
+    }
+
+    public NibbleArray(byte[] abyte, int i) {
+        this.a = abyte;
+        this.b = i;
+        this.c = i + 4;
+        detectAndProcessTrivialArray(); // Spigot
+    }
+
+    public int a(int i, int j, int k) {
+        if (this.a == null) return this.trivialValue; // Spigot
+        int l = j << this.c | k << this.b | i;
+        int i1 = l >> 1;
+        int j1 = l & 1;
+
+        return j1 == 0 ? this.a[i1] & 15 : this.a[i1] >> 4 & 15;
+    }
+
+    public void a(int i, int j, int k, int l) {
+        // Spigot start
+        if (this.a == null) {
+            if (l != this.trivialValue) { // Not same as trivial value, array no longer trivial
+                this.a = new byte[this.length];
+                if (this.trivialByte != 0) {
+                    Arrays.fill(this.a, this.trivialByte);
+                }
+            } else {
+                return;
+            }
+        }
+        // Spigot end
+        int i1 = j << this.c | k << this.b | i;
+        int j1 = i1 >> 1;
+        int k1 = i1 & 1;
+
+        if (k1 == 0) {
+            this.a[j1] = (byte) (this.a[j1] & 240 | l & 15);
+        } else {
+            this.a[j1] = (byte) (this.a[j1] & 15 | (l & 15) << 4);
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/OldChunkLoader.java b/src/main/java/net/minecraft/server/OldChunkLoader.java
new file mode 100644
index 0000000..9a9e20f
--- /dev/null
+++ b/src/main/java/net/minecraft/server/OldChunkLoader.java
@@ -0,0 +1,122 @@
+package net.minecraft.server;
+
+public class OldChunkLoader {
+
+    public static OldChunk a(NBTTagCompound nbttagcompound) {
+        int i = nbttagcompound.getInt("xPos");
+        int j = nbttagcompound.getInt("zPos");
+        OldChunk oldchunk = new OldChunk(i, j);
+
+        oldchunk.g = nbttagcompound.getByteArray("Blocks");
+        oldchunk.f = new OldNibbleArray(nbttagcompound.getByteArray("Data"), 7);
+        oldchunk.e = new OldNibbleArray(nbttagcompound.getByteArray("SkyLight"), 7);
+        oldchunk.d = new OldNibbleArray(nbttagcompound.getByteArray("BlockLight"), 7);
+        oldchunk.c = nbttagcompound.getByteArray("HeightMap");
+        oldchunk.b = nbttagcompound.getBoolean("TerrainPopulated");
+        oldchunk.h = nbttagcompound.getList("Entities");
+        oldchunk.i = nbttagcompound.getList("TileEntities");
+        oldchunk.j = nbttagcompound.getList("TileTicks");
+
+        try {
+            oldchunk.a = nbttagcompound.getLong("LastUpdate");
+        } catch (ClassCastException classcastexception) {
+            oldchunk.a = (long) nbttagcompound.getInt("LastUpdate");
+        }
+
+        return oldchunk;
+    }
+
+    public static void a(OldChunk oldchunk, NBTTagCompound nbttagcompound, WorldChunkManager worldchunkmanager) {
+        nbttagcompound.setInt("xPos", oldchunk.k);
+        nbttagcompound.setInt("zPos", oldchunk.l);
+        nbttagcompound.setLong("LastUpdate", oldchunk.a);
+        int[] aint = new int[oldchunk.c.length];
+
+        for (int i = 0; i < oldchunk.c.length; ++i) {
+            aint[i] = oldchunk.c[i];
+        }
+
+        nbttagcompound.setIntArray("HeightMap", aint);
+        nbttagcompound.setBoolean("TerrainPopulated", oldchunk.b);
+        NBTTagList nbttaglist = new NBTTagList("Sections");
+
+        int j;
+
+        for (int k = 0; k < 8; ++k) {
+            boolean flag = true;
+
+            for (j = 0; j < 16 && flag; ++j) {
+                int l = 0;
+
+                while (l < 16 && flag) {
+                    int i1 = 0;
+
+                    while (true) {
+                        if (i1 < 16) {
+                            int j1 = j << 11 | i1 << 7 | l + (k << 4);
+                            byte b0 = oldchunk.g[j1];
+
+                            if (b0 == 0) {
+                                ++i1;
+                                continue;
+                            }
+
+                            flag = false;
+                        }
+
+                        ++l;
+                        break;
+                    }
+                }
+            }
+
+            if (!flag) {
+                byte[] abyte = new byte[4096];
+                NibbleArray nibblearray = new NibbleArray(abyte.length, 4);
+                NibbleArray nibblearray1 = new NibbleArray(abyte.length, 4);
+                NibbleArray nibblearray2 = new NibbleArray(abyte.length, 4);
+
+                for (int k1 = 0; k1 < 16; ++k1) {
+                    for (int l1 = 0; l1 < 16; ++l1) {
+                        for (int i2 = 0; i2 < 16; ++i2) {
+                            int j2 = k1 << 11 | i2 << 7 | l1 + (k << 4);
+                            byte b1 = oldchunk.g[j2];
+
+                            abyte[l1 << 8 | i2 << 4 | k1] = (byte) (b1 & 255);
+                            nibblearray.a(k1, l1, i2, oldchunk.f.a(k1, l1 + (k << 4), i2));
+                            nibblearray1.a(k1, l1, i2, oldchunk.e.a(k1, l1 + (k << 4), i2));
+                            nibblearray2.a(k1, l1, i2, oldchunk.d.a(k1, l1 + (k << 4), i2));
+                        }
+                    }
+                }
+
+                NBTTagCompound nbttagcompound1 = new NBTTagCompound();
+
+                nbttagcompound1.setByte("Y", (byte) (k & 255));
+                nbttagcompound1.setByteArray("Blocks", abyte);
+                // Spigot start - a -> getValueArray() accessor
+                nbttagcompound1.setByteArray("Data", nibblearray.getValueArray());
+                nbttagcompound1.setByteArray("SkyLight", nibblearray1.getValueArray());
+                nbttagcompound1.setByteArray("BlockLight", nibblearray2.getValueArray());
+                // Spigot end
+                nbttaglist.add(nbttagcompound1);
+            }
+        }
+
+        nbttagcompound.set("Sections", nbttaglist);
+        byte[] abyte1 = new byte[256];
+
+        for (int k2 = 0; k2 < 16; ++k2) {
+            for (j = 0; j < 16; ++j) {
+                abyte1[j << 4 | k2] = (byte) (worldchunkmanager.getBiome(oldchunk.k << 4 | k2, oldchunk.l << 4 | j).id & 255);
+            }
+        }
+
+        nbttagcompound.setByteArray("Biomes", abyte1);
+        nbttagcompound.set("Entities", oldchunk.h);
+        nbttagcompound.set("TileEntities", oldchunk.i);
+        if (oldchunk.j != null) {
+            nbttagcompound.set("TileTicks", oldchunk.j);
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Packet.java b/src/main/java/net/minecraft/server/Packet.java
index e7e1d73..d8b9944 100644
--- a/src/main/java/net/minecraft/server/Packet.java
+++ b/src/main/java/net/minecraft/server/Packet.java
@@ -1,5 +1,7 @@
 package net.minecraft.server;
 
+import com.google.common.base.Charsets;
+import io.netty.buffer.ByteBuf;
 import java.io.DataInput;
 import java.io.DataOutput;
 import java.io.EOFException;
@@ -29,7 +31,7 @@ public abstract class Packet {
     private int packetID;
 
     public Packet() {
-        packetID = ((Integer) a.get(this.getClass())).intValue();
+//        packetID = ((Integer) a.get(this.getClass())).intValue();
     }
     // CraftBukkit end
 
@@ -68,6 +70,101 @@ public abstract class Packet {
         dataoutput.write(abyte);
     }
 
+
+    public static int readVarInt(ByteBuf input)
+    {
+        int out = 0;
+        int bytes = 0;
+        byte in;
+        while ( true )
+        {
+            in = input.readByte();
+
+            out |= ( in & 0x7F ) << ( bytes++ * 7 );
+
+            if ( bytes > 32 )
+            {
+                throw new RuntimeException( "VarInt too big" );
+            }
+
+            if ( ( in & 0x80 ) != 0x80 )
+            {
+                break;
+            }
+        }
+
+        return out;
+    }
+
+    public static void writeVarInt(int value, ByteBuf output)
+    {
+        int part;
+        while ( true )
+        {
+            part = value & 0x7F;
+
+            value >>>= 7;
+            if ( value != 0 )
+            {
+                part |= 0x80;
+            }
+
+            output.writeByte( part );
+
+            if ( value == 0 )
+            {
+                break;
+            }
+        }
+    }
+    
+    public static int readVarInt(DataInput input) throws IOException
+    {
+        int out = 0;
+        int bytes = 0;
+        byte in;
+        while ( true )
+        {
+            in = input.readByte();
+
+            out |= ( in & 0x7F ) << ( bytes++ * 7 );
+
+            if ( bytes > 32 )
+            {
+                throw new RuntimeException( "VarInt too big" );
+            }
+
+            if ( ( in & 0x80 ) != 0x80 )
+            {
+                break;
+            }
+        }
+
+        return out;
+    }
+
+    public static void writeVarInt(int value, DataOutput output) throws IOException
+    {
+        int part;
+        while ( true )
+        {
+            part = value & 0x7F;
+
+            value >>>= 7;
+            if ( value != 0 )
+            {
+                part |= 0x80;
+            }
+
+            output.write(part );
+
+            if ( value == 0 )
+            {
+                break;
+            }
+        }
+    }
+
     public static byte[] b(DataInput datainput) throws IOException { // CraftBukkit - throws IOException
         short short1 = datainput.readShort();
 
@@ -141,30 +238,17 @@ public abstract class Packet {
     }
 
     public static void a(String s, DataOutput dataoutput) throws IOException { // CraftBukkit - throws IOException
-        if (s.length() > 32767) {
-            throw new IOException("String too big");
-        } else {
-            dataoutput.writeShort(s.length());
-            dataoutput.writeChars(s);
-        }
+        byte[] b = s.getBytes( Charsets.UTF_8 );
+        writeVarInt( b.length, dataoutput );
+        dataoutput.write( b );
     }
 
     public static String a(DataInput datainput, int i) throws IOException { // CraftBukkit - throws IOException
-        short short1 = datainput.readShort();
+        int len = readVarInt( datainput);
+        byte[] b = new byte[ len ];
+        datainput.readFully( b );
 
-        if (short1 > i) {
-            throw new IOException("Received string length longer than maximum allowed (" + short1 + " > " + i + ")");
-        } else if (short1 < 0) {
-            throw new IOException("Received string length is less than zero! Weird string!");
-        } else {
-            StringBuilder stringbuilder = new StringBuilder();
-
-            for (int j = 0; j < short1; ++j) {
-                stringbuilder.append(datainput.readChar());
-            }
-
-            return stringbuilder.toString();
-        }
+        return new String( b, Charsets.UTF_8 );
     }
 
     public abstract void a(DataInput datainput) throws IOException; // CraftBukkit - throws IOException
diff --git a/src/main/java/net/minecraft/server/Packet0KeepAlive.java b/src/main/java/net/minecraft/server/Packet0KeepAlive.java
new file mode 100644
index 0000000..98c784a
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Packet0KeepAlive.java
@@ -0,0 +1,44 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+public class Packet0KeepAlive extends Packet {
+
+    public int a;
+
+    public Packet0KeepAlive() {}
+
+    public Packet0KeepAlive(int i) {
+        this.a = i;
+    }
+
+    public void handle(Connection connection) {
+        connection.a(this);
+    }
+
+    public void a(DataInput datainput) throws IOException {
+        this.a = datainput.readInt();
+    }
+
+    public void a(DataOutput dataoutput) throws IOException {
+        dataoutput.writeInt(this.a);
+    }
+
+    public int a() {
+        return 4;
+    }
+
+    public boolean e() {
+        return true;
+    }
+
+    public boolean a(Packet packet) {
+        return true;
+    }
+
+    public boolean a_() {
+        return true;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Packet100OpenWindow.java b/src/main/java/net/minecraft/server/Packet100OpenWindow.java
new file mode 100644
index 0000000..771476a
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Packet100OpenWindow.java
@@ -0,0 +1,60 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+public class Packet100OpenWindow extends Packet {
+
+    public int a;
+    public int b;
+    public String c;
+    public int d;
+    public boolean e;
+    public int f;
+
+    public Packet100OpenWindow() {}
+
+    public Packet100OpenWindow(int i, int j, String s, int k, boolean flag) {
+        this.a = i;
+        this.b = j;
+        this.c = s;
+        this.d = k;
+        this.e = flag;
+    }
+
+    public Packet100OpenWindow(int i, int j, String s, int k, boolean flag, int l) {
+        this(i, j, s, k, flag);
+        this.f = l;
+    }
+
+    public void handle(Connection connection) {
+        connection.a(this);
+    }
+
+    public void a(DataInput datainput) throws IOException {
+        this.a = datainput.readByte() & 255;
+        this.b = datainput.readByte() & 255;
+        this.c = a(datainput, 32);
+        this.d = datainput.readByte() & 255;
+        this.e = datainput.readBoolean();
+        if (this.b == 11) {
+            this.f = datainput.readInt();
+        }
+    }
+
+    public void a(DataOutput dataoutput) throws IOException {
+        dataoutput.writeByte(this.a & 255);
+        dataoutput.writeByte(this.b & 255);
+        a(this.c, dataoutput);
+        dataoutput.writeByte(this.d & 255);
+        dataoutput.writeBoolean(this.e);
+        if (this.b == 11) {
+            dataoutput.writeInt(this.f);
+        }
+    }
+
+    public int a() {
+        return this.b == 11 ? 8 + this.c.length() : 4 + this.c.length();
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Packet101CloseWindow.java b/src/main/java/net/minecraft/server/Packet101CloseWindow.java
new file mode 100644
index 0000000..0314b33
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Packet101CloseWindow.java
@@ -0,0 +1,32 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+public class Packet101CloseWindow extends Packet {
+
+    public int a;
+
+    public Packet101CloseWindow() {}
+
+    public Packet101CloseWindow(int i) {
+        this.a = i;
+    }
+
+    public void handle(Connection connection) {
+        connection.handleContainerClose(this);
+    }
+
+    public void a(DataInput datainput) throws IOException {
+        this.a = datainput.readByte();
+    }
+
+    public void a(DataOutput dataoutput) throws IOException {
+        dataoutput.writeByte(this.a);
+    }
+
+    public int a() {
+        return 1;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Packet102WindowClick.java b/src/main/java/net/minecraft/server/Packet102WindowClick.java
new file mode 100644
index 0000000..a92e289
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Packet102WindowClick.java
@@ -0,0 +1,43 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+public class Packet102WindowClick extends Packet {
+
+    public int a;
+    public int slot;
+    public int button;
+    public short d;
+    public ItemStack item;
+    public int shift;
+
+    public Packet102WindowClick() {}
+
+    public void handle(Connection connection) {
+        connection.a(this);
+    }
+
+    public void a(DataInput datainput) throws IOException {
+        this.a = datainput.readByte();
+        this.slot = datainput.readShort();
+        this.button = datainput.readByte();
+        this.d = datainput.readShort();
+        this.shift = datainput.readByte();
+        this.item = c(datainput);
+    }
+
+    public void a(DataOutput dataoutput) throws IOException {
+        dataoutput.writeByte(this.a);
+        dataoutput.writeShort(this.slot);
+        dataoutput.writeByte(this.button);
+        dataoutput.writeShort(this.d);
+        dataoutput.writeByte(this.shift);
+        a(this.item, dataoutput);
+    }
+
+    public int a() {
+        return 11;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Packet103SetSlot.java b/src/main/java/net/minecraft/server/Packet103SetSlot.java
new file mode 100644
index 0000000..7f38d62
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Packet103SetSlot.java
@@ -0,0 +1,40 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+public class Packet103SetSlot extends Packet {
+
+    public int a;
+    public int b;
+    public ItemStack c;
+
+    public Packet103SetSlot() {}
+
+    public Packet103SetSlot(int i, int j, ItemStack itemstack) {
+        this.a = i;
+        this.b = j;
+        this.c = itemstack == null ? itemstack : itemstack.cloneItemStack();
+    }
+
+    public void handle(Connection connection) {
+        connection.a(this);
+    }
+
+    public void a(DataInput datainput) throws IOException {
+        this.a = datainput.readByte();
+        this.b = datainput.readShort();
+        this.c = c(datainput);
+    }
+
+    public void a(DataOutput dataoutput) throws IOException {
+        dataoutput.writeByte(this.a);
+        dataoutput.writeShort(this.b);
+        a(this.c, dataoutput);
+    }
+
+    public int a() {
+        return 8;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Packet104WindowItems.java b/src/main/java/net/minecraft/server/Packet104WindowItems.java
new file mode 100644
index 0000000..064539b
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Packet104WindowItems.java
@@ -0,0 +1,53 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+import java.util.List;
+
+public class Packet104WindowItems extends Packet {
+
+    public int a;
+    public ItemStack[] b;
+
+    public Packet104WindowItems() {}
+
+    public Packet104WindowItems(int i, List list) {
+        this.a = i;
+        this.b = new ItemStack[list.size()];
+
+        for (int j = 0; j < this.b.length; ++j) {
+            ItemStack itemstack = (ItemStack) list.get(j);
+
+            this.b[j] = itemstack == null ? null : itemstack.cloneItemStack();
+        }
+    }
+
+    public void a(DataInput datainput) throws IOException {
+        this.a = datainput.readByte();
+        short short1 = datainput.readShort();
+
+        this.b = new ItemStack[short1];
+
+        for (int i = 0; i < short1; ++i) {
+            this.b[i] = c(datainput);
+        }
+    }
+
+    public void a(DataOutput dataoutput) throws IOException {
+        dataoutput.writeByte(this.a);
+        dataoutput.writeShort(this.b.length);
+
+        for (int i = 0; i < this.b.length; ++i) {
+            a(this.b[i], dataoutput);
+        }
+    }
+
+    public void handle(Connection connection) {
+        connection.a(this);
+    }
+
+    public int a() {
+        return 3 + this.b.length * 5;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Packet105CraftProgressBar.java b/src/main/java/net/minecraft/server/Packet105CraftProgressBar.java
new file mode 100644
index 0000000..c58a93f
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Packet105CraftProgressBar.java
@@ -0,0 +1,40 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+public class Packet105CraftProgressBar extends Packet {
+
+    public int a;
+    public int b;
+    public int c;
+
+    public Packet105CraftProgressBar() {}
+
+    public Packet105CraftProgressBar(int i, int j, int k) {
+        this.a = i;
+        this.b = j;
+        this.c = k;
+    }
+
+    public void handle(Connection connection) {
+        connection.a(this);
+    }
+
+    public void a(DataInput datainput) throws IOException {
+        this.a = datainput.readByte();
+        this.b = datainput.readShort();
+        this.c = datainput.readShort();
+    }
+
+    public void a(DataOutput dataoutput) throws IOException {
+        dataoutput.writeByte(this.a);
+        dataoutput.writeShort(this.b);
+        dataoutput.writeShort(this.c);
+    }
+
+    public int a() {
+        return 5;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Packet106Transaction.java b/src/main/java/net/minecraft/server/Packet106Transaction.java
new file mode 100644
index 0000000..4267df1
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Packet106Transaction.java
@@ -0,0 +1,40 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+public class Packet106Transaction extends Packet {
+
+    public int a;
+    public short b;
+    public boolean c;
+
+    public Packet106Transaction() {}
+
+    public Packet106Transaction(int i, short short1, boolean flag) {
+        this.a = i;
+        this.b = short1;
+        this.c = flag;
+    }
+
+    public void handle(Connection connection) {
+        connection.a(this);
+    }
+
+    public void a(DataInput datainput) throws IOException {
+        this.a = datainput.readByte();
+        this.b = datainput.readShort();
+        this.c = datainput.readByte() != 0;
+    }
+
+    public void a(DataOutput dataoutput) throws IOException {
+        dataoutput.writeByte(this.a);
+        dataoutput.writeShort(this.b);
+        dataoutput.writeByte(this.c ? 1 : 0);
+    }
+
+    public int a() {
+        return 4;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Packet107SetCreativeSlot.java b/src/main/java/net/minecraft/server/Packet107SetCreativeSlot.java
new file mode 100644
index 0000000..f626e66
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Packet107SetCreativeSlot.java
@@ -0,0 +1,31 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+public class Packet107SetCreativeSlot extends Packet {
+
+    public int slot;
+    public ItemStack b;
+
+    public Packet107SetCreativeSlot() {}
+
+    public void handle(Connection connection) {
+        connection.a(this);
+    }
+
+    public void a(DataInput datainput) throws IOException {
+        this.slot = datainput.readShort();
+        this.b = c(datainput);
+    }
+
+    public void a(DataOutput dataoutput) throws IOException {
+        dataoutput.writeShort(this.slot);
+        a(this.b, dataoutput);
+    }
+
+    public int a() {
+        return 8;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Packet108ButtonClick.java b/src/main/java/net/minecraft/server/Packet108ButtonClick.java
new file mode 100644
index 0000000..7cd9c27
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Packet108ButtonClick.java
@@ -0,0 +1,31 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+public class Packet108ButtonClick extends Packet {
+
+    public int a;
+    public int b;
+
+    public Packet108ButtonClick() {}
+
+    public void handle(Connection connection) {
+        connection.a(this);
+    }
+
+    public void a(DataInput datainput) throws IOException {
+        this.a = datainput.readByte();
+        this.b = datainput.readByte();
+    }
+
+    public void a(DataOutput dataoutput) throws IOException {
+        dataoutput.writeByte(this.a);
+        dataoutput.writeByte(this.b);
+    }
+
+    public int a() {
+        return 2;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Packet10Flying.java b/src/main/java/net/minecraft/server/Packet10Flying.java
new file mode 100644
index 0000000..60889b5
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Packet10Flying.java
@@ -0,0 +1,44 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+public class Packet10Flying extends Packet {
+
+    public double x;
+    public double y;
+    public double z;
+    public double stance;
+    public float yaw;
+    public float pitch;
+    public boolean g;
+    public boolean hasPos;
+    public boolean hasLook;
+
+    public Packet10Flying() {}
+
+    public void handle(Connection connection) {
+        connection.a(this);
+    }
+
+    public void a(DataInput datainput) throws IOException {
+        this.g = datainput.readUnsignedByte() != 0;
+    }
+
+    public void a(DataOutput dataoutput) throws IOException {
+        dataoutput.write(this.g ? 1 : 0);
+    }
+
+    public int a() {
+        return 1;
+    }
+
+    public boolean e() {
+        return true;
+    }
+
+    public boolean a(Packet packet) {
+        return true;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Packet11PlayerPosition.java b/src/main/java/net/minecraft/server/Packet11PlayerPosition.java
new file mode 100644
index 0000000..b052fee
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Packet11PlayerPosition.java
@@ -0,0 +1,32 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+public class Packet11PlayerPosition extends Packet10Flying {
+
+    public Packet11PlayerPosition() {
+        this.hasPos = true;
+    }
+
+    public void a(DataInput datainput) throws IOException {
+        this.x = datainput.readDouble();
+        this.y = datainput.readDouble();
+        this.stance = datainput.readDouble();
+        this.z = datainput.readDouble();
+        super.a(datainput);
+    }
+
+    public void a(DataOutput dataoutput) throws IOException {
+        dataoutput.writeDouble(this.x);
+        dataoutput.writeDouble(this.y);
+        dataoutput.writeDouble(this.stance);
+        dataoutput.writeDouble(this.z);
+        super.a(dataoutput);
+    }
+
+    public int a() {
+        return 33;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Packet12PlayerLook.java b/src/main/java/net/minecraft/server/Packet12PlayerLook.java
new file mode 100644
index 0000000..12db7b3
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Packet12PlayerLook.java
@@ -0,0 +1,28 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+public class Packet12PlayerLook extends Packet10Flying {
+
+    public Packet12PlayerLook() {
+        this.hasLook = true;
+    }
+
+    public void a(DataInput datainput) throws IOException {
+        this.yaw = datainput.readFloat();
+        this.pitch = datainput.readFloat();
+        super.a(datainput);
+    }
+
+    public void a(DataOutput dataoutput) throws IOException {
+        dataoutput.writeFloat(this.yaw);
+        dataoutput.writeFloat(this.pitch);
+        super.a(dataoutput);
+    }
+
+    public int a() {
+        return 9;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Packet130UpdateSign.java b/src/main/java/net/minecraft/server/Packet130UpdateSign.java
new file mode 100644
index 0000000..a1a3e5f
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Packet130UpdateSign.java
@@ -0,0 +1,60 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+public class Packet130UpdateSign extends Packet {
+
+    public int x;
+    public int y;
+    public int z;
+    public String[] lines;
+
+    public Packet130UpdateSign() {
+        this.lowPriority = true;
+    }
+
+    public Packet130UpdateSign(int i, int j, int k, String[] astring) {
+        this.lowPriority = true;
+        this.x = i;
+        this.y = j;
+        this.z = k;
+        this.lines = new String[] { astring[0], astring[1], astring[2], astring[3]};
+    }
+
+    public void a(DataInput datainput) throws IOException {
+        this.x = datainput.readInt();
+        this.y = datainput.readShort();
+        this.z = datainput.readInt();
+        this.lines = new String[4];
+
+        for (int i = 0; i < 4; ++i) {
+            this.lines[i] = a(datainput, 15);
+        }
+    }
+
+    public void a(DataOutput dataoutput) throws IOException {
+        dataoutput.writeInt(this.x);
+        dataoutput.writeShort(this.y);
+        dataoutput.writeInt(this.z);
+
+        for (int i = 0; i < 4; ++i) {
+            a(this.lines[i], dataoutput);
+        }
+    }
+
+    public void handle(Connection connection) {
+        connection.a(this);
+    }
+
+    public int a() {
+        int i = 0;
+
+        for (int j = 0; j < 4; ++j) {
+            i += this.lines[j].length();
+        }
+
+        return i;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Packet131ItemData.java b/src/main/java/net/minecraft/server/Packet131ItemData.java
new file mode 100644
index 0000000..d5828af
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Packet131ItemData.java
@@ -0,0 +1,41 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+public class Packet131ItemData extends Packet {
+
+    public short a;
+    public short b;
+    public byte[] c;
+
+    public Packet131ItemData() {
+        this.lowPriority = true;
+    }
+
+    public Packet131ItemData(short short1, short short2, byte[] abyte) {
+        this.lowPriority = true;
+        this.a = short1;
+        this.b = short2;
+        this.c = abyte;
+    }
+
+    public void a(DataInput datainput) {
+        throw new UnsupportedOperationException();
+    }
+
+    public void a(DataOutput dataoutput) throws IOException {
+        writeVarInt(this.b, dataoutput);
+        dataoutput.writeShort(this.c.length);
+        dataoutput.write(this.c);
+    }
+
+    public void handle(Connection connection) {
+        connection.a(this);
+    }
+
+    public int a() {
+        return 4 + this.c.length;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Packet132TileEntityData.java b/src/main/java/net/minecraft/server/Packet132TileEntityData.java
new file mode 100644
index 0000000..b55e1c4
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Packet132TileEntityData.java
@@ -0,0 +1,51 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+public class Packet132TileEntityData extends Packet {
+
+    public int a;
+    public int b;
+    public int c;
+    public int d;
+    public NBTTagCompound e;
+
+    public Packet132TileEntityData() {
+        this.lowPriority = true;
+    }
+
+    public Packet132TileEntityData(int i, int j, int k, int l, NBTTagCompound nbttagcompound) {
+        this.lowPriority = true;
+        this.a = i;
+        this.b = j;
+        this.c = k;
+        this.d = l;
+        this.e = nbttagcompound;
+    }
+
+    public void a(DataInput datainput) throws IOException {
+        this.a = datainput.readInt();
+        this.b = datainput.readShort();
+        this.c = datainput.readInt();
+        this.d = datainput.readByte();
+        this.e = d(datainput);
+    }
+
+    public void a(DataOutput dataoutput) throws IOException {
+        dataoutput.writeInt(this.a);
+        dataoutput.writeShort(this.b);
+        dataoutput.writeInt(this.c);
+        dataoutput.writeByte((byte) this.d);
+        a(this.e, dataoutput);
+    }
+
+    public void handle(Connection connection) {
+        connection.a(this);
+    }
+
+    public int a() {
+        return 25;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Packet133OpenTileEntity.java b/src/main/java/net/minecraft/server/Packet133OpenTileEntity.java
new file mode 100644
index 0000000..44b6fb8
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Packet133OpenTileEntity.java
@@ -0,0 +1,42 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+public class Packet133OpenTileEntity extends Packet {
+
+    public int a;
+    public int b;
+    public int c;
+    public int d;
+
+    public Packet133OpenTileEntity() {}
+
+    public Packet133OpenTileEntity(int i, int j, int k, int l) {
+        this.a = i;
+        this.b = j;
+        this.c = k;
+        this.d = l;
+    }
+
+    public void handle(Connection connection) {
+        connection.a(this);
+    }
+
+    public void a(DataInput datainput) throws IOException {
+        this.b = datainput.readInt();
+        this.c = datainput.readInt();
+        this.d = datainput.readInt();
+    }
+
+    public void a(DataOutput dataoutput) throws IOException {
+        dataoutput.writeInt(this.b);
+        dataoutput.writeInt(this.c);
+        dataoutput.writeInt(this.d);
+    }
+
+    public int a() {
+        return 13;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Packet13PlayerLookMove.java b/src/main/java/net/minecraft/server/Packet13PlayerLookMove.java
new file mode 100644
index 0000000..75c61cb
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Packet13PlayerLookMove.java
@@ -0,0 +1,48 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+public class Packet13PlayerLookMove extends Packet10Flying {
+
+    public Packet13PlayerLookMove() {
+        this.hasLook = true;
+        this.hasPos = true;
+    }
+
+    public Packet13PlayerLookMove(double d0, double d1, double d2, double d3, float f, float f1, boolean flag) {
+        this.x = d0;
+        this.y = d1;
+        this.stance = d2;
+        this.z = d3;
+        this.yaw = f;
+        this.pitch = f1;
+        this.g = flag;
+        this.hasLook = true;
+        this.hasPos = true;
+    }
+
+    public void a(DataInput datainput) throws IOException {
+        this.x = datainput.readDouble();
+        this.y = datainput.readDouble();
+        this.stance = datainput.readDouble();
+        this.z = datainput.readDouble();
+        this.yaw = datainput.readFloat();
+        this.pitch = datainput.readFloat();
+        super.a(datainput);
+    }
+
+    public void a(DataOutput dataoutput) throws IOException {
+        dataoutput.writeDouble(this.x);
+        dataoutput.writeDouble(this.y);
+        dataoutput.writeDouble(this.z);
+        dataoutput.writeFloat(this.yaw);
+        dataoutput.writeFloat(this.pitch);
+        super.a(dataoutput);
+    }
+
+    public int a() {
+        return 41;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Packet14BlockDig.java b/src/main/java/net/minecraft/server/Packet14BlockDig.java
new file mode 100644
index 0000000..7ce0229
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Packet14BlockDig.java
@@ -0,0 +1,40 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+public class Packet14BlockDig extends Packet {
+
+    public int a;
+    public int b;
+    public int c;
+    public int face;
+    public int e;
+
+    public Packet14BlockDig() {}
+
+    public void a(DataInput datainput) throws IOException {
+        this.e = datainput.readUnsignedByte();
+        this.a = datainput.readInt();
+        this.b = datainput.readUnsignedByte();
+        this.c = datainput.readInt();
+        this.face = datainput.readUnsignedByte();
+    }
+
+    public void a(DataOutput dataoutput) throws IOException {
+        dataoutput.write(this.e);
+        dataoutput.writeInt(this.a);
+        dataoutput.write(this.b);
+        dataoutput.writeInt(this.c);
+        dataoutput.write(this.face);
+    }
+
+    public void handle(Connection connection) {
+        connection.a(this);
+    }
+
+    public int a() {
+        return 11;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Packet15Place.java b/src/main/java/net/minecraft/server/Packet15Place.java
new file mode 100644
index 0000000..ac2343c
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Packet15Place.java
@@ -0,0 +1,81 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+public class Packet15Place extends Packet {
+
+    private int a;
+    private int b;
+    private int c;
+    private int d;
+    private ItemStack e;
+    private float f;
+    private float g;
+    private float h;
+
+    public Packet15Place() {}
+
+    public void a(DataInput datainput) throws IOException {
+        this.a = datainput.readInt();
+        this.b = datainput.readUnsignedByte();
+        this.c = datainput.readInt();
+        this.d = datainput.readUnsignedByte();
+        this.e = c(datainput);
+        this.f = (float) datainput.readUnsignedByte() / 16.0F;
+        this.g = (float) datainput.readUnsignedByte() / 16.0F;
+        this.h = (float) datainput.readUnsignedByte() / 16.0F;
+    }
+
+    public void a(DataOutput dataoutput) throws IOException {
+        dataoutput.writeInt(this.a);
+        dataoutput.write(this.b);
+        dataoutput.writeInt(this.c);
+        dataoutput.write(this.d);
+        a(this.e, dataoutput);
+        dataoutput.write((int) (this.f * 16.0F));
+        dataoutput.write((int) (this.g * 16.0F));
+        dataoutput.write((int) (this.h * 16.0F));
+    }
+
+    public void handle(Connection connection) {
+        connection.a(this);
+    }
+
+    public int a() {
+        return 19;
+    }
+
+    public int d() {
+        return this.a;
+    }
+
+    public int f() {
+        return this.b;
+    }
+
+    public int g() {
+        return this.c;
+    }
+
+    public int getFace() {
+        return this.d;
+    }
+
+    public ItemStack getItemStack() {
+        return this.e;
+    }
+
+    public float j() {
+        return this.f;
+    }
+
+    public float k() {
+        return this.g;
+    }
+
+    public float l() {
+        return this.h;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Packet16BlockItemSwitch.java b/src/main/java/net/minecraft/server/Packet16BlockItemSwitch.java
new file mode 100644
index 0000000..7ddab90
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Packet16BlockItemSwitch.java
@@ -0,0 +1,40 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+public class Packet16BlockItemSwitch extends Packet {
+
+    public int itemInHandIndex;
+
+    public Packet16BlockItemSwitch() {}
+
+    public Packet16BlockItemSwitch(int i) {
+        this.itemInHandIndex = i;
+    }
+
+    public void a(DataInput datainput) throws IOException {
+        this.itemInHandIndex = datainput.readShort();
+    }
+
+    public void a(DataOutput dataoutput) throws IOException {
+        dataoutput.writeByte(this.itemInHandIndex);
+    }
+
+    public void handle(Connection connection) {
+        connection.a(this);
+    }
+
+    public int a() {
+        return 2;
+    }
+
+    public boolean e() {
+        return true;
+    }
+
+    public boolean a(Packet packet) {
+        return true;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Packet17EntityLocationAction.java b/src/main/java/net/minecraft/server/Packet17EntityLocationAction.java
new file mode 100644
index 0000000..6d97567
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Packet17EntityLocationAction.java
@@ -0,0 +1,44 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+public class Packet17EntityLocationAction extends Packet {
+
+    public int a;
+    public int b;
+    public int c;
+    public int d;
+
+    public Packet17EntityLocationAction() {}
+
+    public Packet17EntityLocationAction(Entity entity, int j, int k, int l) {
+        this.b = j;
+        this.c = k;
+        this.d = l;
+        this.a = entity.id;
+    }
+
+    public void a(DataInput datainput) throws IOException {
+        this.a = datainput.readInt();
+        this.b = datainput.readInt();
+        this.c = datainput.readByte();
+        this.d = datainput.readInt();
+    }
+
+    public void a(DataOutput dataoutput) throws IOException {
+        dataoutput.writeInt(this.a);
+        dataoutput.writeInt(this.b);
+        dataoutput.writeByte(this.c);
+        dataoutput.writeInt(this.d);
+    }
+
+    public void handle(Connection connection) {
+        connection.a(this);
+    }
+
+    public int a() {
+        return 14;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Packet18ArmAnimation.java b/src/main/java/net/minecraft/server/Packet18ArmAnimation.java
new file mode 100644
index 0000000..0a1c7f4
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Packet18ArmAnimation.java
@@ -0,0 +1,36 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+public class Packet18ArmAnimation extends Packet {
+
+    public int a;
+    public int b;
+
+    public Packet18ArmAnimation() {}
+
+    public Packet18ArmAnimation(Entity entity, int i) {
+        this.a = entity.id;
+        this.b = i;
+    }
+
+    public void a(DataInput datainput) throws IOException {
+        this.a = datainput.readInt();
+        this.b = datainput.readByte();
+    }
+
+    public void a(DataOutput dataoutput) throws IOException {
+        writeVarInt( this.a, dataoutput );
+        dataoutput.writeByte(this.b);
+    }
+
+    public void handle(Connection connection) {
+        connection.a(this);
+    }
+
+    public int a() {
+        return 5;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Packet19EntityAction.java b/src/main/java/net/minecraft/server/Packet19EntityAction.java
new file mode 100644
index 0000000..36501ba
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Packet19EntityAction.java
@@ -0,0 +1,34 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+public class Packet19EntityAction extends Packet {
+
+    public int a;
+    public int animation;
+    public int c;
+
+    public Packet19EntityAction() {}
+
+    public void a(DataInput datainput) throws IOException {
+        this.a = datainput.readInt();
+        this.animation = datainput.readByte();
+        this.c = datainput.readInt();
+    }
+
+    public void a(DataOutput dataoutput) throws IOException {
+        dataoutput.writeInt(this.a);
+        dataoutput.writeByte(this.animation);
+        dataoutput.writeInt(this.c);
+    }
+
+    public void handle(Connection connection) {
+        connection.a(this);
+    }
+
+    public int a() {
+        return 9;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Packet1Login.java b/src/main/java/net/minecraft/server/Packet1Login.java
new file mode 100644
index 0000000..b9ffb07
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Packet1Login.java
@@ -0,0 +1,65 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+public class Packet1Login extends Packet {
+
+    public int a;
+    public WorldType b;
+    public boolean c;
+    public EnumGamemode d;
+    public int e;
+    public byte f;
+    public byte h;
+
+    public Packet1Login() {}
+
+    public Packet1Login(int i, WorldType worldtype, EnumGamemode enumgamemode, boolean flag, int j, int k, int i1) {
+        this.a = i;
+        this.b = worldtype;
+        this.e = j;
+        this.f = (byte) k;
+        this.d = enumgamemode;
+        this.h = (byte) i1;
+        this.c = flag;
+    }
+
+    public void a(DataInput datainput) throws IOException
+    {
+        throw new UnsupportedOperationException();
+    }
+
+    public void a(DataOutput dataoutput) throws IOException
+    {
+        dataoutput.writeInt( this.a );
+        int i = this.d.a();
+
+        if ( this.c )
+        {
+            i |= 8;
+        }
+
+        dataoutput.writeByte( i );
+        dataoutput.writeByte( this.e );
+        dataoutput.writeByte( this.f );
+        dataoutput.writeByte( this.h );
+
+        a( this.b == null ? "" : this.b.name(), dataoutput );
+    }
+
+    public void handle(Connection connection) {
+        connection.a(this);
+    }
+
+    public int a() {
+        int i = 0;
+
+        if (this.b != null) {
+            i = this.b.name().length();
+        }
+
+        return 6 + 2 * i + 4 + 4 + 1 + 1 + 1;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Packet200Statistic.java b/src/main/java/net/minecraft/server/Packet200Statistic.java
new file mode 100644
index 0000000..e843b65
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Packet200Statistic.java
@@ -0,0 +1,54 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+public class Packet200Statistic extends Packet {
+
+    public Stat[] stats;
+
+    public Packet200Statistic() {}
+
+    public Packet200Statistic(int i, int j) {
+        stats = new Stat[]{new Stat(( (Statistic) StatisticList.a.get( i ) ).g, j)};
+    }
+
+    public Packet200Statistic(String name, int j) {
+        stats = new Stat[]{new Stat(name, j)};
+    }
+
+    public void handle(Connection connection) {
+        connection.a(this);
+    }
+
+    public void a(DataInput datainput) {
+        throw new UnsupportedOperationException();
+    }
+
+    public void a(DataOutput dataoutput) throws IOException {
+        writeVarInt( stats.length, dataoutput );
+        for (Stat stat : stats) {
+            a( stat.name, dataoutput );
+            writeVarInt( stat.value, dataoutput );
+        }
+    }
+
+    public int a() {
+        return 6;
+    }
+
+    public boolean a_() {
+        return true;
+    }
+
+    class Stat {
+        public String name;
+        public int value;
+
+        public Stat(String name, int value) {
+            this.name = name;
+            this.value = value;
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Packet201PlayerInfo.java b/src/main/java/net/minecraft/server/Packet201PlayerInfo.java
new file mode 100644
index 0000000..5d408e1
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Packet201PlayerInfo.java
@@ -0,0 +1,40 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+public class Packet201PlayerInfo extends Packet {
+
+    public String a;
+    public boolean b;
+    public int c;
+
+    public Packet201PlayerInfo() {}
+
+    public Packet201PlayerInfo(String s, boolean flag, int i) {
+        this.a = s;
+        this.b = flag;
+        this.c = i;
+    }
+
+    public void a(DataInput datainput) throws IOException {
+        this.a = a(datainput, 16);
+        this.b = datainput.readByte() != 0;
+        this.c = datainput.readShort();
+    }
+
+    public void a(DataOutput dataoutput) throws IOException {
+        a(this.a, dataoutput);
+        dataoutput.writeByte(this.b ? 1 : 0);
+        dataoutput.writeShort(this.c);
+    }
+
+    public void handle(Connection connection) {
+        connection.a(this);
+    }
+
+    public int a() {
+        return this.a.length() + 2 + 1 + 2;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Packet202Abilities.java b/src/main/java/net/minecraft/server/Packet202Abilities.java
new file mode 100644
index 0000000..c2dcd6c
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Packet202Abilities.java
@@ -0,0 +1,117 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+public class Packet202Abilities extends Packet {
+
+    private boolean a;
+    private boolean b;
+    private boolean c;
+    private boolean d;
+    private float e;
+    private float f;
+
+    public Packet202Abilities() {}
+
+    public Packet202Abilities(PlayerAbilities playerabilities) {
+        this.a(playerabilities.isInvulnerable);
+        this.b(playerabilities.isFlying);
+        this.c(playerabilities.canFly);
+        this.d(playerabilities.canInstantlyBuild);
+        this.a(playerabilities.a());
+        this.b(playerabilities.b());
+    }
+
+    public void a(DataInput datainput) throws IOException {
+        byte b0 = datainput.readByte();
+
+        this.a((b0 & 1) > 0);
+        this.b((b0 & 2) > 0);
+        this.c((b0 & 4) > 0);
+        this.d((b0 & 8) > 0);
+        this.a(datainput.readFloat());
+        this.b(datainput.readFloat());
+    }
+
+    public void a(DataOutput dataoutput) throws IOException {
+        byte b0 = 0;
+
+        if (this.d()) {
+            b0 = (byte) (b0 | 1);
+        }
+
+        if (this.f()) {
+            b0 = (byte) (b0 | 2);
+        }
+
+        if (this.g()) {
+            b0 = (byte) (b0 | 4);
+        }
+
+        if (this.h()) {
+            b0 = (byte) (b0 | 8);
+        }
+
+        dataoutput.writeByte(b0);
+        dataoutput.writeFloat(this.e);
+        dataoutput.writeFloat(this.f);
+    }
+
+    public void handle(Connection connection) {
+        connection.a(this);
+    }
+
+    public int a() {
+        return 2;
+    }
+
+    public boolean d() {
+        return this.a;
+    }
+
+    public void a(boolean flag) {
+        this.a = flag;
+    }
+
+    public boolean f() {
+        return this.b;
+    }
+
+    public void b(boolean flag) {
+        this.b = flag;
+    }
+
+    public boolean g() {
+        return this.c;
+    }
+
+    public void c(boolean flag) {
+        this.c = flag;
+    }
+
+    public boolean h() {
+        return this.d;
+    }
+
+    public void d(boolean flag) {
+        this.d = flag;
+    }
+
+    public void a(float f) {
+        this.e = f;
+    }
+
+    public void b(float f) {
+        this.f = f;
+    }
+
+    public boolean e() {
+        return true;
+    }
+
+    public boolean a(Packet packet) {
+        return true;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Packet203TabComplete.java b/src/main/java/net/minecraft/server/Packet203TabComplete.java
new file mode 100644
index 0000000..5e066b3
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Packet203TabComplete.java
@@ -0,0 +1,46 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+import org.apache.commons.lang3.StringUtils;
+
+public class Packet203TabComplete extends Packet {
+
+    String[] response;
+    String read;
+
+    public Packet203TabComplete() {}
+
+    public Packet203TabComplete(String[] s) {
+        this.response = s;
+    }
+
+    public void a(DataInput datainput) throws IOException {
+        read = a( datainput, Short.MAX_VALUE );
+    }
+
+    public void a(DataOutput dataoutput) throws IOException {
+        writeVarInt( response.length, dataoutput);
+        for (String s : response){
+            a( s, dataoutput );
+        }
+    }
+
+    public void handle(Connection connection) {
+        connection.a(this);
+    }
+
+    public int a() {
+        return 10;
+    }
+
+    public boolean e() {
+        return true;
+    }
+
+    public boolean a(Packet packet) {
+        return true;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Packet204LocaleAndViewDistance.java b/src/main/java/net/minecraft/server/Packet204LocaleAndViewDistance.java
new file mode 100644
index 0000000..7c11382
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Packet204LocaleAndViewDistance.java
@@ -0,0 +1,78 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+public class Packet204LocaleAndViewDistance extends Packet {
+
+    private String a;
+    private int b;
+    private int c;
+    private boolean d;
+    private int e;
+    private boolean f;
+
+    public Packet204LocaleAndViewDistance() {}
+
+    public void a(DataInput datainput) throws IOException {
+              this.a = a(datainput, 7);
+        this.b = datainput.readByte();
+        byte b0 = datainput.readByte();
+
+        this.c = b0 & 7;
+        this.d = (b0 & 8) == 8;
+        datainput.readBoolean();
+        this.e = datainput.readByte();
+        this.f = datainput.readBoolean();
+    }
+
+    public void a(DataOutput dataoutput) throws IOException {
+        a(this.a, dataoutput);
+        dataoutput.writeByte(this.b);
+        dataoutput.writeByte(this.c | (this.d ? 1 : 0) << 3);
+        dataoutput.writeBoolean( true );
+        dataoutput.writeByte(this.e);
+        dataoutput.writeBoolean(this.f);
+    }
+
+    public void handle(Connection connection) {
+        connection.a(this);
+    }
+
+    public int a() {
+        return 7;
+    }
+
+    public String d() {
+        return this.a;
+    }
+
+    public int f() {
+        return this.b;
+    }
+
+    public int g() {
+        return this.c;
+    }
+
+    public boolean h() {
+        return this.d;
+    }
+
+    public int i() {
+        return this.e;
+    }
+
+    public boolean j() {
+        return this.f;
+    }
+
+    public boolean e() {
+        return true;
+    }
+
+    public boolean a(Packet packet) {
+        return true;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Packet205ClientCommand.java b/src/main/java/net/minecraft/server/Packet205ClientCommand.java
new file mode 100644
index 0000000..eacbbec
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Packet205ClientCommand.java
@@ -0,0 +1,28 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+public class Packet205ClientCommand extends Packet {
+
+    public int a;
+
+    public Packet205ClientCommand() {}
+
+    public void a(DataInput datainput) throws IOException {
+        this.a = datainput.readByte();
+    }
+
+    public void a(DataOutput dataoutput) throws IOException {
+        dataoutput.writeByte(this.a & 255);
+    }
+
+    public void handle(Connection connection) {
+        connection.a(this);
+    }
+
+    public int a() {
+        return 1;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Packet206SetScoreboardObjective.java b/src/main/java/net/minecraft/server/Packet206SetScoreboardObjective.java
new file mode 100644
index 0000000..457eaeb
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Packet206SetScoreboardObjective.java
@@ -0,0 +1,40 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+public class Packet206SetScoreboardObjective extends Packet {
+
+    public String a;
+    public String b;
+    public int c;
+
+    public Packet206SetScoreboardObjective() {}
+
+    public Packet206SetScoreboardObjective(ScoreboardObjective scoreboardobjective, int i) {
+        this.a = scoreboardobjective.getName();
+        this.b = scoreboardobjective.getDisplayName();
+        this.c = i;
+    }
+
+    public void a(DataInput datainput) throws IOException {
+        this.a = a(datainput, 16);
+        this.b = a(datainput, 32);
+        this.c = datainput.readByte();
+    }
+
+    public void a(DataOutput dataoutput) throws IOException {
+        a(this.a, dataoutput);
+        a(this.b, dataoutput);
+        dataoutput.writeByte(this.c);
+    }
+
+    public void handle(Connection connection) {
+        connection.a(this);
+    }
+
+    public int a() {
+        return 2 + this.a.length() + 2 + this.b.length() + 1;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Packet207SetScoreboardScore.java b/src/main/java/net/minecraft/server/Packet207SetScoreboardScore.java
new file mode 100644
index 0000000..3ad3765
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Packet207SetScoreboardScore.java
@@ -0,0 +1,55 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+public class Packet207SetScoreboardScore extends Packet {
+
+    public String a = "";
+    public String b = "";
+    public int c;
+    public int d;
+
+    public Packet207SetScoreboardScore() {}
+
+    public Packet207SetScoreboardScore(ScoreboardScore scoreboardscore, int i) {
+        this.a = scoreboardscore.getPlayerName();
+        this.b = scoreboardscore.getObjective().getName();
+        this.c = scoreboardscore.getScore();
+        this.d = i;
+    }
+
+    public Packet207SetScoreboardScore(String s) {
+        this.a = s;
+        this.b = "";
+        this.c = 0;
+        this.d = 1;
+    }
+
+    public void a(DataInput datainput) throws IOException {
+        this.a = a(datainput, 16);
+        this.d = datainput.readByte();
+        if (this.d != 1) {
+            this.b = a(datainput, 16);
+            this.c = datainput.readInt();
+        }
+    }
+
+    public void a(DataOutput dataoutput) throws IOException {
+        a(this.a, dataoutput);
+        dataoutput.writeByte(this.d);
+        if (this.d != 1) {
+            a(this.b, dataoutput);
+            dataoutput.writeInt(this.c);
+        }
+    }
+
+    public void handle(Connection connection) {
+        connection.a(this);
+    }
+
+    public int a() {
+        return 2 + (this.a == null ? 0 : this.a.length()) + 2 + (this.b == null ? 0 : this.b.length()) + 4 + 1;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Packet208SetScoreboardDisplayObjective.java b/src/main/java/net/minecraft/server/Packet208SetScoreboardDisplayObjective.java
new file mode 100644
index 0000000..1bcd6d2
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Packet208SetScoreboardDisplayObjective.java
@@ -0,0 +1,40 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+public class Packet208SetScoreboardDisplayObjective extends Packet {
+
+    public int a;
+    public String b;
+
+    public Packet208SetScoreboardDisplayObjective() {}
+
+    public Packet208SetScoreboardDisplayObjective(int i, ScoreboardObjective scoreboardobjective) {
+        this.a = i;
+        if (scoreboardobjective == null) {
+            this.b = "";
+        } else {
+            this.b = scoreboardobjective.getName();
+        }
+    }
+
+    public void a(DataInput datainput) throws IOException {
+        this.a = datainput.readByte();
+        this.b = a(datainput, 16);
+    }
+
+    public void a(DataOutput dataoutput) throws IOException {
+        dataoutput.writeByte(this.a);
+        a(this.b, dataoutput);
+    }
+
+    public void handle(Connection connection) {
+        connection.a(this);
+    }
+
+    public int a() {
+        return 3 + this.b.length();
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Packet209SetScoreboardTeam.java b/src/main/java/net/minecraft/server/Packet209SetScoreboardTeam.java
new file mode 100644
index 0000000..5f76f66
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Packet209SetScoreboardTeam.java
@@ -0,0 +1,97 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Iterator;
+
+public class Packet209SetScoreboardTeam extends Packet {
+
+    public String a = "";
+    public String b = "";
+    public String c = "";
+    public String d = "";
+    public Collection e = new ArrayList();
+    public int f;
+    public int g;
+
+    public Packet209SetScoreboardTeam() {}
+
+    public Packet209SetScoreboardTeam(ScoreboardTeam scoreboardteam, int i) {
+        this.a = scoreboardteam.getName();
+        this.f = i;
+        if (i == 0 || i == 2) {
+            this.b = scoreboardteam.getDisplayName();
+            this.c = scoreboardteam.getPrefix();
+            this.d = scoreboardteam.getSuffix();
+            this.g = scoreboardteam.packOptionData();
+        }
+
+        if (i == 0) {
+            this.e.addAll(scoreboardteam.getPlayerNameSet());
+        }
+    }
+
+    public Packet209SetScoreboardTeam(ScoreboardTeam scoreboardteam, Collection collection, int i) {
+        if (i != 3 && i != 4) {
+            throw new IllegalArgumentException("Method must be join or leave for player constructor");
+        } else if (collection != null && !collection.isEmpty()) {
+            this.f = i;
+            this.a = scoreboardteam.getName();
+            this.e.addAll(collection);
+        } else {
+            throw new IllegalArgumentException("Players cannot be null/empty");
+        }
+    }
+
+    public void a(DataInput datainput) throws IOException {
+        this.a = a(datainput, 16);
+        this.f = datainput.readByte();
+        if (this.f == 0 || this.f == 2) {
+            this.b = a(datainput, 32);
+            this.c = a(datainput, 16);
+            this.d = a(datainput, 16);
+            this.g = datainput.readByte();
+        }
+
+        if (this.f == 0 || this.f == 3 || this.f == 4) {
+            short short1 = datainput.readShort();
+
+            for (int i = 0; i < short1; ++i) {
+                this.e.add(a(datainput, 16));
+            }
+        }
+    }
+
+    public void a(DataOutput dataoutput) throws IOException {
+        a(this.a, dataoutput);
+        dataoutput.writeByte(this.f);
+        if (this.f == 0 || this.f == 2) {
+            a(this.b, dataoutput);
+            a(this.c, dataoutput);
+            a(this.d, dataoutput);
+            dataoutput.writeByte(this.g);
+        }
+
+        if (this.f == 0 || this.f == 3 || this.f == 4) {
+            dataoutput.writeShort(this.e.size());
+            Iterator iterator = this.e.iterator();
+
+            while (iterator.hasNext()) {
+                String s = (String) iterator.next();
+
+                a(s, dataoutput);
+            }
+        }
+    }
+
+    public void handle(Connection connection) {
+        connection.a(this);
+    }
+
+    public int a() {
+        return 3 + this.a.length();
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Packet20NamedEntitySpawn.java b/src/main/java/net/minecraft/server/Packet20NamedEntitySpawn.java
index 1843d9c..782d537 100644
--- a/src/main/java/net/minecraft/server/Packet20NamedEntitySpawn.java
+++ b/src/main/java/net/minecraft/server/Packet20NamedEntitySpawn.java
@@ -9,6 +9,7 @@ import java.io.IOException; // CraftBukkit
 public class Packet20NamedEntitySpawn extends Packet {
 
     public int a;
+    public String playerUUID;
     public String b;
     public int c;
     public int d;
@@ -23,6 +24,7 @@ public class Packet20NamedEntitySpawn extends Packet {
 
     public Packet20NamedEntitySpawn(EntityHuman entityhuman) {
         this.a = entityhuman.id;
+        this.playerUUID = entityhuman.playerUUID;
 
         // CraftBukkit start - Limit name length to 16 characters
         if (entityhuman.name.length() > 16) {
@@ -45,19 +47,12 @@ public class Packet20NamedEntitySpawn extends Packet {
     }
 
     public void a(DataInput datainput) throws IOException { // CraftBukkit
-        this.a = datainput.readInt();
-        this.b = a(datainput, 16);
-        this.c = datainput.readInt();
-        this.d = datainput.readInt();
-        this.e = datainput.readInt();
-        this.f = datainput.readByte();
-        this.g = datainput.readByte();
-        this.h = datainput.readShort();
-        this.j = DataWatcher.a(datainput);
+        throw new UnsupportedOperationException();
     }
 
     public void a(DataOutput dataoutput) throws IOException { // CraftBukkit
-        dataoutput.writeInt(this.a);
+        writeVarInt( this.a, dataoutput);
+        a(this.playerUUID, dataoutput);
         a(this.b, dataoutput);
         dataoutput.writeInt(this.c);
         dataoutput.writeInt(this.d);
diff --git a/src/main/java/net/minecraft/server/Packet22Collect.java b/src/main/java/net/minecraft/server/Packet22Collect.java
new file mode 100644
index 0000000..2233be0
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Packet22Collect.java
@@ -0,0 +1,36 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+public class Packet22Collect extends Packet {
+
+    public int a;
+    public int b;
+
+    public Packet22Collect() {}
+
+    public Packet22Collect(int i, int j) {
+        this.a = i;
+        this.b = j;
+    }
+
+    public void a(DataInput datainput) throws IOException {
+        this.a = datainput.readInt();
+        this.b = datainput.readInt();
+    }
+
+    public void a(DataOutput dataoutput) throws IOException {
+        dataoutput.writeInt(this.a);
+        dataoutput.writeInt(this.b);
+    }
+
+    public void handle(Connection connection) {
+        connection.a(this);
+    }
+
+    public int a() {
+        return 8;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Packet23VehicleSpawn.java b/src/main/java/net/minecraft/server/Packet23VehicleSpawn.java
new file mode 100644
index 0000000..86f80f3
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Packet23VehicleSpawn.java
@@ -0,0 +1,99 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+public class Packet23VehicleSpawn extends Packet {
+
+    public int a;
+    public int b;
+    public int c;
+    public int d;
+    public int e;
+    public int f;
+    public int g;
+    public int h;
+    public int i;
+    public int j;
+    public int k;
+
+    public Packet23VehicleSpawn() {}
+
+    public Packet23VehicleSpawn(Entity entity, int i) {
+        this(entity, i, 0);
+    }
+
+    public Packet23VehicleSpawn(Entity entity, int i, int j) {
+        this.a = entity.id;
+        this.b = MathHelper.floor(entity.locX * 32.0D);
+        this.c = MathHelper.floor(entity.locY * 32.0D);
+        this.d = MathHelper.floor(entity.locZ * 32.0D);
+        this.h = MathHelper.d(entity.pitch * 256.0F / 360.0F);
+        this.i = MathHelper.d(entity.yaw * 256.0F / 360.0F);
+        this.j = i;
+        this.k = j;
+        if (j > 0) {
+            double d0 = entity.motX;
+            double d1 = entity.motY;
+            double d2 = entity.motZ;
+            double d3 = 3.9D;
+
+            if (d0 < -d3) {
+                d0 = -d3;
+            }
+
+            if (d1 < -d3) {
+                d1 = -d3;
+            }
+
+            if (d2 < -d3) {
+                d2 = -d3;
+            }
+
+            if (d0 > d3) {
+                d0 = d3;
+            }
+
+            if (d1 > d3) {
+                d1 = d3;
+            }
+
+            if (d2 > d3) {
+                d2 = d3;
+            }
+
+            this.e = (int) (d0 * 8000.0D);
+            this.f = (int) (d1 * 8000.0D);
+            this.g = (int) (d2 * 8000.0D);
+        }
+    }
+
+    public void a(DataInput datainput) {
+        throw new UnsupportedOperationException();
+    }
+
+    public void a(DataOutput dataoutput) throws IOException {
+        writeVarInt( this.a, dataoutput);
+        dataoutput.writeByte(this.j);
+        dataoutput.writeInt(this.b);
+        dataoutput.writeInt(this.c);
+        dataoutput.writeInt(this.d);
+        dataoutput.writeByte(this.h);
+        dataoutput.writeByte(this.i);
+        dataoutput.writeInt(this.k);
+        if (this.k > 0) {
+            dataoutput.writeShort(this.e);
+            dataoutput.writeShort(this.f);
+            dataoutput.writeShort(this.g);
+        }
+    }
+
+    public void handle(Connection connection) {
+        connection.a(this);
+    }
+
+    public int a() {
+        return 21 + this.k > 0 ? 6 : 0;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Packet24MobSpawn.java b/src/main/java/net/minecraft/server/Packet24MobSpawn.java
new file mode 100644
index 0000000..0e69388
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Packet24MobSpawn.java
@@ -0,0 +1,96 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+import java.util.List;
+
+public class Packet24MobSpawn extends Packet {
+
+    public int a;
+    public int b;
+    public int c;
+    public int d;
+    public int e;
+    public int f;
+    public int g;
+    public int h;
+    public byte i;
+    public byte j;
+    public byte k;
+    private DataWatcher t;
+    private List u;
+
+    public Packet24MobSpawn() {}
+
+    public Packet24MobSpawn(EntityLiving entityliving) {
+        this.a = entityliving.id;
+        this.b = (byte) EntityTypes.a(entityliving);
+        this.c = entityliving.at.a(entityliving.locX);
+        this.d = MathHelper.floor(entityliving.locY * 32.0D);
+        this.e = entityliving.at.a(entityliving.locZ);
+        this.i = (byte) ((int) (entityliving.yaw * 256.0F / 360.0F));
+        this.j = (byte) ((int) (entityliving.pitch * 256.0F / 360.0F));
+        this.k = (byte) ((int) (entityliving.aP * 256.0F / 360.0F));
+        double d0 = 3.9D;
+        double d1 = entityliving.motX;
+        double d2 = entityliving.motY;
+        double d3 = entityliving.motZ;
+
+        if (d1 < -d0) {
+            d1 = -d0;
+        }
+
+        if (d2 < -d0) {
+            d2 = -d0;
+        }
+
+        if (d3 < -d0) {
+            d3 = -d0;
+        }
+
+        if (d1 > d0) {
+            d1 = d0;
+        }
+
+        if (d2 > d0) {
+            d2 = d0;
+        }
+
+        if (d3 > d0) {
+            d3 = d0;
+        }
+
+        this.f = (int) (d1 * 8000.0D);
+        this.g = (int) (d2 * 8000.0D);
+        this.h = (int) (d3 * 8000.0D);
+        this.t = entityliving.getDataWatcher();
+    }
+
+    public void a(DataInput datainput) {
+        throw new UnsupportedOperationException();
+    }
+
+    public void a(DataOutput dataoutput) throws IOException {
+        writeVarInt( this.a, dataoutput);
+        dataoutput.writeByte(this.b & 255);
+        dataoutput.writeInt(this.c);
+        dataoutput.writeInt(this.d);
+        dataoutput.writeInt(this.e);
+        dataoutput.writeByte(this.i);
+        dataoutput.writeByte(this.j);
+        dataoutput.writeByte(this.k);
+        dataoutput.writeShort(this.f);
+        dataoutput.writeShort(this.g);
+        dataoutput.writeShort(this.h);
+        this.t.a(dataoutput);
+    }
+
+    public void handle(Connection connection) {
+        connection.a(this);
+    }
+
+    public int a() {
+        return 26;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Packet250CustomPayload.java b/src/main/java/net/minecraft/server/Packet250CustomPayload.java
new file mode 100644
index 0000000..730a18a
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Packet250CustomPayload.java
@@ -0,0 +1,50 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+public class Packet250CustomPayload extends Packet {
+
+    public String tag;
+    public int length;
+    public byte[] data;
+
+    public Packet250CustomPayload() {}
+
+    public Packet250CustomPayload(String s, byte[] abyte) {
+        this.tag = s;
+        this.data = abyte;
+        if (abyte != null) {
+            this.length = abyte.length;
+            if (this.length > 32767) {
+                throw new IllegalArgumentException("Payload may not be larger than 32k");
+            }
+        }
+    }
+
+    public void a(DataInput datainput) throws IOException {
+        this.tag = a(datainput, 20);
+        this.length = datainput.readShort();
+        if (this.length > 0 && this.length < 32767) {
+            this.data = new byte[this.length];
+            datainput.readFully(this.data);
+        }
+    }
+
+    public void a(DataOutput dataoutput) throws IOException {
+        a(this.tag, dataoutput);
+        dataoutput.writeShort((short) this.length);
+        if (this.data != null) {
+            dataoutput.write(this.data);
+        }
+    }
+
+    public void handle(Connection connection) {
+        connection.a(this);
+    }
+
+    public int a() {
+        return 2 + this.tag.length() * 2 + 2 + this.length;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Packet252KeyResponse.java b/src/main/java/net/minecraft/server/Packet252KeyResponse.java
new file mode 100644
index 0000000..a5fc843
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Packet252KeyResponse.java
@@ -0,0 +1,46 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+import java.security.PrivateKey;
+import javax.crypto.SecretKey;
+
+public class Packet252KeyResponse extends Packet {
+
+    private byte[] a = new byte[0];
+    private byte[] b = new byte[0];
+    private SecretKey c;
+
+    public Packet252KeyResponse() {}
+
+    public void a(DataInput datainput) throws IOException {
+        this.a = b(datainput);
+        this.b = b(datainput);
+    }
+
+    public void a(DataOutput dataoutput) throws IOException {
+        a(dataoutput, this.a);
+        a(dataoutput, this.b);
+    }
+
+    public void handle(Connection connection) {
+        connection.a(this);
+    }
+
+    public int a() {
+        return 2 + this.a.length + 2 + this.b.length;
+    }
+
+    public SecretKey a(PrivateKey privatekey) {
+        return privatekey == null ? this.c : (this.c = MinecraftEncryption.a(privatekey, this.a));
+    }
+
+    public SecretKey d() {
+        return this.a((PrivateKey) null);
+    }
+
+    public byte[] b(PrivateKey privatekey) {
+        return privatekey == null ? this.b : MinecraftEncryption.b(privatekey, this.b);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Packet253KeyRequest.java b/src/main/java/net/minecraft/server/Packet253KeyRequest.java
new file mode 100644
index 0000000..4162555
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Packet253KeyRequest.java
@@ -0,0 +1,41 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+import java.security.PublicKey;
+
+public class Packet253KeyRequest extends Packet {
+
+    private String a;
+    private PublicKey b;
+    private byte[] c = new byte[0];
+
+    public Packet253KeyRequest() {}
+
+    public Packet253KeyRequest(String s, PublicKey publickey, byte[] abyte) {
+        this.a = s;
+        this.b = publickey;
+        this.c = abyte;
+    }
+
+    public void a(DataInput datainput) throws IOException {
+        this.a = a(datainput, 20);
+        this.b = MinecraftEncryption.a(b(datainput));
+        this.c = b(datainput);
+    }
+
+    public void a(DataOutput dataoutput) throws IOException {
+        a(this.a, dataoutput);
+        a(dataoutput, this.b.getEncoded());
+        a(dataoutput, this.c);
+    }
+
+    public void handle(Connection connection) {
+        connection.a(this);
+    }
+
+    public int a() {
+        return 2 + this.a.length() * 2 + 2 + this.b.getEncoded().length + 2 + this.c.length;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Packet254GetInfo.java b/src/main/java/net/minecraft/server/Packet254GetInfo.java
new file mode 100644
index 0000000..b034b95
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Packet254GetInfo.java
@@ -0,0 +1,32 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+
+public class Packet254GetInfo extends Packet {
+
+    private static final int d = (new Packet250CustomPayload()).n();
+    public int a;
+    public String b;
+    public int c;
+
+    public Packet254GetInfo() {}
+
+    public void a(DataInput datainput) throws java.io.IOException { // Spigot - throws
+    }
+
+    public void a(DataOutput dataoutput) throws java.io.IOException { // Spigot - throws
+    }
+
+    public void handle(Connection connection) {
+        connection.a(this);
+    }
+
+    public int a() {
+        return 3 + this.b.length() * 2 + 4;
+    }
+
+    public boolean d() {
+        return this.a == 0;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Packet255KickDisconnect.java b/src/main/java/net/minecraft/server/Packet255KickDisconnect.java
new file mode 100644
index 0000000..cba4e8d
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Packet255KickDisconnect.java
@@ -0,0 +1,40 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+public class Packet255KickDisconnect extends Packet {
+
+    public String a;
+
+    public Packet255KickDisconnect() {}
+
+    public Packet255KickDisconnect(String s) {
+        this.a = s;
+    }
+
+    public void a(DataInput datainput) throws IOException {
+        this.a = a(datainput, 256);
+    }
+
+    public void a(DataOutput dataoutput) throws IOException {
+        a(this.a, dataoutput);
+    }
+
+    public void handle(Connection connection) {
+        connection.a(this);
+    }
+
+    public int a() {
+        return this.a.length();
+    }
+
+    public boolean e() {
+        return true;
+    }
+
+    public boolean a(Packet packet) {
+        return true;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Packet25EntityPainting.java b/src/main/java/net/minecraft/server/Packet25EntityPainting.java
new file mode 100644
index 0000000..59f2606
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Packet25EntityPainting.java
@@ -0,0 +1,47 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+public class Packet25EntityPainting extends Packet {
+
+    public int a;
+    public int b;
+    public int c;
+    public int d;
+    public int e;
+    public String f;
+
+    public Packet25EntityPainting() {}
+
+    public Packet25EntityPainting(EntityPainting entitypainting) {
+        this.a = entitypainting.id;
+        this.b = entitypainting.x;
+        this.c = entitypainting.y;
+        this.d = entitypainting.z;
+        this.e = entitypainting.direction;
+        this.f = entitypainting.art.B;
+    }
+
+    public void a(DataInput datainput) {
+        throw new UnsupportedOperationException();
+    }
+
+    public void a(DataOutput dataoutput) throws IOException {
+        writeVarInt( this.a, dataoutput);
+        a(this.f, dataoutput);
+        dataoutput.writeInt(this.b);
+        dataoutput.writeInt(this.c);
+        dataoutput.writeInt(this.d);
+        dataoutput.writeInt(this.e);
+    }
+
+    public void handle(Connection connection) {
+        connection.a(this);
+    }
+
+    public int a() {
+        return 24;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Packet26AddExpOrb.java b/src/main/java/net/minecraft/server/Packet26AddExpOrb.java
new file mode 100644
index 0000000..ed8f0de
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Packet26AddExpOrb.java
@@ -0,0 +1,44 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+public class Packet26AddExpOrb extends Packet {
+
+    public int a;
+    public int b;
+    public int c;
+    public int d;
+    public int e;
+
+    public Packet26AddExpOrb() {}
+
+    public Packet26AddExpOrb(EntityExperienceOrb entityexperienceorb) {
+        this.a = entityexperienceorb.id;
+        this.b = MathHelper.floor(entityexperienceorb.locX * 32.0D);
+        this.c = MathHelper.floor(entityexperienceorb.locY * 32.0D);
+        this.d = MathHelper.floor(entityexperienceorb.locZ * 32.0D);
+        this.e = entityexperienceorb.c();
+    }
+
+    public void a(DataInput datainput) {
+        throw new UnsupportedOperationException();
+    }
+
+    public void a(DataOutput dataoutput) throws IOException {
+        writeVarInt( this.a, dataoutput);
+        dataoutput.writeInt(this.b);
+        dataoutput.writeInt(this.c);
+        dataoutput.writeInt(this.d);
+        dataoutput.writeShort(this.e);
+    }
+
+    public void handle(Connection connection) {
+        connection.a(this);
+    }
+
+    public int a() {
+        return 18;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Packet27PlayerInput.java b/src/main/java/net/minecraft/server/Packet27PlayerInput.java
new file mode 100644
index 0000000..f367961
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Packet27PlayerInput.java
@@ -0,0 +1,53 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+public class Packet27PlayerInput extends Packet {
+
+    private float a;
+    private float b;
+    private boolean c;
+    private boolean d;
+
+    public Packet27PlayerInput() {}
+
+    public void a(DataInput datainput) throws IOException {
+        this.a = datainput.readFloat();
+        this.b = datainput.readFloat();
+        this.c = datainput.readBoolean();
+        this.d = datainput.readBoolean();
+    }
+
+    public void a(DataOutput dataoutput) throws IOException {
+        dataoutput.writeFloat(this.a);
+        dataoutput.writeFloat(this.b);
+        dataoutput.writeBoolean(this.c);
+        dataoutput.writeBoolean(this.d);
+    }
+
+    public void handle(Connection connection) {
+        connection.a(this);
+    }
+
+    public int a() {
+        return 10;
+    }
+
+    public float d() {
+        return this.a;
+    }
+
+    public float f() {
+        return this.b;
+    }
+
+    public boolean g() {
+        return this.c;
+    }
+
+    public boolean h() {
+        return this.d;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Packet28EntityVelocity.java b/src/main/java/net/minecraft/server/Packet28EntityVelocity.java
new file mode 100644
index 0000000..971000e
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Packet28EntityVelocity.java
@@ -0,0 +1,84 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+public class Packet28EntityVelocity extends Packet {
+
+    public int a;
+    public int b;
+    public int c;
+    public int d;
+
+    public Packet28EntityVelocity() {}
+
+    public Packet28EntityVelocity(Entity entity) {
+        this(entity.id, entity.motX, entity.motY, entity.motZ);
+    }
+
+    public Packet28EntityVelocity(int i, double d0, double d1, double d2) {
+        this.a = i;
+        double d3 = 3.9D;
+
+        if (d0 < -d3) {
+            d0 = -d3;
+        }
+
+        if (d1 < -d3) {
+            d1 = -d3;
+        }
+
+        if (d2 < -d3) {
+            d2 = -d3;
+        }
+
+        if (d0 > d3) {
+            d0 = d3;
+        }
+
+        if (d1 > d3) {
+            d1 = d3;
+        }
+
+        if (d2 > d3) {
+            d2 = d3;
+        }
+
+        this.b = (int) (d0 * 8000.0D);
+        this.c = (int) (d1 * 8000.0D);
+        this.d = (int) (d2 * 8000.0D);
+    }
+
+    public void a(DataInput datainput) throws IOException {
+        this.a = datainput.readInt();
+        this.b = datainput.readShort();
+        this.c = datainput.readShort();
+        this.d = datainput.readShort();
+    }
+
+    public void a(DataOutput dataoutput) throws IOException {
+        dataoutput.writeInt(this.a);
+        dataoutput.writeShort(this.b);
+        dataoutput.writeShort(this.c);
+        dataoutput.writeShort(this.d);
+    }
+
+    public void handle(Connection connection) {
+        connection.a(this);
+    }
+
+    public int a() {
+        return 10;
+    }
+
+    public boolean e() {
+        return true;
+    }
+
+    public boolean a(Packet packet) {
+        Packet28EntityVelocity packet28entityvelocity = (Packet28EntityVelocity) packet;
+
+        return packet28entityvelocity.a == this.a;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Packet29DestroyEntity.java b/src/main/java/net/minecraft/server/Packet29DestroyEntity.java
new file mode 100644
index 0000000..e878bec
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Packet29DestroyEntity.java
@@ -0,0 +1,40 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+public class Packet29DestroyEntity extends Packet {
+
+    public int[] a;
+
+    public Packet29DestroyEntity() {}
+
+    public Packet29DestroyEntity(int... aint) {
+        this.a = aint;
+    }
+
+    public void a(DataInput datainput) throws IOException {
+        this.a = new int[datainput.readByte()];
+
+        for (int i = 0; i < this.a.length; ++i) {
+            this.a[i] = datainput.readInt();
+        }
+    }
+
+    public void a(DataOutput dataoutput) throws IOException {
+        dataoutput.writeByte(this.a.length);
+
+        for (int i = 0; i < this.a.length; ++i) {
+            dataoutput.writeInt(this.a[i]);
+        }
+    }
+
+    public void handle(Connection connection) {
+        connection.a(this);
+    }
+
+    public int a() {
+        return 1 + this.a.length * 4;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Packet2Handshake.java b/src/main/java/net/minecraft/server/Packet2Handshake.java
index 1e7bad0..d3d3ae1 100644
--- a/src/main/java/net/minecraft/server/Packet2Handshake.java
+++ b/src/main/java/net/minecraft/server/Packet2Handshake.java
@@ -5,42 +5,39 @@ import java.io.DataOutput;
 
 import java.io.IOException; // CraftBukkit
 
-public class Packet2Handshake extends Packet {
+public class Packet2Handshake extends Packet
+{
 
-    private int a;
-    private String b;
-    public String c; // CraftBukkit private -> public
-    public int d; // CraftBukkit private -> public
+    public int protocolVersion;
+    public String serverAddress;
+    public int serverPort;
+    public int state;
 
-    public Packet2Handshake() {}
-
-    public void a(DataInput datainput) throws IOException { // CraftBukkit - throws IOException
-        this.a = datainput.readByte();
-        this.b = a(datainput, 16);
-        this.c = a(datainput, 255);
-        this.d = datainput.readInt();
+    public Packet2Handshake()
+    {
     }
 
-    public void a(DataOutput dataoutput) throws IOException { // CraftBukkit - throws IOException
-        dataoutput.writeByte(this.a);
-        a(this.b, dataoutput);
-        a(this.c, dataoutput);
-        dataoutput.writeInt(this.d);
+    public void a(DataInput datainput) throws IOException
+    { // CraftBukkit - throws IOException
+        protocolVersion = readVarInt( datainput );
+        serverAddress = a( datainput, 0 );
+        serverPort = datainput.readUnsignedShort();
+        state = readVarInt( datainput );
     }
 
-    public void handle(Connection connection) {
-        connection.a(this);
+    public void a(DataOutput dataoutput) throws IOException
+    { // CraftBukkit - throws IOException
+        throw new UnsupportedOperationException();
     }
 
-    public int a() {
-        return 3 + 2 * this.b.length();
+    public void handle(Connection connection)
+    {
+        connection.a( this );
     }
 
-    public int d() {
-        return this.a;
+    public int a()
+    {
+        return 0;
     }
 
-    public String f() {
-        return this.b;
-    }
 }
diff --git a/src/main/java/net/minecraft/server/Packet30Entity.java b/src/main/java/net/minecraft/server/Packet30Entity.java
new file mode 100644
index 0000000..28ec623
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Packet30Entity.java
@@ -0,0 +1,52 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+public class Packet30Entity extends Packet {
+
+    public int a;
+    public byte b;
+    public byte c;
+    public byte d;
+    public byte e;
+    public byte f;
+    public boolean g;
+
+    public Packet30Entity() {}
+
+    public Packet30Entity(int i) {
+        this.a = i;
+    }
+
+    public void a(DataInput datainput) throws IOException {
+        this.a = datainput.readInt();
+    }
+
+    public void a(DataOutput dataoutput) throws IOException {
+        dataoutput.writeInt(this.a);
+    }
+
+    public void handle(Connection connection) {
+        connection.a(this);
+    }
+
+    public int a() {
+        return 4;
+    }
+
+    public String toString() {
+        return "Entity_" + super.toString();
+    }
+
+    public boolean e() {
+        return true;
+    }
+
+    public boolean a(Packet packet) {
+        Packet30Entity packet30entity = (Packet30Entity) packet;
+
+        return packet30entity.a == this.a;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Packet31RelEntityMove.java b/src/main/java/net/minecraft/server/Packet31RelEntityMove.java
new file mode 100644
index 0000000..8e866e2
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Packet31RelEntityMove.java
@@ -0,0 +1,35 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+public class Packet31RelEntityMove extends Packet30Entity {
+
+    public Packet31RelEntityMove() {}
+
+    public Packet31RelEntityMove(int i, byte b0, byte b1, byte b2) {
+        super(i);
+        this.b = b0;
+        this.c = b1;
+        this.d = b2;
+    }
+
+    public void a(DataInput datainput) throws IOException {
+        super.a(datainput);
+        this.b = datainput.readByte();
+        this.c = datainput.readByte();
+        this.d = datainput.readByte();
+    }
+
+    public void a(DataOutput dataoutput) throws IOException {
+        super.a(dataoutput);
+        dataoutput.writeByte(this.b);
+        dataoutput.writeByte(this.c);
+        dataoutput.writeByte(this.d);
+    }
+
+    public int a() {
+        return 7;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Packet32EntityLook.java b/src/main/java/net/minecraft/server/Packet32EntityLook.java
new file mode 100644
index 0000000..8a2cf0c
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Packet32EntityLook.java
@@ -0,0 +1,35 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+public class Packet32EntityLook extends Packet30Entity {
+
+    public Packet32EntityLook() {
+        this.g = true;
+    }
+
+    public Packet32EntityLook(int i, byte b0, byte b1) {
+        super(i);
+        this.e = b0;
+        this.f = b1;
+        this.g = true;
+    }
+
+    public void a(DataInput datainput) throws IOException {
+        super.a(datainput);
+        this.e = datainput.readByte();
+        this.f = datainput.readByte();
+    }
+
+    public void a(DataOutput dataoutput) throws IOException {
+        super.a(dataoutput);
+        dataoutput.writeByte(this.e);
+        dataoutput.writeByte(this.f);
+    }
+
+    public int a() {
+        return 6;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Packet33RelEntityMoveLook.java b/src/main/java/net/minecraft/server/Packet33RelEntityMoveLook.java
new file mode 100644
index 0000000..198d345
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Packet33RelEntityMoveLook.java
@@ -0,0 +1,44 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+public class Packet33RelEntityMoveLook extends Packet30Entity {
+
+    public Packet33RelEntityMoveLook() {
+        this.g = true;
+    }
+
+    public Packet33RelEntityMoveLook(int i, byte b0, byte b1, byte b2, byte b3, byte b4) {
+        super(i);
+        this.b = b0;
+        this.c = b1;
+        this.d = b2;
+        this.e = b3;
+        this.f = b4;
+        this.g = true;
+    }
+
+    public void a(DataInput datainput) throws IOException {
+        super.a(datainput);
+        this.b = datainput.readByte();
+        this.c = datainput.readByte();
+        this.d = datainput.readByte();
+        this.e = datainput.readByte();
+        this.f = datainput.readByte();
+    }
+
+    public void a(DataOutput dataoutput) throws IOException {
+        super.a(dataoutput);
+        dataoutput.writeByte(this.b);
+        dataoutput.writeByte(this.c);
+        dataoutput.writeByte(this.d);
+        dataoutput.writeByte(this.e);
+        dataoutput.writeByte(this.f);
+    }
+
+    public int a() {
+        return 9;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Packet34EntityTeleport.java b/src/main/java/net/minecraft/server/Packet34EntityTeleport.java
new file mode 100644
index 0000000..f99ac8d
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Packet34EntityTeleport.java
@@ -0,0 +1,71 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+public class Packet34EntityTeleport extends Packet {
+
+    public int a;
+    public int b;
+    public int c;
+    public int d;
+    public byte e;
+    public byte f;
+
+    public Packet34EntityTeleport() {}
+
+    public Packet34EntityTeleport(Entity entity) {
+        this.a = entity.id;
+        this.b = MathHelper.floor(entity.locX * 32.0D);
+        this.c = MathHelper.floor(entity.locY * 32.0D);
+        this.d = MathHelper.floor(entity.locZ * 32.0D);
+        this.e = (byte) ((int) (entity.yaw * 256.0F / 360.0F));
+        this.f = (byte) ((int) (entity.pitch * 256.0F / 360.0F));
+    }
+
+    public Packet34EntityTeleport(int i, int j, int k, int l, byte b0, byte b1) {
+        this.a = i;
+        this.b = j;
+        this.c = k;
+        this.d = l;
+        this.e = b0;
+        this.f = b1;
+    }
+
+    public void a(DataInput datainput) throws IOException {
+        this.a = datainput.readInt();
+        this.b = datainput.readInt();
+        this.c = datainput.readInt();
+        this.d = datainput.readInt();
+        this.e = datainput.readByte();
+        this.f = datainput.readByte();
+    }
+
+    public void a(DataOutput dataoutput) throws IOException {
+        dataoutput.writeInt(this.a);
+        dataoutput.writeInt(this.b);
+        dataoutput.writeInt(this.c);
+        dataoutput.writeInt(this.d);
+        dataoutput.write(this.e);
+        dataoutput.write(this.f);
+    }
+
+    public void handle(Connection connection) {
+        connection.a(this);
+    }
+
+    public int a() {
+        return 34;
+    }
+
+    public boolean e() {
+        return true;
+    }
+
+    public boolean a(Packet packet) {
+        Packet34EntityTeleport packet34entityteleport = (Packet34EntityTeleport) packet;
+
+        return packet34entityteleport.a == this.a;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Packet35EntityHeadRotation.java b/src/main/java/net/minecraft/server/Packet35EntityHeadRotation.java
new file mode 100644
index 0000000..907f22c
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Packet35EntityHeadRotation.java
@@ -0,0 +1,50 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+public class Packet35EntityHeadRotation extends Packet {
+
+    public int a;
+    public byte b;
+
+    public Packet35EntityHeadRotation() {}
+
+    public Packet35EntityHeadRotation(int i, byte b0) {
+        this.a = i;
+        this.b = b0;
+    }
+
+    public void a(DataInput datainput) throws IOException {
+        this.a = datainput.readInt();
+        this.b = datainput.readByte();
+    }
+
+    public void a(DataOutput dataoutput) throws IOException {
+        dataoutput.writeInt(this.a);
+        dataoutput.writeByte(this.b);
+    }
+
+    public void handle(Connection connection) {
+        connection.a(this);
+    }
+
+    public int a() {
+        return 5;
+    }
+
+    public boolean e() {
+        return true;
+    }
+
+    public boolean a(Packet packet) {
+        Packet35EntityHeadRotation packet35entityheadrotation = (Packet35EntityHeadRotation) packet;
+
+        return packet35entityheadrotation.a == this.a;
+    }
+
+    public boolean a_() {
+        return true;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Packet38EntityStatus.java b/src/main/java/net/minecraft/server/Packet38EntityStatus.java
new file mode 100644
index 0000000..71823b4
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Packet38EntityStatus.java
@@ -0,0 +1,36 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+public class Packet38EntityStatus extends Packet {
+
+    public int a;
+    public byte b;
+
+    public Packet38EntityStatus() {}
+
+    public Packet38EntityStatus(int i, byte b0) {
+        this.a = i;
+        this.b = b0;
+    }
+
+    public void a(DataInput datainput) throws IOException {
+        this.a = datainput.readInt();
+        this.b = datainput.readByte();
+    }
+
+    public void a(DataOutput dataoutput) throws IOException {
+        dataoutput.writeInt(this.a);
+        dataoutput.writeByte(this.b);
+    }
+
+    public void handle(Connection connection) {
+        connection.a(this);
+    }
+
+    public int a() {
+        return 5;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Packet39AttachEntity.java b/src/main/java/net/minecraft/server/Packet39AttachEntity.java
new file mode 100644
index 0000000..573e621
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Packet39AttachEntity.java
@@ -0,0 +1,50 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+public class Packet39AttachEntity extends Packet {
+
+    public int a;
+    public int b;
+    public int c;
+
+    public Packet39AttachEntity() {}
+
+    public Packet39AttachEntity(int i, Entity entity, Entity entity1) {
+        this.a = i;
+        this.b = entity.id;
+        this.c = entity1 != null ? entity1.id : -1;
+    }
+
+    public int a() {
+        return 8;
+    }
+
+    public void a(DataInput datainput) throws IOException {
+        this.b = datainput.readInt();
+        this.c = datainput.readInt();
+        this.a = datainput.readUnsignedByte();
+    }
+
+    public void a(DataOutput dataoutput) throws IOException {
+        dataoutput.writeInt(this.b);
+        dataoutput.writeInt(this.c);
+        dataoutput.writeByte(this.a);
+    }
+
+    public void handle(Connection connection) {
+        connection.a(this);
+    }
+
+    public boolean e() {
+        return true;
+    }
+
+    public boolean a(Packet packet) {
+        Packet39AttachEntity packet39attachentity = (Packet39AttachEntity) packet;
+
+        return packet39attachentity.b == this.b;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Packet3Chat.java b/src/main/java/net/minecraft/server/Packet3Chat.java
new file mode 100644
index 0000000..e0aac57
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Packet3Chat.java
@@ -0,0 +1,57 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+public class Packet3Chat extends Packet {
+
+    public String message;
+    private boolean b;
+
+    public Packet3Chat() {
+        this.b = true;
+    }
+
+    public Packet3Chat(ChatMessage chatmessage) {
+        this(chatmessage.i());
+    }
+
+    public Packet3Chat(ChatMessage chatmessage, boolean flag) {
+        this(chatmessage.i(), flag);
+    }
+
+    public Packet3Chat(String s) {
+        this(s, true);
+    }
+
+    public Packet3Chat(String s, boolean flag) {
+        this.b = true;
+        if (s.length() > 32767) {
+            s = s.substring(0, 32767);
+        }
+
+        this.message = s;
+        this.b = flag;
+    }
+
+    public void a(DataInput datainput) throws IOException {
+        this.message = a(datainput, 32767);
+    }
+
+    public void a(DataOutput dataoutput) throws IOException {
+        a(this.message, dataoutput);
+    }
+
+    public void handle(Connection connection) {
+        connection.a(this);
+    }
+
+    public int a() {
+        return 2 + this.message.length() * 2;
+    }
+
+    public boolean isServer() {
+        return this.b;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Packet40EntityMetadata.java b/src/main/java/net/minecraft/server/Packet40EntityMetadata.java
new file mode 100644
index 0000000..54299a7
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Packet40EntityMetadata.java
@@ -0,0 +1,41 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+import java.util.List;
+
+public class Packet40EntityMetadata extends Packet {
+
+    public int a;
+    private List b;
+
+    public Packet40EntityMetadata() {}
+
+    public Packet40EntityMetadata(int i, DataWatcher datawatcher, boolean flag) {
+        this.a = i;
+        if (flag) {
+            this.b = datawatcher.c();
+        } else {
+            this.b = datawatcher.b();
+        }
+    }
+
+    public void a(DataInput datainput) throws IOException {
+        this.a = datainput.readInt();
+        this.b = DataWatcher.a(datainput);
+    }
+
+    public void a(DataOutput dataoutput) throws IOException {
+        dataoutput.writeInt(this.a);
+        DataWatcher.a(this.b, dataoutput);
+    }
+
+    public void handle(Connection connection) {
+        connection.a(this);
+    }
+
+    public int a() {
+        return 5;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Packet41MobEffect.java b/src/main/java/net/minecraft/server/Packet41MobEffect.java
new file mode 100644
index 0000000..b11a0af
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Packet41MobEffect.java
@@ -0,0 +1,58 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+public class Packet41MobEffect extends Packet {
+
+    public int a;
+    public byte b;
+    public byte c;
+    public short d;
+
+    public Packet41MobEffect() {}
+
+    public Packet41MobEffect(int i, MobEffect mobeffect) {
+        this.a = i;
+        this.b = (byte) (mobeffect.getEffectId() & 255);
+        this.c = (byte) (mobeffect.getAmplifier() & 255);
+        if (mobeffect.getDuration() > 32767) {
+            this.d = 32767;
+        } else {
+            this.d = (short) mobeffect.getDuration();
+        }
+    }
+
+    public void a(DataInput datainput) throws IOException {
+        this.a = datainput.readInt();
+        this.b = datainput.readByte();
+        this.c = datainput.readByte();
+        this.d = datainput.readShort();
+    }
+
+    public void a(DataOutput dataoutput) throws IOException {
+        dataoutput.writeInt(this.a);
+        dataoutput.writeByte(this.b);
+        dataoutput.writeByte(this.c);
+        dataoutput.writeShort(this.d);
+    }
+
+    public void handle(Connection connection) {
+        connection.a(this);
+    }
+
+    public int a() {
+        return 8;
+    }
+
+    public boolean e() {
+        return true;
+    }
+
+    public boolean a(Packet packet) {
+        Packet41MobEffect packet41mobeffect = (Packet41MobEffect) packet;
+
+        return packet41mobeffect.a == this.a && packet41mobeffect.b == this.b;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Packet42RemoveMobEffect.java b/src/main/java/net/minecraft/server/Packet42RemoveMobEffect.java
new file mode 100644
index 0000000..ef24f41
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Packet42RemoveMobEffect.java
@@ -0,0 +1,36 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+public class Packet42RemoveMobEffect extends Packet {
+
+    public int a;
+    public byte b;
+
+    public Packet42RemoveMobEffect() {}
+
+    public Packet42RemoveMobEffect(int i, MobEffect mobeffect) {
+        this.a = i;
+        this.b = (byte) (mobeffect.getEffectId() & 255);
+    }
+
+    public void a(DataInput datainput) throws IOException {
+        this.a = datainput.readInt();
+        this.b = datainput.readByte();
+    }
+
+    public void a(DataOutput dataoutput) throws IOException {
+        dataoutput.writeInt(this.a);
+        dataoutput.writeByte(this.b);
+    }
+
+    public void handle(Connection connection) {
+        connection.a(this);
+    }
+
+    public int a() {
+        return 5;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Packet43SetExperience.java b/src/main/java/net/minecraft/server/Packet43SetExperience.java
new file mode 100644
index 0000000..bdd9232
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Packet43SetExperience.java
@@ -0,0 +1,48 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+public class Packet43SetExperience extends Packet {
+
+    public float a;
+    public int b;
+    public int c;
+
+    public Packet43SetExperience() {}
+
+    public Packet43SetExperience(float f, int i, int j) {
+        this.a = f;
+        this.b = i;
+        this.c = j;
+    }
+
+    public void a(DataInput datainput) throws IOException {
+        this.a = datainput.readFloat();
+        this.c = datainput.readShort();
+        this.b = datainput.readShort();
+    }
+
+    public void a(DataOutput dataoutput) throws IOException {
+        dataoutput.writeFloat(this.a);
+        dataoutput.writeShort(this.c);
+        dataoutput.writeShort(this.b);
+    }
+
+    public void handle(Connection connection) {
+        connection.a(this);
+    }
+
+    public int a() {
+        return 4;
+    }
+
+    public boolean e() {
+        return true;
+    }
+
+    public boolean a(Packet packet) {
+        return true;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Packet44UpdateAttributes.java b/src/main/java/net/minecraft/server/Packet44UpdateAttributes.java
new file mode 100644
index 0000000..d4b52ae
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Packet44UpdateAttributes.java
@@ -0,0 +1,81 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.List;
+import java.util.UUID;
+
+public class Packet44UpdateAttributes extends Packet {
+
+    private int a;
+    private final List b = new ArrayList();
+
+    public Packet44UpdateAttributes() {}
+
+    public Packet44UpdateAttributes(int i, Collection collection) {
+        this.a = i;
+        Iterator iterator = collection.iterator();
+
+        while (iterator.hasNext()) {
+            AttributeInstance attributeinstance = (AttributeInstance) iterator.next();
+
+            this.b.add(new AttributeSnapshot(this, attributeinstance.a().a(), attributeinstance.b(), attributeinstance.c()));
+        }
+    }
+
+    public void a(DataInput datainput) throws IOException {
+        this.a = datainput.readInt();
+        int i = datainput.readInt();
+
+        for (int j = 0; j < i; ++j) {
+            String s = a(datainput, 64);
+            double d0 = datainput.readDouble();
+            ArrayList arraylist = new ArrayList();
+            short short1 = datainput.readShort();
+
+            for (int k = 0; k < short1; ++k) {
+                UUID uuid = new UUID(datainput.readLong(), datainput.readLong());
+
+                arraylist.add(new AttributeModifier(uuid, "Unknown synced attribute modifier", datainput.readDouble(), datainput.readByte()));
+            }
+
+            this.b.add(new AttributeSnapshot(this, s, d0, arraylist));
+        }
+    }
+
+    public void a(DataOutput dataoutput) throws IOException {
+        dataoutput.writeInt(this.a);
+        dataoutput.writeInt(this.b.size());
+        Iterator iterator = this.b.iterator();
+
+        while (iterator.hasNext()) {
+            AttributeSnapshot attributesnapshot = (AttributeSnapshot) iterator.next();
+
+            a(attributesnapshot.a(), dataoutput);
+            dataoutput.writeDouble(attributesnapshot.b());
+            dataoutput.writeShort(attributesnapshot.c().size());
+            Iterator iterator1 = attributesnapshot.c().iterator();
+
+            while (iterator1.hasNext()) {
+                AttributeModifier attributemodifier = (AttributeModifier) iterator1.next();
+
+                dataoutput.writeLong(attributemodifier.a().getMostSignificantBits());
+                dataoutput.writeLong(attributemodifier.a().getLeastSignificantBits());
+                dataoutput.writeDouble(attributemodifier.d());
+                dataoutput.writeByte(attributemodifier.c());
+            }
+        }
+    }
+
+    public void handle(Connection connection) {
+        connection.a(this);
+    }
+
+    public int a() {
+        return 8 + this.b.size() * 24;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Packet4UpdateTime.java b/src/main/java/net/minecraft/server/Packet4UpdateTime.java
new file mode 100644
index 0000000..ab8a32b
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Packet4UpdateTime.java
@@ -0,0 +1,54 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+public class Packet4UpdateTime extends Packet {
+
+    public long a;
+    public long b;
+
+    public Packet4UpdateTime() {}
+
+    public Packet4UpdateTime(long i, long j, boolean flag) {
+        this.a = i;
+        this.b = j;
+        if (!flag) {
+            this.b = -this.b;
+            if (this.b == 0L) {
+                this.b = -1L;
+            }
+        }
+    }
+
+    public void a(DataInput datainput) throws IOException {
+        this.a = datainput.readLong();
+        this.b = datainput.readLong();
+    }
+
+    public void a(DataOutput dataoutput) throws IOException {
+        dataoutput.writeLong(this.a);
+        dataoutput.writeLong(this.b);
+    }
+
+    public void handle(Connection connection) {
+        connection.a(this);
+    }
+
+    public int a() {
+        return 16;
+    }
+
+    public boolean e() {
+        return true;
+    }
+
+    public boolean a(Packet packet) {
+        return true;
+    }
+
+    public boolean a_() {
+        return true;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Packet51MapChunk.java b/src/main/java/net/minecraft/server/Packet51MapChunk.java
new file mode 100644
index 0000000..29baf6d
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Packet51MapChunk.java
@@ -0,0 +1,199 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+import java.util.zip.DataFormatException;
+import java.util.zip.Deflater;
+import java.util.zip.Inflater;
+
+public class Packet51MapChunk extends Packet {
+
+    public int a;
+    public int b;
+    public int c;
+    public int d;
+    private byte[] buffer;
+    private byte[] inflatedBuffer;
+    public boolean e;
+    private int size;
+    private static byte[] buildBuffer = new byte[196864];
+
+    public Packet51MapChunk() {
+        this.lowPriority = true;
+    }
+
+    public Packet51MapChunk(Chunk chunk, boolean flag, int i) {
+        this.lowPriority = true;
+        this.a = chunk.x;
+        this.b = chunk.z;
+        this.e = flag;
+        ChunkMap chunkmap = a(chunk, flag, i);
+        Deflater deflater = new Deflater(4); // Spigot 4 -> -1
+
+        this.d = chunkmap.c;
+        this.c = chunkmap.b;
+        chunk.world.spigotConfig.antiXrayInstance.obfuscateSync(chunk.x, chunk.z, i, chunkmap.a, chunk.world); // Spigot
+
+        try {
+            this.inflatedBuffer = chunkmap.a;
+            deflater.setInput(chunkmap.a, 0, chunkmap.a.length);
+            deflater.finish();
+            this.buffer = new byte[chunkmap.a.length];
+            this.size = deflater.deflate(this.buffer);
+        } finally {
+            deflater.end();
+        }
+    }
+
+    public void a(DataInput datainput) throws java.io.IOException { // Spigot - throws
+        this.a = datainput.readInt();
+        this.b = datainput.readInt();
+        this.e = datainput.readBoolean();
+        this.c = datainput.readShort();
+        this.d = datainput.readShort();
+        this.size = datainput.readInt();
+        if (buildBuffer.length < this.size) {
+            buildBuffer = new byte[this.size];
+        }
+
+        datainput.readFully(buildBuffer, 0, this.size);
+        int i = 0;
+
+        int j;
+
+        for (j = 0; j < 16; ++j) {
+            i += this.c >> j & 1;
+        }
+
+        j = 12288 * i;
+        if (this.e) {
+            j += 256;
+        }
+
+        this.inflatedBuffer = new byte[j];
+        Inflater inflater = new Inflater();
+
+        inflater.setInput(buildBuffer, 0, this.size);
+
+        try {
+            inflater.inflate(this.inflatedBuffer);
+        } catch (DataFormatException dataformatexception) {
+            throw new IOException("Bad compressed data format");
+        } finally {
+            inflater.end();
+        }
+    }
+
+    public void a(DataOutput dataoutput) throws java.io.IOException { // Spigot - throws
+        dataoutput.writeInt(this.a);
+        dataoutput.writeInt(this.b);
+        dataoutput.writeBoolean(this.e);
+        dataoutput.writeShort((short) (this.c & '\uffff'));
+        dataoutput.writeShort((short) (this.d & '\uffff'));
+        dataoutput.writeInt(this.size);
+        dataoutput.write(this.buffer, 0, this.size);
+    }
+
+    public void handle(Connection connection) {
+        connection.a(this);
+    }
+
+    public int a() {
+        return 17 + this.size;
+    }
+
+    public static ChunkMap a(Chunk chunk, boolean flag, int i) {
+        int j = 0;
+        ChunkSection[] achunksection = chunk.i();
+        int k = 0;
+        ChunkMap chunkmap = new ChunkMap();
+        byte[] abyte = buildBuffer;
+
+        if (flag) {
+            chunk.seenByPlayer = true;
+        }
+
+        int l;
+
+        for (l = 0; l < achunksection.length; ++l) {
+            if (achunksection[l] != null && (!flag || !achunksection[l].isEmpty()) && (i & 1 << l) != 0) {
+                chunkmap.b |= 1 << l;
+                if (achunksection[l].getExtendedIdArray() != null) {
+                    chunkmap.c |= 1 << l;
+                    ++k;
+                }
+            }
+        }
+
+        for (l = 0; l < achunksection.length; ++l) {
+            if (achunksection[l] != null && (!flag || !achunksection[l].isEmpty()) && (i & 1 << l) != 0) {
+                byte[] abyte1 = achunksection[l].getIdArray();
+
+                System.arraycopy(abyte1, 0, abyte, j, abyte1.length);
+                j += abyte1.length;
+            }
+        }
+
+        NibbleArray nibblearray;
+
+        for (l = 0; l < achunksection.length; ++l) {
+            if (achunksection[l] != null && (!flag || !achunksection[l].isEmpty()) && (i & 1 << l) != 0) {
+                nibblearray = achunksection[l].getDataArray();
+                // Spigot start
+                // System.arraycopy(nibblearray.a, 0, abyte, j, nibblearray.a.length);
+                // j += nibblearray.a.length;
+                j = nibblearray.copyToByteArray(abyte, j);
+                // Spigot end
+            }
+        }
+
+        for (l = 0; l < achunksection.length; ++l) {
+            if (achunksection[l] != null && (!flag || !achunksection[l].isEmpty()) && (i & 1 << l) != 0) {
+                nibblearray = achunksection[l].getEmittedLightArray();
+                // Spigot start
+                // System.arraycopy(nibblearray.a, 0, abyte, j, nibblearray.a.length);
+                // j += nibblearray.a.length;
+                j = nibblearray.copyToByteArray(abyte, j);
+                // Spigot end
+            }
+        }
+
+        if (!chunk.world.worldProvider.g) {
+            for (l = 0; l < achunksection.length; ++l) {
+                if (achunksection[l] != null && (!flag || !achunksection[l].isEmpty()) && (i & 1 << l) != 0) {
+                    nibblearray = achunksection[l].getSkyLightArray();
+                    // Spigot start
+                    // System.arraycopy(nibblearray.a, 0, abyte, j, nibblearray.a.length);
+                    // j += nibblearray.a.length;
+                    j = nibblearray.copyToByteArray(abyte, j);
+                    // Spigot end
+                }
+            }
+        }
+
+        if (k > 0) {
+            for (l = 0; l < achunksection.length; ++l) {
+                if (achunksection[l] != null && (!flag || !achunksection[l].isEmpty()) && achunksection[l].getExtendedIdArray() != null && (i & 1 << l) != 0) {
+                    nibblearray = achunksection[l].getExtendedIdArray();
+                    // Spigot start
+                    //System.arraycopy(nibblearray.a, 0, abyte, j, nibblearray.a.length);
+                    //j += nibblearray.a.length;
+                    j = nibblearray.copyToByteArray(abyte, j);
+                    // Spigot end
+                }
+            }
+        }
+
+        if (flag) {
+            byte[] abyte2 = chunk.m();
+
+            System.arraycopy(abyte2, 0, abyte, j, abyte2.length);
+            j += abyte2.length;
+        }
+
+        chunkmap.a = new byte[j];
+        System.arraycopy(abyte, 0, chunkmap.a, 0, j);
+        return chunkmap;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Packet52MultiBlockChange.java b/src/main/java/net/minecraft/server/Packet52MultiBlockChange.java
new file mode 100644
index 0000000..55148d5
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Packet52MultiBlockChange.java
@@ -0,0 +1,90 @@
+package net.minecraft.server;
+
+import java.io.ByteArrayOutputStream;
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.DataOutputStream;
+import java.io.IOException;
+
+public class Packet52MultiBlockChange extends Packet {
+
+    public int a;
+    public int b;
+    public byte[] c;
+    public int d;
+    private static byte[] e = new byte[0];
+
+    public Packet52MultiBlockChange() {
+        this.lowPriority = true;
+    }
+
+    public Packet52MultiBlockChange(int i, int j, short[] ashort, int k, World world) {
+        this.lowPriority = true;
+        this.a = i;
+        this.b = j;
+        this.d = k;
+        int l = 4 * k;
+        Chunk chunk = world.getChunkAt(i, j);
+
+        try {
+            if (k >= 64) {
+                this.m.info("ChunkTilesUpdatePacket compress " + k);
+                if (e.length < l) {
+                    e = new byte[l];
+                }
+            } else {
+                ByteArrayOutputStream bytearrayoutputstream = new ByteArrayOutputStream(l);
+                DataOutputStream dataoutputstream = new DataOutputStream(bytearrayoutputstream);
+
+                for (int i1 = 0; i1 < k; ++i1) {
+                    int j1 = ashort[i1] >> 12 & 15;
+                    int k1 = ashort[i1] >> 8 & 15;
+                    int l1 = ashort[i1] & 255;
+
+                    dataoutputstream.writeShort(ashort[i1]);
+                    dataoutputstream.writeShort((short) ((chunk.getTypeId(j1, l1, k1) & 4095) << 4 | chunk.getData(j1, l1, k1) & 15));
+                }
+
+                this.c = bytearrayoutputstream.toByteArray();
+                if (this.c.length != l) {
+                    throw new RuntimeException("Expected length " + l + " doesn\'t match received length " + this.c.length);
+                }
+            }
+        } catch (IOException ioexception) {
+            this.m.severe("Couldn\'t create chunk packet", ioexception);
+            this.c = null;
+        }
+    }
+
+    public void a(DataInput datainput) throws IOException {
+        this.a = datainput.readInt();
+        this.b = datainput.readInt();
+        this.d = datainput.readShort() & '\uffff';
+        int i = datainput.readInt();
+
+        if (i > 0) {
+            this.c = new byte[i];
+            datainput.readFully(this.c);
+        }
+    }
+
+    public void a(DataOutput dataoutput) throws IOException {
+        dataoutput.writeInt(this.a);
+        dataoutput.writeInt(this.b);
+        dataoutput.writeShort((short) this.d);
+        if (this.c != null) {
+            dataoutput.writeInt(this.c.length);
+            dataoutput.write(this.c);
+        } else {
+            dataoutput.writeInt(0);
+        }
+    }
+
+    public void handle(Connection connection) {
+        connection.a(this);
+    }
+
+    public int a() {
+        return 10 + this.d * 4;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Packet53BlockChange.java b/src/main/java/net/minecraft/server/Packet53BlockChange.java
new file mode 100644
index 0000000..31513f4
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Packet53BlockChange.java
@@ -0,0 +1,47 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+public class Packet53BlockChange extends Packet {
+
+    public int a;
+    public int b;
+    public int c;
+    public int material;
+    public int data;
+
+    public Packet53BlockChange() {
+        this.lowPriority = true;
+    }
+
+    public Packet53BlockChange(int i, int j, int k, World world) {
+        this.lowPriority = true;
+        this.a = i;
+        this.b = j;
+        this.c = k;
+        this.material = world.getTypeId(i, j, k);
+        this.data = world.getData(i, j, k);
+    }
+
+    public void a(DataInput datainput) {
+        throw new UnsupportedOperationException();
+    }
+
+    public void a(DataOutput dataoutput) throws IOException {
+        dataoutput.writeInt(this.a);
+        dataoutput.write(this.b);
+        dataoutput.writeInt(this.c);
+        writeVarInt(this.material, dataoutput);
+        dataoutput.write(this.data);
+    }
+
+    public void handle(Connection connection) {
+        connection.a(this);
+    }
+
+    public int a() {
+        return 11;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Packet54PlayNoteBlock.java b/src/main/java/net/minecraft/server/Packet54PlayNoteBlock.java
new file mode 100644
index 0000000..889e136
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Packet54PlayNoteBlock.java
@@ -0,0 +1,47 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+public class Packet54PlayNoteBlock extends Packet {
+
+    public int a;
+    public int b;
+    public int c;
+    public int d;
+    public int e;
+    public int f;
+
+    public Packet54PlayNoteBlock() {}
+
+    public Packet54PlayNoteBlock(int i, int j, int k, int l, int i1, int j1) {
+        this.a = i;
+        this.b = j;
+        this.c = k;
+        this.d = i1;
+        this.e = j1;
+        this.f = l;
+    }
+
+    public void a(DataInput datainput) {
+        throw new UnsupportedOperationException();
+    }
+
+    public void a(DataOutput dataoutput) throws IOException {
+        dataoutput.writeInt(this.a);
+        dataoutput.writeShort(this.b);
+        dataoutput.writeInt(this.c);
+        dataoutput.write(this.d);
+        dataoutput.write(this.e);
+        writeVarInt( this.f, dataoutput);
+    }
+
+    public void handle(Connection connection) {
+        connection.a(this);
+    }
+
+    public int a() {
+        return 14;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Packet55BlockBreakAnimation.java b/src/main/java/net/minecraft/server/Packet55BlockBreakAnimation.java
new file mode 100644
index 0000000..1d0c4cd
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Packet55BlockBreakAnimation.java
@@ -0,0 +1,54 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+public class Packet55BlockBreakAnimation extends Packet {
+
+    private int a;
+    private int b;
+    private int c;
+    private int d;
+    private int e;
+
+    public Packet55BlockBreakAnimation() {}
+
+    public Packet55BlockBreakAnimation(int i, int j, int k, int l, int i1) {
+        this.a = i;
+        this.b = j;
+        this.c = k;
+        this.d = l;
+        this.e = i1;
+    }
+
+    public void a(DataInput datainput) {
+        throw new UnsupportedOperationException();
+    }
+
+    public void a(DataOutput dataoutput) throws IOException {
+        writeVarInt( this.a, dataoutput);
+        dataoutput.writeInt(this.b);
+        dataoutput.writeInt(this.c);
+        dataoutput.writeInt(this.d);
+        dataoutput.write(this.e);
+    }
+
+    public void handle(Connection connection) {
+        connection.a(this);
+    }
+
+    public int a() {
+        return 13;
+    }
+
+    public boolean e() {
+        return true;
+    }
+
+    public boolean a(Packet packet) {
+        Packet55BlockBreakAnimation packet55blockbreakanimation = (Packet55BlockBreakAnimation) packet;
+
+        return packet55blockbreakanimation.a == this.a;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Packet56MapChunkBulk.java b/src/main/java/net/minecraft/server/Packet56MapChunkBulk.java
index 04c44fc..63dd8d3 100644
--- a/src/main/java/net/minecraft/server/Packet56MapChunkBulk.java
+++ b/src/main/java/net/minecraft/server/Packet56MapChunkBulk.java
@@ -24,10 +24,11 @@ public class Packet56MapChunkBulk extends Packet {
         @Override
         protected Deflater initialValue() {
             // Don't use higher compression level, slows things down too much
-            return new Deflater(6);
+            return new Deflater(4); // Spigot 6 -> 4
         }
     };
     // CraftBukkit end
+    private World world; // Spigot
 
     public Packet56MapChunkBulk() {}
 
@@ -46,6 +47,9 @@ public class Packet56MapChunkBulk extends Packet {
             Chunk chunk = (Chunk) list.get(k);
             ChunkMap chunkmap = Packet51MapChunk.a(chunk, true, '\uffff');
 
+            // Spigot start
+            world = chunk.world;
+            /*
             if (buildBuffer.length < j + chunkmap.a.length) {
                 byte[] abyte = new byte[j + chunkmap.a.length];
 
@@ -54,6 +58,8 @@ public class Packet56MapChunkBulk extends Packet {
             }
 
             System.arraycopy(chunkmap.a, 0, buildBuffer, j, chunkmap.a.length);
+            */
+            // Spigot end
             j += chunkmap.a.length;
             this.c[k] = chunk.x;
             this.d[k] = chunk.z;
@@ -81,6 +87,22 @@ public class Packet56MapChunkBulk extends Packet {
         if (this.buffer != null) {
             return;
         }
+        // Spigot start
+        int finalBufferSize = 0;
+        // Obfuscate all sections
+        for (int i = 0; i < a.length; i++) {
+            world.spigotConfig.antiXrayInstance.obfuscate(c[i], d[i], a[i], inflatedBuffers[i], world);
+            finalBufferSize += inflatedBuffers[i].length;
+        }
+
+        // Now it's time to efficiently copy the chunk to the build buffer
+        buildBuffer = new byte[finalBufferSize];
+        int bufferLocation = 0;
+        for (int i = 0; i < a.length; i++) {
+            System.arraycopy(inflatedBuffers[i], 0, buildBuffer, bufferLocation, inflatedBuffers[i].length);
+            bufferLocation += inflatedBuffers[i].length;
+        }
+        // Spigot end
 
         Deflater deflater = localDeflater.get();
         deflater.reset();
diff --git a/src/main/java/net/minecraft/server/Packet5EntityEquipment.java b/src/main/java/net/minecraft/server/Packet5EntityEquipment.java
new file mode 100644
index 0000000..28eb6ea
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Packet5EntityEquipment.java
@@ -0,0 +1,50 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+public class Packet5EntityEquipment extends Packet {
+
+    public int a;
+    public int b;
+    private ItemStack c;
+
+    public Packet5EntityEquipment() {}
+
+    public Packet5EntityEquipment(int i, int j, ItemStack itemstack) {
+        this.a = i;
+        this.b = j;
+        this.c = itemstack == null ? null : itemstack.cloneItemStack();
+    }
+
+    public void a(DataInput datainput) throws IOException {
+        this.a = datainput.readInt();
+        this.b = datainput.readShort();
+        this.c = c(datainput);
+    }
+
+    public void a(DataOutput dataoutput) throws IOException {
+        dataoutput.writeInt(this.a);
+        dataoutput.writeShort(this.b);
+        a(this.c, dataoutput);
+    }
+
+    public void handle(Connection connection) {
+        connection.a(this);
+    }
+
+    public int a() {
+        return 8;
+    }
+
+    public boolean e() {
+        return true;
+    }
+
+    public boolean a(Packet packet) {
+        Packet5EntityEquipment packet5entityequipment = (Packet5EntityEquipment) packet;
+
+        return packet5entityequipment.a == this.a && packet5entityequipment.b == this.b;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Packet60Explosion.java b/src/main/java/net/minecraft/server/Packet60Explosion.java
new file mode 100644
index 0000000..e17e4ec
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Packet60Explosion.java
@@ -0,0 +1,74 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+
+public class Packet60Explosion extends Packet {
+
+    public double a;
+    public double b;
+    public double c;
+    public float d;
+    public List e;
+    private float f;
+    private float g;
+    private float h;
+
+    public Packet60Explosion() {}
+
+    public Packet60Explosion(double d0, double d1, double d2, float f, List list, Vec3D vec3d) {
+        this.a = d0;
+        this.b = d1;
+        this.c = d2;
+        this.d = f;
+        this.e = new ArrayList(list);
+        if (vec3d != null) {
+            this.f = (float) vec3d.c;
+            this.g = (float) vec3d.d;
+            this.h = (float) vec3d.e;
+        }
+    }
+
+    public void a(DataInput datainput) {
+        throw new UnsupportedOperationException();
+    }
+
+    public void a(DataOutput dataoutput) throws IOException {
+        dataoutput.writeFloat((float)this.a);
+        dataoutput.writeFloat((float)this.b);
+        dataoutput.writeFloat((float)this.c);
+        dataoutput.writeFloat(this.d);
+        dataoutput.writeInt(this.e.size());
+        int i = (int) this.a;
+        int j = (int) this.b;
+        int k = (int) this.c;
+        Iterator iterator = this.e.iterator();
+
+        while (iterator.hasNext()) {
+            ChunkPosition chunkposition = (ChunkPosition) iterator.next();
+            int l = chunkposition.x - i;
+            int i1 = chunkposition.y - j;
+            int j1 = chunkposition.z - k;
+
+            dataoutput.writeByte(l);
+            dataoutput.writeByte(i1);
+            dataoutput.writeByte(j1);
+        }
+
+        dataoutput.writeFloat(this.f);
+        dataoutput.writeFloat(this.g);
+        dataoutput.writeFloat(this.h);
+    }
+
+    public void handle(Connection connection) {
+        connection.a(this);
+    }
+
+    public int a() {
+        return 32 + this.e.size() * 3 + 3;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Packet61WorldEvent.java b/src/main/java/net/minecraft/server/Packet61WorldEvent.java
new file mode 100644
index 0000000..3b392aa
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Packet61WorldEvent.java
@@ -0,0 +1,52 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+public class Packet61WorldEvent extends Packet {
+
+    public int a;
+    public int b;
+    public int c;
+    public int d;
+    public int e;
+    private boolean f;
+
+    public Packet61WorldEvent() {}
+
+    public Packet61WorldEvent(int i, int j, int k, int l, int i1, boolean flag) {
+        this.a = i;
+        this.c = j;
+        this.d = k;
+        this.e = l;
+        this.b = i1;
+        this.f = flag;
+    }
+
+    public void a(DataInput datainput) throws IOException {
+        this.a = datainput.readInt();
+        this.c = datainput.readInt();
+        this.d = datainput.readByte() & 255;
+        this.e = datainput.readInt();
+        this.b = datainput.readInt();
+        this.f = datainput.readBoolean();
+    }
+
+    public void a(DataOutput dataoutput) throws IOException {
+        dataoutput.writeInt(this.a);
+        dataoutput.writeInt(this.c);
+        dataoutput.writeByte(this.d & 255);
+        dataoutput.writeInt(this.e);
+        dataoutput.writeInt(this.b);
+        dataoutput.writeBoolean(this.f);
+    }
+
+    public void handle(Connection connection) {
+        connection.a(this);
+    }
+
+    public int a() {
+        return 21;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Packet62NamedSoundEffect.java b/src/main/java/net/minecraft/server/Packet62NamedSoundEffect.java
new file mode 100644
index 0000000..170a86c
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Packet62NamedSoundEffect.java
@@ -0,0 +1,59 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+public class Packet62NamedSoundEffect extends Packet {
+
+    private String a;
+    private int b;
+    private int c = Integer.MAX_VALUE;
+    private int d;
+    private float e;
+    private int f;
+
+    public Packet62NamedSoundEffect() {}
+
+    public Packet62NamedSoundEffect(String s, double d0, double d1, double d2, float f, float f1) {
+        this.a = s;
+        this.b = (int) (d0 * 8.0D);
+        this.c = (int) (d1 * 8.0D);
+        this.d = (int) (d2 * 8.0D);
+        this.e = f;
+        this.f = (int) (f1 * 63.0F);
+        if (this.f < 0) {
+            this.f = 0;
+        }
+
+        if (this.f > 255) {
+            this.f = 255;
+        }
+    }
+
+    public void a(DataInput datainput) throws IOException {
+        this.a = a(datainput, 256);
+        this.b = datainput.readInt();
+        this.c = datainput.readInt();
+        this.d = datainput.readInt();
+        this.e = datainput.readFloat();
+        this.f = datainput.readUnsignedByte();
+    }
+
+    public void a(DataOutput dataoutput) throws IOException {
+        a(this.a, dataoutput);
+        dataoutput.writeInt(this.b);
+        dataoutput.writeInt(this.c);
+        dataoutput.writeInt(this.d);
+        dataoutput.writeFloat(this.e);
+        dataoutput.writeByte(this.f);
+    }
+
+    public void handle(Connection connection) {
+        connection.a(this);
+    }
+
+    public int a() {
+        return 24;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Packet63WorldParticles.java b/src/main/java/net/minecraft/server/Packet63WorldParticles.java
new file mode 100644
index 0000000..60e1237
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Packet63WorldParticles.java
@@ -0,0 +1,65 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+
+public class Packet63WorldParticles extends Packet {
+
+    private String a;
+    private float b;
+    private float c;
+    private float d;
+    private float e;
+    private float f;
+    private float g;
+    private float h;
+    private int i;
+
+    public Packet63WorldParticles() {}
+
+    // Spigot start - Added constructor
+    public Packet63WorldParticles(String particleName, float x, float y, float z, float offsetX, float offsetY, float offsetZ, float speed, int count) {
+        a = particleName;
+        b = x;
+        c = y;
+        d = z;
+        e = offsetX;
+        f = offsetY;
+        g = offsetZ;
+        h = speed;
+        i = count;
+    }
+    // Spigot end
+
+    public void a(DataInput datainput) throws java.io.IOException { // Spigot - throws
+        this.a = a(datainput, 64);
+        this.b = datainput.readFloat();
+        this.c = datainput.readFloat();
+        this.d = datainput.readFloat();
+        this.e = datainput.readFloat();
+        this.f = datainput.readFloat();
+        this.g = datainput.readFloat();
+        this.h = datainput.readFloat();
+        this.i = datainput.readInt();
+    }
+
+    public void a(DataOutput dataoutput) throws java.io.IOException { // Spigot - throws
+        a(this.a, dataoutput);
+        dataoutput.writeFloat(this.b);
+        dataoutput.writeFloat(this.c);
+        dataoutput.writeFloat(this.d);
+        dataoutput.writeFloat(this.e);
+        dataoutput.writeFloat(this.f);
+        dataoutput.writeFloat(this.g);
+        dataoutput.writeFloat(this.h);
+        dataoutput.writeInt(this.i);
+    }
+
+    public void handle(Connection connection) {
+        connection.a(this);
+    }
+
+    public int a() {
+        return 64;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Packet6SpawnPosition.java b/src/main/java/net/minecraft/server/Packet6SpawnPosition.java
new file mode 100644
index 0000000..1082db0
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Packet6SpawnPosition.java
@@ -0,0 +1,52 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+public class Packet6SpawnPosition extends Packet {
+
+    public int x;
+    public int y;
+    public int z;
+
+    public Packet6SpawnPosition() {}
+
+    public Packet6SpawnPosition(int i, int j, int k) {
+        this.x = i;
+        this.y = j;
+        this.z = k;
+    }
+
+    public void a(DataInput datainput) throws IOException {
+        this.x = datainput.readInt();
+        this.y = datainput.readInt();
+        this.z = datainput.readInt();
+    }
+
+    public void a(DataOutput dataoutput) throws IOException {
+        dataoutput.writeInt(this.x);
+        dataoutput.writeInt(this.y);
+        dataoutput.writeInt(this.z);
+    }
+
+    public void handle(Connection connection) {
+        connection.a(this);
+    }
+
+    public int a() {
+        return 12;
+    }
+
+    public boolean e() {
+        return true;
+    }
+
+    public boolean a(Packet packet) {
+        return true;
+    }
+
+    public boolean a_() {
+        return false;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Packet70Bed.java b/src/main/java/net/minecraft/server/Packet70Bed.java
new file mode 100644
index 0000000..c244868
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Packet70Bed.java
@@ -0,0 +1,43 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+public class Packet70Bed extends Packet {
+
+    public static final String[] a = new String[] { "tile.bed.notValid", null, null, "gameMode.changed"};
+    public int b;
+    public int c;
+
+    public Packet70Bed() {}
+
+    public Packet70Bed(int i, int j) {
+        if (i == 2) {           
+            this.b = 1;             
+        } else if (i == 1) {            
+            this.b = 2;             
+        } else {
+            this.b = i;
+        }
+
+        this.c = j;
+    }
+
+    public void a(DataInput datainput) {
+        throw new UnsupportedOperationException();
+    }
+
+    public void a(DataOutput dataoutput) throws IOException {
+        dataoutput.writeByte(this.b);
+        dataoutput.writeFloat((float)this.c);
+    }
+
+    public void handle(Connection connection) {
+        connection.a(this);
+    }
+
+    public int a() {
+        return 2;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Packet71Weather.java b/src/main/java/net/minecraft/server/Packet71Weather.java
new file mode 100644
index 0000000..4472cdd
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Packet71Weather.java
@@ -0,0 +1,46 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+public class Packet71Weather extends Packet {
+
+    public int a;
+    public int b;
+    public int c;
+    public int d;
+    public int e;
+
+    public Packet71Weather() {}
+
+    public Packet71Weather(Entity entity) {
+        this.a = entity.id;
+        this.b = MathHelper.floor(entity.locX * 32.0D);
+        this.c = MathHelper.floor(entity.locY * 32.0D);
+        this.d = MathHelper.floor(entity.locZ * 32.0D);
+        if (entity instanceof EntityLightning) {
+            this.e = 1;
+        }
+    }
+
+    public void a(DataInput datainput) {
+        throw new UnsupportedOperationException();
+    }
+
+    public void a(DataOutput dataoutput) throws IOException {
+        writeVarInt(this.a, dataoutput);
+        dataoutput.writeByte(this.e);
+        dataoutput.writeInt(this.b);
+        dataoutput.writeInt(this.c);
+        dataoutput.writeInt(this.d);
+    }
+
+    public void handle(Connection connection) {
+        connection.a(this);
+    }
+
+    public int a() {
+        return 17;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Packet7UseEntity.java b/src/main/java/net/minecraft/server/Packet7UseEntity.java
new file mode 100644
index 0000000..591bdaf
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Packet7UseEntity.java
@@ -0,0 +1,31 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+public class Packet7UseEntity extends Packet {
+
+    public int target;
+    public int action;
+
+    public Packet7UseEntity() {}
+
+    public void a(DataInput datainput) throws IOException {
+        this.target = datainput.readInt();
+        this.action = datainput.readByte();
+    }
+
+    public void a(DataOutput dataoutput) throws IOException {
+        dataoutput.writeInt(this.target);
+        dataoutput.writeByte(this.action);
+    }
+
+    public void handle(Connection connection) {
+        connection.a(this);
+    }
+
+    public int a() {
+        return 9;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Packet8UpdateHealth.java b/src/main/java/net/minecraft/server/Packet8UpdateHealth.java
new file mode 100644
index 0000000..5f0eb85
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Packet8UpdateHealth.java
@@ -0,0 +1,48 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+public class Packet8UpdateHealth extends Packet {
+
+    public float a;
+    public int b;
+    public float c;
+
+    public Packet8UpdateHealth() {}
+
+    public Packet8UpdateHealth(float f, int i, float f1) {
+        this.a = f;
+        this.b = i;
+        this.c = f1;
+    }
+
+    public void a(DataInput datainput) throws IOException {
+        this.a = datainput.readFloat();
+        this.b = datainput.readShort();
+        this.c = datainput.readFloat();
+    }
+
+    public void a(DataOutput dataoutput) throws IOException {
+        dataoutput.writeFloat(this.a);
+        dataoutput.writeShort(this.b);
+        dataoutput.writeFloat(this.c);
+    }
+
+    public void handle(Connection connection) {
+        connection.a(this);
+    }
+
+    public int a() {
+        return 8;
+    }
+
+    public boolean e() {
+        return true;
+    }
+
+    public boolean a(Packet packet) {
+        return true;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Packet9Respawn.java b/src/main/java/net/minecraft/server/Packet9Respawn.java
new file mode 100644
index 0000000..2b4e41b
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Packet9Respawn.java
@@ -0,0 +1,49 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+public class Packet9Respawn extends Packet {
+
+    public int a;
+    public int b;
+    public EnumGamemode d;
+    public WorldType e;
+
+    public Packet9Respawn() {}
+
+    public Packet9Respawn(int i, byte b0, WorldType worldtype, EnumGamemode enumgamemode) {
+        this.a = i;
+        this.b = b0;
+        this.d = enumgamemode;
+        this.e = worldtype;
+    }
+
+    public void handle(Connection connection) {
+        connection.a(this);
+    }
+
+    public void a(DataInput datainput) throws IOException {
+        this.a = datainput.readInt();
+        this.b = datainput.readByte();
+        this.d = EnumGamemode.a(datainput.readByte());
+        String s = a(datainput, 16);
+
+        this.e = WorldType.getType(s);
+        if (this.e == null) {
+            this.e = WorldType.NORMAL;
+        }
+    }
+
+    public void a(DataOutput dataoutput) throws IOException {
+        dataoutput.writeInt(this.a);
+        dataoutput.writeByte(this.b);
+        dataoutput.writeByte(this.d.a());
+        a(this.e.name(), dataoutput);
+    }
+
+    public int a() {
+        return 8 + (this.e == null ? 0 : this.e.name().length());
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PacketCounter.java b/src/main/java/net/minecraft/server/PacketCounter.java
new file mode 100644
index 0000000..4d732d2
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PacketCounter.java
@@ -0,0 +1,28 @@
+package net.minecraft.server;
+
+import java.util.HashMap;
+import java.util.Map;
+
+public class PacketCounter {
+
+    public static boolean a = true;
+    private static final Map b = new HashMap();
+    private static final Map c = new HashMap();
+    private static final Object d = new Object();
+
+    public static void a(int i, long j) {
+        if (a) {
+            Object object = d;
+
+            synchronized (d) {
+                if (b.containsKey(Integer.valueOf(i))) {
+                    b.put(Integer.valueOf(i), Long.valueOf(((Long) b.get(Integer.valueOf(i))).longValue() + 1L));
+                    c.put(Integer.valueOf(i), Long.valueOf(((Long) c.get(Integer.valueOf(i))).longValue() + j));
+                } else {
+                    b.put(Integer.valueOf(i), Long.valueOf(1L));
+                    c.put(Integer.valueOf(i), Long.valueOf(j));
+                }
+            }
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PacketLoginRequest.java b/src/main/java/net/minecraft/server/PacketLoginRequest.java
new file mode 100644
index 0000000..45b46ab
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PacketLoginRequest.java
@@ -0,0 +1,40 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+public class PacketLoginRequest extends Packet
+{
+
+    public String name;
+
+    public PacketLoginRequest()
+    {
+    }
+
+    @Override
+    public void a(DataInput datainput) throws IOException
+    {
+        name = a( datainput, 16 );
+    }
+
+    @Override
+    public void a(DataOutput dataoutput) throws IOException
+    {
+        throw new UnsupportedOperationException( "Not supported yet." ); //To change body of generated methods, choose Tools | Templates.
+    }
+
+    @Override
+    public void handle(Connection connection)
+    {
+        connection.a( this );
+    }
+
+    @Override
+    public int a()
+    {
+        return 0;
+    }
+
+}
diff --git a/src/main/java/net/minecraft/server/PacketLoginSuccess.java b/src/main/java/net/minecraft/server/PacketLoginSuccess.java
new file mode 100644
index 0000000..1ec6788
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PacketLoginSuccess.java
@@ -0,0 +1,48 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+public class PacketLoginSuccess extends Packet
+{
+
+    private String uuid;
+    private String name;
+
+    public PacketLoginSuccess()
+    {
+    }
+
+    public PacketLoginSuccess(String uuid, String name)
+    {
+        this.uuid = uuid;
+        this.name = name;
+    }
+
+    @Override
+    public void a(DataInput datainput) throws IOException
+    {
+        throw new UnsupportedOperationException( "Not supported yet." ); //To change body of generated methods, choose Tools | Templates.
+    }
+
+    @Override
+    public void a(DataOutput dataoutput) throws IOException
+    {
+        a( uuid, dataoutput );
+        a( name, dataoutput);
+    }
+
+    @Override
+    public void handle(Connection connection)
+    {
+        throw new UnsupportedOperationException( "Not supported yet." ); //To change body of generated methods, choose Tools | Templates.
+    }
+
+    @Override
+    public int a()
+    {
+        return 0;
+    }
+
+}
diff --git a/src/main/java/net/minecraft/server/PacketPingTime.java b/src/main/java/net/minecraft/server/PacketPingTime.java
new file mode 100644
index 0000000..21bc272
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PacketPingTime.java
@@ -0,0 +1,45 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+public class PacketPingTime extends Packet
+{
+
+    public long l;
+
+    public PacketPingTime()
+    {
+    }
+
+    public PacketPingTime(long l)
+    {
+        this.l = l;
+    }
+
+    @Override
+    public void a(DataInput datainput) throws IOException
+    {
+        l = datainput.readLong();
+    }
+
+    @Override
+    public void a(DataOutput dataoutput) throws IOException
+    {
+        dataoutput.writeLong( l );
+    }
+
+    @Override
+    public void handle(Connection connection)
+    {
+        connection.a( this );
+    }
+
+    @Override
+    public int a()
+    {
+        return 0;
+    }
+
+}
diff --git a/src/main/java/net/minecraft/server/PacketStatusRequest.java b/src/main/java/net/minecraft/server/PacketStatusRequest.java
new file mode 100644
index 0000000..2508a0f
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PacketStatusRequest.java
@@ -0,0 +1,38 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+public class PacketStatusRequest extends Packet
+{
+
+    public PacketStatusRequest()
+    {
+    }
+
+    @Override
+    public void a(DataInput datainput) throws IOException
+    {
+
+    }
+
+    @Override
+    public void a(DataOutput dataoutput) throws IOException
+    {
+
+    }
+
+    @Override
+    public void handle(Connection connection)
+    {
+        connection.a( this );
+    }
+
+    @Override
+    public int a()
+    {
+        return 0;
+    }
+
+}
diff --git a/src/main/java/net/minecraft/server/PathfinderGoalMeleeAttack.java b/src/main/java/net/minecraft/server/PathfinderGoalMeleeAttack.java
index a07c6cf..ee4bc7e 100644
--- a/src/main/java/net/minecraft/server/PathfinderGoalMeleeAttack.java
+++ b/src/main/java/net/minecraft/server/PathfinderGoalMeleeAttack.java
@@ -63,19 +63,88 @@ public class PathfinderGoalMeleeAttack extends PathfinderGoal {
         this.b.getNavigation().h();
     }
 
+    // Spigot start
+    private double pathX;
+    private double pathY;
+    private double pathZ;
+    private boolean prevPathOK;
+    private int fullRangeSearchDelay;
+    // Spigot end
     public void e() {
         EntityLiving entityliving = this.b.getGoalTarget();
 
         this.b.getControllerLook().a(entityliving, 30.0F, 30.0F);
+        double goalDistanceSq = this.b.e( entityliving.locX, entityliving.boundingBox.b, entityliving.locZ ); // Spigot
         if ((this.e || this.b.getEntitySenses().canSee(entityliving)) && --this.h <= 0) {
-            this.h = 4 + this.b.aD().nextInt(7);
-            this.b.getNavigation().a((Entity) entityliving, this.d);
+            // Spigot start
+            double targetMovement = entityliving.e( pathX, pathY, pathZ );
+            // If this is true, then we are re-pathing
+            if ( ( this.h <= 0 && targetMovement >= 1.0D ) || ( this.h <= 0 && this.b.aD().nextInt( 200 ) == 0 ) ) /* EntityCreature random instance */
+
+            {
+                AttributeInstance rangeAttr = this.b.getAttributeInstance( GenericAttributes.b );
+                double origRange = rangeAttr.getValue();
+                if ( fullRangeSearchDelay > 0 )
+                {
+
+                    double dist = Math.sqrt( goalDistanceSq );
+                    if ( dist <= 8.0D )
+                    {
+                        dist = 8.0D;
+                    }
+                    if ( dist > origRange )
+                    {
+                        dist = origRange;
+                    }
+                    rangeAttr.setValue( dist );
+                }
+
+                prevPathOK = this.b.getNavigation().a( (Entity) entityliving, this.d );
+
+                if ( fullRangeSearchDelay > 0 )
+                {
+                    fullRangeSearchDelay--;
+                    if ( origRange > 40.0D )
+                    {
+                        origRange = 40.0D;
+                    }
+                    rangeAttr.setValue( origRange );
+                }
+
+                pathX = entityliving.locX;
+                pathY = entityliving.boundingBox.b;
+                pathZ = entityliving.locZ;
+                this.h = 4 + this.b.aD().nextInt( 7 ); /* EntityCreature random instance */
+
+                if ( goalDistanceSq > 256.0D )
+                {
+                    if ( goalDistanceSq > 1024.0D )
+                    {
+                        this.h += 8;
+                    } else
+                    {
+                        this.h += 16;
+                    }
+                } else if ( !prevPathOK )
+                {
+                    this.h += 24;
+                }
+
+                if ( !prevPathOK || goalDistanceSq <= 256.0D )
+                {
+                    if ( fullRangeSearchDelay <= 0 )
+                    {
+                        fullRangeSearchDelay = 4 + this.b.aD().nextInt( 4 ); /* EntityCreature random instance */
+                    }
+                }
+            }
         }
+        // Spigot end
 
         this.c = Math.max(this.c - 1, 0);
         double d0 = (double) (this.b.width * 2.0F * this.b.width * 2.0F + entityliving.width);
 
-        if (this.b.e(entityliving.locX, entityliving.boundingBox.b, entityliving.locZ) <= d0) {
+        if (goalDistanceSq <= d0) { // Spigot
             if (this.c <= 0) {
                 this.c = 20;
                 if (this.b.aZ() != null) {
diff --git a/src/main/java/net/minecraft/server/PendingConnection.java b/src/main/java/net/minecraft/server/PendingConnection.java
index 2a96168..a5169db 100644
--- a/src/main/java/net/minecraft/server/PendingConnection.java
+++ b/src/main/java/net/minecraft/server/PendingConnection.java
@@ -1,22 +1,26 @@
 package net.minecraft.server;
 
-import java.io.Serializable;
+import com.google.common.base.Preconditions;
+import com.google.gson.Gson;
 import java.net.InetAddress;
+import java.net.InetSocketAddress;
 import java.net.Socket;
 import java.security.PrivateKey;
 import java.security.PublicKey;
 import java.util.Arrays;
-import java.util.Iterator;
-import java.util.List;
 import java.util.Random;
+import java.util.UUID;
 import javax.crypto.SecretKey;
+import org.bukkit.craftbukkit.event.CraftEventFactory;
+import org.bukkit.event.server.ServerListPingEvent;
+import org.spigotmc.netty.ServerPing;
 
 public class PendingConnection extends Connection {
 
     private static Random random = new Random();
     private byte[] d;
     private final MinecraftServer server;
-    public final NetworkManager networkManager;
+    public final INetworkManager networkManager;
     public boolean b;
     private int f;
     private String g;
@@ -26,10 +30,15 @@ public class PendingConnection extends Connection {
     private SecretKey k;
     public String hostname = ""; // CraftBukkit - add field
 
+    public PendingConnection(MinecraftServer minecraftserver, org.spigotmc.netty.NettyNetworkManager networkManager) {
+        this.server = minecraftserver;
+        this.networkManager = networkManager;
+    }
+
     public PendingConnection(MinecraftServer minecraftserver, Socket socket, String s) throws java.io.IOException { // CraftBukkit - throws IOException
         this.server = minecraftserver;
         this.networkManager = new NetworkManager(minecraftserver.getLogger(), socket, s, this, minecraftserver.H().getPrivate());
-        this.networkManager.e = 0;
+        // this.networkManager.e = 0;
     }
 
     // CraftBukkit start
@@ -61,34 +70,79 @@ public class PendingConnection extends Connection {
         }
     }
 
-    public void a(Packet2Handshake packet2handshake) {
-        if (this.g != null) {
-            this.disconnect("Quit repeating yourself!");
-        } else {
-            this.hostname = packet2handshake.c + ':' + packet2handshake.d; // CraftBukkit - initialize field
-            this.g = packet2handshake.f();
-            if (!this.g.equals(StripColor.a(this.g))) {
-                this.disconnect("Invalid username!");
-            } else {
-                PublicKey publickey = this.server.H().getPublic();
+    private enum State
+    {
 
-                if (packet2handshake.d() != 78) {
-                    if (packet2handshake.d() > 78) {
-                        this.disconnect("Outdated server!");
-                    } else {
-                        this.disconnect("Outdated client!");
-                    }
-                } else {
-                    this.loginKey = this.server.getOnlineMode() ? Long.toString(random.nextLong(), 16) : "-";
-                    this.d = new byte[4];
-                    random.nextBytes(this.d);
-                    this.networkManager.queue(new Packet253KeyRequest(this.loginKey, publickey, this.d));
-                }
+        HANDSHAKE, STATUS, PING, USERNAME, ENCRYPT, FINISHED;
+    }
+    private State state = State.HANDSHAKE;
+    private static final java.util.regex.Pattern validName = java.util.regex.Pattern.compile("^[a-zA-Z0-9_-]{2,16}$"); // Spigot
+    public void a(Packet2Handshake packet2handshake) {
+        Preconditions.checkState( state == State.HANDSHAKE,"Not handshakey now");
+        hostname = packet2handshake.serverAddress;
+        if (packet2handshake.protocolVersion != 4){
+            disconnect( "Outdated client!");
+        }
+        if ( org.spigotmc.SpigotConfig.bungee )
+        {
+            String[] split = packet2handshake.serverAddress.split( "\00" );
+            if ( split.length == 2 )
+            {
+                hostname = split[0];
+                networkManager.setSocketAddress( new InetSocketAddress( split[1], packet2handshake.serverPort ) );
             }
         }
+        switch ( packet2handshake.state )
+        {
+            case 1:
+                state = State.STATUS;
+                break;
+            case 2:
+                state = State.USERNAME;
+                break;
+        }
+    }
+
+    @Override
+    public void a(PacketPingTime time)
+    {
+        Preconditions.checkState( state == State.PING, "ping" );
+        networkManager.queue( new PacketPingTime( time.l ) );
+        disconnect( "" );
+    }
+
+    @Override
+    public void a(PacketLoginRequest request)
+    {
+        Preconditions.checkState( state == State.USERNAME );
+        this.g = request.name;
+        if ( this.server.getOnlineMode() )
+        {
+            PublicKey publickey = this.server.H().getPublic();
+            this.loginKey = this.server.getOnlineMode() ? Long.toString( random.nextLong(), 16 ) : "-";
+            this.d = new byte[ 4 ];
+            random.nextBytes( this.d );
+            this.networkManager.queue( new Packet253KeyRequest( this.loginKey, publickey, this.d ) );
+            state = State.ENCRYPT;
+        } else {
+           (new ThreadLoginVerifier(this, server.server)).start();
+        }
+    }
+
+    @Override
+    public void a(PacketStatusRequest request)
+    {
+        Preconditions.checkState( state == State.STATUS,"status");
+        ServerListPingEvent event = CraftEventFactory.callServerListPingEvent(server.server, getSocket().getInetAddress(),server.getMotd(), server.getPlayerList().getPlayerCount(),server.getPlayerList().getMaxPlayers());
+        ServerPing response = new ServerPing( new ServerPing.Protocol( "1.7.2", 0x04 ), new ServerPing.Players( event.getMaxPlayers(),event.getNumPlayers() ),
+                event.getMotd(), server.favicon );
+        networkManager.queue( new Packet255KickDisconnect( new Gson().toJson( response ) ) );
+        state = State.PING;
     }
 
-    public void a(Packet252KeyResponse packet252keyresponse) {
+    public void a(Packet252KeyResponse packet252keyresponse)
+    {
+        Preconditions.checkState( state == State.ENCRYPT, "encrypt");
         PrivateKey privatekey = this.server.H().getPrivate();
 
         this.k = packet252keyresponse.a(privatekey);
@@ -96,30 +150,31 @@ public class PendingConnection extends Connection {
             this.disconnect("Invalid client reply");
         }
 
-        this.networkManager.queue(new Packet252KeyResponse());
-    }
-
-    public void a(Packet205ClientCommand packet205clientcommand) {
-        if (packet205clientcommand.a == 0) {
             if (this.j) {
                 this.disconnect("Duplicate login");
                 return;
             }
 
             this.j = true;
-            if (this.server.getOnlineMode()) {
+            if (true) { // Spigot - Always fire
                 (new ThreadLoginVerifier(this, server.server)).start(); // CraftBukkit - add CraftServer
             } else {
                 this.h = true;
             }
-        }
     }
 
-    public void a(Packet1Login packet1login) {}
+    public void a(Packet205ClientCommand packet205clientcommand) {
+
+    }
 
+    public void a(Packet1Login packet1login) {}
+public String uuid;
     public void e() {
         // CraftBukkit start
-        EntityPlayer s = this.server.getPlayerList().attemptLogin(this, this.g, this.hostname);
+        if (uuid == null){
+            uuid = UUID.randomUUID().toString();
+        }
+        EntityPlayer s = this.server.getPlayerList().attemptLogin(this, this.g, this.hostname, uuid);
 
         if (s == null) {
             // this.disconnect(s);
@@ -129,11 +184,13 @@ public class PendingConnection extends Connection {
             EntityPlayer entityplayer = this.server.getPlayerList().processLogin(s); // CraftBukkit - this.g -> s
 
             if (entityplayer != null) {
+                this.networkManager.queue( new PacketLoginSuccess(uuid, g));
                 this.server.getPlayerList().a((INetworkManager) this.networkManager, entityplayer);
             }
         }
 
         this.b = true;
+        state = State.FINISHED;
     }
 
     public void a(String s, Object[] aobject) {
@@ -148,7 +205,7 @@ public class PendingConnection extends Connection {
             String s = null;
             // CraftBukkit
             org.bukkit.event.server.ServerListPingEvent pingEvent = org.bukkit.craftbukkit.event.CraftEventFactory.callServerListPingEvent(this.server.server, getSocket().getInetAddress(), this.server.getMotd(), playerlist.getPlayerCount(), playerlist.getMaxPlayers());
-            if (packet254getinfo.d()) {
+            if (false) { // Spigot: TODO: Use trick from Bungee maybe?
                 // CraftBukkit
                 s = pingEvent.getMotd() + "\u00A7" + playerlist.getPlayerCount() + "\u00A7" + pingEvent.getMaxPlayers();
             } else {
@@ -177,9 +234,18 @@ public class PendingConnection extends Connection {
 
             this.networkManager.queue(new Packet255KickDisconnect(s));
             this.networkManager.d();
-            if (inetaddress != null && this.server.ag() instanceof DedicatedServerConnection) {
-                ((DedicatedServerConnection) this.server.ag()).a(inetaddress);
+            // Spigot start
+            if ( inetaddress != null )
+            {
+                if ( this.server.ag() instanceof DedicatedServerConnection )
+                {
+                    ((DedicatedServerConnection) this.server.ag()).a(inetaddress);
+                } else
+                {
+                    ((org.spigotmc.netty.NettyServerConnection)this.server.ag()).unThrottle( inetaddress );
+                }
             }
+            // Spigot end
 
             this.b = true;
         } catch (Exception exception) {
diff --git a/src/main/java/net/minecraft/server/PlayerChunkMap.java b/src/main/java/net/minecraft/server/PlayerChunkMap.java
index 4e0398c..ae4ca63 100644
--- a/src/main/java/net/minecraft/server/PlayerChunkMap.java
+++ b/src/main/java/net/minecraft/server/PlayerChunkMap.java
@@ -24,7 +24,7 @@ public class PlayerChunkMap {
     public PlayerChunkMap(WorldServer worldserver, int i) {
         if (i > 15) {
             throw new IllegalArgumentException("Too big view radius!");
-        } else if (i < 3) {
+        } else if (i < 1) {
             throw new IllegalArgumentException("Too small view radius!");
         } else {
             this.f = i;
diff --git a/src/main/java/net/minecraft/server/PlayerConnection.java b/src/main/java/net/minecraft/server/PlayerConnection.java
index e4cb5c7..5f87e39 100644
--- a/src/main/java/net/minecraft/server/PlayerConnection.java
+++ b/src/main/java/net/minecraft/server/PlayerConnection.java
@@ -5,7 +5,6 @@ import java.io.DataInput;
 import java.io.DataInputStream;
 import java.io.IOException;
 import java.util.ArrayList;
-import java.util.Iterator;
 import java.util.Random;
 import java.util.concurrent.Callable;
 
@@ -16,6 +15,7 @@ import java.io.UnsupportedEncodingException;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
 import java.util.HashSet;
+import java.util.List;
 
 import org.bukkit.craftbukkit.inventory.CraftInventoryView;
 import org.bukkit.craftbukkit.inventory.CraftItemStack;
@@ -96,6 +96,7 @@ public class PlayerConnection extends Connection {
     private float lastPitch = Float.MAX_VALUE;
     private float lastYaw = Float.MAX_VALUE;
     private boolean justTeleported = false;
+    private boolean hasMoved; // Spigot
 
     // For the packet15 hack :(
     Long lastPacket;
@@ -159,7 +160,7 @@ public class PlayerConnection extends Connection {
             // CraftBukkit end
 
             this.player.l();
-            this.sendPacket(new Packet255KickDisconnect(s));
+            this.sendPacket(new Packet255KickDisconnect(ChatMessage.d( s ).i()));
             this.networkManager.d();
 
             // CraftBukkit start
@@ -222,7 +223,7 @@ public class PlayerConnection extends Connection {
                 this.lastPitch = to.getPitch();
 
                 // Skip the first time we do this
-                if (from.getX() != Double.MAX_VALUE) {
+                if (hasMoved) { // Spigot - Better Check!
                     PlayerMoveEvent event = new PlayerMoveEvent(player, from, to);
                     this.server.getPluginManager().callEvent(event);
 
@@ -246,7 +247,7 @@ public class PlayerConnection extends Connection {
                         this.justTeleported = false;
                         return;
                     }
-                }
+                } else { hasMoved = true; } // Spigot - Better Check!
             }
 
             if (Double.isNaN(packet10flying.x) || Double.isNaN(packet10flying.y) || Double.isNaN(packet10flying.z) || Double.isNaN(packet10flying.stance)) {
@@ -843,7 +844,17 @@ public class PlayerConnection extends Connection {
                 }
 
                 // This section stays because it is only applicable to packets
-                if (chatSpamField.addAndGet(this, 20) > 200 && !this.minecraftServer.getPlayerList().isOp(this.player.getName())) { // CraftBukkit use thread-safe spam
+                // Spigot - spam exclusions
+                boolean counted = true;
+                for ( String exclude : org.spigotmc.SpigotConfig.spamExclusions )
+                {
+                    if ( exclude != null && s.startsWith( exclude ) )
+                    {
+                        counted = false;
+                        break;
+                    }
+                }
+                if (counted && chatSpamField.addAndGet(this, 20) > 200 && !this.minecraftServer.getPlayerList().isOp(this.player.getName())) { // CraftBukkit use thread-safe spam
                     if (packet3chat.a_()) {
                         Waitable waitable = new Waitable() {
                             @Override
@@ -907,7 +918,7 @@ public class PlayerConnection extends Connection {
                             PlayerConnection.this.minecraftServer.console.sendMessage(message);
                             if (((LazyPlayerSet) queueEvent.getRecipients()).isLazy()) {
                                 for (Object player : PlayerConnection.this.minecraftServer.getPlayerList().players) {
-                                    ((EntityPlayer) player).sendMessage(ChatMessage.d(message));
+                                    ((EntityPlayer) player).getBukkitEntity().sendMessage(message);
                                 }
                             } else {
                                 for (Player player : queueEvent.getRecipients()) {
@@ -937,7 +948,7 @@ public class PlayerConnection extends Connection {
                     minecraftServer.console.sendMessage(s);
                     if (((LazyPlayerSet) event.getRecipients()).isLazy()) {
                         for (Object recipient : minecraftServer.getPlayerList().players) {
-                            ((EntityPlayer) recipient).sendMessage(ChatMessage.d(s));
+                            ((EntityPlayer) recipient).getBukkitEntity().sendMessage(s);
                         }
                     } else {
                         for (Player recipient : event.getRecipients()) {
@@ -953,6 +964,7 @@ public class PlayerConnection extends Connection {
     // CraftBukkit end
 
     private void handleCommand(String s) {
+        org.bukkit.craftbukkit.SpigotTimings.playerCommandTimer.startTiming(); // Spigot
         // CraftBukkit start
         CraftPlayer player = this.getPlayer();
 
@@ -960,19 +972,28 @@ public class PlayerConnection extends Connection {
         this.server.getPluginManager().callEvent(event);
 
         if (event.isCancelled()) {
+            org.bukkit.craftbukkit.SpigotTimings.playerCommandTimer.stopTiming(); // Spigot
             return;
         }
 
         try {
-            this.minecraftServer.getLogger().info(event.getPlayer().getName() + " issued server command: " + event.getMessage()); // CraftBukkit
+            // Spigot Start
+            if ( org.spigotmc.SpigotConfig.logCommands )
+            {
+                this.minecraftServer.getLogger().info(event.getPlayer().getName() + " issued server command: " + event.getMessage()); // CraftBukkit
+            }
+            // Spigot end
             if (this.server.dispatchCommand(event.getPlayer(), event.getMessage().substring(1))) {
+                org.bukkit.craftbukkit.SpigotTimings.playerCommandTimer.stopTiming(); // Spigot
                 return;
             }
         } catch (org.bukkit.command.CommandException ex) {
             player.sendMessage(org.bukkit.ChatColor.RED + "An internal error occurred while attempting to perform this command");
             java.util.logging.Logger.getLogger(PlayerConnection.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
+            org.bukkit.craftbukkit.SpigotTimings.playerCommandTimer.stopTiming(); // Spigot
             return;
         }
+        org.bukkit.craftbukkit.SpigotTimings.playerCommandTimer.stopTiming(); // Spigot
         // CraftBukkit end
 
         /* CraftBukkit start - No longer needed as we have already handled it in server.dispatchServerCommand above.
@@ -1076,6 +1097,13 @@ public class PlayerConnection extends Connection {
 
         WorldServer worldserver = this.minecraftServer.getWorldServer(this.player.dimension);
         Entity entity = worldserver.getEntity(packet7useentity.target);
+        // Spigot Start
+        if ( entity == player )
+        {
+            disconnect( "Cannot interact with self!" );
+            return;
+        }
+        // Spigot End
 
         this.player.u();
         if (entity != null) {
@@ -1140,7 +1168,7 @@ public class PlayerConnection extends Connection {
 
     public void a(Packet205ClientCommand packet205clientcommand) {
         this.player.u();
-        if (packet205clientcommand.a == 1) {
+        if (packet205clientcommand.a == 0) {
             if (this.player.viewingCredits) {
                 this.minecraftServer.getPlayerList().changeDimension(this.player, 0, PlayerTeleportEvent.TeleportCause.END_PORTAL); // CraftBukkit - reroute logic through custom portal management
             } else if (this.player.p().getWorldData().isHardcore()) {
@@ -1161,6 +1189,8 @@ public class PlayerConnection extends Connection {
 
                 this.player = this.minecraftServer.getPlayerList().moveToWorld(this.player, 0, false);
             }
+        } else if (packet205clientcommand.a == 1) {
+            this.player.playerConnection.sendPacket(new Packet200Statistic("achievement.openInventory", 1));
         }
     }
 
@@ -1581,7 +1611,7 @@ public class PlayerConnection extends Connection {
                     flag = false;
                 } else {
                     for (i = 0; i < packet130updatesign.lines[j].length(); ++i) {
-                        if (SharedConstants.allowedCharacters.indexOf(packet130updatesign.lines[j].charAt(i)) < 0) {
+                        if (!SharedConstants.isAllowedChatCharacter(packet130updatesign.lines[j].charAt(i))) { // Spigot
                             flag = false;
                         }
                     }
@@ -1649,18 +1679,10 @@ public class PlayerConnection extends Connection {
     }
 
     public void a(Packet203TabComplete packet203tabcomplete) {
-        StringBuilder stringbuilder = new StringBuilder();
 
-        String s;
+        String[] s = ((List<String>)this.minecraftServer.a(this.player, packet203tabcomplete.read)).toArray( new String[0]);
 
-        for (Iterator iterator = this.minecraftServer.a(this.player, packet203tabcomplete.d()).iterator(); iterator.hasNext(); stringbuilder.append(s)) {
-            s = (String) iterator.next();
-            if (stringbuilder.length() > 0) {
-                stringbuilder.append('\0'); // CraftBukkit - fix decompile issue
-            }
-        }
-
-        this.player.playerConnection.sendPacket(new Packet203TabComplete(stringbuilder.toString()));
+        this.player.playerConnection.sendPacket(new Packet203TabComplete(s));
     }
 
     public void a(Packet204LocaleAndViewDistance packet204localeandviewdistance) {
@@ -1741,16 +1763,22 @@ public class PlayerConnection extends Connection {
                     } else if (this.player.a(2, "") && this.player.abilities.canInstantlyBuild) {
                         try {
                             datainputstream = new DataInputStream(new ByteArrayInputStream(packet250custompayload.data));
-                            i = datainputstream.readInt();
-                            j = datainputstream.readInt();
-                            int k = datainputstream.readInt();
-                            String s = Packet.a((DataInput) datainputstream, 256);
-                            TileEntity tileentity = this.player.world.getTileEntity(i, j, k);
-
-                            if (tileentity != null && tileentity instanceof TileEntityCommand) {
-                                ((TileEntityCommand) tileentity).a(s);
-                                this.player.world.notify(i, j, k);
-                                this.player.sendMessage(ChatMessage.b("advMode.setCommand.success", new Object[] { s}));
+                            byte type = datainputstream.readByte();
+                            switch (type) {
+                                case 0: //Command block
+                                    i = datainputstream.readInt();
+                                    j = datainputstream.readInt();
+                                    int k = datainputstream.readInt();
+                                    String s = Packet.a((DataInput) datainputstream, 256);
+                                    TileEntity tileentity = this.player.world.getTileEntity(i, j, k);
+
+                                    if (tileentity != null && tileentity instanceof TileEntityCommand) {
+                                        ((TileEntityCommand) tileentity).a(s);
+                                        this.player.world.notify(i, j, k);
+                                        this.player.sendMessage(ChatMessage.b("advMode.setCommand.success", new Object[] { s}));
+                                    }
+                                case 1: //Command block minecart
+                                    //Not supported - ignore
                             }
                         } catch (Exception exception3) {
                             // CraftBukkit start
diff --git a/src/main/java/net/minecraft/server/PlayerInteractManager.java b/src/main/java/net/minecraft/server/PlayerInteractManager.java
index 16420e4..db2e2a7 100644
--- a/src/main/java/net/minecraft/server/PlayerInteractManager.java
+++ b/src/main/java/net/minecraft/server/PlayerInteractManager.java
@@ -184,6 +184,7 @@ public class PlayerInteractManager {
                     this.o = j1;
                 }
             }
+            world.spigotConfig.antiXrayInstance.updateNearbyBlocks(world, i, j, k); // Spigot
         }
     }
 
diff --git a/src/main/java/net/minecraft/server/PlayerList.java b/src/main/java/net/minecraft/server/PlayerList.java
index 5dafeaf..d306262 100644
--- a/src/main/java/net/minecraft/server/PlayerList.java
+++ b/src/main/java/net/minecraft/server/PlayerList.java
@@ -30,6 +30,7 @@ import org.bukkit.event.player.PlayerQuitEvent;
 import org.bukkit.event.player.PlayerRespawnEvent;
 import org.bukkit.event.player.PlayerTeleportEvent.TeleportCause;
 import org.bukkit.util.Vector;
+import org.spigotmc.ChatConverter;
 // CraftBukkit end
 
 public abstract class PlayerList {
@@ -89,9 +90,10 @@ public abstract class PlayerList {
         if (maxPlayers > 60) {
             maxPlayers = 60;
         }
-        playerconnection.sendPacket(new Packet1Login(entityplayer.id, worldserver.getWorldData().getType(), entityplayer.playerInteractManager.getGameMode(), worldserver.getWorldData().isHardcore(), worldserver.worldProvider.dimension, worldserver.difficulty, worldserver.getHeight(), maxPlayers));
+        playerconnection.sendPacket(new Packet1Login(entityplayer.id, worldserver.getWorldData().getType(), entityplayer.playerInteractManager.getGameMode(), worldserver.getWorldData().isHardcore(), worldserver.worldProvider.dimension, worldserver.difficulty, maxPlayers));
         entityplayer.getBukkitEntity().sendSupportedChannels();
         // CraftBukkit end
+        playerconnection.sendPacket(new Packet200Statistic("achievement.openInventory", 1));
 
         playerconnection.sendPacket(new Packet250CustomPayload("MC|Brand", this.getServer().getServerModName().getBytes(Charsets.UTF_8)));
         playerconnection.sendPacket(new Packet6SpawnPosition(chunkcoordinates.x, chunkcoordinates.y, chunkcoordinates.z));
@@ -209,7 +211,9 @@ public abstract class PlayerList {
         String joinMessage = playerJoinEvent.getJoinMessage();
 
         if ((joinMessage != null) && (joinMessage.length() > 0)) {
-            this.server.getPlayerList().sendAll(new Packet3Chat(ChatMessage.d(joinMessage)));
+            for (String msg : ChatConverter.toJSONChat(joinMessage)) {
+                this.server.getPlayerList().sendAll(new Packet3Chat(msg));
+            }
         }
         this.cserver.onPlayerJoin(playerJoinEvent.getPlayer());
 
@@ -290,13 +294,14 @@ public abstract class PlayerList {
     }
 
     // CraftBukkit start - Whole method and signature
-    public EntityPlayer attemptLogin(PendingConnection pendingconnection, String s, String hostname) {
+    public EntityPlayer attemptLogin(PendingConnection pendingconnection, String s, String hostname, String uuid) {
         // Instead of kicking then returning, we need to store the kick reason
         // in the event, check with plugins to see if it's ok, and THEN kick
         // depending on the outcome.
         EntityPlayer entity = new EntityPlayer(this.server, this.server.getWorldServer(0), s, this.server.O() ? new DemoPlayerInteractManager(this.server.getWorldServer(0)) : new PlayerInteractManager(this.server.getWorldServer(0)));
+        entity.playerUUID = uuid;
         Player player = entity.getBukkitEntity();
-        PlayerLoginEvent event = new PlayerLoginEvent(player, hostname, pendingconnection.getSocket().getInetAddress());
+        PlayerLoginEvent event = new PlayerLoginEvent(player, hostname, ((java.net.InetSocketAddress) pendingconnection.networkManager.getSocketAddress()).getAddress(), pendingconnection.getSocket().getInetAddress()); // Spigot
 
         SocketAddress socketaddress = pendingconnection.networkManager.getSocketAddress();
 
@@ -310,7 +315,7 @@ public abstract class PlayerList {
 
             event.disallow(PlayerLoginEvent.Result.KICK_BANNED, s1);
         } else if (!this.isWhitelisted(s)) {
-            event.disallow(PlayerLoginEvent.Result.KICK_WHITELIST, "You are not white-listed on this server!");
+            event.disallow(PlayerLoginEvent.Result.KICK_WHITELIST, org.spigotmc.SpigotConfig.whitelistMessage); // Spigot
         } else {
             String s2 = socketaddress.toString();
 
@@ -326,7 +331,7 @@ public abstract class PlayerList {
 
                 event.disallow(PlayerLoginEvent.Result.KICK_BANNED, s3);
             } else if (this.players.size() >= this.maxPlayers) {
-                event.disallow(PlayerLoginEvent.Result.KICK_FULL, "The server is full!");
+                event.disallow(PlayerLoginEvent.Result.KICK_FULL, org.spigotmc.SpigotConfig.serverFullMessage); // Spigot
             } else {
                 event.disallow(PlayerLoginEvent.Result.ALLOWED, s2);
             }
@@ -423,6 +428,9 @@ public abstract class PlayerList {
             Player respawnPlayer = this.cserver.getPlayer(entityplayer1);
             PlayerRespawnEvent respawnEvent = new PlayerRespawnEvent(respawnPlayer, location, isBedSpawn);
             this.cserver.getPluginManager().callEvent(respawnEvent);
+            if (entityplayer.playerConnection.disconnected) {
+                return entityplayer;
+            }
 
             location = respawnEvent.getRespawnLocation();
             entityplayer.reset();
@@ -442,8 +450,8 @@ public abstract class PlayerList {
         // CraftBukkit start
         byte actualDimension = (byte) (worldserver.getWorld().getEnvironment().getId());
         // Force the client to refresh their chunk cache.
-        entityplayer1.playerConnection.sendPacket(new Packet9Respawn((byte) (actualDimension >= 0 ? -1 : 0), (byte) worldserver.difficulty, worldserver.getWorldData().getType(), worldserver.getHeight(), entityplayer.playerInteractManager.getGameMode()));
-        entityplayer1.playerConnection.sendPacket(new Packet9Respawn(actualDimension, (byte) worldserver.difficulty, worldserver.getWorldData().getType(), worldserver.getHeight(), entityplayer.playerInteractManager.getGameMode()));
+        entityplayer1.playerConnection.sendPacket(new Packet9Respawn((byte) (actualDimension >= 0 ? -1 : 0), (byte) worldserver.difficulty, worldserver.getWorldData().getType(), entityplayer.playerInteractManager.getGameMode()));
+        entityplayer1.playerConnection.sendPacket(new Packet9Respawn(actualDimension, (byte) worldserver.difficulty, worldserver.getWorldData().getType(), entityplayer.playerInteractManager.getGameMode()));
         entityplayer1.spawnIn(worldserver);
         entityplayer1.dead = false;
         entityplayer1.playerConnection.teleport(new Location(worldserver.getWorld(), entityplayer1.locX, entityplayer1.locY, entityplayer1.locZ, entityplayer1.yaw, entityplayer1.pitch));
@@ -720,6 +728,25 @@ public abstract class PlayerList {
             this.sendAll(new Packet201PlayerInfo(entityplayer.getName(), true, entityplayer.ping));
         }
         // CraftBukkit end */
+        // Spigot start
+        if ( !players.isEmpty() )
+        {
+            int index = MinecraftServer.currentTick % this.players.size();
+            EntityPlayer player = (EntityPlayer) this.players.get( index );
+            if ( player.lastPing == -1 || Math.abs( player.ping - player.lastPing ) > 20 )
+            {
+                Packet packet = new Packet201PlayerInfo( player.listName, true, player.ping );
+                for ( EntityPlayer splayer : (List<EntityPlayer>) this.players )
+                {
+                    if ( splayer.getBukkitEntity().canSee( player.getBukkitEntity() ) )
+                    {
+                        splayer.playerConnection.sendPacket( packet );
+                    }
+                }
+                player.lastPing = player.ping;
+            }
+        }
+        // Spigot end
     }
 
     public void sendAll(Packet packet) {
@@ -1045,7 +1072,14 @@ public abstract class PlayerList {
 
     public void r() {
         while (!this.players.isEmpty()) {
-            ((EntityPlayer) this.players.get(0)).playerConnection.disconnect(this.server.server.getShutdownMessage()); // CraftBukkit - add custom shutdown message
+            // Spigot start
+            EntityPlayer p = (EntityPlayer) this.players.get( 0 );
+            p.playerConnection.disconnect( this.server.server.getShutdownMessage() );
+            if ( ( !this.players.isEmpty() ) && ( this.players.get( 0 ) == p ) )
+            {
+                this.players.remove( 0 ); // Prevent shutdown hang if already disconnected
+            }
+            // Spigot end
         }
     }
 
diff --git a/src/main/java/net/minecraft/server/PropertyManager.java b/src/main/java/net/minecraft/server/PropertyManager.java
index 03aa219..a45c4ea 100644
--- a/src/main/java/net/minecraft/server/PropertyManager.java
+++ b/src/main/java/net/minecraft/server/PropertyManager.java
@@ -53,7 +53,7 @@ public class PropertyManager {
     }
 
     private <T> T getOverride(String name, T value) {
-        if ((this.options != null) && (this.options.has(name))) {
+        if ((this.options != null) && (this.options.has(name)) && !name.equals( "online-mode")) { // Spigot
             return (T) this.options.valueOf(name);
         }
 
diff --git a/src/main/java/net/minecraft/server/RegionFileCache.java b/src/main/java/net/minecraft/server/RegionFileCache.java
new file mode 100644
index 0000000..829f4a3
--- /dev/null
+++ b/src/main/java/net/minecraft/server/RegionFileCache.java
@@ -0,0 +1,67 @@
+package net.minecraft.server;
+
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.File;
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Map;
+
+public class RegionFileCache {
+
+    public static final Map a = new HashMap(); // CraftBukkit - private -> public
+
+    public static synchronized RegionFile a(File file1, int i, int j) {
+        File file2 = new File(file1, "region");
+        File file3 = new File(file2, "r." + (i >> 5) + "." + (j >> 5) + ".mca");
+        RegionFile regionfile = (RegionFile) a.get(file3);
+
+        if (regionfile != null) {
+            return regionfile;
+        } else {
+            if (!file2.exists()) {
+                file2.mkdirs();
+            }
+
+            if (a.size() >= 256) {
+                a();
+            }
+
+            RegionFile regionfile1 = new RegionFile(file3);
+
+            a.put(file3, regionfile1);
+            return regionfile1;
+        }
+    }
+
+    public static synchronized void a() {
+        Iterator iterator = a.values().iterator();
+
+        while (iterator.hasNext()) {
+            RegionFile regionfile = (RegionFile) iterator.next();
+
+            try {
+                if (regionfile != null) {
+                    regionfile.c();
+                }
+            } catch (IOException ioexception) {
+                ioexception.printStackTrace();
+            }
+        }
+
+        a.clear();
+    }
+
+    public static DataInputStream c(File file1, int i, int j) {
+        RegionFile regionfile = a(file1, i, j);
+
+        return regionfile.a(i & 31, j & 31);
+    }
+
+    public static DataOutputStream d(File file1, int i, int j) {
+        RegionFile regionfile = a(file1, i, j);
+
+        return regionfile.b(i & 31, j & 31);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/ShapedRecipes.java b/src/main/java/net/minecraft/server/ShapedRecipes.java
index 8f4246b..ac92050 100644
--- a/src/main/java/net/minecraft/server/ShapedRecipes.java
+++ b/src/main/java/net/minecraft/server/ShapedRecipes.java
@@ -10,7 +10,7 @@ public class ShapedRecipes implements IRecipe {
     private int width;
     private int height;
     private ItemStack[] items;
-    private ItemStack result;
+    public ItemStack result; // Spigot
     public final int a;
     private boolean f;
 
@@ -158,4 +158,11 @@ public class ShapedRecipes implements IRecipe {
         this.f = true;
         return this;
     }
+
+    // Spigot start
+    public java.util.List<ItemStack> getIngredients()
+    {
+        return java.util.Arrays.asList( items );
+    }
+    // Spigot end
 }
diff --git a/src/main/java/net/minecraft/server/ShapelessRecipes.java b/src/main/java/net/minecraft/server/ShapelessRecipes.java
index fbdad80..dc0ce9e 100644
--- a/src/main/java/net/minecraft/server/ShapelessRecipes.java
+++ b/src/main/java/net/minecraft/server/ShapelessRecipes.java
@@ -11,7 +11,7 @@ import org.bukkit.craftbukkit.inventory.CraftShapelessRecipe;
 
 public class ShapelessRecipes implements IRecipe {
 
-    private final ItemStack result;
+    public final ItemStack result; // Spigot
     private final List ingredients;
 
     public ShapelessRecipes(ItemStack itemstack, List list) {
@@ -75,4 +75,11 @@ public class ShapelessRecipes implements IRecipe {
     public int a() {
         return this.ingredients.size();
     }
+
+    // Spigot start
+    public java.util.List<ItemStack> getIngredients()
+    {
+        return java.util.Collections.unmodifiableList( ingredients );
+    }
+    // Spigot end
 }
diff --git a/src/main/java/net/minecraft/server/SpawnerCreature.java b/src/main/java/net/minecraft/server/SpawnerCreature.java
index 9812538..ecf13aa 100644
--- a/src/main/java/net/minecraft/server/SpawnerCreature.java
+++ b/src/main/java/net/minecraft/server/SpawnerCreature.java
@@ -27,6 +27,23 @@ public final class SpawnerCreature {
         return new ChunkPosition(k, i1, l);
     }
 
+    // Spigot start - get entity count only from chunks being processed in b
+    private int getEntityCount(WorldServer server, Class oClass)
+    {
+        int i = 0;
+        for ( Long coord : this.a.keySet() )
+        {
+            int x = LongHash.msw( coord );
+            int z = LongHash.lsw( coord );
+            if ( !server.chunkProviderServer.unloadQueue.contains( coord ) && server.isChunkLoaded( x, z ) )
+            {
+                i += server.getChunkAt( x, z ).entityCount.get( oClass );
+            }
+        }
+        return i;
+    }
+    // Spigot end
+
     public int spawnEntities(WorldServer worldserver, boolean flag, boolean flag1, boolean flag2) {
         if (!flag && !flag1) {
             return 0;
@@ -42,6 +59,11 @@ public final class SpawnerCreature {
 
                 j = MathHelper.floor(entityhuman.locZ / 16.0D);
                 byte b0 = 8;
+                // Spigot Start
+                b0 = worldserver.spigotConfig.mobSpawnRange;
+                b0 = ( b0 > worldserver.spigotConfig.viewDistance ) ? (byte) worldserver.spigotConfig.viewDistance : b0;
+                b0 = ( b0 > 8 ) ? 8 : b0;
+                // Spigot End
 
                 for (int l = -b0; l <= b0; ++l) {
                     for (int i1 = -b0; i1 <= b0; ++i1) {
@@ -89,13 +111,15 @@ public final class SpawnerCreature {
                 if (limit == 0) {
                     continue;
                 }
+                int mobcnt = 0;
                 // CraftBukkit end
 
-                if ((!enumcreaturetype.d() || flag1) && (enumcreaturetype.d() || flag) && (!enumcreaturetype.e() || flag2) && worldserver.a(enumcreaturetype.a()) <= limit * this.a.size() / 256) { // CraftBukkit - use per-world limits
+                if ((!enumcreaturetype.d() || flag1) && (enumcreaturetype.d() || flag) && (!enumcreaturetype.e() || flag2) && (mobcnt = getEntityCount(worldserver, enumcreaturetype.a())) <= limit * this.a.size() / 256) { // Spigot - use per-world limits and use all loaded chunks
                     Iterator iterator = this.a.keySet().iterator();
 
+                    int moblimit = (limit * this.a.size() / 256) - mobcnt + 1; // Spigot - up to 1 more than limit
                     label110:
-                    while (iterator.hasNext()) {
+                    while (iterator.hasNext() && (moblimit > 0)) { // Spigot - while more allowed
                         // CraftBukkit start
                         long key = ((Long) iterator.next()).longValue();
 
@@ -160,6 +184,13 @@ public final class SpawnerCreature {
                                                                 groupdataentity = entityinsentient.a(groupdataentity);
                                                                 worldserver.addEntity(entityinsentient, SpawnReason.NATURAL);
                                                                 // CraftBukkit end
+                                                                // Spigot start
+                                                                if ( --moblimit <= 0 )
+                                                                {
+                                                                    // If we're past limit, stop spawn
+                                                                    continue label110;
+                                                                }
+                                                                // Spigot end
                                                                 if (j2 >= entityinsentient.bv()) {
                                                                     continue label110;
                                                                 }
diff --git a/src/main/java/net/minecraft/server/StructureGenerator.java b/src/main/java/net/minecraft/server/StructureGenerator.java
new file mode 100644
index 0000000..cb8ff49
--- /dev/null
+++ b/src/main/java/net/minecraft/server/StructureGenerator.java
@@ -0,0 +1,224 @@
+package net.minecraft.server;
+
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Random;
+import java.util.concurrent.Callable;
+
+public abstract class StructureGenerator extends WorldGenBase {
+
+    private WorldGenFeature e;
+    protected Map d = new HashMap();
+
+    public StructureGenerator() {}
+
+    public abstract String a();
+
+    protected final void a(World world, int i, int j, int k, int l, byte[] abyte) {
+        this.a(world);
+        if (!this.d.containsKey(Long.valueOf(ChunkCoordIntPair.a(i, j)))) {
+            this.b.nextInt();
+
+            try {
+                if (this.a(i, j)) {
+                    StructureStart structurestart = this.b(i, j);
+
+                    this.d.put(Long.valueOf(ChunkCoordIntPair.a(i, j)), structurestart);
+                    this.a(i, j, structurestart);
+                }
+            } catch (Throwable throwable) {
+                CrashReport crashreport = CrashReport.a(throwable, "Exception preparing structure feature");
+                CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Feature being prepared");
+
+                crashreportsystemdetails.a("Is feature chunk", (Callable) (new CrashReportIsFeatureChunk(this, i, j)));
+                crashreportsystemdetails.a("Chunk location", String.format("%d,%d", new Object[] { Integer.valueOf(i), Integer.valueOf(j)}));
+                crashreportsystemdetails.a("Chunk pos hash", (Callable) (new CrashReportChunkPosHash(this, i, j)));
+                crashreportsystemdetails.a("Structure type", (Callable) (new CrashReportStructureType(this)));
+                throw new ReportedException(crashreport);
+            }
+        }
+    }
+
+    public boolean a(World world, Random random, int i, int j) {
+        this.a(world);
+        int k = (i << 4) + 8;
+        int l = (j << 4) + 8;
+        boolean flag = false;
+        Iterator iterator = this.d.values().iterator();
+
+        while (iterator.hasNext()) {
+            StructureStart structurestart = (StructureStart) iterator.next();
+
+            if (structurestart.d() && structurestart.a().a(k, l, k + 15, l + 15)) {
+                structurestart.a(world, random, new StructureBoundingBox(k, l, k + 15, l + 15));
+                flag = true;
+                this.a(structurestart.e(), structurestart.f(), structurestart);
+            }
+        }
+
+        return flag;
+    }
+
+    public boolean b(int i, int j, int k) {
+        this.a(this.c);
+        return this.c(i, j, k) != null;
+    }
+
+    protected StructureStart c(int i, int j, int k) {
+        Iterator iterator = this.d.values().iterator();
+
+        while (iterator.hasNext()) {
+            StructureStart structurestart = (StructureStart) iterator.next();
+
+            if (structurestart.d() && structurestart.a().a(i, k, i, k)) {
+                Iterator iterator1 = structurestart.b().iterator();
+
+                while (iterator1.hasNext()) {
+                    StructurePiece structurepiece = (StructurePiece) iterator1.next();
+
+                    if (structurepiece.c().b(i, j, k)) {
+                        return structurestart;
+                    }
+                }
+            }
+        }
+
+        return null;
+    }
+
+    public boolean d(int i, int j, int k) {
+        this.a(this.c);
+        Iterator iterator = this.d.values().iterator();
+
+        StructureStart structurestart;
+
+        do {
+            if (!iterator.hasNext()) {
+                return false;
+            }
+
+            structurestart = (StructureStart) iterator.next();
+        } while (!structurestart.d());
+
+        return structurestart.a().a(i, k, i, k);
+    }
+
+    public ChunkPosition getNearestGeneratedFeature(World world, int i, int j, int k) {
+        this.c = world;
+        this.a(world);
+        this.b.setSeed(world.getSeed());
+        long l = this.b.nextLong();
+        long i1 = this.b.nextLong();
+        long j1 = (long) (i >> 4) * l;
+        long k1 = (long) (k >> 4) * i1;
+
+        this.b.setSeed(j1 ^ k1 ^ world.getSeed());
+        this.a(world, i >> 4, k >> 4, 0, 0, (byte[]) null);
+        double d0 = Double.MAX_VALUE;
+        ChunkPosition chunkposition = null;
+        Iterator iterator = this.d.values().iterator();
+
+        ChunkPosition chunkposition1;
+        int l1;
+        int i2;
+        double d1;
+        int j2;
+
+        while (iterator.hasNext()) {
+            StructureStart structurestart = (StructureStart) iterator.next();
+
+            if (structurestart.d()) {
+                StructurePiece structurepiece = (StructurePiece) structurestart.b().get(0);
+
+                chunkposition1 = structurepiece.a();
+                i2 = chunkposition1.x - i;
+                l1 = chunkposition1.y - j;
+                j2 = chunkposition1.z - k;
+                d1 = (double) (i2 * i2 + l1 * l1 + j2 * j2);
+                if (d1 < d0) {
+                    d0 = d1;
+                    chunkposition = chunkposition1;
+                }
+            }
+        }
+
+        if (chunkposition != null) {
+            return chunkposition;
+        } else {
+            List list = this.p_();
+
+            if (list != null) {
+                ChunkPosition chunkposition2 = null;
+                Iterator iterator1 = list.iterator();
+
+                while (iterator1.hasNext()) {
+                    chunkposition1 = (ChunkPosition) iterator1.next();
+                    i2 = chunkposition1.x - i;
+                    l1 = chunkposition1.y - j;
+                    j2 = chunkposition1.z - k;
+                    d1 = (double) (i2 * i2 + l1 * l1 + j2 * j2);
+                    if (d1 < d0) {
+                        d0 = d1;
+                        chunkposition2 = chunkposition1;
+                    }
+                }
+
+                return chunkposition2;
+            } else {
+                return null;
+            }
+        }
+    }
+
+    protected List p_() {
+        return null;
+    }
+
+    private void a(World world) {
+        if (this.e == null) {
+            // Spigot Start
+            if ( world.spigotConfig.saveStructureInfo )
+            {
+                this.e = (WorldGenFeature) world.a( WorldGenFeature.class, this.a() );
+            } else
+            {
+                this.e = new WorldGenFeature( this.a() );
+            }
+            // Spigot End
+            if (this.e == null) {
+                this.e = new WorldGenFeature(this.a());
+                world.a(this.a(), (WorldMapBase) this.e);
+            } else {
+                NBTTagCompound nbttagcompound = this.e.a();
+                Iterator iterator = nbttagcompound.c().iterator();
+
+                while (iterator.hasNext()) {
+                    NBTBase nbtbase = (NBTBase) iterator.next();
+
+                    if (nbtbase.getTypeId() == 10) {
+                        NBTTagCompound nbttagcompound1 = (NBTTagCompound) nbtbase;
+
+                        if (nbttagcompound1.hasKey("ChunkX") && nbttagcompound1.hasKey("ChunkZ")) {
+                            int i = nbttagcompound1.getInt("ChunkX");
+                            int j = nbttagcompound1.getInt("ChunkZ");
+                            StructureStart structurestart = WorldGenFactory.a(nbttagcompound1, world);
+
+                            this.d.put(Long.valueOf(ChunkCoordIntPair.a(i, j)), structurestart);
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    private void a(int i, int j, StructureStart structurestart) {
+        this.e.a(structurestart.a(i, j), i, j);
+        this.e.c();
+    }
+
+    protected abstract boolean a(int i, int j);
+
+    protected abstract StructureStart b(int i, int j);
+}
diff --git a/src/main/java/net/minecraft/server/ThreadCommandReader.java b/src/main/java/net/minecraft/server/ThreadCommandReader.java
index 489e184..bfd219c 100644
--- a/src/main/java/net/minecraft/server/ThreadCommandReader.java
+++ b/src/main/java/net/minecraft/server/ThreadCommandReader.java
@@ -11,6 +11,7 @@ class ThreadCommandReader extends Thread {
     final DedicatedServer server;
 
     ThreadCommandReader(DedicatedServer dedicatedserver) {
+        super("Command Reader"); // Spigot
         this.server = dedicatedserver;
     }
 
diff --git a/src/main/java/net/minecraft/server/ThreadLoginVerifier.java b/src/main/java/net/minecraft/server/ThreadLoginVerifier.java
index 2ce2e3a..3dd5f9a 100644
--- a/src/main/java/net/minecraft/server/ThreadLoginVerifier.java
+++ b/src/main/java/net/minecraft/server/ThreadLoginVerifier.java
@@ -1,5 +1,6 @@
 package net.minecraft.server;
 
+import com.google.gson.Gson;
 import java.io.BufferedReader;
 import java.io.InputStreamReader;
 import java.math.BigInteger;
@@ -21,34 +22,43 @@ class ThreadLoginVerifier extends Thread {
     CraftServer server;
 
     ThreadLoginVerifier(PendingConnection pendingconnection, CraftServer server) {
+        super("Login Verifier - " + pendingconnection.getName());
         this.server = server;
         // CraftBukkit end
         this.pendingConnection = pendingconnection;
     }
+public static class NewResponse{private String id;}
+    private boolean auth() throws java.io.IOException {
+        String s = (new BigInteger(MinecraftEncryption.a(PendingConnection.a(this.pendingConnection), PendingConnection.b(this.pendingConnection).H().getPublic(), PendingConnection.c(this.pendingConnection)))).toString(16);
+        URL url = new URL("https://sessionserver.mojang.com/session/minecraft/hasJoined?username=" + URLEncoder.encode(PendingConnection.d(this.pendingConnection), "UTF-8") + "&serverId=" + URLEncoder.encode(s, "UTF-8"));
+        BufferedReader bufferedreader = new BufferedReader(new InputStreamReader(url.openConnection(PendingConnection.b(this.pendingConnection).ap()).getInputStream()));
+        String s1 = bufferedreader.readLine();
 
-    public void run() {
-        try {
-            String s = (new BigInteger(MinecraftEncryption.a(PendingConnection.a(this.pendingConnection), PendingConnection.b(this.pendingConnection).H().getPublic(), PendingConnection.c(this.pendingConnection)))).toString(16);
-            URL url = new URL("http://session.minecraft.net/game/checkserver.jsp?user=" + URLEncoder.encode(PendingConnection.d(this.pendingConnection), "UTF-8") + "&serverId=" + URLEncoder.encode(s, "UTF-8"));
-            BufferedReader bufferedreader = new BufferedReader(new InputStreamReader(url.openConnection(PendingConnection.b(this.pendingConnection).ap()).getInputStream()));
-            String s1 = bufferedreader.readLine();
+        bufferedreader.close();
+        NewResponse response = new Gson().fromJson( s1, NewResponse.class );
+         if ( response != null )
+ {
+ if ( response.id != null )
+ {
+ this.pendingConnection.uuid = response.id;
+ return true;
+ }
+ }
+ this.pendingConnection.disconnect( "Failed to verify username!" );
+ return false;
 
-            bufferedreader.close();
-            if (!"YES".equals(s1)) {
-                this.pendingConnection.disconnect("Failed to verify username!");
-                return;
-            }
+    }
 
-            // CraftBukkit start
-            if (this.pendingConnection.getSocket() == null) {
-                return;
-            }
+    public void run() {
+        try {
+            if (org.spigotmc.SpamHaus.filterIp(pendingConnection)) return; // Spigot
+            if (server.getOnlineMode() && !auth()) return; // Spigot
 
-            AsyncPlayerPreLoginEvent asyncEvent = new AsyncPlayerPreLoginEvent(PendingConnection.d(this.pendingConnection), this.pendingConnection.getSocket().getInetAddress());
+            AsyncPlayerPreLoginEvent asyncEvent = new AsyncPlayerPreLoginEvent(PendingConnection.d(this.pendingConnection), ((java.net.InetSocketAddress) this.pendingConnection.networkManager.getSocketAddress()).getAddress()); // Spigot
             this.server.getPluginManager().callEvent(asyncEvent);
 
             if (PlayerPreLoginEvent.getHandlerList().getRegisteredListeners().length != 0) {
-                final PlayerPreLoginEvent event = new PlayerPreLoginEvent(PendingConnection.d(this.pendingConnection), this.pendingConnection.getSocket().getInetAddress());
+                final PlayerPreLoginEvent event = new PlayerPreLoginEvent(PendingConnection.d(this.pendingConnection), ((java.net.InetSocketAddress) this.pendingConnection.networkManager.getSocketAddress()).getAddress()); // Spigot
                 if (asyncEvent.getResult() != PlayerPreLoginEvent.Result.ALLOWED) {
                     event.disallow(asyncEvent.getResult(), asyncEvent.getKickMessage());
                 }
diff --git a/src/main/java/net/minecraft/server/TileEntity.java b/src/main/java/net/minecraft/server/TileEntity.java
index f4be980..6ae7cb3 100644
--- a/src/main/java/net/minecraft/server/TileEntity.java
+++ b/src/main/java/net/minecraft/server/TileEntity.java
@@ -4,10 +4,12 @@ import java.util.HashMap;
 import java.util.Map;
 import java.util.concurrent.Callable;
 
+import org.spigotmc.CustomTimingsHandler; // Spigot
 import org.bukkit.inventory.InventoryHolder; // CraftBukkit
 
 public class TileEntity {
 
+    public CustomTimingsHandler tickTimer = org.bukkit.craftbukkit.SpigotTimings.getTileEntityTimings(this); // Spigot
     private static Map a = new HashMap();
     private static Map b = new HashMap();
     protected World world;
diff --git a/src/main/java/net/minecraft/server/TileEntityHopper.java b/src/main/java/net/minecraft/server/TileEntityHopper.java
index e8cd525..5793b5c 100644
--- a/src/main/java/net/minecraft/server/TileEntityHopper.java
+++ b/src/main/java/net/minecraft/server/TileEntityHopper.java
@@ -182,12 +182,17 @@ public class TileEntityHopper extends TileEntity implements IHopper {
 
                 flag = suckInItems(this) || flag;
                 if (flag) {
-                    this.c(8);
+                    this.c(world.spigotConfig.hopperTransfer); // Spigot
                     this.update();
                     return true;
                 }
             }
-
+            // Spigot start
+            if ( !this.l() )
+            {
+                this.c( world.spigotConfig.hopperCheck );
+            }
+            // Spigot end
             return false;
         } else {
             return false;
@@ -218,7 +223,7 @@ public class TileEntityHopper extends TileEntity implements IHopper {
                     this.getWorld().getServer().getPluginManager().callEvent(event);
                     if (event.isCancelled()) {
                         this.setItem(i, itemstack);
-                        this.c(8); // Delay hopper checks
+                        this.c(world.spigotConfig.hopperTransfer); // Spigot
                         return false;
                     }
                     ItemStack itemstack1 = addItem(iinventory, CraftItemStack.asNMSCopy(event.getItem()), Facing.OPPOSITE_FACING[BlockHopper.c(this.p())]);
@@ -299,9 +304,9 @@ public class TileEntityHopper extends TileEntity implements IHopper {
                 iinventory.setItem(i, itemstack1);
 
                 if (ihopper instanceof TileEntityHopper) {
-                    ((TileEntityHopper) ihopper).c(8); // Delay hopper checks
+                    ((TileEntityHopper) ihopper).c(ihopper.getWorld().spigotConfig.hopperTransfer); // Spigot
                 } else if (ihopper instanceof EntityMinecartHopper) {
-                    ((EntityMinecartHopper) ihopper).l(4); // Delay hopper minecart checks
+                    ((EntityMinecartHopper) ihopper).l(ihopper.getWorld().spigotConfig.hopperTransfer / 2); // Spigot
                 }
 
                 return false;
@@ -405,7 +410,7 @@ public class TileEntityHopper extends TileEntity implements IHopper {
 
             if (flag) {
                 if (iinventory instanceof TileEntityHopper) {
-                    ((TileEntityHopper) iinventory).c(8);
+                    ((TileEntityHopper) iinventory).c(((TileEntityHopper) iinventory).world.spigotConfig.hopperTransfer); // Spigot
                     iinventory.update();
                 }
 
diff --git a/src/main/java/net/minecraft/server/World.java b/src/main/java/net/minecraft/server/World.java
index 3924a5c..cb21133 100644
--- a/src/main/java/net/minecraft/server/World.java
+++ b/src/main/java/net/minecraft/server/World.java
@@ -13,6 +13,7 @@ import java.util.concurrent.Callable;
 // CraftBukkit start
 import org.bukkit.Bukkit;
 import org.bukkit.craftbukkit.util.LongHashSet;
+import org.bukkit.craftbukkit.SpigotTimings; // Spigot
 import org.bukkit.craftbukkit.util.UnsafeList;
 import org.bukkit.generator.ChunkGenerator;
 import org.bukkit.craftbukkit.CraftServer;
@@ -28,7 +29,25 @@ import org.bukkit.event.weather.ThunderChangeEvent;
 public abstract class World implements IBlockAccess {
 
     public boolean d;
-    public List entityList = new ArrayList();
+    public List entityList = new ArrayList() { // Spigot start - guard entity list from removals
+        @Override
+        public Object remove(int index) {
+            guard();
+            return super.remove(index);
+        }
+
+        @Override
+        public boolean remove(Object o) {
+            guard();
+            return super.remove(o);
+        }
+
+        private void guard() {
+            if (guardEntityList) {
+                throw new java.util.ConcurrentModificationException();
+            }
+        }
+    }; // Spigot end
     protected List f = new ArrayList();
     public Set tileEntityList = new HashSet(); // CraftBukkit - ArrayList -> HashSet
     private List a = new ArrayList();
@@ -66,13 +85,36 @@ public abstract class World implements IBlockAccess {
     // CraftBukkit start - public, longhashset
     public boolean allowMonsters = true;
     public boolean allowAnimals = true;
-    protected LongHashSet chunkTickList = new LongHashSet();
     public long ticksPerAnimalSpawns;
     public long ticksPerMonsterSpawns;
     // CraftBukkit end
     private int O;
     int[] H;
     public boolean isStatic;
+    // Spigot start
+    private boolean guardEntityList = false;
+    protected final gnu.trove.map.hash.TLongShortHashMap chunkTickList;
+    protected float growthOdds = 100;
+    protected float modifiedOdds = 100;
+    private final byte chunkTickRadius;
+
+    public static long chunkToKey(int x, int z)
+    {
+        long k = ( ( ( (long) x ) & 0xFFFF0000L ) << 16 ) | ( ( ( (long) x ) & 0x0000FFFFL ) << 0 );
+        k     |= ( ( ( (long) z ) & 0xFFFF0000L ) << 32 ) | ( ( ( (long) z ) & 0x0000FFFFL ) << 16 );
+        return k;
+    }
+
+    public static int keyToX(long k)
+    {
+        return (int) ( ( ( k >> 16 ) & 0xFFFF0000 ) | ( k & 0x0000FFFF ) );
+    }
+
+    public static int keyToZ(long k)
+    {
+        return (int) ( ( ( k >> 32 ) & 0xFFFF0000L ) | ( ( k >> 16 ) & 0x0000FFFF ) );
+    }
+    // Spigot end
 
     public BiomeBase getBiome(int i, int j) {
         if (this.isLoaded(i, 0, j)) {
@@ -99,6 +141,9 @@ public abstract class World implements IBlockAccess {
     int lastXAccessed = Integer.MIN_VALUE;
     int lastZAccessed = Integer.MIN_VALUE;
     final Object chunkLock = new Object();
+    public final org.spigotmc.SpigotWorldConfig spigotConfig; // Spigot
+
+    public final SpigotTimings.WorldTimingsHandler timings; // Spigot
 
     public CraftWorld getWorld() {
         return this.world;
@@ -110,11 +155,17 @@ public abstract class World implements IBlockAccess {
 
     // Changed signature
     public World(IDataManager idatamanager, String s, WorldSettings worldsettings, WorldProvider worldprovider, MethodProfiler methodprofiler, IConsoleLogManager iconsolelogmanager, ChunkGenerator gen, org.bukkit.World.Environment env) {
+        this.spigotConfig = new org.spigotmc.SpigotWorldConfig( s ); // Spigot
         this.generator = gen;
         this.world = new CraftWorld((WorldServer) this, gen, env);
         this.ticksPerAnimalSpawns = this.getServer().getTicksPerAnimalSpawns(); // CraftBukkit
         this.ticksPerMonsterSpawns = this.getServer().getTicksPerMonsterSpawns(); // CraftBukkit
         // CraftBukkit end
+        // Spigot start
+        this.chunkTickRadius = (byte) ( ( this.getServer().getViewDistance() < 7 ) ? this.getServer().getViewDistance() : 7 );
+        this.chunkTickList = new gnu.trove.map.hash.TLongShortHashMap( spigotConfig.chunksPerTick * 5, 0.7f, Long.MIN_VALUE, Short.MIN_VALUE );
+        this.chunkTickList.setAutoCompactionFactor( 0 );
+        // Spigot end
 
         this.O = this.random.nextInt(12000);
         this.H = new int['\u8000'];
@@ -171,6 +222,7 @@ public abstract class World implements IBlockAccess {
         this.a();
 
         this.getServer().addWorld(this.world); // CraftBukkit
+        timings = new SpigotTimings.WorldTimingsHandler(this); // Spigot
     }
 
     protected abstract IChunkProvider j();
@@ -271,15 +323,13 @@ public abstract class World implements IBlockAccess {
 
     // CraftBukkit start
     public Chunk getChunkAt(int i, int j) {
-        Chunk result = null;
-        synchronized (this.chunkLock) {
-            if (this.lastChunkAccessed == null || this.lastXAccessed != i || this.lastZAccessed != j) {
-                this.lastChunkAccessed = this.chunkProvider.getOrCreateChunk(i, j);
-                this.lastXAccessed = i;
-                this.lastZAccessed = j;
-            }
-            result = this.lastChunkAccessed;
+        //synchronized (this.chunkLock) {
+        Chunk result = this.lastChunkAccessed; // Exploit fact that read is atomic 
+        if (result == null || result.x != i || result.z != j) {
+            result = this.chunkProvider.getOrCreateChunk(i, j);
+            this.lastChunkAccessed = result; // Exploit fact that write is atomic
         }
+        //}
         return result;
     }
     // CraftBukkit end
@@ -896,6 +946,7 @@ public abstract class World implements IBlockAccess {
     }
 
     public boolean addEntity(Entity entity, SpawnReason spawnReason) { // Changed signature, added SpawnReason
+        if (Thread.currentThread() != MinecraftServer.getServer().primaryThread) throw new IllegalStateException("Asynchronous entity add!"); // Spigot
         if (entity == null) return false;
         // CraftBukkit end
 
@@ -927,6 +978,23 @@ public abstract class World implements IBlockAccess {
             // Not all projectiles extend EntityProjectile, so check for Bukkit interface instead
             event = CraftEventFactory.callProjectileLaunchEvent(entity);
         }
+        // Spigot start
+        else if (entity instanceof EntityExperienceOrb) {
+            EntityExperienceOrb xp = (EntityExperienceOrb) entity;
+            double radius = spigotConfig.expMerge;
+            if (radius > 0) {
+                List<Entity> entities = this.getEntities(entity, entity.boundingBox.grow(radius, radius, radius));
+                for (Entity e : entities) {
+                    if (e instanceof EntityExperienceOrb) {
+                        EntityExperienceOrb loopItem = (EntityExperienceOrb) e;
+                        if (!loopItem.dead) {
+                            xp.value += loopItem.value;
+                            loopItem.die();
+                        }
+                    }
+                }
+            }
+        } // Spigot end
 
         if (event != null && (event.isCancelled() || entity.dead)) {
             entity.dead = true;
@@ -985,6 +1053,7 @@ public abstract class World implements IBlockAccess {
     }
 
     public void removeEntity(Entity entity) {
+        if (Thread.currentThread() != MinecraftServer.getServer().primaryThread) throw new IllegalStateException("Asynchronous entity remove!"); // Spigot
         entity.die();
         if (entity instanceof EntityHuman) {
             this.players.remove(entity);
@@ -1015,19 +1084,47 @@ public abstract class World implements IBlockAccess {
         int i1 = MathHelper.floor(axisalignedbb.c);
         int j1 = MathHelper.floor(axisalignedbb.f + 1.0D);
 
-        for (int k1 = i; k1 < j; ++k1) {
-            for (int l1 = i1; l1 < j1; ++l1) {
-                if (this.isLoaded(k1, 64, l1)) {
-                    for (int i2 = k - 1; i2 < l; ++i2) {
-                        Block block = Block.byId[this.getTypeId(k1, i2, l1)];
-
-                        if (block != null) {
-                            block.a(this, k1, i2, l1, axisalignedbb, this.M, entity);
+        // Spigot start
+        int ystart = ( ( k - 1 ) < 0 ) ? 0 : ( k - 1 );
+        for ( int chunkx = ( i >> 4 ); chunkx <= ( ( j - 1 ) >> 4 ); chunkx++ )
+        {
+            int cx = chunkx << 4;
+            for ( int chunkz = ( i1 >> 4 ); chunkz <= ( ( j1 - 1 ) >> 4 ); chunkz++ )
+            {
+                if ( !this.isChunkLoaded( chunkx, chunkz ) )
+                {
+                    continue;
+                }
+                int cz = chunkz << 4;
+                Chunk chunk = this.getChunkAt( chunkx, chunkz );
+                // Compute ranges within chunk
+                int xstart = ( i < cx ) ? cx : i;
+                int xend = ( j < ( cx + 16 ) ) ? j : ( cx + 16 );
+                int zstart = ( i1 < cz ) ? cz : i1;
+                int zend = ( j1 < ( cz + 16 ) ) ? j1 : ( cz + 16 );
+                // Loop through blocks within chunk
+                for ( int x = xstart; x < xend; x++ )
+                {
+                    for ( int z = zstart; z < zend; z++ )
+                    {
+                        for ( int y = ystart; y < l; y++ )
+                        {
+                            int blkid = chunk.getTypeId( x - cx, y, z - cz );
+                            if ( blkid > 0 )
+                            {
+                                Block block = Block.byId[blkid];
+
+                                if ( block != null )
+                                {
+                                    block.a( this, x, y, z, axisalignedbb, this.M, entity );
+                                }
+                            }
                         }
                     }
                 }
             }
         }
+        // Spigot end
 
         double d0 = 0.25D;
         List list = this.getEntities(entity, axisalignedbb.grow(d0, d0, d0));
@@ -1143,6 +1240,7 @@ public abstract class World implements IBlockAccess {
         CrashReport crashreport;
         CrashReportSystemDetails crashreportsystemdetails;
 
+        long lastChunk = Long.MIN_VALUE; // Spigot - cache chunk x, z cords for unload queue
         for (i = 0; i < this.i.size(); ++i) {
             entity = (Entity) this.i.get(i);
             // CraftBukkit start - Fixed an NPE, don't process entities in chunks queued for unload
@@ -1151,10 +1249,15 @@ public abstract class World implements IBlockAccess {
             }
 
             ChunkProviderServer chunkProviderServer = ((WorldServer) this).chunkProviderServer;
-            if (chunkProviderServer.unloadQueue.contains(MathHelper.floor(entity.locX) >> 4, MathHelper.floor(entity.locZ) >> 4)) {
-                continue;
+            // Spigot start - check last chunk to see if this loaded (fast cache)
+            long chunk = org.bukkit.craftbukkit.util.LongHash.toLong(MathHelper.floor(entity.locX) >> 4, MathHelper.floor(entity.locZ) >> 4);
+            if (lastChunk != chunk) {
+                if (chunkProviderServer.unloadQueue.contains(chunk)) { // Spigot end
+                    continue;
+                }
             }
             // CraftBukkit end
+            lastChunk = chunk; // Spigot
 
             try {
                 ++entity.ticksLived;
@@ -1175,6 +1278,7 @@ public abstract class World implements IBlockAccess {
                 this.i.remove(i--);
             }
         }
+        lastChunk = Long.MIN_VALUE; // Spigot
 
         this.methodProfiler.c("remove");
         this.entityList.removeAll(this.f);
@@ -1198,15 +1302,23 @@ public abstract class World implements IBlockAccess {
         this.f.clear();
         this.methodProfiler.c("regular");
 
+        org.spigotmc.ActivationRange.activateEntities(this); // Spigot
+        timings.entityTick.startTiming(); // Spigot
+        guardEntityList = true; // Spigot
         for (i = 0; i < this.entityList.size(); ++i) {
             entity = (Entity) this.entityList.get(i);
 
             // CraftBukkit start - Don't tick entities in chunks queued for unload
             ChunkProviderServer chunkProviderServer = ((WorldServer) this).chunkProviderServer;
-            if (chunkProviderServer.unloadQueue.contains(MathHelper.floor(entity.locX) >> 4, MathHelper.floor(entity.locZ) >> 4)) {
-                continue;
+            // Spigot start - check last chunk to see if this loaded (fast cache)
+            long chunk = org.bukkit.craftbukkit.util.LongHash.toLong(MathHelper.floor(entity.locX) >> 4, MathHelper.floor(entity.locZ) >> 4);
+            if (lastChunk != chunk) {
+                if (chunkProviderServer.unloadQueue.contains(chunk)) { // Spigot end
+                    continue;
+                }
             }
             // CraftBukkit end
+            lastChunk = Long.MIN_VALUE; // Spigot
 
             if (entity.vehicle != null) {
                 if (!entity.vehicle.dead && entity.vehicle.passenger == entity) {
@@ -1220,7 +1332,9 @@ public abstract class World implements IBlockAccess {
             this.methodProfiler.a("tick");
             if (!entity.dead) {
                 try {
+                    SpigotTimings.tickEntityTimer.startTiming(); // Spigot
                     this.playerJoinedWorld(entity);
+                    SpigotTimings.tickEntityTimer.stopTiming(); // Spigot
                 } catch (Throwable throwable1) {
                     crashreport = CrashReport.a(throwable1, "Ticking entity");
                     crashreportsystemdetails = crashreport.a("Entity being ticked");
@@ -1238,19 +1352,31 @@ public abstract class World implements IBlockAccess {
                     this.getChunkAt(j, k).b(entity);
                 }
 
+                guardEntityList = false; // Spigot
                 this.entityList.remove(i--);
+                guardEntityList = true; // Spigot
                 this.b(entity);
             }
 
             this.methodProfiler.b();
         }
+        guardEntityList = false; // Spigot
 
+        timings.entityTick.stopTiming(); // Spigot
         this.methodProfiler.c("tileEntities");
+        timings.tileEntityTick.startTiming(); // Spigot
         this.N = true;
         Iterator iterator = this.tileEntityList.iterator();
 
         while (iterator.hasNext()) {
             TileEntity tileentity = (TileEntity) iterator.next();
+            // Spigot start
+            if (tileentity == null) {
+                getServer().getLogger().severe("Spigot has detected a null entity and has removed it, preventing a crash");
+                iterator.remove();
+                continue;
+            }
+            // Spigot end
             // CraftBukkit start - Don't tick entities in chunks queued for unload
             ChunkProviderServer chunkProviderServer = ((WorldServer) this).chunkProviderServer;
             if (chunkProviderServer.unloadQueue.contains(tileentity.x >> 4, tileentity.z >> 4)) {
@@ -1260,8 +1386,11 @@ public abstract class World implements IBlockAccess {
 
             if (!tileentity.r() && tileentity.o() && this.isLoaded(tileentity.x, tileentity.y, tileentity.z)) {
                 try {
+                    tileentity.tickTimer.startTiming(); // Spigot
                     tileentity.h();
+                    tileentity.tickTimer.stopTiming(); // Spigot
                 } catch (Throwable throwable2) {
+                    tileentity.tickTimer.stopTiming(); // Spigot
                     crashreport = CrashReport.a(throwable2, "Ticking tile entity");
                     crashreportsystemdetails = crashreport.a("Tile entity being ticked");
                     tileentity.a(crashreportsystemdetails);
@@ -1281,6 +1410,8 @@ public abstract class World implements IBlockAccess {
             }
         }
 
+        timings.tileEntityTick.stopTiming(); // Spigot
+        timings.tileEntityPending.startTiming(); // Spigot
         this.N = false;
         if (!this.b.isEmpty()) {
             this.tileEntityList.removeAll(this.b);
@@ -1319,6 +1450,7 @@ public abstract class World implements IBlockAccess {
             this.a.clear();
         }
 
+        timings.tileEntityPending.stopTiming(); // Spigot
         this.methodProfiler.b();
         this.methodProfiler.b();
     }
@@ -1340,7 +1472,13 @@ public abstract class World implements IBlockAccess {
         int j = MathHelper.floor(entity.locZ);
         byte b0 = 32;
 
-        if (!flag || this.e(i - b0, 0, j - b0, i + b0, 0, j + b0)) {
+        // Spigot start
+        if (!org.spigotmc.ActivationRange.checkIfActive(entity)) {
+            entity.ticksLived++;
+            entity.inactiveTick();
+        } else {
+            entity.tickTimer.startTiming();
+            // Spigot end
             entity.U = entity.locX;
             entity.V = entity.locY;
             entity.W = entity.locZ;
@@ -1402,6 +1540,7 @@ public abstract class World implements IBlockAccess {
                     entity.passenger = null;
                 }
             }
+            entity.tickTimer.stopTiming(); // Spigot
         }
     }
 
@@ -1953,24 +2092,44 @@ public abstract class World implements IBlockAccess {
         int j;
         int k;
 
+        // Spigot start
+        int optimalChunks = spigotConfig.chunksPerTick;
+        // Quick conditions to allow us to exist early
+        if ( optimalChunks <= 0 || players.isEmpty() )
+        {
+            return;
+        }
+        // Keep chunks with growth inside of the optimal chunk range
+        int chunksPerPlayer = Math.min( 200, Math.max( 1, (int) ( ( ( optimalChunks - players.size() ) / (double) players.size() ) + 0.5 ) ) );
+        int randRange = 3 + chunksPerPlayer / 30;
+        // Limit to normal tick radius - including view distance
+        randRange = ( randRange > chunkTickRadius ) ? chunkTickRadius : randRange;
+        // odds of growth happening vs growth happening in vanilla
+        this.growthOdds = this.modifiedOdds = Math.max( 35, Math.min( 100, ( ( chunksPerPlayer + 1 ) * 100F ) / 15F ) );
+        // Spigot end
         for (i = 0; i < this.players.size(); ++i) {
             entityhuman = (EntityHuman) this.players.get(i);
             j = MathHelper.floor(entityhuman.locX / 16.0D);
             k = MathHelper.floor(entityhuman.locZ / 16.0D);
             byte b0 = 7;
 
-            for (int l = -b0; l <= b0; ++l) {
-                for (int i1 = -b0; i1 <= b0; ++i1) {
-                    // CraftBukkit start - Don't tick chunks queued for unload
-                    ChunkProviderServer chunkProviderServer = ((WorldServer) entityhuman.world).chunkProviderServer;
-                    if (chunkProviderServer.unloadQueue.contains(l + j, i1 + k)) {
-                        continue;
-                    }
-                    // CraftBukkit end
-
-                    this.chunkTickList.add(org.bukkit.craftbukkit.util.LongHash.toLong(l + j, i1 + k)); // CraftBukkit
+            // Spigot start - Always update the chunk the player is on
+            long key = chunkToKey( j, k );
+            int existingPlayers = Math.max( 0, chunkTickList.get( key ) ); // filter out -1
+            chunkTickList.put(key, (short) (existingPlayers + 1));
+
+            // Check and see if we update the chunks surrounding the player this tick
+            for ( int chunk = 0; chunk < chunksPerPlayer; chunk++ )
+            {
+                int dx = ( random.nextBoolean() ? 1 : -1 ) * random.nextInt( randRange );
+                int dz = ( random.nextBoolean() ? 1 : -1 ) * random.nextInt( randRange );
+                long hash = chunkToKey( dx + j, dz + k );
+                if ( !chunkTickList.contains( hash ) && this.isChunkLoaded( dx + j, dz + k ) )
+                {
+                    chunkTickList.put( hash, (short) -1 ); // no players
                 }
             }
+            // Spigot End
         }
 
         this.methodProfiler.b();
@@ -1979,7 +2138,7 @@ public abstract class World implements IBlockAccess {
         }
 
         this.methodProfiler.a("playerCheckLight");
-        if (!this.players.isEmpty()) {
+        if (spigotConfig.randomLightUpdates && !this.players.isEmpty()) { // Spigot
             i = this.random.nextInt(this.players.size());
             entityhuman = (EntityHuman) this.players.get(i);
             j = MathHelper.floor(entityhuman.locX) + this.random.nextInt(11) - 5;
@@ -2354,6 +2513,7 @@ public abstract class World implements IBlockAccess {
     }
 
     public void a(List list) {
+        if (Thread.currentThread() != MinecraftServer.getServer().primaryThread) throw new IllegalStateException("Asynchronous entity world add!"); // Spigot
         // CraftBukkit start
         Entity entity = null;
         for (int i = 0; i < list.size(); ++i) {
diff --git a/src/main/java/net/minecraft/server/WorldMapHumanTracker.java b/src/main/java/net/minecraft/server/WorldMapHumanTracker.java
index 22d9c7e..bed8705 100644
--- a/src/main/java/net/minecraft/server/WorldMapHumanTracker.java
+++ b/src/main/java/net/minecraft/server/WorldMapHumanTracker.java
@@ -38,23 +38,29 @@ public class WorldMapHumanTracker {
             int i;
             int j;
 
-            org.bukkit.craftbukkit.map.RenderData render = this.worldMap.mapView.render((org.bukkit.craftbukkit.entity.CraftPlayer) trackee.getBukkitEntity()); // CraftBukkit
+            // Spigot start
+            boolean custom = this.worldMap.mapView.renderers.size() > 1 || !(this.worldMap.mapView.renderers.get(0) instanceof org.bukkit.craftbukkit.map.CraftMapRenderer);
+            org.bukkit.craftbukkit.map.RenderData render = (custom) ? this.worldMap.mapView.render((org.bukkit.craftbukkit.entity.CraftPlayer) trackee.getBukkitEntity()) : null; // CraftBukkit
 
             if (--this.g < 0) {
                 this.g = 4;
-                abyte = new byte[render.cursors.size() * 3 + 1]; // CraftBukkit
+                abyte = new byte[((custom) ? render.cursors.size() : this.worldMap.g.size()) * 3 + 1]; // CraftBukkit
                 abyte[0] = 1;
                 i = 0;
 
                 // CraftBukkit start
-                for (i = 0; i < render.cursors.size(); ++i) {
-                    org.bukkit.map.MapCursor cursor = render.cursors.get(i);
-                    if (!cursor.isVisible()) continue;
 
-                    abyte[i * 3 + 1] = (byte) (cursor.getRawType() << 4 | cursor.getDirection() & 15);
-                    abyte[i * 3 + 2] = (byte) cursor.getX();
-                    abyte[i * 3 + 3] = (byte) cursor.getY();
+                // Spigot start
+                for (Iterator iterator = ((custom) ? render.cursors.iterator() : this.worldMap.g.values().iterator()); iterator.hasNext(); ++i) {
+                    org.bukkit.map.MapCursor cursor = (custom) ? (org.bukkit.map.MapCursor) iterator.next() : null;
+                    if (cursor != null && !cursor.isVisible()) continue;
+                    WorldMapDecoration deco = (custom) ? null : (WorldMapDecoration) iterator.next();
+
+                    abyte[i * 3 + 1] = (byte) (((custom) ? cursor.getRawType() : deco.type) << 4 | ((custom) ? cursor.getDirection() : deco.rotation) & 15);
+                    abyte[i * 3 + 2] = (byte) ((custom) ? cursor.getX() : deco.locX);
+                    abyte[i * 3 + 3] = (byte) ((custom) ? cursor.getY() : deco.locY);
                 }
+                // Spigot end
                 // CraftBukkit end
 
                 boolean flag = !itemstack.A();
@@ -89,7 +95,7 @@ public class WorldMapHumanTracker {
                     abyte1[2] = (byte) j;
 
                     for (int i1 = 0; i1 < abyte1.length - 3; ++i1) {
-                        abyte1[i1 + 3] = render.buffer[(i1 + j) * 128 + i]; // CraftBukkit
+                        abyte1[i1 + 3] = ((custom) ? render.buffer : this.worldMap.colors)[(i1 + j) * 128 + i];
                     }
 
                     this.c[i] = -1;
diff --git a/src/main/java/net/minecraft/server/WorldServer.java b/src/main/java/net/minecraft/server/WorldServer.java
index 73c1ac7..5eb335f 100644
--- a/src/main/java/net/minecraft/server/WorldServer.java
+++ b/src/main/java/net/minecraft/server/WorldServer.java
@@ -25,8 +25,8 @@ public class WorldServer extends World implements org.bukkit.BlockChangeDelegate
     private final MinecraftServer server;
     public EntityTracker tracker; // CraftBukkit - private final -> public
     private final PlayerChunkMap manager;
-    private Set L;
-    private TreeSet M;
+    private org.bukkit.craftbukkit.util.LongObjectHashMap<Set<NextTickListEntry>> tickEntriesByChunk; // Spigot - switch to something better for chunk-wise access
+    private TreeSet<NextTickListEntry> tickEntryQueue; // Spigot
     public ChunkProviderServer chunkProviderServer;
     public boolean savingDisabled;
     private boolean N;
@@ -36,7 +36,8 @@ public class WorldServer extends World implements org.bukkit.BlockChangeDelegate
     private NoteDataList[] R = new NoteDataList[] { new NoteDataList((EmptyClass2) null), new NoteDataList((EmptyClass2) null)};
     private int S;
     private static final StructurePieceTreasure[] T = new StructurePieceTreasure[] { new StructurePieceTreasure(Item.STICK.id, 0, 1, 3, 10), new StructurePieceTreasure(Block.WOOD.id, 0, 1, 3, 10), new StructurePieceTreasure(Block.LOG.id, 0, 1, 3, 10), new StructurePieceTreasure(Item.STONE_AXE.id, 0, 1, 1, 3), new StructurePieceTreasure(Item.WOOD_AXE.id, 0, 1, 1, 5), new StructurePieceTreasure(Item.STONE_PICKAXE.id, 0, 1, 1, 3), new StructurePieceTreasure(Item.WOOD_PICKAXE.id, 0, 1, 1, 5), new StructurePieceTreasure(Item.APPLE.id, 0, 2, 3, 5), new StructurePieceTreasure(Item.BREAD.id, 0, 2, 3, 3)};
-    private List U = new ArrayList();
+    private ArrayList<NextTickListEntry> pendingTickEntries = new ArrayList<NextTickListEntry>(); // Spigot
+    private int nextPendingTickEntry; // Spigot
     private IntHashMap entitiesById;
 
     // CraftBukkit start
@@ -49,18 +50,20 @@ public class WorldServer extends World implements org.bukkit.BlockChangeDelegate
         // CraftBukkit end
         this.server = minecraftserver;
         this.tracker = new EntityTracker(this);
-        this.manager = new PlayerChunkMap(this, minecraftserver.getPlayerList().o());
+        this.manager = new PlayerChunkMap(this, spigotConfig.viewDistance); // Spigot
         if (this.entitiesById == null) {
             this.entitiesById = new IntHashMap();
         }
 
-        if (this.L == null) {
-            this.L = new HashSet();
+        // Spigot start
+        if (this.tickEntriesByChunk == null) {
+            this.tickEntriesByChunk = new org.bukkit.craftbukkit.util.LongObjectHashMap<Set<NextTickListEntry>>();
         }
 
-        if (this.M == null) {
-            this.M = new TreeSet();
+        if (this.tickEntryQueue == null) {
+            this.tickEntryQueue = new TreeSet<NextTickListEntry>();
         }
+        // Spigot end
 
         this.P = new org.bukkit.craftbukkit.CraftTravelAgent(this); // CraftBukkit
         this.scoreboard = new ScoreboardServer(minecraftserver);
@@ -179,9 +182,12 @@ public class WorldServer extends World implements org.bukkit.BlockChangeDelegate
         // CraftBukkit start - Only call spawner if we have players online and the world allows for mobs or animals
         long time = this.worldData.getTime();
         if (this.getGameRules().getBoolean("doMobSpawning") && (this.allowMonsters || this.allowAnimals) && (this instanceof WorldServer && this.players.size() > 0)) {
+            timings.mobSpawn.startTiming(); // Spigot
             this.Q.spawnEntities(this, this.allowMonsters && (this.ticksPerMonsterSpawns != 0 && time % this.ticksPerMonsterSpawns == 0L), this.allowAnimals && (this.ticksPerAnimalSpawns != 0 && time % this.ticksPerAnimalSpawns == 0L), this.worldData.getTime() % 400L == 0L);
+            timings.mobSpawn.stopTiming(); // Spigot
         }
         // CraftBukkit end
+        timings.doChunkUnload.startTiming(); // Spigot
         this.methodProfiler.c("chunkSource");
         this.chunkProvider.unloadChunks();
         int j = this.a(1.0F);
@@ -195,21 +201,36 @@ public class WorldServer extends World implements org.bukkit.BlockChangeDelegate
             this.worldData.setDayTime(this.worldData.getDayTime() + 1L);
         }
 
+        timings.doChunkUnload.stopTiming(); // Spigot
         this.methodProfiler.c("tickPending");
+        timings.doTickPending.startTiming(); // Spigot
         this.a(false);
+        timings.doTickPending.stopTiming(); // Spigot
         this.methodProfiler.c("tickTiles");
+        timings.doTickTiles.startTiming(); // Spigot
         this.g();
+        timings.doTickTiles.stopTiming(); // Spigot
         this.methodProfiler.c("chunkMap");
+        timings.doChunkMap.startTiming(); // Spigot
         this.manager.flush();
+        timings.doChunkMap.stopTiming(); // Spigot
         this.methodProfiler.c("village");
+        timings.doVillages.startTiming(); // Spigot
         this.villages.tick();
         this.siegeManager.a();
+        timings.doVillages.stopTiming(); // Spigot
         this.methodProfiler.c("portalForcer");
+        timings.doPortalForcer.startTiming(); // Spigot
         this.P.a(this.getTime());
+        timings.doPortalForcer.stopTiming(); // Spigot
         this.methodProfiler.b();
+        timings.doSounds.startTiming(); // Spigot
         this.aa();
+        timings.doSounds.stopTiming(); // Spigot
 
+        timings.doChunkGC.startTiming(); // Spigot
         this.getWorld().processChunkGC(); // CraftBukkit
+        timings.doChunkGC.stopTiming(); // Spigot
     }
 
     public BiomeMeta a(EnumCreatureType enumcreaturetype, int i, int j, int k) {
@@ -300,9 +321,19 @@ public class WorldServer extends World implements org.bukkit.BlockChangeDelegate
         // CraftBukkit start
         // Iterator iterator = this.chunkTickList.iterator();
 
-        for (long chunkCoord : this.chunkTickList.popAll()) {
-            int chunkX = LongHash.msw(chunkCoord);
-            int chunkZ = LongHash.lsw(chunkCoord);
+        // Spigot start
+        for (gnu.trove.iterator.TLongShortIterator iter = chunkTickList.iterator(); iter.hasNext();) {
+            iter.advance();
+            long chunkCoord = iter.key();
+            int chunkX = World.keyToX(chunkCoord);
+            int chunkZ = World.keyToZ(chunkCoord);
+            // If unloaded, or in procedd of being unloaded, drop it
+            if ( ( !this.isChunkLoaded( chunkX, chunkZ ) ) || ( this.chunkProviderServer.unloadQueue.contains( chunkX, chunkZ ) ) )
+            {
+                iter.remove();
+                continue;
+            }
+            // Spigot end
             // ChunkCoordIntPair chunkcoordintpair = (ChunkCoordIntPair) iterator.next();
             int k = chunkX * 16;
             int l = chunkZ * 16;
@@ -400,6 +431,7 @@ public class WorldServer extends World implements org.bukkit.BlockChangeDelegate
 
                         if (block != null && block.isTicking()) {
                             ++i;
+                            this.growthOdds = (iter.value() < 1) ? this.modifiedOdds : 100; // Spigot - grow fast if no players are in this chunk (value = player count)
                             block.a(this, k2 + k, i3 + chunksection.getYPosition(), l2 + l, this.random);
                         }
                     }
@@ -411,9 +443,16 @@ public class WorldServer extends World implements org.bukkit.BlockChangeDelegate
     }
 
     public boolean a(int i, int j, int k, int l) {
-        NextTickListEntry nextticklistentry = new NextTickListEntry(i, j, k, l);
-
-        return this.U.contains(nextticklistentry);
+        // Spigot start
+        int te_cnt = this.pendingTickEntries.size();
+        for (int idx = this.nextPendingTickEntry; idx < te_cnt; idx++) {
+            NextTickListEntry ent = this.pendingTickEntries.get(idx);
+            if ((ent.a == i) && (ent.b == j) && (ent.c == k) && Block.b(ent.d, l)) {
+                return true;
+            }
+        }
+        return false;
+        // Spigot end
     }
 
     public void a(int i, int j, int k, int l, int i1) {
@@ -447,10 +486,9 @@ public class WorldServer extends World implements org.bukkit.BlockChangeDelegate
                 nextticklistentry.a(j1);
             }
 
-            if (!this.L.contains(nextticklistentry)) {
-                this.L.add(nextticklistentry);
-                this.M.add(nextticklistentry);
-            }
+            // Spigot start
+            addNextTickIfNeeded(nextticklistentry);
+            // Spigot end
         }
     }
 
@@ -462,10 +500,9 @@ public class WorldServer extends World implements org.bukkit.BlockChangeDelegate
             nextticklistentry.a((long) i1 + this.worldData.getTime());
         }
 
-        if (!this.L.contains(nextticklistentry)) {
-            this.L.add(nextticklistentry);
-            this.M.add(nextticklistentry);
-        }
+        // Spigot start
+        addNextTickIfNeeded(nextticklistentry);
+        // Spigot end
     }
 
     public void tickEntities() {
@@ -485,11 +522,12 @@ public class WorldServer extends World implements org.bukkit.BlockChangeDelegate
     }
 
     public boolean a(boolean flag) {
-        int i = this.M.size();
+        // Spigot start
+        int i = this.tickEntryQueue.size(); 
 
-        if (i != this.L.size()) {
-            throw new IllegalStateException("TickNextTick list out of synch");
-        } else {
+        this.nextPendingTickEntry = 0;
+        {
+        // Spigot end
             if (i > 1000) {
                 // CraftBukkit start - If the server has too much to process over time, try to alleviate that
                 if (i > 20 * 1000) {
@@ -505,23 +543,24 @@ public class WorldServer extends World implements org.bukkit.BlockChangeDelegate
             NextTickListEntry nextticklistentry;
 
             for (int j = 0; j < i; ++j) {
-                nextticklistentry = (NextTickListEntry) this.M.first();
+                nextticklistentry = (NextTickListEntry) this.tickEntryQueue.first(); // Spigot
                 if (!flag && nextticklistentry.e > this.worldData.getTime()) {
                     break;
                 }
 
-                this.M.remove(nextticklistentry);
-                this.L.remove(nextticklistentry);
-                this.U.add(nextticklistentry);
+                // Spigot start
+                this.removeNextTickIfNeeded(nextticklistentry);
+                this.pendingTickEntries.add(nextticklistentry);
+                // Spigot end
             }
 
             this.methodProfiler.b();
             this.methodProfiler.a("ticking");
-            Iterator iterator = this.U.iterator();
-
-            while (iterator.hasNext()) {
-                nextticklistentry = (NextTickListEntry) iterator.next();
-                iterator.remove();
+            // Spigot start
+            for (int j = 0, te_cnt = this.pendingTickEntries.size(); j < te_cnt; j++) {
+                nextticklistentry = pendingTickEntries.get(j);
+                this.nextPendingTickEntry = j + 1; // treat this as dequeued
+                // Spigot end
                 byte b0 = 0;
 
                 if (this.e(nextticklistentry.a - b0, nextticklistentry.b - b0, nextticklistentry.c - b0, nextticklistentry.a + b0, nextticklistentry.b + b0, nextticklistentry.c + b0)) {
@@ -552,52 +591,18 @@ public class WorldServer extends World implements org.bukkit.BlockChangeDelegate
             }
 
             this.methodProfiler.b();
-            this.U.clear();
-            return !this.M.isEmpty();
-        }
+            // Spigot start
+            this.pendingTickEntries.clear();
+            this.nextPendingTickEntry = 0;
+            return !this.tickEntryQueue.isEmpty();
+            // Spigot end
+        } 
     }
 
     public List a(Chunk chunk, boolean flag) {
-        ArrayList arraylist = null;
-        ChunkCoordIntPair chunkcoordintpair = chunk.l();
-        int i = (chunkcoordintpair.x << 4) - 2;
-        int j = i + 16 + 2;
-        int k = (chunkcoordintpair.z << 4) - 2;
-        int l = k + 16 + 2;
-
-        for (int i1 = 0; i1 < 2; ++i1) {
-            Iterator iterator;
-
-            if (i1 == 0) {
-                iterator = this.M.iterator();
-            } else {
-                iterator = this.U.iterator();
-                /* CraftBukkit start - Comment out debug spam
-                if (!this.U.isEmpty()) {
-                    System.out.println(this.U.size());
-                }
-                // CraftBukkit end */
-            }
-
-            while (iterator.hasNext()) {
-                NextTickListEntry nextticklistentry = (NextTickListEntry) iterator.next();
-
-                if (nextticklistentry.a >= i && nextticklistentry.a < j && nextticklistentry.c >= k && nextticklistentry.c < l) {
-                    if (flag) {
-                        this.L.remove(nextticklistentry);
-                        iterator.remove();
-                    }
-
-                    if (arraylist == null) {
-                        arraylist = new ArrayList();
-                    }
-
-                    arraylist.add(nextticklistentry);
-                }
-            }
-        }
-
-        return arraylist;
+        // Spigot start
+        return this.getNextTickEntriesForChunk(chunk, flag);
+        // Spigot end
     }
 
     /* CraftBukkit start - We prevent spawning in general, so this butchering is not needed
@@ -669,13 +674,15 @@ public class WorldServer extends World implements org.bukkit.BlockChangeDelegate
             this.entitiesById = new IntHashMap();
         }
 
-        if (this.L == null) {
-            this.L = new HashSet();
+        // Spigot start
+        if (this.tickEntriesByChunk == null) {
+            this.tickEntriesByChunk = new org.bukkit.craftbukkit.util.LongObjectHashMap<Set<NextTickListEntry>>();
         }
 
-        if (this.M == null) {
-            this.M = new TreeSet();
+        if (this.tickEntryQueue == null) {
+            this.tickEntryQueue = new TreeSet<NextTickListEntry>();
         }
+        // Spigot end
 
         this.b(worldsettings);
         super.a(worldsettings);
@@ -966,4 +973,62 @@ public class WorldServer extends World implements org.bukkit.BlockChangeDelegate
         return this.setTypeIdAndData(x, y, z, typeId, data, 3);
     }
     // CraftBukkit end
+    // Spigot start
+    private void addNextTickIfNeeded(NextTickListEntry ent) {
+        long coord = LongHash.toLong(ent.a >> 4, ent.c >> 4);
+        Set<NextTickListEntry> chunkset = this.tickEntriesByChunk.get(coord);
+        if (chunkset == null) {
+            chunkset = new HashSet<NextTickListEntry>();
+            this.tickEntriesByChunk.put(coord, chunkset);
+        } else if (chunkset.contains(ent)) {
+            return;
+        }
+        chunkset.add(ent);
+        this.tickEntryQueue.add(ent);
+    }
+    
+    private void removeNextTickIfNeeded(NextTickListEntry ent) {
+        long coord = LongHash.toLong(ent.a >> 4, ent.c >> 4);
+        Set<NextTickListEntry> chunkset = this.tickEntriesByChunk.get(coord);
+        if (chunkset != null) {
+            chunkset.remove(ent);
+            if (chunkset.isEmpty()) {
+                this.tickEntriesByChunk.remove(coord);
+            }
+        }
+        this.tickEntryQueue.remove(ent);
+    }
+    
+    private List<NextTickListEntry> getNextTickEntriesForChunk(Chunk chunk, boolean remove) {
+        long coord = LongHash.toLong(chunk.x, chunk.z);
+        Set<NextTickListEntry> chunkset = this.tickEntriesByChunk.get(coord);
+        List<NextTickListEntry> list = null;
+        if (chunkset != null) {
+            list = new ArrayList<NextTickListEntry>(chunkset);
+            if (remove) {
+                this.tickEntriesByChunk.remove(coord);
+                this.tickEntryQueue.removeAll(list);
+                chunkset.clear();
+            }
+        }
+        // See if any on list of ticks being processed now
+        if (this.nextPendingTickEntry < this.pendingTickEntries.size()) {
+            int xmin = (chunk.x << 4);
+            int xmax = xmin + 16;
+            int zmin = (chunk.z << 4);
+            int zmax = zmin + 16;
+            int te_cnt = this.pendingTickEntries.size();
+            for (int i = this.nextPendingTickEntry; i < te_cnt; i++) {
+                NextTickListEntry ent = this.pendingTickEntries.get(i);
+                if ((ent.a >= xmin) && (ent.a < xmax) && (ent.c >= zmin) && (ent.c < zmax)) {
+                    if (list == null) {
+                        list = new ArrayList<NextTickListEntry>();
+                    }
+                    list.add(ent);
+                }
+            }
+        }
+        return list;
+    }
+    // Spigot end 
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftChunk.java b/src/main/java/org/bukkit/craftbukkit/CraftChunk.java
index 1a21516..6921206 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftChunk.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftChunk.java
@@ -174,7 +174,18 @@ public class CraftChunk implements Chunk {
                 }
 
                 if (cs[i].getExtendedIdArray() != null) { /* If we've got extended IDs */
-                    byte[] extids = cs[i].getExtendedIdArray().a;
+                    // Spigot start
+                    if (cs[i].getExtendedIdArray().isTrivialArray()) {
+                        int tval = cs[i].getExtendedIdArray().getTrivialArrayValue();
+                        if (tval != 0) {
+                            tval = tval << 8;
+                            for (int j = 0; j < 4096; j++) {
+                                blockids[j] |= tval;
+                            }
+                        }
+                  } else {
+                    byte[] extids = cs[i].getExtendedIdArray().getValueArray();
+                    // Spigot end
 
                     for (int j = 0; j < 2048; j++) {
                         short b = (short) (extids[j] & 0xFF);
@@ -186,21 +197,42 @@ public class CraftChunk implements Chunk {
                         blockids[j<<1] |= (b & 0x0F) << 8;
                         blockids[(j<<1)+1] |= (b & 0xF0) << 4;
                     }
+                    } // Spigot
                 }
 
                 sectionBlockIDs[i] = blockids;
 
                 /* Get block data nibbles */
-                sectionBlockData[i] = new byte[2048];
-                System.arraycopy(cs[i].getDataArray().a, 0, sectionBlockData[i], 0, 2048);
+                // Spigot start
+                if (cs[i].getDataArray().isTrivialArray() && (cs[i].getDataArray().getTrivialArrayValue() == 0)) {
+                    sectionBlockData[i] = emptyData;
+                } else {
+                    sectionBlockData[i] = new byte[2048];
+                    cs[i].getDataArray().copyToByteArray(sectionBlockData[i], 0);
+                }
                 if (cs[i].getSkyLightArray() == null) {
                     sectionSkyLights[i] = emptyData;
+                }
+                else if (cs[i].getSkyLightArray().isTrivialArray()) {
+                    if (cs[i].getSkyLightArray().getTrivialArrayValue() == 0) {
+                        sectionSkyLights[i] = emptyData;
+                    } else if (cs[i].getSkyLightArray().getTrivialArrayValue() == 15) {
+                        sectionSkyLights[i] = emptySkyLight;
+                    } else {
+                        sectionSkyLights[i] = new byte[2048];
+                        cs[i].getSkyLightArray().copyToByteArray(sectionSkyLights[i], 0);
+                    }
                 } else {
                     sectionSkyLights[i] = new byte[2048];
-                    System.arraycopy(cs[i].getSkyLightArray().a, 0, sectionSkyLights[i], 0, 2048);
+                    cs[i].getSkyLightArray().copyToByteArray(sectionSkyLights[i], 0);
+                }
+                if (cs[i].getEmittedLightArray().isTrivialArray() && (cs[i].getEmittedLightArray().getTrivialArrayValue() == 0)) {
+                    sectionEmitLights[i] = emptyData;
+                } else {
+                    sectionEmitLights[i] = new byte[2048];
+                    cs[i].getEmittedLightArray().copyToByteArray(sectionEmitLights[i], 0);
                 }
-                sectionEmitLights[i] = new byte[2048];
-                System.arraycopy(cs[i].getEmittedLightArray().a, 0, sectionEmitLights[i], 0, 2048);
+                // Spigot end
             }
         }
 
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftEffect.java b/src/main/java/org/bukkit/craftbukkit/CraftEffect.java
index 7de0de5..7eca388 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftEffect.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftEffect.java
@@ -55,6 +55,8 @@ public class CraftEffect {
             Validate.isTrue(((Material) data).isBlock(), "Material is not a block!");
             datavalue = ((Material) data).getId();
             break;
+        case ITEM_BREAK:
+            datavalue = ((Material) data).getId();
         default:
             datavalue = 0;
         }
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index d140c4f..3629959 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -37,6 +37,8 @@ import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.MobEffectList;
 import net.minecraft.server.PropertyManager;
 import net.minecraft.server.ServerCommand;
+import net.minecraft.server.RegionFile;
+import net.minecraft.server.RegionFileCache;
 import net.minecraft.server.ServerNBTManager;
 import net.minecraft.server.WorldLoaderServer;
 import net.minecraft.server.WorldManager;
@@ -210,14 +212,16 @@ public final class CraftServer implements Server {
         chunkGCLoadThresh = configuration.getInt("chunk-gc.load-threshold");
 
         updater = new AutoUpdater(new BukkitDLUpdaterService(configuration.getString("auto-updater.host")), getLogger(), configuration.getString("auto-updater.preferred-channel"));
-        updater.setEnabled(configuration.getBoolean("auto-updater.enabled"));
+        updater.setEnabled(false); // Spigot
         updater.setSuggestChannels(configuration.getBoolean("auto-updater.suggest-channels"));
         updater.getOnBroken().addAll(configuration.getStringList("auto-updater.on-broken"));
         updater.getOnUpdate().addAll(configuration.getStringList("auto-updater.on-update"));
         updater.check(serverVersion);
 
-        loadPlugins();
-        enablePlugins(PluginLoadOrder.STARTUP);
+        // Spigot Start - Moved to old location of new DedicatedPlayerList in DedicatedServer
+        // loadPlugins();
+        // enablePlugins(PluginLoadOrder.STARTUP);
+        // Spigot End
     }
 
     private File getConfigFile() {
@@ -529,11 +533,7 @@ public final class CraftServer implements Server {
             return true;
         }
 
-        if (sender instanceof Player) {
-            sender.sendMessage("Unknown command. Type \"/help\" for help.");
-        } else {
-            sender.sendMessage("Unknown command. Type \"help\" for help.");
-        }
+        sender.sendMessage(org.spigotmc.SpigotConfig.unknownCommandMessage);
 
         return false;
     }
@@ -566,6 +566,7 @@ public final class CraftServer implements Server {
         playerList.getIPBans().load();
         playerList.getNameBans().load();
 
+        org.spigotmc.SpigotConfig.init(); // Spigot
         for (WorldServer world : console.worlds) {
             world.difficulty = difficulty;
             world.setSpawnFlags(monsters, animals);
@@ -580,11 +581,13 @@ public final class CraftServer implements Server {
             } else {
                 world.ticksPerMonsterSpawns = this.getTicksPerMonsterSpawns();
             }
+            world.spigotConfig.init(); // Spigot
         }
 
         pluginManager.clearPlugins();
         commandMap.clearCommands();
         resetRecipes();
+        org.spigotmc.SpigotConfig.registerCommands(); // Spigot
 
         int pollCount = 0;
 
@@ -817,6 +820,30 @@ public final class CraftServer implements Server {
         worlds.remove(world.getName().toLowerCase());
         console.worlds.remove(console.worlds.indexOf(handle));
 
+        File parentFolder = world.getWorldFolder().getAbsoluteFile();
+
+        // Synchronized because access to RegionFileCache.a is guarded by this lock.
+        synchronized (RegionFileCache.class) {
+            // RegionFileCache.a should be RegionFileCache.cache
+            Iterator<Map.Entry<File, RegionFile>> i = RegionFileCache.a.entrySet().iterator();
+            while(i.hasNext()) {
+                Map.Entry<File, RegionFile> entry = i.next();
+                File child = entry.getKey().getAbsoluteFile();
+                while (child != null) {
+                    if (child.equals(parentFolder)) {
+                        i.remove();
+                        try {
+                            entry.getValue().c(); // Should be RegionFile.close();
+                        } catch (IOException ex) {
+                            getLogger().log(Level.SEVERE, null, ex);
+                        }
+                        break;
+                    }
+                    child = child.getParentFile();
+                }
+            }
+        }
+
         return true;
     }
 
@@ -1073,7 +1100,7 @@ public final class CraftServer implements Server {
     }
 
     public OfflinePlayer getOfflinePlayer(String name) {
-        return getOfflinePlayer(name, true);
+        return getOfflinePlayer(name, false); // Spigot
     }
 
     public OfflinePlayer getOfflinePlayer(String name, boolean search) {
@@ -1340,7 +1367,7 @@ public final class CraftServer implements Server {
     public List<String> tabCompleteCommand(Player player, String message) {
         List<String> completions = null;
         try {
-            completions = getCommandMap().tabComplete(player, message.substring(1));
+            completions = (org.spigotmc.SpigotConfig.tabComplete) ? getCommandMap().tabComplete(player, message.substring(1)) : null;
         } catch (CommandException ex) {
             player.sendMessage(ChatColor.RED + "An internal error occurred while attempting to tab-complete this command");
             getLogger().log(Level.SEVERE, "Exception when " + player.getName() + " attempted to tab complete " + message, ex);
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
index 9f75d8e..4076e6d 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
@@ -159,6 +159,7 @@ public class CraftWorld implements World {
     }
 
     public boolean unloadChunkRequest(int x, int z, boolean safe) {
+        if (Thread.currentThread() != MinecraftServer.getServer().primaryThread) throw new IllegalStateException("Asynchronous chunk unload!"); // Spigot
         if (safe && isChunkInUse(x, z)) {
             return false;
         }
@@ -169,6 +170,7 @@ public class CraftWorld implements World {
     }
 
     public boolean unloadChunk(int x, int z, boolean save, boolean safe) {
+        if (Thread.currentThread() != MinecraftServer.getServer().primaryThread) throw new IllegalStateException("Asynchronous chunk unload!"); // Spigot
         if (safe && isChunkInUse(x, z)) {
             return false;
         }
@@ -236,6 +238,7 @@ public class CraftWorld implements World {
     }
 
     public boolean loadChunk(int x, int z, boolean generate) {
+        if (Thread.currentThread() != MinecraftServer.getServer().primaryThread) throw new IllegalStateException("Asynchronous chunk load!"); // Spigot
         chunkLoadCount++;
         if (generate) {
             // Use the default variant of loadChunk when generate == true.
@@ -763,31 +766,21 @@ public class CraftWorld implements World {
         } else {
             Validate.isTrue(effect.getData() == null, "Wrong kind of data for this effect!");
         }
-
-        int datavalue = data == null ? 0 : CraftEffect.getDataValue(effect, data);
-        playEffect(loc, effect, datavalue, radius);
+        if (data != null && data.getClass().equals(org.bukkit.material.MaterialData.class)) {
+            org.bukkit.material.MaterialData materialData = (org.bukkit.material.MaterialData) data;
+            Validate.isTrue(materialData.getItemType().isBlock(), "Material must be block");
+            spigot().playEffect(loc, effect, materialData.getItemType().getId(), materialData.getData(), 0, 0, 0, 1, 1, radius);
+        } else {
+            int datavalue = data == null ? 0 : CraftEffect.getDataValue(effect, data);
+            playEffect(loc, effect, datavalue, radius);
+        }
     }
 
     public void playEffect(Location location, Effect effect, int data, int radius) {
-        Validate.notNull(location, "Location cannot be null");
-        Validate.notNull(effect, "Effect cannot be null");
-        Validate.notNull(location.getWorld(), "World cannot be null");
-        int packetData = effect.getId();
-        Packet61WorldEvent packet = new Packet61WorldEvent(packetData, location.getBlockX(), location.getBlockY(), location.getBlockZ(), data, false);
-        int distance;
-        radius *= radius;
-
-        for (Player player : getPlayers()) {
-            if (((CraftPlayer) player).getHandle().playerConnection == null) continue;
-            if (!location.getWorld().equals(player.getWorld())) continue;
-
-            distance = (int) player.getLocation().distanceSquared(location);
-            if (distance <= radius) {
-                ((CraftPlayer) player).getHandle().playerConnection.sendPacket(packet);
-            }
-        }
+        spigot().playEffect(location,effect, data, 0, 0f, 0f, 0f, 1f, 1, radius);
     }
 
+
     public <T extends Entity> T spawn(Location location, Class<T> clazz) throws IllegalArgumentException {
         return spawn(location, clazz, SpawnReason.CUSTOM);
     }
@@ -1268,4 +1261,70 @@ public class CraftWorld implements World {
             cps.queueUnload(chunk.x, chunk.z);
         }
     }
+    // Spigot start
+    private final Spigot spigot = new Spigot()
+    {
+        @Override
+        public void playEffect(Location location, Effect effect, int id, int data, float offsetX, float offsetY, float offsetZ, float speed, int particleCount, int radius)
+        {
+            Validate.notNull( location, "Location cannot be null" );
+            Validate.notNull( effect, "Effect cannot be null" );
+            Validate.notNull( location.getWorld(), "World cannot be null" );
+
+            Packet packet;
+            if ( effect.getType() != Effect.Type.PARTICLE )
+            {
+                int packetData = effect.getId();
+                packet = new Packet61WorldEvent( packetData, location.getBlockX(), location.getBlockY(), location.getBlockZ(), id, false );
+            } else
+            {
+                StringBuilder particleFullName = new StringBuilder();
+                particleFullName.append( effect.getName() );
+
+                if ( effect.getData() != null && ( effect.getData().equals( Material.class ) || effect.getData().equals( org.bukkit.material.MaterialData.class ) ) )
+                {
+                    particleFullName.append( '_' ).append( id );
+                }
+
+                if ( effect.getData() != null && effect.getData().equals( org.bukkit.material.MaterialData.class ) )
+                {
+                    particleFullName.append( '_' ).append( data );
+                }
+                packet = new Packet63WorldParticles( particleFullName.toString(), (float) location.getX(), (float) location.getY(), (float) location.getZ(), offsetX, offsetY, offsetZ, speed, particleCount );
+            }
+
+            int distance;
+            radius *= radius;
+
+            for ( Player player : getPlayers() )
+            {
+                if ( ( (CraftPlayer) player ).getHandle().playerConnection == null )
+                {
+                    continue;
+                }
+                if ( !location.getWorld().equals( player.getWorld() ) )
+                {
+                    continue;
+                }
+
+                distance = (int) player.getLocation().distanceSquared( location );
+                if ( distance <= radius )
+                {
+                    ( (CraftPlayer) player ).getHandle().playerConnection.sendPacket( packet );
+                }
+            }
+        }
+
+        @Override
+        public void playEffect(Location location, Effect effect)
+        {
+            CraftWorld.this.playEffect( location, effect, 0 );
+        }
+    };
+
+    public Spigot spigot()
+    {
+        return spigot;
+    }
+    // Spigot end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/Main.java b/src/main/java/org/bukkit/craftbukkit/Main.java
index 9aa28c8..1130be7 100644
--- a/src/main/java/org/bukkit/craftbukkit/Main.java
+++ b/src/main/java/org/bukkit/craftbukkit/Main.java
@@ -5,6 +5,7 @@ import java.io.IOException;
 import java.text.SimpleDateFormat;
 import java.util.Arrays;
 import java.util.List;
+import java.util.concurrent.TimeUnit;
 import java.util.logging.Level;
 import java.util.logging.Logger;
 import joptsimple.OptionParser;
@@ -149,6 +150,26 @@ public class Main {
                     useConsole = false;
                 }
 
+                System.out.println( "*************************************************************" );
+                System.out.println( "*************************************************************" );
+                System.out.println( "************************** WARNING **************************" );
+                System.out.println( "*************************************************************" );
+                System.out.println( "*********** This is an unsupported build for 1.7. ***********" );
+                System.out.println( "****************** Use it at your own risk ******************" );
+                System.out.println( "************ Join us at http://www.spigotmc.org/ ************" );
+                System.out.println( "************** Server will start in 10 seconds **************" );
+                System.out.println( "*************************************************************" );
+                System.out.println( "*************************************************************" );
+
+                if ( System.getProperty( "IknowWhatImDoingISwear" ) == null )
+                {
+                    try
+                    {
+                        Thread.sleep( TimeUnit.SECONDS.toMillis( 10 ) );
+                    } catch ( InterruptedException ex )
+                    {
+                    }
+                }
                 MinecraftServer.main(options);
             } catch (Throwable t) {
                 t.printStackTrace();
diff --git a/src/main/java/org/bukkit/craftbukkit/SpigotTimings.java b/src/main/java/org/bukkit/craftbukkit/SpigotTimings.java
new file mode 100644
index 0000000..541dfe4
--- /dev/null
+++ b/src/main/java/org/bukkit/craftbukkit/SpigotTimings.java
@@ -0,0 +1,128 @@
+package org.bukkit.craftbukkit;
+
+import net.minecraft.server.*;
+import org.spigotmc.CustomTimingsHandler;
+import org.bukkit.scheduler.BukkitTask;
+
+import java.util.HashMap;
+import org.bukkit.craftbukkit.scheduler.CraftTask;
+
+public class SpigotTimings {
+
+    public static final CustomTimingsHandler serverTickTimer = new CustomTimingsHandler("** Full Server Tick");
+    public static final CustomTimingsHandler playerListTimer = new CustomTimingsHandler("Player List");
+    public static final CustomTimingsHandler connectionTimer = new CustomTimingsHandler("Player Tick");
+    public static final CustomTimingsHandler tickablesTimer = new CustomTimingsHandler("Tickables");
+    public static final CustomTimingsHandler schedulerTimer = new CustomTimingsHandler("Scheduler");
+    public static final CustomTimingsHandler chunkIOTickTimer = new CustomTimingsHandler("ChunkIOTick");
+    public static final CustomTimingsHandler syncChunkLoadTimer = new CustomTimingsHandler("syncChunkLoad");
+
+    public static final CustomTimingsHandler entityMoveTimer = new CustomTimingsHandler("** entityMove");
+    public static final CustomTimingsHandler tickEntityTimer = new CustomTimingsHandler("** tickEntity");
+    public static final CustomTimingsHandler activatedEntityTimer = new CustomTimingsHandler("** activatedTickEntity");
+    public static final CustomTimingsHandler tickTileEntityTimer = new CustomTimingsHandler("** tickTileEntity");
+
+    public static final CustomTimingsHandler timerEntityBaseTick = new CustomTimingsHandler("** livingEntityBaseTick");
+    public static final CustomTimingsHandler timerEntityAI = new CustomTimingsHandler("** livingEntityAI");
+    public static final CustomTimingsHandler timerEntityAICollision = new CustomTimingsHandler("** livingEntityAICollision");
+    public static final CustomTimingsHandler timerEntityAIMove = new CustomTimingsHandler("** livingEntityAIMove");
+    public static final CustomTimingsHandler timerEntityTickRest = new CustomTimingsHandler("** livingEntityTickRest");
+
+    public static final CustomTimingsHandler playerCommandTimer = new CustomTimingsHandler("** playerCommand");
+
+    public static final CustomTimingsHandler entityActivationCheckTimer = new CustomTimingsHandler("entityActivationCheck");
+    public static final CustomTimingsHandler checkIfActiveTimer = new CustomTimingsHandler("** checkIfActive");
+
+    public static final HashMap<String, CustomTimingsHandler> entityTypeTimingMap = new HashMap<String, CustomTimingsHandler>();
+    public static final HashMap<String, CustomTimingsHandler> tileEntityTypeTimingMap = new HashMap<String, CustomTimingsHandler>();
+    public static final HashMap<String, CustomTimingsHandler> pluginTaskTimingMap = new HashMap<String, CustomTimingsHandler>();
+
+    /**
+     * Gets a timer associated with a plugins tasks.
+     * @param task
+     * @param period
+     * @return
+     */
+    public static CustomTimingsHandler getPluginTaskTimings(BukkitTask task, long period) {
+        String plugin = task.getOwner().getDescription().getFullName();
+        String name = "Task: " + plugin + " Runnable: " + ( (CraftTask) task ).getTaskClass().getSimpleName();
+        if (period > 0) {
+            name += "(interval:" + period +")";
+        } else {
+            name += "(Single)";
+        }
+        CustomTimingsHandler result = pluginTaskTimingMap.get(name);
+        if (result == null) {
+            result = new CustomTimingsHandler(name);
+            pluginTaskTimingMap.put(name, result);
+        }
+        return result;
+    }
+
+    /**
+     * Get a named timer for the specified entity type to track type specific timings.
+     * @param entity
+     * @return
+     */
+    public static CustomTimingsHandler getEntityTimings(Entity entity) {
+        String entityType = entity.getClass().getSimpleName();
+        CustomTimingsHandler result = entityTypeTimingMap.get(entityType);
+        if (result == null) {
+            result = new CustomTimingsHandler("** tickEntity - " + entityType, activatedEntityTimer);
+            entityTypeTimingMap.put(entityType, result);
+        }
+        return result;
+    }
+
+    /**
+     * Get a named timer for the specified tile entity type to track type specific timings.
+     * @param entity
+     * @return
+     */
+    public static CustomTimingsHandler getTileEntityTimings(TileEntity entity) {
+        String entityType = entity.getClass().getSimpleName();
+        CustomTimingsHandler result = tileEntityTypeTimingMap.get(entityType);
+        if (result == null) {
+            result = new CustomTimingsHandler("** tickTileEntity - " + entityType, tickTileEntityTimer);
+            tileEntityTypeTimingMap.put(entityType, result);
+        }
+        return result;
+    }
+
+    /**
+     * Set of timers per world, to track world specific timings.
+     */
+    public static class WorldTimingsHandler {
+        public final CustomTimingsHandler mobSpawn;
+        public final CustomTimingsHandler doChunkUnload;
+        public final CustomTimingsHandler doPortalForcer;
+        public final CustomTimingsHandler doTickPending;
+        public final CustomTimingsHandler doTickTiles;
+        public final CustomTimingsHandler doVillages;
+        public final CustomTimingsHandler doChunkMap;
+        public final CustomTimingsHandler doChunkGC;
+        public final CustomTimingsHandler doSounds;
+        public final CustomTimingsHandler entityTick;
+        public final CustomTimingsHandler tileEntityTick;
+        public final CustomTimingsHandler tileEntityPending;
+        public final CustomTimingsHandler tracker;
+
+        public WorldTimingsHandler(World server) {
+            String name = server.worldData.getName() +" - ";
+
+            mobSpawn = new CustomTimingsHandler(name + "mobSpawn");
+            doChunkUnload = new CustomTimingsHandler(name + "doChunkUnload");
+            doTickPending = new CustomTimingsHandler(name + "doTickPending");
+            doTickTiles = new CustomTimingsHandler(name + "doTickTiles");
+            doVillages = new CustomTimingsHandler(name + "doVillages");
+            doChunkMap = new CustomTimingsHandler(name + "doChunkMap");
+            doSounds = new CustomTimingsHandler(name + "doSounds");
+            doChunkGC = new CustomTimingsHandler(name + "doChunkGC");
+            doPortalForcer = new CustomTimingsHandler(name + "doPortalForcer");
+            entityTick = new CustomTimingsHandler(name + "entityTick");
+            tileEntityTick = new CustomTimingsHandler(name + "tileEntityTick");
+            tileEntityPending = new CustomTimingsHandler(name + "tileEntityPending");
+            tracker = new CustomTimingsHandler(name + "tracker");
+        }
+    }
+}
diff --git a/src/main/java/org/bukkit/craftbukkit/block/CraftSign.java b/src/main/java/org/bukkit/craftbukkit/block/CraftSign.java
index 1647100..43c4434 100644
--- a/src/main/java/org/bukkit/craftbukkit/block/CraftSign.java
+++ b/src/main/java/org/bukkit/craftbukkit/block/CraftSign.java
@@ -14,6 +14,12 @@ public class CraftSign extends CraftBlockState implements Sign {
 
         CraftWorld world = (CraftWorld) block.getWorld();
         sign = (TileEntitySign) world.getTileEntityAt(getX(), getY(), getZ());
+        // Spigot start
+        if (sign == null) {
+            lines = new String[]{"", "", "", ""};
+            return;
+        }
+        // Spigot end
         lines = new String[sign.lines.length];
         System.arraycopy(sign.lines, 0, lines, 0, lines.length);
     }
@@ -34,7 +40,7 @@ public class CraftSign extends CraftBlockState implements Sign {
     public boolean update(boolean force, boolean applyPhysics) {
         boolean result = super.update(force, applyPhysics);
 
-        if (result) {
+        if (result && sign != null) { // Spigot, add null check
             for(int i = 0; i < 4; i++) {
                 if(lines[i] != null) {
                     sign.lines[i] = lines[i];
diff --git a/src/main/java/org/bukkit/craftbukkit/command/TicksPerSecondCommand.java b/src/main/java/org/bukkit/craftbukkit/command/TicksPerSecondCommand.java
new file mode 100644
index 0000000..f114a31
--- /dev/null
+++ b/src/main/java/org/bukkit/craftbukkit/command/TicksPerSecondCommand.java
@@ -0,0 +1,35 @@
+package org.bukkit.craftbukkit.command;
+
+import net.minecraft.server.MinecraftServer;
+import org.bukkit.ChatColor;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+
+public class TicksPerSecondCommand extends Command {
+
+    public TicksPerSecondCommand(String name) {
+        super(name);
+        this.description = "Gets the current ticks per second for the server";
+        this.usageMessage = "/tps";
+        this.setPermission("bukkit.command.tps");
+    }
+
+    @Override
+    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
+        if (!testPermission(sender)) return true;
+
+        double tps = Math.min(20,  Math.round(MinecraftServer.currentTPS * 10) / 10.0);
+        ChatColor color;
+        if (tps > 19.2D) {
+            color = ChatColor.GREEN;
+        } else if (tps > 17.4D) {
+            color = ChatColor.YELLOW;
+        } else {
+            color = ChatColor.RED;
+        }
+
+        sender.sendMessage(ChatColor.GOLD + "[TPS] " + color + tps);
+
+        return true;
+    }
+}
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftArrow.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftArrow.java
index b46b9c4..e976b83 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftArrow.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftArrow.java
@@ -40,4 +40,26 @@ public class CraftArrow extends AbstractProjectile implements Arrow {
     public EntityType getType() {
         return EntityType.ARROW;
     }
+
+    // Spigot start
+    private final Arrow.Spigot spigot = new Arrow.Spigot()
+    {
+        @Override
+        public double getDamage()
+        {
+            return getHandle().c();
+        }
+
+        @Override
+        public void setDamage(double damage)
+        {
+            getHandle().b( damage );
+        }
+    };
+
+    public Arrow.Spigot spigot()
+    {
+        return spigot;
+    }
+    // Spigot end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
index d9659fb..65a77dc 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
@@ -398,4 +398,20 @@ public abstract class CraftEntity implements org.bukkit.entity.Entity {
 
         return getHandle().vehicle.getBukkitEntity();
     }
+
+    // Spigot start
+    private final Spigot spigot = new Spigot()
+    {
+        @Override
+        public boolean isInvulnerable()
+        {
+            return getHandle().isInvulnerable();
+        }
+    };
+
+    public Spigot spigot()
+    {
+        return spigot;
+    }
+    // Spigot end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
index ac73273..2f162ea 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
@@ -52,6 +52,7 @@ import org.bukkit.plugin.Plugin;
 import org.bukkit.plugin.messaging.Messenger;
 import org.bukkit.plugin.messaging.StandardMessenger;
 import org.bukkit.scoreboard.Scoreboard;
+import org.spigotmc.ChatConverter;
 
 @DelegateDeserialization(CraftOfflinePlayer.class)
 public class CraftPlayer extends CraftHumanEntity implements Player {
@@ -132,7 +133,11 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
     public void sendRawMessage(String message) {
         if (getHandle().playerConnection == null) return;
 
-        getHandle().playerConnection.sendPacket(new Packet3Chat(ChatMessage.d(message)));
+        for (String msg : message.split("\n")) {
+            for (String jMsg : ChatConverter.toJSONChat(msg)) {
+                getHandle().playerConnection.sendPacket(new Packet3Chat(jMsg));
+            }
+        }
     }
 
     public void sendMessage(String message) {
@@ -218,6 +223,7 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
     }
 
     public void kickPlayer(String message) {
+        if (Thread.currentThread() != MinecraftServer.getServer().primaryThread) throw new IllegalStateException("Asynchronous player kick!"); // Spigot
         if (getHandle().playerConnection == null) return;
 
         getHandle().playerConnection.disconnect(message == null ? "" : message);
@@ -276,13 +282,11 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
         getHandle().playerConnection.sendPacket(packet);
     }
 
-    public void playEffect(Location loc, Effect effect, int data) {
-        if (getHandle().playerConnection == null) return;
-
-        int packetData = effect.getId();
-        Packet61WorldEvent packet = new Packet61WorldEvent(packetData, loc.getBlockX(), loc.getBlockY(), loc.getBlockZ(), data, false);
-        getHandle().playerConnection.sendPacket(packet);
+    // Spigot start
+    public void playEffect(Location location, Effect effect, int data) {
+        spigot().playEffect(location, effect, data, 0, 0f, 0f, 0f, 1f, 1, 64);
     }
+    // Spigot end
 
     public <T> void playEffect(Location loc, Effect effect, T data) {
         if (data != null) {
@@ -290,9 +294,14 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
         } else {
             Validate.isTrue(effect.getData() == null, "Wrong kind of data for this effect!");
         }
-
-        int datavalue = data == null ? 0 : CraftEffect.getDataValue(effect, data);
-        playEffect(loc, effect, datavalue);
+        if (data != null && data.getClass().equals(org.bukkit.material.MaterialData.class)) {
+            org.bukkit.material.MaterialData materialData = (org.bukkit.material.MaterialData) data;
+            Validate.isTrue(!materialData.getItemType().isBlock(), "Material must be block");
+            spigot().playEffect(loc, effect, materialData.getItemType().getId(), materialData.getData(), 0, 0, 0, 1, 1, 64);
+        } else {
+            int datavalue = data == null ? 0 : CraftEffect.getDataValue(effect, data);
+            playEffect(loc, effect, datavalue);
+        }
     }
 
     public void sendBlockChange(Location loc, Material material, byte data) {
@@ -948,7 +957,7 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
     public void setFlySpeed(float value) {
         validateSpeed(value);
         EntityPlayer player = getHandle();
-        player.abilities.flySpeed = value / 2f;
+        player.abilities.flySpeed = Math.max( value, 0.0001f ) / 2f; // Spigot
         player.updateAbilities();
 
     }
@@ -956,7 +965,7 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
     public void setWalkSpeed(float value) {
         validateSpeed(value);
         EntityPlayer player = getHandle();
-        player.abilities.walkSpeed = value / 2f;
+        player.abilities.walkSpeed = Math.max( value, 0.0001f ) / 2f; // Spigot
         player.updateAbilities();
     }
 
@@ -1072,4 +1081,79 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
         }
         collection.add(new AttributeModifiable(getHandle().aX(), (new AttributeRanged("generic.maxHealth", scaledHealth ? healthScale : getMaxHealth(), 0.0D, Float.MAX_VALUE)).a("Max Health").a(true)));
     }
+
+    // Spigot start
+    private final Player.Spigot spigot = new Player.Spigot()
+    {
+        @Override
+        public InetSocketAddress getRawAddress()
+        {
+            return ( getHandle().playerConnection == null ) ? null : (InetSocketAddress) getHandle().playerConnection.networkManager.getSocket().getRemoteSocketAddress();
+        }
+
+        @Override
+        public void playEffect(Location location, Effect effect, int id, int data, float offsetX, float offsetY, float offsetZ, float speed, int particleCount, int radius)
+        {
+            Validate.notNull( location, "Location cannot be null" );
+            Validate.notNull( effect, "Effect cannot be null" );
+            Validate.notNull( location.getWorld(), "World cannot be null" );
+
+            Packet packet;
+            if ( effect.getType() != Effect.Type.PARTICLE )
+            {
+                int packetData = effect.getId();
+                packet = new Packet61WorldEvent( packetData, location.getBlockX(), location.getBlockY(), location.getBlockZ(), id, false );
+            } else
+            {
+                StringBuilder particleFullName = new StringBuilder();
+                particleFullName.append( effect.getName() );
+
+                if ( effect.getData() != null && ( effect.getData().equals( Material.class ) || effect.getData().equals( org.bukkit.material.MaterialData.class ) ) )
+                {
+                    particleFullName.append( '_' ).append( id );
+                }
+
+                if ( effect.getData() != null && effect.getData().equals( org.bukkit.material.MaterialData.class ) )
+                {
+                    particleFullName.append( '_' ).append( data );
+                }
+                packet = new Packet63WorldParticles( effect.getName(), (float) location.getX(), (float) location.getY(), (float) location.getZ(), offsetX, offsetY, offsetZ, particleCount, radius );
+            }
+
+            if ( !location.getWorld().equals( getWorld() ) )
+            {
+                return;
+            }
+
+            getHandle().playerConnection.sendPacket( packet );
+        }
+
+        @Override
+        public boolean getCollidesWithEntities()
+        {
+            return getHandle().collidesWithEntities;
+        }
+
+        @Override
+        public void setCollidesWithEntities(boolean collides)
+        {
+            getHandle().collidesWithEntities = collides;
+            getHandle().m = collides; // First boolean of Entity
+        }
+
+        @Override
+        public void respawn()
+        {
+            if ( getHealth() <= 0 )
+            {
+                server.getServer().getPlayerList().moveToWorld( getHandle(), 0, false );
+            }
+        }
+    };
+
+    public Player.Spigot spigot()
+    {
+        return spigot;
+    }
+    // Spigot end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java b/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
index cccfe75..d8f56e9 100644
--- a/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
+++ b/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
@@ -35,6 +35,7 @@ import org.bukkit.Server;
 import org.bukkit.block.Block;
 import org.bukkit.block.BlockFace;
 import org.bukkit.block.BlockState;
+import org.bukkit.block.CreatureSpawner;
 import org.bukkit.craftbukkit.CraftServer;
 import org.bukkit.craftbukkit.CraftWorld;
 import org.bukkit.craftbukkit.block.CraftBlock;
@@ -115,6 +116,22 @@ public class CraftEventFactory {
     }
 
     /**
+     * Mob spawner event
+     */
+    public static SpawnerSpawnEvent callSpawnerSpawnEvent(Entity spawnee, int spawnerX, int spawnerY, int spawnerZ) {
+        org.bukkit.craftbukkit.entity.CraftEntity entity = spawnee.getBukkitEntity();
+        BlockState state = entity.getWorld().getBlockAt(spawnerX, spawnerY, spawnerZ).getState();
+
+        if (!(state instanceof CreatureSpawner)) {
+            state = null;
+        }
+
+        SpawnerSpawnEvent event = new SpawnerSpawnEvent(entity, (CreatureSpawner) state);
+        entity.getServer().getPluginManager().callEvent(event);
+        return event;
+    }
+
+    /**
      * Bucket methods
      */
     public static PlayerBucketEmptyEvent callPlayerBucketEmptyEvent(EntityHuman who, int clickedX, int clickedY, int clickedZ, int clickedFace, ItemStack itemInHand) {
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftInventoryAnvil.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftInventoryAnvil.java
index a91d81a..46a1d38 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftInventoryAnvil.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftInventoryAnvil.java
@@ -1,7 +1,9 @@
 package org.bukkit.craftbukkit.inventory;
 
 import net.minecraft.server.IInventory;
+
 import org.bukkit.inventory.AnvilInventory;
+import org.bukkit.inventory.ItemStack;
 
 public class CraftInventoryAnvil extends CraftInventory implements AnvilInventory {
     private final IInventory resultInventory;
@@ -20,6 +22,26 @@ public class CraftInventoryAnvil extends CraftInventory implements AnvilInventor
     }
 
     @Override
+    public ItemStack getItem(int slot) {
+        if (slot < getIngredientsInventory().getSize()) {
+            net.minecraft.server.ItemStack item = getIngredientsInventory().getItem(slot);
+            return item == null ? null : CraftItemStack.asCraftMirror(item);
+        } else {
+            net.minecraft.server.ItemStack item = getResultInventory().getItem(slot - getIngredientsInventory().getSize());
+            return item == null ? null : CraftItemStack.asCraftMirror(item);
+        }
+    }
+
+    @Override
+    public void setItem(int index, ItemStack item) {
+        if (index < getIngredientsInventory().getSize()) {
+            getIngredientsInventory().setItem(index, (item == null ? null : CraftItemStack.asNMSCopy(item)));
+        } else {
+            getResultInventory().setItem((index - getIngredientsInventory().getSize()), (item == null ? null : CraftItemStack.asNMSCopy(item)));
+        }
+    }
+
+    @Override
     public int getSize() {
         return getResultInventory().getSize() + getIngredientsInventory().getSize();
     }
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaFirework.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaFirework.java
index 3f9e4a3..93a1ce0 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaFirework.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaFirework.java
@@ -145,7 +145,7 @@ class CraftMetaFirework extends CraftMetaItem implements FireworkMeta {
             case BURST:
                 return 4;
             default:
-                throw new AssertionError(type);
+                throw new IllegalStateException(type.toString()); // Spigot
         }
     }
 
@@ -162,7 +162,7 @@ class CraftMetaFirework extends CraftMetaItem implements FireworkMeta {
             case 4:
                 return Type.BURST;
             default:
-                throw new AssertionError(nbt);
+                throw new IllegalStateException(Integer.toString(nbt)); // Spigot
         }
     }
 
diff --git a/src/main/java/org/bukkit/craftbukkit/map/CraftMapView.java b/src/main/java/org/bukkit/craftbukkit/map/CraftMapView.java
index b28d6a3..e70e4e4 100644
--- a/src/main/java/org/bukkit/craftbukkit/map/CraftMapView.java
+++ b/src/main/java/org/bukkit/craftbukkit/map/CraftMapView.java
@@ -18,7 +18,7 @@ import org.bukkit.map.MapView;
 public final class CraftMapView implements MapView {
 
     private final Map<CraftPlayer, RenderData> renderCache = new HashMap<CraftPlayer, RenderData>();
-    private final List<MapRenderer> renderers = new ArrayList<MapRenderer>();
+    public final List<MapRenderer> renderers = new ArrayList<MapRenderer>(); // Spigot
     private final Map<MapRenderer, Map<CraftPlayer, CraftMapCanvas>> canvases = new HashMap<MapRenderer, Map<CraftPlayer, CraftMapCanvas>>();
     protected final WorldMap worldMap;
 
diff --git a/src/main/java/org/bukkit/craftbukkit/scheduler/CraftScheduler.java b/src/main/java/org/bukkit/craftbukkit/scheduler/CraftScheduler.java
index 84dcfcc..a30f217 100644
--- a/src/main/java/org/bukkit/craftbukkit/scheduler/CraftScheduler.java
+++ b/src/main/java/org/bukkit/craftbukkit/scheduler/CraftScheduler.java
@@ -71,7 +71,7 @@ public class CraftScheduler implements BukkitScheduler {
      */
     private final ConcurrentHashMap<Integer, CraftTask> runners = new ConcurrentHashMap<Integer, CraftTask>();
     private volatile int currentTick = -1;
-    private final Executor executor = Executors.newCachedThreadPool();
+    private final Executor executor = Executors.newCachedThreadPool(new com.google.common.util.concurrent.ThreadFactoryBuilder().setNameFormat("Craft Scheduler Thread - %1$d").build()); // Spigot
     private CraftAsyncDebugger debugHead = new CraftAsyncDebugger(-1, null, null) {@Override StringBuilder debugTo(StringBuilder string) {return string;}};
     private CraftAsyncDebugger debugTail = debugHead;
     private static final int RECENT_TICKS;
diff --git a/src/main/java/org/bukkit/craftbukkit/scheduler/CraftTask.java b/src/main/java/org/bukkit/craftbukkit/scheduler/CraftTask.java
index 55db3ff..7d294c0 100644
--- a/src/main/java/org/bukkit/craftbukkit/scheduler/CraftTask.java
+++ b/src/main/java/org/bukkit/craftbukkit/scheduler/CraftTask.java
@@ -1,11 +1,13 @@
 package org.bukkit.craftbukkit.scheduler;
 
 import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.SpigotTimings; // Spigot
+import org.spigotmc.CustomTimingsHandler; // Spigot
 import org.bukkit.plugin.Plugin;
 import org.bukkit.scheduler.BukkitTask;
 
 
-class CraftTask implements BukkitTask, Runnable {
+public class CraftTask implements BukkitTask, Runnable { // Spigot
 
     private volatile CraftTask next = null;
     /**
@@ -22,6 +24,7 @@ class CraftTask implements BukkitTask, Runnable {
     private final Plugin plugin;
     private final int id;
 
+    CustomTimingsHandler timings = null; // Spigot
     CraftTask() {
         this(null, null, -1, -1);
     }
@@ -50,7 +53,22 @@ class CraftTask implements BukkitTask, Runnable {
     }
 
     public void run() {
+        // Spigot start - Wrap custom timings on Tasks
+        if (!Bukkit.getServer().getPluginManager().useTimings()) {
+            task.run();
+            return;
+        }
+        if (timings == null && this.getOwner() != null && this.isSync()) {
+            timings = SpigotTimings.getPluginTaskTimings(this, period);
+        }
+        if (timings != null) {
+            timings.startTiming();
+        }
         task.run();
+        if (timings != null) {
+            timings.stopTiming();
+        }
+        // Spigot end
     }
 
     long getPeriod() {
@@ -77,7 +95,7 @@ class CraftTask implements BukkitTask, Runnable {
         this.next = next;
     }
 
-    Class<? extends Runnable> getTaskClass() {
+    public Class<? extends Runnable> getTaskClass() { // Spigot
         return task.getClass();
     }
 
diff --git a/src/main/java/org/bukkit/craftbukkit/util/LongHash.java b/src/main/java/org/bukkit/craftbukkit/util/LongHash.java
index 691cafd..9d54472 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/LongHash.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/LongHash.java
@@ -10,6 +10,6 @@ public class LongHash {
     }
 
     public static int lsw(long l) {
-        return (int) (l & 0xFFFFFFFF) + Integer.MIN_VALUE;
+        return (int) (l) + Integer.MIN_VALUE; // Spigot - remove redundant &
     }
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/util/LongHashSet.java b/src/main/java/org/bukkit/craftbukkit/util/LongHashSet.java
index 22c96c5..7f659b7 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/LongHashSet.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/LongHashSet.java
@@ -31,6 +31,7 @@ public class LongHashSet {
     private int elements;
     private long[] values;
     private int modCount;
+    private org.spigotmc.FlatMap<Boolean> flat = new org.spigotmc.FlatMap<Boolean>(); // Spigot
 
     public LongHashSet() {
         this(INITIAL_SIZE);
@@ -56,10 +57,30 @@ public class LongHashSet {
     }
 
     public boolean contains(int msw, int lsw) {
+        // Spigot start
+        if ( elements == 0 )
+        {
+            return false;
+        }
+        if ( flat.contains( msw, lsw ) )
+        {
+            return true;
+        }
+        // Spigot end
         return contains(LongHash.toLong(msw, lsw));
     }
 
     public boolean contains(long value) {
+        // Spigot start
+        if ( elements == 0 )
+        {
+            return false;
+        }
+        if ( flat.contains( value ) )
+        {
+            return true;
+        }
+        // Spigot end
         int hash = hash(value);
         int index = (hash & 0x7FFFFFFF) % values.length;
         int offset = 1;
@@ -82,6 +103,7 @@ public class LongHashSet {
     }
 
     public boolean add(long value) {
+        flat.put( value, Boolean.TRUE ); // Spigot
         int hash = hash(value);
         int index = (hash & 0x7FFFFFFF) % values.length;
         int offset = 1;
@@ -125,10 +147,18 @@ public class LongHashSet {
     }
 
     public void remove(int msw, int lsw) {
-        remove(LongHash.toLong(msw, lsw));
+        // Spigot start
+        flat.remove(msw, lsw);
+        remove0(LongHash.toLong(msw, lsw));
     }
 
     public boolean remove(long value) {
+        flat.remove(value);
+        return remove0(value);
+    }
+
+    private boolean remove0(long value) {
+        // Spigot end
         int hash = hash(value);
         int index = (hash & 0x7FFFFFFF) % values.length;
         int offset = 1;
@@ -161,6 +191,7 @@ public class LongHashSet {
 
         freeEntries = values.length;
         modCount++;
+        flat = new org.spigotmc.FlatMap<Boolean>();
     }
 
     public long[] toArray() {
diff --git a/src/main/java/org/bukkit/craftbukkit/util/LongObjectHashMap.java b/src/main/java/org/bukkit/craftbukkit/util/LongObjectHashMap.java
index 01861cc..2e5b436 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/LongObjectHashMap.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/LongObjectHashMap.java
@@ -28,6 +28,7 @@ public class LongObjectHashMap<V> implements Cloneable, Serializable {
     private transient V[][]    values;
     private transient int      modCount;
     private transient int      size;
+    private transient org.spigotmc.FlatMap<V> flat = new org.spigotmc.FlatMap<V>(); // Spigot
 
     public LongObjectHashMap() {
         initialize();
@@ -61,6 +62,17 @@ public class LongObjectHashMap<V> implements Cloneable, Serializable {
     }
 
     public V get(long key) {
+        // Spigot start
+        if ( size == 0 )
+        {
+            return null;
+        }
+        V val = flat.get( key );
+        if ( val != null )
+        {
+            return val;
+        }
+        // Spigot end
         int index = (int) (keyIndex(key) & (BUCKET_SIZE - 1));
         long[] inner = keys[index];
         if (inner == null) return null;
@@ -78,6 +90,7 @@ public class LongObjectHashMap<V> implements Cloneable, Serializable {
     }
 
     public V put(long key, V value) {
+        flat.put(key, value); // Spigot
         int index = (int) (keyIndex(key) & (BUCKET_SIZE - 1));
         long[] innerKeys = keys[index];
         V[] innerValues = values[index];
@@ -124,6 +137,7 @@ public class LongObjectHashMap<V> implements Cloneable, Serializable {
     }
 
     public V remove(long key) {
+        flat.remove(key); // Spigot
         int index = (int) (keyIndex(key) & (BUCKET_SIZE - 1));
         long[] inner = keys[index];
         if (inner == null) {
@@ -174,6 +188,7 @@ public class LongObjectHashMap<V> implements Cloneable, Serializable {
         size = 0;
         Arrays.fill(keys, null);
         Arrays.fill(values, null);
+        flat = new org.spigotmc.FlatMap<V>();
     }
 
     public Set<Long> keySet() {
diff --git a/src/main/java/org/bukkit/craftbukkit/util/Versioning.java b/src/main/java/org/bukkit/craftbukkit/util/Versioning.java
index f905d17..9304637 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/Versioning.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/Versioning.java
@@ -11,7 +11,7 @@ public final class Versioning {
     public static String getBukkitVersion() {
         String result = "Unknown-Version";
 
-        InputStream stream = Bukkit.class.getClassLoader().getResourceAsStream("META-INF/maven/org.bukkit/bukkit/pom.properties");
+        InputStream stream = Bukkit.class.getClassLoader().getResourceAsStream("META-INF/maven/org.spigotmc/spigot-api/pom.properties");
         Properties properties = new Properties();
 
         if (stream != null) {
diff --git a/src/main/java/org/spigotmc/ActivationRange.java b/src/main/java/org/spigotmc/ActivationRange.java
new file mode 100644
index 0000000..9285a0d
--- /dev/null
+++ b/src/main/java/org/spigotmc/ActivationRange.java
@@ -0,0 +1,296 @@
+package org.spigotmc;
+
+import java.util.ArrayList;
+import java.util.List;
+import net.minecraft.server.AxisAlignedBB;
+import net.minecraft.server.Chunk;
+import net.minecraft.server.Entity;
+import net.minecraft.server.EntityAmbient;
+import net.minecraft.server.EntityAnimal;
+import net.minecraft.server.EntityArrow;
+import net.minecraft.server.EntityComplexPart;
+import net.minecraft.server.EntityCreature;
+import net.minecraft.server.EntityEnderCrystal;
+import net.minecraft.server.EntityEnderDragon;
+import net.minecraft.server.EntityFireball;
+import net.minecraft.server.EntityFireworks;
+import net.minecraft.server.EntityHuman;
+import net.minecraft.server.EntityLiving;
+import net.minecraft.server.EntityMonster;
+import net.minecraft.server.EntityProjectile;
+import net.minecraft.server.EntitySheep;
+import net.minecraft.server.EntitySlime;
+import net.minecraft.server.EntityTNTPrimed;
+import net.minecraft.server.EntityVillager;
+import net.minecraft.server.EntityWeather;
+import net.minecraft.server.EntityWither;
+import net.minecraft.server.MathHelper;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.World;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.craftbukkit.SpigotTimings;
+
+public class ActivationRange
+{
+
+    static AxisAlignedBB maxBB = AxisAlignedBB.a( 0, 0, 0, 0, 0, 0 );
+    static AxisAlignedBB miscBB = AxisAlignedBB.a( 0, 0, 0, 0, 0, 0 );
+    static AxisAlignedBB animalBB = AxisAlignedBB.a( 0, 0, 0, 0, 0, 0 );
+    static AxisAlignedBB monsterBB = AxisAlignedBB.a( 0, 0, 0, 0, 0, 0 );
+
+    /**
+     * Initializes an entities type on construction to specify what group this
+     * entity is in for activation ranges.
+     *
+     * @param entity
+     * @return group id
+     */
+    public static byte initializeEntityActivationType(Entity entity)
+    {
+        if ( entity instanceof EntityMonster || entity instanceof EntitySlime )
+        {
+            return 1; // Monster
+        } else if ( entity instanceof EntityCreature || entity instanceof EntityAmbient )
+        {
+            return 2; // Animal
+        } else
+        {
+            return 3; // Misc
+        }
+    }
+
+    /**
+     * These entities are excluded from Activation range checks.
+     *
+     * @param entity
+     * @param world
+     * @return boolean If it should always tick.
+     */
+    public static boolean initializeEntityActivationState(Entity entity, SpigotWorldConfig config)
+    {
+        if ( ( entity.activationType == 3 && config.miscActivationRange == 0 )
+                || ( entity.activationType == 2 && config.animalActivationRange == 0 )
+                || ( entity.activationType == 1 && config.monsterActivationRange == 0 )
+                || entity instanceof EntityHuman
+                || entity instanceof EntityProjectile
+                || entity instanceof EntityEnderDragon
+                || entity instanceof EntityComplexPart
+                || entity instanceof EntityWither
+                || entity instanceof EntityFireball
+                || entity instanceof EntityWeather
+                || entity instanceof EntityTNTPrimed
+                || entity instanceof EntityEnderCrystal
+                || entity instanceof EntityFireworks )
+        {
+            return true;
+        }
+
+        return false;
+    }
+
+    /**
+     * Utility method to grow an AABB without creating a new AABB or touching
+     * the pool, so we can re-use ones we have.
+     *
+     * @param target
+     * @param source
+     * @param x
+     * @param y
+     * @param z
+     */
+    public static void growBB(AxisAlignedBB target, AxisAlignedBB source, int x, int y, int z)
+    {
+        target.a = source.a - x;
+        target.b = source.b - y;
+        target.c = source.c - z;
+        target.d = source.d + x;
+        target.e = source.e + y;
+        target.f = source.f + z;
+    }
+
+    /**
+     * Find what entities are in range of the players in the world and set
+     * active if in range.
+     *
+     * @param world
+     */
+    public static void activateEntities(World world)
+    {
+        SpigotTimings.entityActivationCheckTimer.startTiming();
+        final int miscActivationRange = world.spigotConfig.miscActivationRange;
+        final int animalActivationRange = world.spigotConfig.animalActivationRange;
+        final int monsterActivationRange = world.spigotConfig.monsterActivationRange;
+
+        int maxRange = Math.max( monsterActivationRange, animalActivationRange );
+        maxRange = Math.max( maxRange, miscActivationRange );
+        maxRange = Math.min( ( world.spigotConfig.viewDistance << 4 ) - 8, maxRange );
+
+        for ( Entity player : new ArrayList<Entity>( world.players ) )
+        {
+
+            player.activatedTick = MinecraftServer.currentTick;
+            growBB( maxBB, player.boundingBox, maxRange, 256, maxRange );
+            growBB( miscBB, player.boundingBox, miscActivationRange, 256, miscActivationRange );
+            growBB( animalBB, player.boundingBox, animalActivationRange, 256, animalActivationRange );
+            growBB( monsterBB, player.boundingBox, monsterActivationRange, 256, monsterActivationRange );
+
+            int i = MathHelper.floor( maxBB.a / 16.0D );
+            int j = MathHelper.floor( maxBB.d / 16.0D );
+            int k = MathHelper.floor( maxBB.c / 16.0D );
+            int l = MathHelper.floor( maxBB.f / 16.0D );
+
+            for ( int i1 = i; i1 <= j; ++i1 )
+            {
+                for ( int j1 = k; j1 <= l; ++j1 )
+                {
+                    if ( world.getWorld().isChunkLoaded( i1, j1 ) )
+                    {
+                        activateChunkEntities( world.getChunkAt( i1, j1 ) );
+                    }
+                }
+            }
+        }
+        SpigotTimings.entityActivationCheckTimer.stopTiming();
+    }
+
+    /**
+     * Checks for the activation state of all entities in this chunk.
+     *
+     * @param chunk
+     */
+    private static void activateChunkEntities(Chunk chunk)
+    {
+        for ( List<Entity> slice : chunk.entitySlices )
+        {
+            for ( Entity entity : slice )
+            {
+                if ( MinecraftServer.currentTick > entity.activatedTick )
+                {
+                    if ( entity.defaultActivationState )
+                    {
+                        entity.activatedTick = MinecraftServer.currentTick;
+                        continue;
+                    }
+                    switch ( entity.activationType )
+                    {
+                        case 1:
+                            if ( monsterBB.b( entity.boundingBox ) )
+                            {
+                                entity.activatedTick = MinecraftServer.currentTick;
+                            }
+                            break;
+                        case 2:
+                            if ( animalBB.b( entity.boundingBox ) )
+                            {
+                                entity.activatedTick = MinecraftServer.currentTick;
+                            }
+                            break;
+                        case 3:
+                        default:
+                            if ( miscBB.b( entity.boundingBox ) )
+                            {
+                                entity.activatedTick = MinecraftServer.currentTick;
+                            }
+                    }
+                }
+            }
+        }
+    }
+
+    /**
+     * If an entity is not in range, do some more checks to see if we should
+     * give it a shot.
+     *
+     * @param entity
+     * @return
+     */
+    public static boolean checkEntityImmunities(Entity entity)
+    {
+        // quick checks.
+        if ( entity.inWater /* isInWater */ || entity.fireTicks > 0 )
+        {
+            return true;
+        }
+        if ( !( entity instanceof EntityArrow ) )
+        {
+            if ( !entity.onGround || entity.passenger != null
+                    || entity.vehicle != null )
+            {
+                return true;
+            }
+        } else if ( !( (EntityArrow) entity ).inGround )
+        {
+            return true;
+        }
+        // special cases.
+        if ( entity instanceof EntityLiving )
+        {
+            EntityLiving living = (EntityLiving) entity;
+            if ( living.attackTicks > 0 || living.hurtTicks > 0 || living.effects.size() > 0 )
+            {
+                return true;
+            }
+            if ( entity instanceof EntityCreature && ( (EntityCreature) entity ).target != null )
+            {
+                return true;
+            }
+            if ( entity instanceof EntityVillager && ( (EntityVillager) entity ).bU() /* Getter for first boolean */ )
+            {
+                return true;
+            }
+            if ( entity instanceof EntityAnimal )
+            {
+                EntityAnimal animal = (EntityAnimal) entity;
+                if ( animal.isBaby() || animal.bY() /*love*/ )
+                {
+                    return true;
+                }
+                if ( entity instanceof EntitySheep && ( (EntitySheep) entity ).isSheared() )
+                {
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+
+    /**
+     * Checks if the entity is active for this tick.
+     *
+     * @param entity
+     * @return
+     */
+    public static boolean checkIfActive(Entity entity)
+    {
+        SpigotTimings.checkIfActiveTimer.startTiming();
+        boolean isActive = entity.activatedTick >= MinecraftServer.currentTick || entity.defaultActivationState;
+
+        // Should this entity tick?
+        if ( !isActive )
+        {
+            if ( ( MinecraftServer.currentTick - entity.activatedTick - 1 ) % 20 == 0 )
+            {
+                // Check immunities every 20 ticks.
+                if ( checkEntityImmunities( entity ) )
+                {
+                    // Triggered some sort of immunity, give 20 full ticks before we check again.
+                    entity.activatedTick = MinecraftServer.currentTick + 20;
+                }
+                isActive = true;
+            }
+            // Add a little performance juice to active entities. Skip 1/4 if not immune.
+        } else if ( !entity.defaultActivationState && entity.ticksLived % 4 == 0 && !checkEntityImmunities( entity ) )
+        {
+            isActive = false;
+        }
+        int x = MathHelper.floor( entity.locX );
+        int z = MathHelper.floor( entity.locZ );
+        // Make sure not on edge of unloaded chunk
+        if ( isActive && !entity.world.areChunksLoaded( x, 0, z, 16 ) )
+        {
+            isActive = false;
+        }
+        SpigotTimings.checkIfActiveTimer.stopTiming();
+        return isActive;
+    }
+}
diff --git a/src/main/java/org/spigotmc/AntiXray.java b/src/main/java/org/spigotmc/AntiXray.java
new file mode 100644
index 0000000..c165304
--- /dev/null
+++ b/src/main/java/org/spigotmc/AntiXray.java
@@ -0,0 +1,204 @@
+package org.spigotmc;
+
+import gnu.trove.set.TByteSet;
+import gnu.trove.set.hash.TByteHashSet;
+import net.minecraft.server.Block;
+import net.minecraft.server.World;
+
+public class AntiXray
+{
+
+    private static final CustomTimingsHandler update = new CustomTimingsHandler( "xray - update" );
+    private static final CustomTimingsHandler obfuscate = new CustomTimingsHandler( "xray - obfuscate" );
+    /*========================================================================*/
+    // Used to keep track of which blocks to obfuscate
+    private final boolean[] obfuscateBlocks = new boolean[ Short.MAX_VALUE ];
+    // Used to select a random replacement ore
+    private byte[] replacementOres;
+
+    public AntiXray(SpigotWorldConfig config)
+    {
+        // Set all listed blocks as true to be obfuscated
+        for ( int id : config.blocks )
+        {
+            obfuscateBlocks[id] = true;
+        }
+
+        // For every block
+        TByteSet blocks = new TByteHashSet();
+        for ( int i = 0; i < obfuscateBlocks.length; i++ )
+        {
+            // If we are obfuscating it
+            if ( obfuscateBlocks[i] )
+            {
+                Block block = Block.byId[i];
+                // Check it exists and is not a tile entity
+                if ( block != null && !block.t() /* isTileEntity */ )
+                {
+                    // Add it to the set of replacement blocks
+                    blocks.add( (byte) i );
+                }
+            }
+        }
+        // Bake it to a flat array of replacements
+        replacementOres = blocks.toArray();
+    }
+
+    /**
+     * Starts the timings handler, then updates all blocks within the set radius
+     * of the given coordinate, revealing them if they are hidden ores.
+     */
+    public void updateNearbyBlocks(World world, int x, int y, int z)
+    {
+        if ( world.spigotConfig.antiXray )
+        {
+            update.startTiming();
+            updateNearbyBlocks( world, x, y, z, 2, false ); // 2 is the radius, we shouldn't change it as that would make it exponentially slower
+            update.stopTiming();
+        }
+    }
+
+    /**
+     * Starts the timings handler, and then removes all non exposed ores from
+     * the chunk buffer.
+     */
+    public void obfuscateSync(int chunkX, int chunkY, int bitmask, byte[] buffer, World world)
+    {
+        if ( world.spigotConfig.antiXray )
+        {
+            obfuscate.startTiming();
+            obfuscate( chunkX, chunkY, bitmask, buffer, world );
+            obfuscate.stopTiming();
+        }
+    }
+
+    /**
+     * Removes all non exposed ores from the chunk buffer.
+     */
+    public void obfuscate(int chunkX, int chunkY, int bitmask, byte[] buffer, World world)
+    {
+        // If the world is marked as obfuscated
+        if ( world.spigotConfig.antiXray )
+        {
+            // Initial radius to search around for air
+            int initialRadius = 1;
+            // Which block in the buffer we are looking at, anywhere from 0 to 16^4
+            int index = 0;
+            // The iterator marking which random ore we should use next
+            int randomOre = 0;
+
+            // Chunk corner X and Z blocks
+            int startX = chunkX << 4;
+            int startZ = chunkY << 4;
+
+            // Chunks can have up to 16 sections
+            for ( int i = 0; i < 16; i++ )
+            {
+                // If the bitmask indicates this chunk is sent...
+                if ( ( bitmask & 1 << i ) != 0 )
+                {
+                    // Work through all blocks in the chunk, y,z,x
+                    for ( int y = 0; y < 16; y++ )
+                    {
+                        for ( int z = 0; z < 16; z++ )
+                        {
+                            for ( int x = 0; x < 16; x++ )
+                            {
+                                // For some reason we can get too far ahead of ourselves (concurrent modification on bulk chunks?) so if we do, just abort and move on
+                                if ( index >= buffer.length )
+                                {
+                                    continue;
+                                }
+                                // Grab the block ID in the buffer.
+                                // TODO: extended IDs are not yet supported
+                                int blockId = buffer[index] & 0xFF;
+                                // Check if the block should be obfuscated
+                                if ( obfuscateBlocks[blockId] )
+                                {
+                                    // TODO: Don't really understand this, but if radius is not 0 and the world isn't loaded, bail out
+                                    if ( initialRadius != 0 && !isLoaded( world, startX + x, ( i << 4 ) + y, startZ + z, initialRadius ) )
+                                    {
+                                        continue;
+                                    }
+                                    // On the otherhand, if radius is 0, or the nearby blocks are all non air, we can obfuscate
+                                    if ( initialRadius == 0 || !hasTransparentBlockAdjacent( world, startX + x, ( i << 4 ) + y, startZ + z, initialRadius ) )
+                                    {
+                                        switch ( world.spigotConfig.engineMode )
+                                        {
+                                            case 1:
+                                                // Replace with stone
+                                                buffer[index] = (byte) Block.STONE.id;
+                                                break;
+                                            case 2:
+                                                // Replace with random ore.
+                                                if ( randomOre >= replacementOres.length )
+                                                {
+                                                    randomOre = 0;
+                                                }
+                                                buffer[index] = replacementOres[randomOre++];
+                                                break;
+                                        }
+                                    }
+                                }
+
+                                index++;
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    private void updateNearbyBlocks(World world, int x, int y, int z, int radius, boolean updateSelf)
+    {
+        // If the block in question is loaded
+        if ( world.isLoaded( x, y, z ) )
+        {
+            // Get block id
+            int id = world.getTypeId( x, y, z );
+
+            // See if it needs update
+            if ( updateSelf && obfuscateBlocks[id] )
+            {
+                // Send the update
+                world.notify( x, y, z );
+            }
+
+            // Check other blocks for updates
+            if ( radius > 0 )
+            {
+                updateNearbyBlocks( world, x + 1, y, z, radius - 1, true );
+                updateNearbyBlocks( world, x - 1, y, z, radius - 1, true );
+                updateNearbyBlocks( world, x, y + 1, z, radius - 1, true );
+                updateNearbyBlocks( world, x, y - 1, z, radius - 1, true );
+                updateNearbyBlocks( world, x, y, z + 1, radius - 1, true );
+                updateNearbyBlocks( world, x, y, z - 1, radius - 1, true );
+            }
+        }
+    }
+
+    private static boolean isLoaded(World world, int x, int y, int z, int radius)
+    {
+        return world.isLoaded( x, y, z )
+                || ( radius > 0
+                && ( isLoaded( world, x + 1, y, z, radius - 1 )
+                || isLoaded( world, x - 1, y, z, radius - 1 )
+                || isLoaded( world, x, y + 1, z, radius - 1 )
+                || isLoaded( world, x, y - 1, z, radius - 1 )
+                || isLoaded( world, x, y, z + 1, radius - 1 )
+                || isLoaded( world, x, y, z - 1, radius - 1 ) ) );
+    }
+
+    private static boolean hasTransparentBlockAdjacent(World world, int x, int y, int z, int radius)
+    {
+        return !Block.l( world.getTypeId( x, y, z ) ) /* isSolidBlock */
+                || ( radius > 0
+                && ( hasTransparentBlockAdjacent( world, x + 1, y, z, radius - 1 )
+                || hasTransparentBlockAdjacent( world, x - 1, y, z, radius - 1 )
+                || hasTransparentBlockAdjacent( world, x, y + 1, z, radius - 1 )
+                || hasTransparentBlockAdjacent( world, x, y - 1, z, radius - 1 )
+                || hasTransparentBlockAdjacent( world, x, y, z + 1, radius - 1 )
+                || hasTransparentBlockAdjacent( world, x, y, z - 1, radius - 1 ) ) );
+    }
+}
diff --git a/src/main/java/org/spigotmc/ChatConverter.java b/src/main/java/org/spigotmc/ChatConverter.java
new file mode 100644
index 0000000..26ec8a3
--- /dev/null
+++ b/src/main/java/org/spigotmc/ChatConverter.java
@@ -0,0 +1,197 @@
+package org.spigotmc;
+
+import com.google.gson.Gson;
+import com.google.gson.annotations.SerializedName;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+public class ChatConverter {
+
+    private static final Gson gson = new Gson();
+    private static final char COLOR_CHAR = '\u00A7';
+    private static final Pattern url = Pattern.compile("^(?:(https?)://)?([-\\w_\\.]{2,}\\.[a-z]{2,4})(/\\S*)?$");
+
+    public static String[] toJSONChat(String txt) {
+        Message msg = new Message();
+        ArrayList<String> parts = new ArrayList<String>();
+        StringBuilder outBuffer = new StringBuilder("[");
+        StringBuilder buf = new StringBuilder();
+        Matcher matcher = url.matcher(txt);
+        for (int i = 0; i < txt.length(); i++) {
+            char c = txt.charAt(i);
+            if (c != COLOR_CHAR) {
+                int pos = txt.indexOf(' ', i);
+                if (pos == -1) pos = txt.length();
+                if (matcher.region(i, pos).find()) { //Web link handling
+                    msg.text = buf.toString();
+                    buf = new StringBuilder();
+                    outBuffer = append(parts, outBuffer, msg);
+                    Message old = msg;
+                    msg = new Message(old);
+                    msg.clickEvent = new ClickEvent();
+                    msg.clickEvent.action = "open_url";
+                    String urlString = txt.substring(i, pos);
+                    if (urlString.startsWith("http")) {
+                        msg.text = msg.clickEvent.value = urlString;
+                    } else {
+                        msg.text = urlString;
+                        msg.clickEvent.value = "http://" + urlString;
+                    }
+                    outBuffer = append(parts, outBuffer, msg);
+                    i += pos - i - 1;
+                    msg = new Message(old);
+                    continue;
+                }
+                buf.append(c);
+                continue;
+            }
+            i++;
+            c = txt.charAt(i);
+            if (c >= 'A' && c <= 'Z') {
+                c += 32;
+            }
+            msg.text = buf.toString();
+            buf = new StringBuilder();
+            outBuffer = append(parts, outBuffer, msg);
+            msg = new Message(msg);
+            switch(c) {
+                case 'k':
+                    msg.obfuscated = true;
+                    break;
+                case 'l':
+                    msg.bold = true;
+                    break;
+                case 'm':
+                    msg.strikethrough = true;
+                    break;
+                case 'n':
+                    msg.underlined = true;
+                    break;
+                case 'o':
+                    msg.italic = true;
+                    break;
+                default:
+                    msg.obfuscated = false;
+                    msg.bold = false;
+                    msg.strikethrough = false;
+                    msg.underlined = false;
+                    msg.italic = false;
+                    if (c != 'r') {
+                        msg.color = Color.fromCode(Character.toString(c));
+                    } else {
+                        msg.color = Color.WHITE;
+                    }
+                    break;
+            }
+        }
+        msg.text = buf.toString();
+        append(parts, outBuffer, msg);
+
+        parts.add(outBuffer.append("]").toString());
+        String[] pArray = new String[parts.size()];
+        parts.toArray(pArray);
+        return pArray;
+    }
+
+    private static StringBuilder append(ArrayList<String> parts, StringBuilder outBuffer, Message part) {
+        String p = gson.toJson(part);
+        if (p.length() + outBuffer.length() + 1 >= Short.MAX_VALUE  - 20) {
+            outBuffer.append("]");
+            parts.add(outBuffer.toString());
+            outBuffer = new StringBuilder("[");
+        }
+        if (outBuffer.length() != 1) {
+            outBuffer.append(",");
+        }
+        outBuffer.append(p);
+        return outBuffer;
+    }
+}
+
+class Message {
+    public String text;
+
+    public boolean bold;
+    public boolean italic;
+    public boolean underlined;
+    public boolean strikethrough;
+    public boolean obfuscated;
+
+    public Color color;
+
+    public ClickEvent clickEvent;
+
+    public Message() {
+
+    }
+
+    public Message(Message old) {
+        this.bold = old.bold;
+        this.italic = old.italic;
+        this.underlined = old.underlined;
+        this.strikethrough = old.strikethrough;
+        this.color = old.color;
+    }
+}
+
+class ClickEvent {
+    public String action;
+    public String value;
+}
+
+enum Color {
+    @SerializedName("black")
+    BLACK("0"),
+    @SerializedName("dark_blue")
+    DARK_BLUE("1"),
+    @SerializedName("dark_green")
+    DARK_GREEN("2"),
+    @SerializedName("dark_aqua")
+    DARK_AQUA("3"),
+    @SerializedName("dark_red")
+    DARK_RED("4"),
+    @SerializedName("dark_purple")
+    DARK_PURPLE("5"),
+    @SerializedName("gold")
+    GOLD("6"),
+    @SerializedName("gray")
+    GRAY("7"),
+    @SerializedName("dark_gray")
+    DARK_GRAY("8"),
+    @SerializedName("blue")
+    BLUE("9"),
+    @SerializedName("green")
+    GREEN("a"),
+    @SerializedName("aqua")
+    AQUA("b"),
+    @SerializedName("red")
+    RED("c"),
+    @SerializedName("light_purple")
+    LIGHT_PURPLE("d"),
+    @SerializedName("yellow")
+    YELLOW("e"),
+    @SerializedName("white")
+    WHITE("f");
+
+    public String code;
+
+    Color(String code) {
+        this.code = code;
+    }
+
+
+    private static HashMap<String, Color> codeMap = new HashMap<String, Color>();
+
+    public static Color fromCode(String code) {
+        return codeMap.get(code);
+    }
+
+    static {
+        for (Color color : values()) {
+            codeMap.put(color.code, color);
+        }
+    }
+}
diff --git a/src/main/java/org/spigotmc/FlatMap.java b/src/main/java/org/spigotmc/FlatMap.java
new file mode 100644
index 0000000..9416f6e
--- /dev/null
+++ b/src/main/java/org/spigotmc/FlatMap.java
@@ -0,0 +1,64 @@
+package org.spigotmc;
+
+import org.bukkit.craftbukkit.util.LongHash;
+
+public class FlatMap<V>
+{
+
+    private static final int FLAT_LOOKUP_SIZE = 512;
+    private final Object[][] flatLookup = new Object[ FLAT_LOOKUP_SIZE * 2 ][ FLAT_LOOKUP_SIZE * 2 ];
+
+    public void put(long msw, long lsw, V value)
+    {
+        long acx = Math.abs( msw );
+        long acz = Math.abs( lsw );
+        if ( acx < FLAT_LOOKUP_SIZE && acz < FLAT_LOOKUP_SIZE )
+        {
+            flatLookup[(int) ( msw + FLAT_LOOKUP_SIZE )][(int) ( lsw + FLAT_LOOKUP_SIZE )] = value;
+        }
+    }
+
+    public void put(long key, V value)
+    {
+        put( LongHash.msw( key ), LongHash.lsw( key ), value );
+
+    }
+
+    public void remove(long key)
+    {
+        put( key, null );
+    }
+
+    public void remove(long msw, long lsw)
+    {
+        put( msw, lsw, null );
+    }
+
+    public boolean contains(long msw, long lsw)
+    {
+        return get( msw, lsw ) != null;
+    }
+
+    public boolean contains(long key)
+    {
+        return get( key ) != null;
+    }
+
+    public V get(long msw, long lsw)
+    {
+        long acx = Math.abs( msw );
+        long acz = Math.abs( lsw );
+        if ( acx < FLAT_LOOKUP_SIZE && acz < FLAT_LOOKUP_SIZE )
+        {
+            return (V) flatLookup[(int) ( msw + FLAT_LOOKUP_SIZE )][(int) ( lsw + FLAT_LOOKUP_SIZE )];
+        } else
+        {
+            return null;
+        }
+    }
+
+    public V get(long key)
+    {
+        return get( LongHash.msw( key ), LongHash.lsw( key ) );
+    }
+}
diff --git a/src/main/java/org/spigotmc/LogFilter.java b/src/main/java/org/spigotmc/LogFilter.java
new file mode 100644
index 0000000..aa7e9ab
--- /dev/null
+++ b/src/main/java/org/spigotmc/LogFilter.java
@@ -0,0 +1,24 @@
+package org.spigotmc;
+
+import java.util.logging.Filter;
+import java.util.logging.LogRecord;
+import java.util.regex.Pattern;
+
+public class LogFilter implements Filter
+{
+
+    public boolean isLoggable(LogRecord record)
+    {
+        if ( record.getMessage() != null )
+        {
+            for ( Pattern pattern : SpigotConfig.logFilters )
+            {
+                if ( pattern.matcher( record.getMessage() ).matches() )
+                {
+                    return false;
+                }
+            }
+        }
+        return true;
+    }
+}
diff --git a/src/main/java/org/spigotmc/Metrics.java b/src/main/java/org/spigotmc/Metrics.java
new file mode 100644
index 0000000..f1690a2
--- /dev/null
+++ b/src/main/java/org/spigotmc/Metrics.java
@@ -0,0 +1,645 @@
+/*
+ * Copyright 2011-2013 Tyler Blair. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are
+ * permitted provided that the following conditions are met:
+ *
+ *    1. Redistributions of source code must retain the above copyright notice, this list of
+ *       conditions and the following disclaimer.
+ *
+ *    2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *       of conditions and the following disclaimer in the documentation and/or other materials
+ *       provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ''AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * The views and conclusions contained in the software and documentation are those of the
+ * authors and contributors and should not be interpreted as representing official policies,
+ * either expressed or implied, of anybody else.
+ */
+package org.spigotmc;
+
+import org.bukkit.Bukkit;
+import org.bukkit.configuration.file.YamlConfiguration;
+import org.bukkit.configuration.InvalidConfigurationException;
+import org.bukkit.plugin.Plugin;
+import org.bukkit.plugin.PluginDescriptionFile;
+import org.bukkit.scheduler.BukkitTask;
+
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.io.OutputStreamWriter;
+import java.io.UnsupportedEncodingException;
+import java.net.Proxy;
+import java.net.URL;
+import java.net.URLConnection;
+import java.net.URLEncoder;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.LinkedHashSet;
+import java.util.Set;
+import java.util.Timer;
+import java.util.TimerTask;
+import java.util.UUID;
+import java.util.concurrent.TimeUnit;
+import java.util.logging.Level;
+import net.minecraft.server.MinecraftServer;
+
+/**
+ * <p> The metrics class obtains data about a plugin and submits statistics about it to the metrics backend. </p> <p>
+ * Public methods provided by this class: </p>
+ * <code>
+ * Graph createGraph(String name); <br/>
+ * void addCustomData(BukkitMetrics.Plotter plotter); <br/>
+ * void start(); <br/>
+ * </code>
+ */
+public class Metrics {
+
+    /**
+     * The current revision number
+     */
+    private final static int REVISION = 6;
+    /**
+     * The base url of the metrics domain
+     */
+    private static final String BASE_URL = "http://mcstats.org";
+    /**
+     * The url used to report a server's status
+     */
+    private static final String REPORT_URL = "/report/%s";
+    /**
+     * The separator to use for custom data. This MUST NOT change unless you are hosting your own version of metrics and
+     * want to change it.
+     */
+    private static final String CUSTOM_DATA_SEPARATOR = "~~";
+    /**
+     * Interval of time to ping (in minutes)
+     */
+    private static final int PING_INTERVAL = 10;
+    /**
+     * All of the custom graphs to submit to metrics
+     */
+    private final Set<Graph> graphs = Collections.synchronizedSet(new HashSet<Graph>());
+    /**
+     * The default graph, used for addCustomData when you don't want a specific graph
+     */
+    private final Graph defaultGraph = new Graph("Default");
+    /**
+     * The plugin configuration file
+     */
+    private final YamlConfiguration configuration;
+    /**
+     * The plugin configuration file
+     */
+    private final File configurationFile;
+    /**
+     * Unique server id
+     */
+    private final String guid;
+    /**
+     * Debug mode
+     */
+    private final boolean debug;
+    /**
+     * Lock for synchronization
+     */
+    private final Object optOutLock = new Object();
+    /**
+     * The scheduled task
+     */
+    private volatile Timer task = null;
+
+    public Metrics() throws IOException {
+        // load the config
+        configurationFile = getConfigFile();
+        configuration = YamlConfiguration.loadConfiguration(configurationFile);
+
+        // add some defaults
+        configuration.addDefault("opt-out", false);
+        configuration.addDefault("guid", UUID.randomUUID().toString());
+        configuration.addDefault("debug", false);
+
+        // Do we need to create the file?
+        if (configuration.get("guid", null) == null) {
+            configuration.options().header("http://mcstats.org").copyDefaults(true);
+            configuration.save(configurationFile);
+        }
+
+        // Load the guid then
+        guid = configuration.getString("guid");
+        debug = configuration.getBoolean("debug", false);
+    }
+
+    /**
+     * Construct and create a Graph that can be used to separate specific plotters to their own graphs on the metrics
+     * website. Plotters can be added to the graph object returned.
+     *
+     * @param name The name of the graph
+     * @return Graph object created. Will never return NULL under normal circumstances unless bad parameters are given
+     */
+    public Graph createGraph(final String name) {
+        if (name == null) {
+            throw new IllegalArgumentException("Graph name cannot be null");
+        }
+
+        // Construct the graph object
+        final Graph graph = new Graph(name);
+
+        // Now we can add our graph
+        graphs.add(graph);
+
+        // and return back
+        return graph;
+    }
+
+    /**
+     * Add a Graph object to BukkitMetrics that represents data for the plugin that should be sent to the backend
+     *
+     * @param graph The name of the graph
+     */
+    public void addGraph(final Graph graph) {
+        if (graph == null) {
+            throw new IllegalArgumentException("Graph cannot be null");
+        }
+
+        graphs.add(graph);
+    }
+
+    /**
+     * Adds a custom data plotter to the default graph
+     *
+     * @param plotter The plotter to use to plot custom data
+     */
+    public void addCustomData(final Plotter plotter) {
+        if (plotter == null) {
+            throw new IllegalArgumentException("Plotter cannot be null");
+        }
+
+        // Add the plotter to the graph o/
+        defaultGraph.addPlotter(plotter);
+
+        // Ensure the default graph is included in the submitted graphs
+        graphs.add(defaultGraph);
+    }
+
+    /**
+     * Start measuring statistics. This will immediately create an async repeating task as the plugin and send the
+     * initial data to the metrics backend, and then after that it will post in increments of PING_INTERVAL * 1200
+     * ticks.
+     *
+     * @return True if statistics measuring is running, otherwise false.
+     */
+    public boolean start() {
+        synchronized (optOutLock) {
+            // Did we opt out?
+            if (isOptOut()) {
+                return false;
+            }
+
+            // Is metrics already running?
+            if (task != null) {
+                return true;
+            }
+
+            // Begin hitting the server with glorious data
+            task = new Timer("Spigot Metrics Thread", true);
+
+            task.scheduleAtFixedRate(new TimerTask() {
+                private boolean firstPost = true;
+
+                public void run() {
+                    try {
+                        // This has to be synchronized or it can collide with the disable method.
+                        synchronized (optOutLock) {
+                            // Disable Task, if it is running and the server owner decided to opt-out
+                            if (isOptOut() && task != null) {
+                                task.cancel();
+                                task = null;
+                                // Tell all plotters to stop gathering information.
+                                for (Graph graph : graphs) {
+                                    graph.onOptOut();
+                                }
+                            }
+                        }
+
+                        // We use the inverse of firstPost because if it is the first time we are posting,
+                        // it is not a interval ping, so it evaluates to FALSE
+                        // Each time thereafter it will evaluate to TRUE, i.e PING!
+                        postPlugin(!firstPost);
+
+                        // After the first post we set firstPost to false
+                        // Each post thereafter will be a ping
+                        firstPost = false;
+                    } catch (IOException e) {
+                        if (debug) {
+                            Bukkit.getLogger().log(Level.INFO, "[Metrics] " + e.getMessage());
+                        }
+                    }
+                }
+            }, 0, TimeUnit.MINUTES.toMillis(PING_INTERVAL));
+
+            return true;
+        }
+    }
+
+    /**
+     * Has the server owner denied plugin metrics?
+     *
+     * @return true if metrics should be opted out of it
+     */
+    public boolean isOptOut() {
+        synchronized (optOutLock) {
+            try {
+                // Reload the metrics file
+                configuration.load(getConfigFile());
+            } catch (IOException ex) {
+                if (debug) {
+                    Bukkit.getLogger().log(Level.INFO, "[Metrics] " + ex.getMessage());
+                }
+                return true;
+            } catch (InvalidConfigurationException ex) {
+                if (debug) {
+                    Bukkit.getLogger().log(Level.INFO, "[Metrics] " + ex.getMessage());
+                }
+                return true;
+            }
+            return configuration.getBoolean("opt-out", false);
+        }
+    }
+
+    /**
+     * Enables metrics for the server by setting "opt-out" to false in the config file and starting the metrics task.
+     *
+     * @throws java.io.IOException
+     */
+    public void enable() throws IOException {
+        // This has to be synchronized or it can collide with the check in the task.
+        synchronized (optOutLock) {
+            // Check if the server owner has already set opt-out, if not, set it.
+            if (isOptOut()) {
+                configuration.set("opt-out", false);
+                configuration.save(configurationFile);
+            }
+
+            // Enable Task, if it is not running
+            if (task == null) {
+                start();
+            }
+        }
+    }
+
+    /**
+     * Disables metrics for the server by setting "opt-out" to true in the config file and canceling the metrics task.
+     *
+     * @throws java.io.IOException
+     */
+    public void disable() throws IOException {
+        // This has to be synchronized or it can collide with the check in the task.
+        synchronized (optOutLock) {
+            // Check if the server owner has already set opt-out, if not, set it.
+            if (!isOptOut()) {
+                configuration.set("opt-out", true);
+                configuration.save(configurationFile);
+            }
+
+            // Disable Task, if it is running
+            if (task != null) {
+                task.cancel();
+                task = null;
+            }
+        }
+    }
+
+    /**
+     * Gets the File object of the config file that should be used to store data such as the GUID and opt-out status
+     *
+     * @return the File object for the config file
+     */
+    public File getConfigFile() {
+        // I believe the easiest way to get the base folder (e.g craftbukkit set via -P) for plugins to use
+        // is to abuse the plugin object we already have
+        // plugin.getDataFolder() => base/plugins/PluginA/
+        // pluginsFolder => base/plugins/
+        // The base is not necessarily relative to the startup directory.
+        // File pluginsFolder = plugin.getDataFolder().getParentFile();
+
+        // return => base/plugins/PluginMetrics/config.yml
+        return new File(new File((File) MinecraftServer.getServer().options.valueOf("plugins"), "PluginMetrics"), "config.yml");
+    }
+
+    /**
+     * Generic method that posts a plugin to the metrics website
+     */
+    private void postPlugin(final boolean isPing) throws IOException {
+        // Server software specific section
+        String pluginName = "Spigot";
+        boolean onlineMode = Bukkit.getServer().getOnlineMode(); // TRUE if online mode is enabled
+        String pluginVersion = (Metrics.class.getPackage().getImplementationVersion() != null) ? Metrics.class.getPackage().getImplementationVersion() : "unknown";
+        String serverVersion = Bukkit.getVersion();
+        int playersOnline = Bukkit.getServer().getOnlinePlayers().length;
+
+        // END server software specific section -- all code below does not use any code outside of this class / Java
+
+        // Construct the post data
+        final StringBuilder data = new StringBuilder();
+
+        // The plugin's description file containg all of the plugin data such as name, version, author, etc
+        data.append(encode("guid")).append('=').append(encode(guid));
+        encodeDataPair(data, "version", pluginVersion);
+        encodeDataPair(data, "server", serverVersion);
+        encodeDataPair(data, "players", Integer.toString(playersOnline));
+        encodeDataPair(data, "revision", String.valueOf(REVISION));
+
+        // New data as of R6
+        String osname = System.getProperty("os.name");
+        String osarch = System.getProperty("os.arch");
+        String osversion = System.getProperty("os.version");
+        String java_version = System.getProperty("java.version");
+        int coreCount = Runtime.getRuntime().availableProcessors();
+
+        // normalize os arch .. amd64 -> x86_64
+        if (osarch.equals("amd64")) {
+            osarch = "x86_64";
+        }
+
+        encodeDataPair(data, "osname", osname);
+        encodeDataPair(data, "osarch", osarch);
+        encodeDataPair(data, "osversion", osversion);
+        encodeDataPair(data, "cores", Integer.toString(coreCount));
+        encodeDataPair(data, "online-mode", Boolean.toString(onlineMode));
+        encodeDataPair(data, "java_version", java_version);
+
+        // If we're pinging, append it
+        if (isPing) {
+            encodeDataPair(data, "ping", "true");
+        }
+
+        // Acquire a lock on the graphs, which lets us make the assumption we also lock everything
+        // inside of the graph (e.g plotters)
+        synchronized (graphs) {
+            final Iterator<Graph> iter = graphs.iterator();
+
+            while (iter.hasNext()) {
+                final Graph graph = iter.next();
+
+                for (Plotter plotter : graph.getPlotters()) {
+                    // The key name to send to the metrics server
+                    // The format is C-GRAPHNAME-PLOTTERNAME where separator - is defined at the top
+                    // Legacy (R4) submitters use the format Custom%s, or CustomPLOTTERNAME
+                    final String key = String.format("C%s%s%s%s", CUSTOM_DATA_SEPARATOR, graph.getName(), CUSTOM_DATA_SEPARATOR, plotter.getColumnName());
+
+                    // The value to send, which for the foreseeable future is just the string
+                    // value of plotter.getValue()
+                    final String value = Integer.toString(plotter.getValue());
+
+                    // Add it to the http post data :)
+                    encodeDataPair(data, key, value);
+                }
+            }
+        }
+
+        // Create the url
+        URL url = new URL(BASE_URL + String.format(REPORT_URL, encode(pluginName)));
+
+        // Connect to the website
+        URLConnection connection;
+
+        // Mineshafter creates a socks proxy, so we can safely bypass it
+        // It does not reroute POST requests so we need to go around it
+        if (isMineshafterPresent()) {
+            connection = url.openConnection(Proxy.NO_PROXY);
+        } else {
+            connection = url.openConnection();
+        }
+
+        connection.setDoOutput(true);
+
+        // Write the data
+        final OutputStreamWriter writer = new OutputStreamWriter(connection.getOutputStream());
+        writer.write(data.toString());
+        writer.flush();
+
+        // Now read the response
+        final BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));
+        final String response = reader.readLine();
+
+        // close resources
+        writer.close();
+        reader.close();
+
+        if (response == null || response.startsWith("ERR")) {
+            throw new IOException(response); //Throw the exception
+        } else {
+            // Is this the first update this hour?
+            if (response.contains("OK This is your first update this hour")) {
+                synchronized (graphs) {
+                    final Iterator<Graph> iter = graphs.iterator();
+
+                    while (iter.hasNext()) {
+                        final Graph graph = iter.next();
+
+                        for (Plotter plotter : graph.getPlotters()) {
+                            plotter.reset();
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    /**
+     * Check if mineshafter is present. If it is, we need to bypass it to send POST requests
+     *
+     * @return true if mineshafter is installed on the server
+     */
+    private boolean isMineshafterPresent() {
+        try {
+            Class.forName("mineshafter.MineServer");
+            return true;
+        } catch (Exception e) {
+            return false;
+        }
+    }
+
+    /**
+     * <p>Encode a key/value data pair to be used in a HTTP post request. This INCLUDES a & so the first key/value pair
+     * MUST be included manually, e.g:</p>
+     * <code>
+     * StringBuffer data = new StringBuffer();
+     * data.append(encode("guid")).append('=').append(encode(guid));
+     * encodeDataPair(data, "version", description.getVersion());
+     * </code>
+     *
+     * @param buffer the stringbuilder to append the data pair onto
+     * @param key the key value
+     * @param value the value
+     */
+    private static void encodeDataPair(final StringBuilder buffer, final String key, final String value) throws UnsupportedEncodingException {
+        buffer.append('&').append(encode(key)).append('=').append(encode(value));
+    }
+
+    /**
+     * Encode text as UTF-8
+     *
+     * @param text the text to encode
+     * @return the encoded text, as UTF-8
+     */
+    private static String encode(final String text) throws UnsupportedEncodingException {
+        return URLEncoder.encode(text, "UTF-8");
+    }
+
+    /**
+     * Represents a custom graph on the website
+     */
+    public static class Graph {
+
+        /**
+         * The graph's name, alphanumeric and spaces only :) If it does not comply to the above when submitted, it is
+         * rejected
+         */
+        private final String name;
+        /**
+         * The set of plotters that are contained within this graph
+         */
+        private final Set<Plotter> plotters = new LinkedHashSet<Plotter>();
+
+        private Graph(final String name) {
+            this.name = name;
+        }
+
+        /**
+         * Gets the graph's name
+         *
+         * @return the Graph's name
+         */
+        public String getName() {
+            return name;
+        }
+
+        /**
+         * Add a plotter to the graph, which will be used to plot entries
+         *
+         * @param plotter the plotter to add to the graph
+         */
+        public void addPlotter(final Plotter plotter) {
+            plotters.add(plotter);
+        }
+
+        /**
+         * Remove a plotter from the graph
+         *
+         * @param plotter the plotter to remove from the graph
+         */
+        public void removePlotter(final Plotter plotter) {
+            plotters.remove(plotter);
+        }
+
+        /**
+         * Gets an <b>unmodifiable</b> set of the plotter objects in the graph
+         *
+         * @return an unmodifiable {@link java.util.Set} of the plotter objects
+         */
+        public Set<Plotter> getPlotters() {
+            return Collections.unmodifiableSet(plotters);
+        }
+
+        @Override
+        public int hashCode() {
+            return name.hashCode();
+        }
+
+        @Override
+        public boolean equals(final Object object) {
+            if (!(object instanceof Graph)) {
+                return false;
+            }
+
+            final Graph graph = (Graph) object;
+            return graph.name.equals(name);
+        }
+
+        /**
+         * Called when the server owner decides to opt-out of BukkitMetrics while the server is running.
+         */
+        protected void onOptOut() {
+        }
+    }
+
+    /**
+     * Interface used to collect custom data for a plugin
+     */
+    public static abstract class Plotter {
+
+        /**
+         * The plot's name
+         */
+        private final String name;
+
+        /**
+         * Construct a plotter with the default plot name
+         */
+        public Plotter() {
+            this("Default");
+        }
+
+        /**
+         * Construct a plotter with a specific plot name
+         *
+         * @param name the name of the plotter to use, which will show up on the website
+         */
+        public Plotter(final String name) {
+            this.name = name;
+        }
+
+        /**
+         * Get the current value for the plotted point. Since this function defers to an external function it may or may
+         * not return immediately thus cannot be guaranteed to be thread friendly or safe. This function can be called
+         * from any thread so care should be taken when accessing resources that need to be synchronized.
+         *
+         * @return the current value for the point to be plotted.
+         */
+        public abstract int getValue();
+
+        /**
+         * Get the column name for the plotted point
+         *
+         * @return the plotted point's column name
+         */
+        public String getColumnName() {
+            return name;
+        }
+
+        /**
+         * Called after the website graphs have been updated
+         */
+        public void reset() {
+        }
+
+        @Override
+        public int hashCode() {
+            return getColumnName().hashCode();
+        }
+
+        @Override
+        public boolean equals(final Object object) {
+            if (!(object instanceof Plotter)) {
+                return false;
+            }
+
+            final Plotter plotter = (Plotter) object;
+            return plotter.name.equals(name) && plotter.getValue() == getValue();
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/org/spigotmc/RestartCommand.java b/src/main/java/org/spigotmc/RestartCommand.java
new file mode 100644
index 0000000..3ca7a46
--- /dev/null
+++ b/src/main/java/org/spigotmc/RestartCommand.java
@@ -0,0 +1,111 @@
+package org.spigotmc;
+
+import java.io.File;
+import java.util.List;
+import net.minecraft.server.EntityPlayer;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.Packet255KickDisconnect;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+
+public class RestartCommand extends Command
+{
+
+    public RestartCommand(String name)
+    {
+        super( name );
+        this.description = "Restarts the server";
+        this.usageMessage = "/restart";
+        this.setPermission( "bukkit.command.restart" );
+    }
+
+    @Override
+    public boolean execute(CommandSender sender, String currentAlias, String[] args)
+    {
+        if ( testPermission( sender ) )
+        {
+            restart();
+        }
+        return true;
+    }
+
+    public static void restart()
+    {
+        try
+        {
+            final File file = new File( SpigotConfig.restartScript );
+            if ( file.isFile() )
+            {
+                System.out.println( "Attempting to restart with " + SpigotConfig.restartScript );
+
+                // Kick all players
+                for ( EntityPlayer p : (List< EntityPlayer>) MinecraftServer.getServer().getPlayerList().players )
+                {
+                    p.playerConnection.networkManager.queue( new Packet255KickDisconnect( SpigotConfig.restartMessage ) );
+                    p.playerConnection.networkManager.d();
+                }
+                // Give the socket a chance to send the packets
+                try
+                {
+                    Thread.sleep( 100 );
+                } catch ( InterruptedException ex )
+                {
+                }
+                // Close the socket so we can rebind with the new process
+                MinecraftServer.getServer().ag().a();
+
+                // Give time for it to kick in
+                try
+                {
+                    Thread.sleep( 100 );
+                } catch ( InterruptedException ex )
+                {
+                }
+
+                // Actually shutdown
+                try
+                {
+                    MinecraftServer.getServer().stop();
+                } catch ( Throwable t )
+                {
+                }
+
+                // This will be done AFTER the server has completely halted
+                Thread shutdownHook = new Thread()
+                {
+                    @Override
+                    public void run()
+                    {
+                        try
+                        {
+                            String os = System.getProperty( "os.name" ).toLowerCase();
+                            if ( os.contains( "win" ) )
+                            {
+                                Runtime.getRuntime().exec( "cmd /c start " + file.getPath() );
+                            } else
+                            {
+                                Runtime.getRuntime().exec( new String[]
+                                {
+                                    "sh", file.getPath()
+                                } );
+                            }
+                        } catch ( Exception e )
+                        {
+                            e.printStackTrace();
+                        }
+                    }
+                };
+
+                shutdownHook.setDaemon( true );
+                Runtime.getRuntime().addShutdownHook( shutdownHook );
+            } else
+            {
+                System.out.println( "Startup script '" + SpigotConfig.restartScript + "' does not exist! Stopping server." );
+            }
+            System.exit( 0 );
+        } catch ( Exception ex )
+        {
+            ex.printStackTrace();
+        }
+    }
+}
diff --git a/src/main/java/org/spigotmc/SpamHaus.java b/src/main/java/org/spigotmc/SpamHaus.java
new file mode 100644
index 0000000..55d8d12
--- /dev/null
+++ b/src/main/java/org/spigotmc/SpamHaus.java
@@ -0,0 +1,44 @@
+package org.spigotmc;
+
+import java.net.InetAddress;
+import net.minecraft.server.PendingConnection;
+
+public class SpamHaus
+{
+
+    private SpamHaus()
+    {
+    }
+
+    public static boolean filterIp(PendingConnection con)
+    {
+        if ( SpigotConfig.preventProxies )
+        {
+            try
+            {
+                InetAddress address = con.getSocket().getInetAddress();
+                String ip = address.getHostAddress();
+
+                if ( !address.isLoopbackAddress() )
+                {
+                    String[] split = ip.split( "\\." );
+                    StringBuilder lookup = new StringBuilder();
+                    for ( int i = split.length - 1; i >= 0; i-- )
+                    {
+                        lookup.append( split[i] );
+                        lookup.append( "." );
+                    }
+                    lookup.append( "xbl.spamhaus.org." );
+                    if ( InetAddress.getByName( lookup.toString() ) != null )
+                    {
+                        con.disconnect( "Your IP address (" + ip + ") is flagged as unsafe by spamhaus.org/xbl" );
+                        return true;
+                    }
+                }
+            } catch ( Exception ex )
+            {
+            }
+        }
+        return false;
+    }
+}
diff --git a/src/main/java/org/spigotmc/SpigotConfig.java b/src/main/java/org/spigotmc/SpigotConfig.java
new file mode 100644
index 0000000..06cc126
--- /dev/null
+++ b/src/main/java/org/spigotmc/SpigotConfig.java
@@ -0,0 +1,293 @@
+package org.spigotmc;
+
+import com.google.common.base.Throwables;
+import java.io.File;
+import java.io.IOException;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.logging.Level;
+import java.util.regex.Pattern;
+import java.util.regex.PatternSyntaxException;
+import net.minecraft.server.MinecraftServer;
+import org.bukkit.Bukkit;
+import org.bukkit.ChatColor;
+import org.bukkit.command.Command;
+import org.bukkit.configuration.file.YamlConfiguration;
+import org.bukkit.craftbukkit.command.TicksPerSecondCommand;
+
+public class SpigotConfig
+{
+
+    private static final File CONFIG_FILE = new File( "spigot.yml" );
+    private static final String HEADER = "This is the main configuration file for Spigot.\n"
+            + "As you can see, there's tons to configure. Some options may impact gameplay, so use\n"
+            + "with caution, and make sure you know what each option does before configuring.\n"
+            + "For a reference for any variable inside this file, check out the Spigot wiki at\n"
+            + "http://www.spigotmc.org/wiki/spigot-configuration/\n"
+            + "\n"
+            + "If you need help with the configuration or have any questions related to Spigot,\n"
+            + "join us at the IRC or drop by our forums and leave a post.\n"
+            + "\n"
+            + "IRC: #spigot @ irc.esper.net ( http://webchat.esper.net/?channel=spigot )\n"
+            + "Forums: http://www.spigotmc.org/forum/\n";
+    /*========================================================================*/
+    static YamlConfiguration config;
+    static int version;
+    static Map<String, Command> commands;
+    /*========================================================================*/
+    private static Metrics metrics;
+
+    public static void init()
+    {
+        config = YamlConfiguration.loadConfiguration( CONFIG_FILE );
+        config.options().header( HEADER );
+        config.options().copyDefaults( true );
+
+        commands = new HashMap<String, Command>();
+
+        version = getInt( "config-version", 4 );
+        set( "config-version", 4 );
+        readConfig( SpigotConfig.class, null );
+    }
+
+    public static void registerCommands()
+    {
+        for ( Map.Entry<String, Command> entry : commands.entrySet() )
+        {
+            MinecraftServer.getServer().server.getCommandMap().register( entry.getKey(), "Spigot", entry.getValue() );
+        }
+
+        if ( metrics == null )
+        {
+            try
+            {
+                metrics = new Metrics();
+                metrics.start();
+            } catch ( IOException ex )
+            {
+                Bukkit.getServer().getLogger().log( Level.SEVERE, "Could not start metrics service", ex );
+            }
+        }
+    }
+
+    static void readConfig(Class<?> clazz, Object instance)
+    {
+        for ( Method method : clazz.getDeclaredMethods() )
+        {
+            if ( Modifier.isPrivate( method.getModifiers() ) )
+            {
+                if ( method.getParameterTypes().length == 0 && method.getReturnType() == Void.TYPE )
+                {
+                    try
+                    {
+                        method.setAccessible( true );
+                        method.invoke( instance );
+                    } catch ( InvocationTargetException ex )
+                    {
+                        Throwables.propagate( ex.getCause() );
+                    } catch ( Exception ex )
+                    {
+                        Bukkit.getLogger().log( Level.SEVERE, "Error invoking " + method, ex );
+                    }
+                }
+            }
+        }
+
+        try
+        {
+            config.save( CONFIG_FILE );
+        } catch ( IOException ex )
+        {
+            Bukkit.getLogger().log( Level.SEVERE, "Could not save " + CONFIG_FILE, ex );
+        }
+    }
+
+    private static void set(String path, Object val)
+    {
+        config.set( path, val );
+    }
+
+    private static boolean getBoolean(String path, boolean def)
+    {
+        config.addDefault( path, def );
+        return config.getBoolean( path, config.getBoolean( path ) );
+    }
+
+    private static int getInt(String path, int def)
+    {
+        config.addDefault( path, def );
+        return config.getInt( path, config.getInt( path ) );
+    }
+
+    private static <T> List getList(String path, T def)
+    {
+        config.addDefault( path, def );
+        return (List<T>) config.getList( path, config.getList( path ) );
+    }
+
+    private static String getString(String path, String def)
+    {
+        config.addDefault( path, def );
+        return config.getString( path, config.getString( path ) );
+    }
+
+    public static boolean preventProxies;
+    private static void preventProxies()
+    {
+        preventProxies = getBoolean( "settings.prevent-proxies", false );
+    }
+
+    private static void tpsCommand()
+    {
+        commands.put( "tps", new TicksPerSecondCommand( "tps" ) );
+    }
+
+    public static class Listener
+    {
+
+        public String host;
+        public int port;
+        public boolean netty;
+        public long connectionThrottle;
+
+        public Listener(String host, int port, boolean netty, long connectionThrottle)
+        {
+            this.host = host;
+            this.port = port;
+            this.netty = netty;
+            this.connectionThrottle = connectionThrottle;
+        }
+    }
+    public static List<Listener> listeners = new ArrayList<Listener>();
+    public static int nettyThreads;
+    private static void listeners()
+    {
+        listeners.clear(); // We don't rebuild listeners on reload but we should clear them out!
+
+        Map<String, Object> def = new HashMap<String, Object>();
+        def.put( "host", "default" );
+        def.put( "port", "default" );
+        def.put( "netty", true );
+        // def.put( "throttle", "default" );
+
+        config.addDefault( "listeners", Collections.singletonList( def ) );
+        for ( Map<String, Object> info : (List<Map<String, Object>>) config.getList( "listeners" ) )
+        {
+            String host = (String) info.get( "host" );
+            if ( "default".equals( host ) )
+            {
+                host = Bukkit.getIp();
+            } else
+            {
+                throw new IllegalArgumentException( "Can only bind listener to default! Configure it in server.properties" );
+            }
+            int port ;
+            
+            if (info.get( "port" ) instanceof Integer){
+                throw new IllegalArgumentException( "Can only bind port to default! Configure it in server.properties");
+            } else{
+                port = Bukkit.getPort();
+            }
+            boolean netty = (Boolean) info.get( "netty" );
+            // long connectionThrottle = ( info.get( "throttle" ) instanceof Number ) ? ( (Number) info.get( "throttle" ) ).longValue() : Bukkit.getConnectionThrottle();
+            listeners.add( new Listener( host, port, true, Bukkit.getConnectionThrottle() ) );
+        }
+        if ( listeners.size() != 1 )
+        {
+            throw new IllegalArgumentException( "May only have one listener!" );
+        }
+
+        nettyThreads = getInt( "settings.netty-threads", 3 );
+    }
+    public static boolean bungee = false;
+    private static void bungee()
+    {
+        if (version < 4){
+            set( "settings.bungeecord", false);
+        }
+        bungee = getBoolean( "settings.bungeecord", false );
+    }
+
+    public static List<String> spamExclusions;
+    private static void spamExclusions()
+    {
+        spamExclusions = getList( "commands.spam-exclusions", Arrays.asList( new String[]
+        {
+            "/skill"
+        } ) );
+    }
+
+    public static boolean logCommands;
+    private static void logCommands()
+    {
+        logCommands = getBoolean( "commands.log", true );
+    }
+
+    public static boolean tabComplete;
+    private static void tabComplete()
+    {
+        tabComplete = getBoolean( "commands.tab-complete", true );
+    }
+
+    public static String whitelistMessage;
+    public static String unknownCommandMessage;
+    public static String serverFullMessage;
+    public static String outdatedClientMessage;
+    public static String outdatedServerMessage;
+    private static String transform(String s)
+    {
+        return ChatColor.translateAlternateColorCodes( '&', s ).replaceAll( "\\n", "\n" );
+    }
+    private static void messages()
+    {
+        whitelistMessage = transform( getString( "messages.whitelist", "You are not whitelisted on this server!" ) );
+        unknownCommandMessage = transform( getString( "messages.unknown-command", "Unknown command. Type \"/help\" for help." ) );
+        serverFullMessage = transform( getString( "messages.server-full", "The server is full!" ) );
+        outdatedClientMessage = transform( getString( "messages.outdated-client", "Outdated client!" ) );
+        outdatedServerMessage = transform( getString( "messages.outdated-server", "Outdated server!" ) );
+    }
+
+    public static List<Pattern> logFilters;
+    private static void filters()
+    {
+        List<String> def = Arrays.asList( new String[]
+        {
+            "^(.*)(/login)(.*)$"
+        } );
+        logFilters = new ArrayList<Pattern>();
+
+        for ( String regex : (List<String>) getList( "settings.log-filters", def ) )
+        {
+            try
+            {
+                logFilters.add( Pattern.compile( regex ) );
+            } catch ( PatternSyntaxException ex )
+            {
+                Bukkit.getLogger().log( Level.WARNING, "Supplied filter " + regex + " is invalid, ignoring!", ex );
+            }
+        }
+
+        Bukkit.getLogger().setFilter( new LogFilter() );
+    }
+
+    public static int timeoutTime = 60;
+    public static boolean restartOnCrash = true;
+    public static String restartScript = "./start.sh";
+    public static String restartMessage;
+    private static void watchdog()
+    {
+        timeoutTime = getInt( "settings.timeout-time", timeoutTime );
+        restartOnCrash = getBoolean( "settings.restart-on-crash", restartOnCrash );
+        restartScript = getString( "settings.restart-script", restartScript );
+        restartMessage = transform( getString( "messages.restart", "Server is restarting" ) );
+        commands.put( "restart", new RestartCommand( "restart" ) );
+        WatchdogThread.doStart( timeoutTime, restartOnCrash );
+    }
+}
diff --git a/src/main/java/org/spigotmc/SpigotWorldConfig.java b/src/main/java/org/spigotmc/SpigotWorldConfig.java
new file mode 100644
index 0000000..300db67
--- /dev/null
+++ b/src/main/java/org/spigotmc/SpigotWorldConfig.java
@@ -0,0 +1,236 @@
+package org.spigotmc;
+
+import java.util.Arrays;
+import java.util.List;
+import org.bukkit.Bukkit;
+import org.bukkit.configuration.file.YamlConfiguration;
+
+public class SpigotWorldConfig
+{
+
+    private final String worldName;
+    private final YamlConfiguration config;
+    private boolean verbose;
+
+    public SpigotWorldConfig(String worldName)
+    {
+        this.worldName = worldName;
+        this.config = SpigotConfig.config;
+        init();
+    }
+
+    public void init()
+    {
+        this.verbose = getBoolean( "verbose", true );
+
+        log( "-------- World Settings For [" + worldName + "] --------" );
+        SpigotConfig.readConfig( SpigotWorldConfig.class, this );
+    }
+
+    private void log(String s)
+    {
+        if ( verbose )
+        {
+            Bukkit.getLogger().info( s );
+        }
+    }
+
+    private void set(String path, Object val)
+    {
+        config.set( "world-settings.default." + path, val );
+    }
+
+    private boolean getBoolean(String path, boolean def)
+    {
+        config.addDefault( "world-settings.default." + path, def );
+        return config.getBoolean( "world-settings." + worldName + "." + path, config.getBoolean( "world-settings.default." + path ) );
+    }
+
+    private double getDouble(String path, double def)
+    {
+        config.addDefault( "world-settings.default." + path, def );
+        return config.getDouble( "world-settings." + worldName + "." + path, config.getDouble( "world-settings.default." + path ) );
+    }
+
+    private int getInt(String path, int def)
+    {
+        config.addDefault( "world-settings.default." + path, def );
+        return config.getInt( "world-settings." + worldName + "." + path, config.getInt( "world-settings.default." + path ) );
+    }
+
+    private <T> List getList(String path, T def)
+    {
+        config.addDefault( "world-settings.default." + path, def );
+        return (List<T>) config.getList( "world-settings." + worldName + "." + path, config.getList( "world-settings.default." + path ) );
+    }
+
+    private String getString(String path, String def)
+    {
+        config.addDefault( "world-settings.default." + path, def );
+        return config.getString( "world-settings." + worldName + "." + path, config.getString( "world-settings.default." + path ) );
+    }
+
+    public int chunksPerTick;
+    private void chunksPerTick()
+    {
+        chunksPerTick = getInt( "chunks-per-tick", 650 );
+        log( "Chunks to Grow per Tick: " + chunksPerTick );
+    }
+
+    // Crop growth rates
+    public int cactusModifier;
+    public int caneModifier;
+    public int melonModifier;
+    public int mushroomModifier;
+    public int pumpkinModifier;
+    public int saplingModifier;
+    public int wheatModifier;
+    private void growthModifiers()
+    {
+        cactusModifier = getInt( "growth.cactus-modifier", 100 );
+        log( "Cactus Growth Modifier: " + cactusModifier + "%" );
+
+        caneModifier = getInt( "growth.cane-modifier", 100 );
+        log( "Cane Growth Modifier: " + caneModifier + "%" );
+
+        melonModifier = getInt( "growth.melon-modifier", 100 );
+        log( "Melon Growth Modifier: " + melonModifier + "%" );
+
+        mushroomModifier = getInt( "growth.mushroom-modifier", 100 );
+        log( "Mushroom Growth Modifier: " + mushroomModifier + "%" );
+
+        pumpkinModifier = getInt( "growth.pumpkin-modifier", 100 );
+        log( "Pumpkin Growth Modifier: " + pumpkinModifier + "%" );
+
+        saplingModifier = getInt( "growth.sapling-modifier", 100 );
+        log( "Sapling Growth Modifier: " + saplingModifier + "%" );
+
+        wheatModifier = getInt( "growth.wheat-modifier", 100 );
+        log( "Wheat Growth Modifier: " + wheatModifier + "%" );
+    }
+
+    public double itemMerge;
+    private void itemMerge()
+    {
+        itemMerge = getDouble("merge-radius.item", 2.5 );
+        log( "Item Merge Radius: " + itemMerge );
+    }
+
+    public double expMerge;
+    private void expMerge()
+    {
+        expMerge = getDouble("merge-radius.exp", 3.0 );
+        log( "Experience Merge Radius: " + expMerge );
+    }
+
+    public int viewDistance;
+    private void viewDistance()
+    {
+        viewDistance = getInt( "view-distance", Bukkit.getViewDistance() );
+        log( "View Distance: " + viewDistance );
+    }
+
+    public boolean antiXray = true;
+    public int engineMode = 1;
+    public List<Integer> blocks = Arrays.asList( new Integer[]
+    {
+        1, 5, 14, 15, 16, 21, 48, 49, 54, 56, 73, 74, 82, 129, 130
+    } );
+    public AntiXray antiXrayInstance;
+    private void antiXray()
+    {
+        antiXray = getBoolean( "anti-xray.enabled", antiXray );
+        log( "Anti X-Ray: " + antiXray );
+
+        engineMode = getInt( "anti-xray.engine-mode", engineMode );
+        log( "\tEngine Mode: " + engineMode );
+
+        if ( SpigotConfig.version < 3 )
+        {
+            set( "anti-xray.blocks", blocks );
+        }
+        blocks = getList( "anti-xray.blocks", blocks );
+        log( "\tBlocks: " + blocks );
+
+        antiXrayInstance = new AntiXray( this );
+    }
+
+    public byte mobSpawnRange;
+    private void mobSpawnRange()
+    {
+        mobSpawnRange = (byte) getInt( "mob-spawn-range", 4 );
+        log( "Mob Spawn Range: " + mobSpawnRange );
+    }
+
+    public int animalActivationRange = 32;
+    public int monsterActivationRange = 32;
+    public int miscActivationRange = 16;
+    private void activationRange()
+    {
+        animalActivationRange = getInt( "entity-activation-range.animals", animalActivationRange );
+        monsterActivationRange = getInt( "entity-activation-range.monsters", monsterActivationRange );
+        miscActivationRange = getInt( "entity-activation-range.misc", miscActivationRange );
+        log( "Entity Activation Range: An " + animalActivationRange + " / Mo " + monsterActivationRange + " / Mi " + miscActivationRange );
+    }
+
+    public int playerTrackingRange = 48;
+    public int animalTrackingRange = 48;
+    public int monsterTrackingRange = 48;
+    public int miscTrackingRange = 32;
+    public int maxTrackingRange = 64;
+    private void trackingRange()
+    {
+        playerTrackingRange = getInt( "entity-tracking-range.players", playerTrackingRange );
+        animalTrackingRange = getInt( "entity-tracking-range.animals", animalTrackingRange );
+        monsterTrackingRange = getInt( "entity-tracking-range.monsters", monsterTrackingRange );
+        miscTrackingRange = getInt( "entity-tracking-range.misc", miscTrackingRange );
+        maxTrackingRange = getInt( "entity-tracking-range.other", maxTrackingRange );
+        log( "Entity Tracking Range: Pl " + playerTrackingRange + " / An " + animalTrackingRange + " / Mo " + monsterTrackingRange + " / Mi " + miscTrackingRange + " / Other " + maxTrackingRange );
+    }
+
+    public int hopperTransfer = 8;
+    public int hopperCheck = 8;
+    private void hoppers()
+    {
+        // Set the tick delay between hopper item movements
+        hopperTransfer = getInt( "ticks-per.hopper-transfer", hopperTransfer );
+        // Set the tick delay between checking for items after the associated
+        // container is empty. Default to the hopperTransfer value to prevent
+        // hopper sorting machines from becoming out of sync.
+        hopperCheck = getInt( "ticks-per.hopper-check", hopperTransfer );
+        log( "Hopper Transfer: " + hopperTransfer + " Hopper Check: " + hopperCheck );
+    }
+
+    public boolean randomLightUpdates;
+    private void lightUpdates()
+    {
+        randomLightUpdates = getBoolean( "random-light-updates", false );
+        log( "Random Lighting Updates: " + randomLightUpdates );
+    }
+
+    public boolean saveStructureInfo;
+    private void structureInfo()
+    {
+        saveStructureInfo = getBoolean( "save-structure-info", true );
+        log( "Structure Info Saving: " + saveStructureInfo );
+        if ( !saveStructureInfo )
+        {
+            log( "*** WARNING *** You have selected to NOT save structure info. This may cause structures such as fortresses to not spawn mobs when updating to 1.7!" );
+            log( "*** WARNING *** Please use this option with caution, SpigotMC is not responsible for any issues this option may cause in the future!" );
+        }
+    }
+
+    public int itemDespawnRate;
+    private void itemDespawnRate()
+    {
+        itemDespawnRate = getInt( "item-despawn-rate", 6000 );
+        log( "Item Despawn Rate: " + itemDespawnRate );
+    }
+
+    public int arrowDespawnRate;
+    private void arrowDespawnRate()
+    {
+        arrowDespawnRate = getInt( "arrow-despawn-rate", 1200  );
+        log( "Arrow Despawn Rate: " + arrowDespawnRate );
+    }
+}
diff --git a/src/main/java/org/spigotmc/TrackingRange.java b/src/main/java/org/spigotmc/TrackingRange.java
new file mode 100644
index 0000000..bc6438d
--- /dev/null
+++ b/src/main/java/org/spigotmc/TrackingRange.java
@@ -0,0 +1,45 @@
+package org.spigotmc;
+
+import net.minecraft.server.Entity;
+import net.minecraft.server.EntityExperienceOrb;
+import net.minecraft.server.EntityGhast;
+import net.minecraft.server.EntityItem;
+import net.minecraft.server.EntityItemFrame;
+import net.minecraft.server.EntityPainting;
+import net.minecraft.server.EntityPlayer;
+
+public class TrackingRange
+{
+
+    /**
+     * Gets the range an entity should be 'tracked' by players and visible in
+     * the client.
+     *
+     * @param entity
+     * @param defaultRange Default range defined by Mojang
+     * @return
+     */
+    public static int getEntityTrackingRange(Entity entity, int defaultRange)
+    {
+        SpigotWorldConfig config = entity.world.spigotConfig;
+        int range = defaultRange;
+        if ( entity instanceof EntityPlayer )
+        {
+            range = config.playerTrackingRange;
+        } else if ( entity.defaultActivationState || entity instanceof EntityGhast )
+        {
+            range = defaultRange;
+        } else if ( entity.activationType == 1 )
+        {
+            range = config.monsterTrackingRange;
+        } else if ( entity.activationType == 2 )
+        {
+            range = config.animalTrackingRange;
+        } else if ( entity instanceof EntityItemFrame || entity instanceof EntityPainting || entity instanceof EntityItem || entity instanceof EntityExperienceOrb )
+        {
+            range = config.miscTrackingRange;
+        }
+
+        return Math.min( config.maxTrackingRange, range );
+    }
+}
diff --git a/src/main/java/org/spigotmc/WatchdogThread.java b/src/main/java/org/spigotmc/WatchdogThread.java
new file mode 100644
index 0000000..8d6e1b4
--- /dev/null
+++ b/src/main/java/org/spigotmc/WatchdogThread.java
@@ -0,0 +1,121 @@
+package org.spigotmc;
+
+import java.lang.management.ManagementFactory;
+import java.lang.management.MonitorInfo;
+import java.lang.management.ThreadInfo;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+import net.minecraft.server.MinecraftServer;
+import org.bukkit.Bukkit;
+
+public class WatchdogThread extends Thread
+{
+
+    private static WatchdogThread instance;
+    private final long timeoutTime;
+    private final boolean restart;
+    private volatile long lastTick;
+    private volatile boolean stopping;
+
+    private WatchdogThread(long timeoutTime, boolean restart)
+    {
+        super( "Spigot Watchdog Thread" );
+        this.timeoutTime = timeoutTime;
+        this.restart = restart;
+    }
+
+    public static void doStart(int timeoutTime, boolean restart)
+    {
+        if ( instance == null )
+        {
+            instance = new WatchdogThread( timeoutTime * 1000L, restart );
+            instance.start();
+        }
+    }
+
+    public static void tick()
+    {
+        instance.lastTick = System.currentTimeMillis();
+    }
+
+    public static void doStop()
+    {
+        if ( instance != null )
+        {
+            instance.stopping = true;
+        }
+    }
+
+    @Override
+    public void run()
+    {
+        while ( !stopping )
+        {
+            //
+            if ( lastTick != 0 && System.currentTimeMillis() > lastTick + timeoutTime )
+            {
+                Logger log = Bukkit.getServer().getLogger();
+                log.log( Level.SEVERE, "The server has stopped responding!" );
+                log.log( Level.SEVERE, "Please report this to http://www.spigotmc.org/" );
+                log.log( Level.SEVERE, "Be sure to include ALL relevant console errors and Minecraft crash reports" );
+                log.log( Level.SEVERE, "Spigot version: " + Bukkit.getServer().getVersion() );
+                //
+                log.log( Level.SEVERE, "------------------------------" );
+                log.log( Level.SEVERE, "Server thread dump (Look for plugins here before reporting to Spigot!):" );
+                dumpThread( ManagementFactory.getThreadMXBean().getThreadInfo( MinecraftServer.getServer().primaryThread.getId(), Integer.MAX_VALUE ), log );
+                log.log( Level.SEVERE, "------------------------------" );
+                //
+                log.log( Level.SEVERE, "Entire Thread Dump:" );
+                ThreadInfo[] threads = ManagementFactory.getThreadMXBean().dumpAllThreads( true, true );
+                for ( ThreadInfo thread : threads )
+                {
+                    dumpThread( thread, log );
+                }
+                log.log( Level.SEVERE, "------------------------------" );
+
+                if ( restart )
+                {
+                    RestartCommand.restart();
+                }
+                break;
+            }
+
+            try
+            {
+                sleep( 10000 );
+            } catch ( InterruptedException ex )
+            {
+                interrupt();
+            }
+        }
+    }
+
+    private static void dumpThread(ThreadInfo thread, Logger log)
+    {
+        if ( thread.getThreadState() != State.WAITING )
+        {
+            log.log( Level.SEVERE, "------------------------------" );
+            //
+            log.log( Level.SEVERE, "Current Thread: " + thread.getThreadName() );
+            log.log( Level.SEVERE, "\tPID: " + thread.getThreadId()
+                    + " | Suspended: " + thread.isSuspended()
+                    + " | Native: " + thread.isInNative()
+                    + " | State: " + thread.getThreadState() );
+            if ( thread.getLockedMonitors().length != 0 )
+            {
+                log.log( Level.SEVERE, "\tThread is waiting on monitor(s):" );
+                for ( MonitorInfo monitor : thread.getLockedMonitors() )
+                {
+                    log.log( Level.SEVERE, "\t\tLocked on:" + monitor.getLockedStackFrame() );
+                }
+            }
+            log.log( Level.SEVERE, "\tStack:" );
+            //
+            StackTraceElement[] stack = thread.getStackTrace();
+            for ( int line = 0; line < stack.length; line++ )
+            {
+                log.log( Level.SEVERE, "\t\t" + stack[line].toString() );
+            }
+        }
+    }
+}
diff --git a/src/main/java/org/spigotmc/netty/CipherBase.java b/src/main/java/org/spigotmc/netty/CipherBase.java
new file mode 100644
index 0000000..c4306f7
--- /dev/null
+++ b/src/main/java/org/spigotmc/netty/CipherBase.java
@@ -0,0 +1,73 @@
+package org.spigotmc.netty;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.ChannelHandlerContext;
+import javax.crypto.Cipher;
+import javax.crypto.ShortBufferException;
+
+/**
+ * Class to expose an
+ * {@link #cipher(io.netty.buffer.ByteBuf, io.netty.buffer.ByteBuf)} method to
+ * aid in the efficient passing of ByteBuffers through a cipher.
+ */
+class CipherBase
+{
+
+    private final Cipher cipher;
+    private ThreadLocal<byte[]> heapInLocal = new EmptyByteThreadLocal();
+    private ThreadLocal<byte[]> heapOutLocal = new EmptyByteThreadLocal();
+
+    private static class EmptyByteThreadLocal extends ThreadLocal<byte[]>
+    {
+
+        @Override
+        protected byte[] initialValue()
+        {
+            return new byte[ 0 ];
+        }
+    }
+
+    protected CipherBase(Cipher cipher)
+    {
+        this.cipher = cipher;
+    }
+
+    private byte[] bufToByte(ByteBuf in)
+    {
+        byte[] heapIn = heapInLocal.get();
+        int readableBytes = in.readableBytes();
+        if ( heapIn.length < readableBytes )
+        {
+            heapIn = new byte[ readableBytes ];
+            heapInLocal.set( heapIn );
+        }
+        in.readBytes( heapIn, 0, readableBytes );
+        return heapIn;
+    }
+
+    protected ByteBuf cipher(ChannelHandlerContext ctx, ByteBuf in) throws ShortBufferException
+    {
+        int readableBytes = in.readableBytes();
+        byte[] heapIn = bufToByte( in );
+
+        ByteBuf heapOut = ctx.alloc().heapBuffer( cipher.getOutputSize( readableBytes ) );
+        heapOut.writerIndex( cipher.update( heapIn, 0, readableBytes, heapOut.array(), heapOut.arrayOffset() ) );
+
+        return heapOut;
+    }
+
+    protected void cipher(ByteBuf in, ByteBuf out) throws ShortBufferException
+    {
+        int readableBytes = in.readableBytes();
+        byte[] heapIn = bufToByte( in );
+
+        byte[] heapOut = heapOutLocal.get();
+        int outputSize = cipher.getOutputSize( readableBytes );
+        if ( heapOut.length < outputSize )
+        {
+            heapOut = new byte[ outputSize ];
+            heapOutLocal.set( heapOut );
+        }
+        out.writeBytes( heapOut, 0, cipher.update( heapIn, 0, readableBytes, heapOut ) );
+    }
+}
diff --git a/src/main/java/org/spigotmc/netty/CipherDecoder.java b/src/main/java/org/spigotmc/netty/CipherDecoder.java
new file mode 100644
index 0000000..e37bae7
--- /dev/null
+++ b/src/main/java/org/spigotmc/netty/CipherDecoder.java
@@ -0,0 +1,24 @@
+package org.spigotmc.netty;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.MessageToMessageDecoder;
+import java.util.List;
+import javax.crypto.Cipher;
+
+public class CipherDecoder extends MessageToMessageDecoder<ByteBuf>
+{
+
+    private final CipherBase cipher;
+
+    public CipherDecoder(Cipher cipher)
+    {
+        this.cipher = new CipherBase( cipher );
+    }
+
+    @Override
+    protected void decode(ChannelHandlerContext ctx, ByteBuf msg, List<Object> out) throws Exception
+    {
+        out.add( cipher.cipher( ctx, msg ) );
+    }
+}
diff --git a/src/main/java/org/spigotmc/netty/CipherEncoder.java b/src/main/java/org/spigotmc/netty/CipherEncoder.java
new file mode 100644
index 0000000..2eb1dcb
--- /dev/null
+++ b/src/main/java/org/spigotmc/netty/CipherEncoder.java
@@ -0,0 +1,23 @@
+package org.spigotmc.netty;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.MessageToByteEncoder;
+import javax.crypto.Cipher;
+
+public class CipherEncoder extends MessageToByteEncoder<ByteBuf>
+{
+
+    private final CipherBase cipher;
+
+    public CipherEncoder(Cipher cipher)
+    {
+        this.cipher = new CipherBase( cipher );
+    }
+
+    @Override
+    protected void encode(ChannelHandlerContext ctx, ByteBuf in, ByteBuf out) throws Exception
+    {
+        cipher.cipher( in, out );
+    }
+}
diff --git a/src/main/java/org/spigotmc/netty/KickStringWriter.java b/src/main/java/org/spigotmc/netty/KickStringWriter.java
new file mode 100644
index 0000000..5c2745f
--- /dev/null
+++ b/src/main/java/org/spigotmc/netty/KickStringWriter.java
@@ -0,0 +1,20 @@
+package org.spigotmc.netty;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.MessageToByteEncoder;
+
+public class KickStringWriter extends MessageToByteEncoder<String>
+{
+
+    @Override
+    protected void encode(ChannelHandlerContext ctx, String msg, ByteBuf out) throws Exception
+    {
+        out.writeByte( 0xFF );
+        out.writeShort( msg.length() );
+        for ( char c : msg.toCharArray() )
+        {
+            out.writeChar( c );
+        }
+    }
+}
diff --git a/src/main/java/org/spigotmc/netty/LegacyDecoder.java b/src/main/java/org/spigotmc/netty/LegacyDecoder.java
new file mode 100644
index 0000000..3b1c3b6
--- /dev/null
+++ b/src/main/java/org/spigotmc/netty/LegacyDecoder.java
@@ -0,0 +1,40 @@
+package org.spigotmc.netty;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.ByteToMessageDecoder;
+import java.util.List;
+import net.minecraft.server.MinecraftServer;
+import org.bukkit.ChatColor;
+import static org.spigotmc.SpigotConfig.bungee;
+
+public class LegacyDecoder extends ByteToMessageDecoder
+{
+
+    @Override
+    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception
+    {
+        if ( in.readableBytes() < 3 )
+        {
+            return;
+        }
+        int i = in.readerIndex();
+        short b1 = in.getUnsignedByte( i++ );
+        short b2 = in.getUnsignedByte( i++ );
+        short b3 = in.getUnsignedByte( i++ );
+
+        if ( b1 == 0xFE && b2 == 0x01 && b3 == 0xFA )
+        {
+            String kickMessage = ChatColor.DARK_BLUE
+                    + "\00" + 0x04
+                    + "\00" + MinecraftServer.getServer().getVersion()
+                    + "\00" + MinecraftServer.getServer().getMotd()
+                    + "\00" + MinecraftServer.getServer().getPlayerList().getPlayerCount()
+                    + "\00" + MinecraftServer.getServer().getPlayerList().getMaxPlayers();
+
+            ctx.writeAndFlush(kickMessage );
+            ctx.close();
+        }
+        ctx.pipeline().remove( this );
+    }
+}
diff --git a/src/main/java/org/spigotmc/netty/NettyNetworkManager.java b/src/main/java/org/spigotmc/netty/NettyNetworkManager.java
new file mode 100644
index 0000000..fd5927e
--- /dev/null
+++ b/src/main/java/org/spigotmc/netty/NettyNetworkManager.java
@@ -0,0 +1,314 @@
+package org.spigotmc.netty;
+
+import com.google.common.util.concurrent.ThreadFactoryBuilder;
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.SimpleChannelInboundHandler;
+import io.netty.channel.socket.SocketChannel;
+import io.netty.handler.timeout.ReadTimeoutException;
+import java.io.IOException;
+import java.net.Socket;
+import java.net.SocketAddress;
+import java.security.PrivateKey;
+import java.util.AbstractList;
+import java.util.List;
+import java.util.Queue;
+import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.logging.Level;
+import javax.crypto.Cipher;
+import javax.crypto.SecretKey;
+import net.minecraft.server.Connection;
+import net.minecraft.server.INetworkManager;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.Packet;
+import net.minecraft.server.Packet252KeyResponse;
+import net.minecraft.server.PacketLoginSuccess;
+import net.minecraft.server.PendingConnection;
+import net.minecraft.server.PlayerConnection;
+import org.bukkit.Bukkit;
+
+/**
+ * This class forms the basis of the Netty integration. It implements
+ * {@link INetworkManager} and handles all events and inbound messages provided
+ * by the upstream Netty process.
+ */
+public class NettyNetworkManager extends SimpleChannelInboundHandler<Packet> implements INetworkManager
+{
+
+    private static final ExecutorService threadPool = Executors.newCachedThreadPool( new ThreadFactoryBuilder().setNameFormat( "Async Packet Handler - %1$d" ).build() );
+    private static final MinecraftServer server = MinecraftServer.getServer();
+    private static final PrivateKey key = server.H().getPrivate();
+    private static final NettyServerConnection serverConnection = (NettyServerConnection) server.ag();
+    /*========================================================================*/
+    private final Queue<Packet> syncPackets = new ConcurrentLinkedQueue<Packet>();
+    private final List<Packet> highPriorityQueue = new AbstractList<Packet>()
+    {
+        @Override
+        public void add(int index, Packet element)
+        {
+            // NOP
+        }
+
+        @Override
+        public Packet get(int index)
+        {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public int size()
+        {
+            return 0;
+        }
+    };
+    private volatile boolean connected;
+    private Channel channel;
+    private SocketAddress address;
+    Connection connection;
+    private SecretKey secret;
+    private String dcReason;
+    private Object[] dcArgs;
+    private Socket socketAdaptor;
+    private long writtenBytes;
+
+    @Override
+    public void channelActive(ChannelHandlerContext ctx) throws Exception
+    {
+        // Channel and address groundwork first
+        channel = ctx.channel();
+        address = channel.remoteAddress();
+        // Then the socket adaptor
+        socketAdaptor = NettySocketAdaptor.adapt( (SocketChannel) channel );
+        // Followed by their first handler
+        connection = new PendingConnection( server, this );
+        // Finally register the connection
+        connected = true;
+        serverConnection.register( (PendingConnection) connection );
+    }
+
+    @Override
+    public void channelInactive(ChannelHandlerContext ctx) throws Exception
+    {
+        a( "disconnect.endOfStream", new Object[ 0 ] );
+    }
+
+    @Override
+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception
+    {
+        // TODO: Remove this once we are more stable
+        if ( !( cause instanceof IOException ) && !( cause instanceof ReadTimeoutException ) )
+        {
+            Bukkit.getServer().getLogger().severe( "======================= Start Netty Debug Log - Ignore if this isn't causing issues =======================" );
+            Bukkit.getServer().getLogger().log( Level.SEVERE, "Error caught whilst handling " + channel, cause );
+            Bukkit.getServer().getLogger().severe( "======================= End Netty Debug Log =======================" );
+        }
+        // Disconnect with generic reason + exception
+        a( "disconnect.genericReason", new Object[]
+        {
+            "Internal exception: " + cause
+        } );
+    }
+
+    public void setProtocol(Protocol prot)
+    {
+        channel.pipeline().get( PacketDecoder.class ).setProtocol( prot );
+        channel.pipeline().get( PacketEncoder.class ).setProtocol( prot );
+    }
+
+    @Override
+    protected void channelRead0(ChannelHandlerContext ctx, final Packet msg) throws Exception
+    {
+        if ( connected )
+        {
+            if ( msg instanceof Packet252KeyResponse )
+            {
+                secret = ( (Packet252KeyResponse) msg ).a( key );
+            }
+
+            if ( msg.a_() )
+            {
+                threadPool.submit( new Runnable()
+                {
+                    public void run()
+                    {
+                        Packet packet = PacketListener.callReceived( NettyNetworkManager.this, connection, msg );
+                        if ( packet != null )
+                        {
+                            packet.handle( connection );
+                        }
+                    }
+                } );
+            } else
+            {
+                syncPackets.add( msg );
+            }
+        }
+    }
+
+    public Socket getSocket()
+    {
+        return socketAdaptor;
+    }
+
+    /**
+     * setHandler. Set the {@link NetHandler} used to process received packets.
+     *
+     * @param nh the new {@link NetHandler} instance
+     */
+    public void a(Connection nh)
+    {
+        connection = nh;
+    }
+
+    /**
+     * queue. Queue a packet for sending, or in this case send it to be write it
+     * straight to the channel.
+     *
+     * @param packet the packet to queue
+     */
+    public void queue(final Packet packet)
+    {
+        // Only send if channel is still connected
+        if ( connected )
+        {
+            // Process packet via handler
+            final Packet packet0 = PacketListener.callQueued( this, connection, packet );
+            highPriorityQueue.add( packet0 );
+            // If handler indicates packet send
+            if ( packet0 != null )
+            {
+                if ( channel.eventLoop().inEventLoop() )
+                {
+                    queue0( packet0 );
+                } else
+                {
+                    channel.eventLoop().execute( new Runnable()
+                    {
+                        public void run()
+                        {
+                            queue0( packet0 );
+                        }
+                    } );
+                }
+            }
+        }
+    }
+
+    private void queue0(Packet packet)
+    {
+        if ( packet instanceof PacketLoginSuccess && server.getOnlineMode() )
+        {
+            Cipher decrypt = NettyServerConnection.getCipher( Cipher.DECRYPT_MODE, secret );
+            channel.pipeline().addBefore( "lengthdecoder", "decrypt", new CipherDecoder( decrypt ) );
+            Cipher encrypt = NettyServerConnection.getCipher( Cipher.ENCRYPT_MODE, secret );
+            channel.pipeline().addBefore( "decoder", "encrypt", new CipherEncoder( encrypt ) );
+        }
+        channel.writeAndFlush( packet );
+
+    }
+
+    /**
+     * wakeThreads. In Vanilla this method will interrupt the network read and
+     * write threads, thus waking them.
+     */
+    public void a()
+    {
+    }
+
+    /**
+     * processPackets. Remove up to 1000 packets from the queue and process
+     * them. This method should only be called from the main server thread.
+     */
+    public void b()
+    {
+        for ( int i = 1000; !syncPackets.isEmpty() && i >= 0; i-- )
+        {
+            if ( connection instanceof PendingConnection ? ( (PendingConnection) connection ).b : ( (PlayerConnection) connection ).disconnected )
+            {
+                syncPackets.clear();
+                break;
+            }
+
+            Packet packet = PacketListener.callReceived( this, connection, syncPackets.poll() );
+            if ( packet != null )
+            {
+                packet.handle( connection );
+            }
+        }
+
+        // Disconnect via the handler - this performs all plugin related cleanup + logging
+        if ( !connected && ( dcReason != null || dcArgs != null ) )
+        {
+            connection.a( dcReason, dcArgs );
+        }
+    }
+
+    /**
+     * getSocketAddress. Return the remote address of the connected user. It is
+     * important that this method returns a value even after disconnect.
+     *
+     * @return the remote address of this connection
+     */
+    public SocketAddress getSocketAddress()
+    {
+        return address;
+    }
+
+    public void setSocketAddress(SocketAddress address)
+    {
+        this.address = address;
+    }
+
+    /**
+     * close. Close and release all resources associated with this connection.
+     */
+    public void d()
+    {
+        if ( connected )
+        {
+            connected = false;
+            channel.close();
+        }
+    }
+
+    /**
+     * queueSize. Return the number of packets in the low priority queue. In a
+     * NIO environment this will always be 0.
+     *
+     * @return the size of the packet send queue
+     */
+    public int e()
+    {
+        return 0;
+    }
+
+    /**
+     * networkShutdown. Shuts down this connection, storing the reason and
+     * parameters, used to notify the current {@link Connection}.
+     *
+     * @param reason the main disconnect reason
+     * @param arguments additional disconnect arguments, for example, the
+     * exception which triggered the disconnect.
+     */
+    public void a(String reason, Object... arguments)
+    {
+        if ( connected )
+        {
+            dcReason = reason;
+            dcArgs = arguments;
+            d();
+        }
+    }
+
+    public long getWrittenBytes()
+    {
+        return writtenBytes;
+    }
+
+    public void addWrittenBytes(int written)
+    {
+        writtenBytes += written;
+    }
+}
diff --git a/src/main/java/org/spigotmc/netty/NettyServerConnection.java b/src/main/java/org/spigotmc/netty/NettyServerConnection.java
new file mode 100644
index 0000000..a06fa12
--- /dev/null
+++ b/src/main/java/org/spigotmc/netty/NettyServerConnection.java
@@ -0,0 +1,176 @@
+package org.spigotmc.netty;
+
+import com.google.common.util.concurrent.ThreadFactoryBuilder;
+import io.netty.bootstrap.ServerBootstrap;
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelException;
+import io.netty.channel.ChannelFuture;
+import io.netty.channel.ChannelInitializer;
+import io.netty.channel.ChannelOption;
+import io.netty.channel.EventLoopGroup;
+import io.netty.channel.nio.NioEventLoopGroup;
+import io.netty.channel.socket.nio.NioServerSocketChannel;
+import io.netty.handler.timeout.ReadTimeoutHandler;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.security.GeneralSecurityException;
+import java.security.Key;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.logging.Level;
+import javax.crypto.Cipher;
+import javax.crypto.spec.IvParameterSpec;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.PendingConnection;
+import net.minecraft.server.ServerConnection;
+import org.bukkit.Bukkit;
+import org.spigotmc.SpigotConfig;
+
+/**
+ * This is the NettyServerConnection class. It implements
+ * {@link ServerConnection} and is the main interface between the Minecraft
+ * server and this NIO implementation. It handles starting, stopping and
+ * processing the Netty backend.
+ */
+public class NettyServerConnection extends ServerConnection
+{
+
+    private final ChannelFuture socket;
+    private static EventLoopGroup group;
+    private final Map<InetAddress, Long> throttle = new HashMap<InetAddress, Long>();
+    private final List<PendingConnection> pending = Collections.synchronizedList( new ArrayList<PendingConnection>() );
+
+    public void unThrottle(InetAddress address)
+    {
+        if ( address != null )
+        {
+            synchronized ( throttle )
+            {
+                throttle.remove( address );
+            }
+        }
+    }
+
+    public boolean throttle(InetAddress address)
+    {
+        long currentTime = System.currentTimeMillis();
+        synchronized ( throttle )
+        {
+            Long value = throttle.get( address );
+            if ( value != null && !address.isLoopbackAddress() && currentTime - value < d().server.getConnectionThrottle() )
+            {
+                throttle.put( address, currentTime );
+                return true;
+            }
+
+            throttle.put( address, currentTime );
+        }
+        return false;
+    }
+
+    public NettyServerConnection(final MinecraftServer ms, InetAddress host, int port)
+    {
+        super( ms );
+        if ( group == null )
+        {
+            group = new NioEventLoopGroup( SpigotConfig.nettyThreads, new ThreadFactoryBuilder().setNameFormat( "Netty IO Thread - %1$d" ).build() );
+        }
+
+        socket = new ServerBootstrap().channel( NioServerSocketChannel.class ).childHandler( new ChannelInitializer()
+        {
+            @Override
+            public void initChannel(Channel ch) throws Exception
+            {
+                // Set IP_TOS
+                try
+                {
+                    ch.config().setOption( ChannelOption.IP_TOS, 0x18 );
+                } catch ( ChannelException ex )
+                {
+                    // IP_TOS is not supported (Windows XP / Windows Server 2003)
+                }
+                try
+                {
+                    ch.config().setOption( ChannelOption.TCP_NODELAY, false );
+                } catch ( ChannelException ex )
+                {
+                    // TCP_NODELAY is not supported (Mac)
+                }
+
+                NettyNetworkManager networkManager = new NettyNetworkManager();
+                ch.pipeline()
+                        .addLast( "timer", new ReadTimeoutHandler( 30 ) )
+                        .addLast( "old", new KickStringWriter())
+                        .addLast( "legacy", new LegacyDecoder() )
+                        .addLast( "lengthdecoder", new Varint21FrameDecoder() )
+                        .addLast( "decoder", new PacketDecoder( Protocol.HANDSHAKE ) )
+                        .addLast( "lengthencoder", new Varint21LengthFieldPrepender() )
+                        .addLast( "packetencoder", new PacketEncoder( Protocol.HANDSHAKE ) )
+                        .addLast( "manager", networkManager );
+            }
+        } ).group( group ).localAddress( host, port ).bind().syncUninterruptibly();
+    }
+
+    /**
+     * Shutdown. This method is called when the server is shutting down and the
+     * server socket and all clients should be terminated with no further
+     * action.
+     */
+    @Override
+    public void a()
+    {
+        socket.channel().close().syncUninterruptibly();
+    }
+
+    @Override
+    public void b()
+    {
+        super.b(); // pulse PlayerConnections
+        for ( int i = 0; i < pending.size(); ++i )
+        {
+            PendingConnection connection = pending.get( i );
+
+            try
+            {
+                connection.d();
+            } catch ( Exception ex )
+            {
+                connection.disconnect( "Internal server error" );
+                Bukkit.getServer().getLogger().log( Level.WARNING, "Failed to handle packet: " + ex, ex );
+            }
+
+            if ( connection.b )
+            {
+                pending.remove( i-- );
+            }
+        }
+    }
+
+    public void register(PendingConnection conn)
+    {
+        pending.add( conn );
+    }
+
+    /**
+     * Return a Minecraft compatible cipher instance from the specified key.
+     *
+     * @param opMode the mode to initialize the cipher in
+     * @param key to use as the initial vector
+     * @return the initialized cipher
+     */
+    public static Cipher getCipher(int opMode, Key key)
+    {
+        try
+        {
+            Cipher cip = Cipher.getInstance( "AES/CFB8/NoPadding" );
+            cip.init( opMode, key, new IvParameterSpec( key.getEncoded() ) );
+            return cip;
+        } catch ( GeneralSecurityException ex )
+        {
+            throw new RuntimeException( ex );
+        }
+    }
+}
diff --git a/src/main/java/org/spigotmc/netty/NettySocketAdaptor.java b/src/main/java/org/spigotmc/netty/NettySocketAdaptor.java
new file mode 100644
index 0000000..5da8a59
--- /dev/null
+++ b/src/main/java/org/spigotmc/netty/NettySocketAdaptor.java
@@ -0,0 +1,294 @@
+package org.spigotmc.netty;
+
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelOption;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.net.InetAddress;
+import java.net.Socket;
+import java.net.SocketAddress;
+import java.net.SocketException;
+import java.nio.channels.SocketChannel;
+
+/**
+ * This class wraps a Netty {@link Channel} in a {@link Socket}. It overrides
+ * all methods in {@link Socket} to ensure that calls are not mistakingly made
+ * to the unsupported super socket. All operations that can be sanely applied to
+ * a {@link Channel} are implemented here. Those which cannot will throw an
+ * {@link UnsupportedOperationException}.
+ */
+public class NettySocketAdaptor extends Socket
+{
+
+    private final io.netty.channel.socket.SocketChannel ch;
+
+    private NettySocketAdaptor(io.netty.channel.socket.SocketChannel ch)
+    {
+        this.ch = ch;
+    }
+
+    public static NettySocketAdaptor adapt(io.netty.channel.socket.SocketChannel ch)
+    {
+        return new NettySocketAdaptor( ch );
+    }
+
+    @Override
+    public void bind(SocketAddress bindpoint) throws IOException
+    {
+        ch.bind( bindpoint ).syncUninterruptibly();
+    }
+
+    @Override
+    public synchronized void close() throws IOException
+    {
+        ch.close().syncUninterruptibly();
+    }
+
+    @Override
+    public void connect(SocketAddress endpoint) throws IOException
+    {
+        ch.connect( endpoint ).syncUninterruptibly();
+    }
+
+    @Override
+    public void connect(SocketAddress endpoint, int timeout) throws IOException
+    {
+        ch.config().setConnectTimeoutMillis( timeout );
+        ch.connect( endpoint ).syncUninterruptibly();
+    }
+
+    @Override
+    public boolean equals(Object obj)
+    {
+        return obj instanceof NettySocketAdaptor && ch.equals( ( (NettySocketAdaptor) obj ).ch );
+    }
+
+    @Override
+    public SocketChannel getChannel()
+    {
+        throw new UnsupportedOperationException( "Operation not supported on Channel wrapper." );
+    }
+
+    @Override
+    public InetAddress getInetAddress()
+    {
+        return ch.remoteAddress().getAddress();
+    }
+
+    @Override
+    public InputStream getInputStream() throws IOException
+    {
+        throw new UnsupportedOperationException( "Operation not supported on Channel wrapper." );
+    }
+
+    @Override
+    public boolean getKeepAlive() throws SocketException
+    {
+        return ch.config().getOption( ChannelOption.SO_KEEPALIVE );
+    }
+
+    @Override
+    public InetAddress getLocalAddress()
+    {
+        return ch.localAddress().getAddress();
+    }
+
+    @Override
+    public int getLocalPort()
+    {
+        return ch.localAddress().getPort();
+    }
+
+    @Override
+    public SocketAddress getLocalSocketAddress()
+    {
+        return ch.localAddress();
+    }
+
+    @Override
+    public boolean getOOBInline() throws SocketException
+    {
+        throw new UnsupportedOperationException( "Operation not supported on Channel wrapper." );
+    }
+
+    @Override
+    public OutputStream getOutputStream() throws IOException
+    {
+        throw new UnsupportedOperationException( "Operation not supported on Channel wrapper." );
+    }
+
+    @Override
+    public int getPort()
+    {
+        return ch.remoteAddress().getPort();
+    }
+
+    @Override
+    public synchronized int getReceiveBufferSize() throws SocketException
+    {
+        return ch.config().getOption( ChannelOption.SO_RCVBUF );
+    }
+
+    @Override
+    public SocketAddress getRemoteSocketAddress()
+    {
+        return ch.remoteAddress();
+    }
+
+    @Override
+    public boolean getReuseAddress() throws SocketException
+    {
+        return ch.config().getOption( ChannelOption.SO_REUSEADDR );
+    }
+
+    @Override
+    public synchronized int getSendBufferSize() throws SocketException
+    {
+        return ch.config().getOption( ChannelOption.SO_SNDBUF );
+    }
+
+    @Override
+    public int getSoLinger() throws SocketException
+    {
+        return ch.config().getOption( ChannelOption.SO_LINGER );
+    }
+
+    @Override
+    public synchronized int getSoTimeout() throws SocketException
+    {
+        throw new UnsupportedOperationException( "Operation not supported on Channel wrapper." );
+    }
+
+    @Override
+    public boolean getTcpNoDelay() throws SocketException
+    {
+        return ch.config().getOption( ChannelOption.TCP_NODELAY );
+    }
+
+    @Override
+    public int getTrafficClass() throws SocketException
+    {
+        return ch.config().getOption( ChannelOption.IP_TOS );
+    }
+
+    @Override
+    public int hashCode()
+    {
+        return ch.hashCode();
+    }
+
+    @Override
+    public boolean isBound()
+    {
+        return ch.localAddress() != null;
+    }
+
+    @Override
+    public boolean isClosed()
+    {
+        return !ch.isOpen();
+    }
+
+    @Override
+    public boolean isConnected()
+    {
+        return ch.isActive();
+    }
+
+    @Override
+    public boolean isInputShutdown()
+    {
+        return ch.isInputShutdown();
+    }
+
+    @Override
+    public boolean isOutputShutdown()
+    {
+        return ch.isOutputShutdown();
+    }
+
+    @Override
+    public void sendUrgentData(int data) throws IOException
+    {
+        throw new UnsupportedOperationException( "Operation not supported on Channel wrapper." );
+    }
+
+    @Override
+    public void setKeepAlive(boolean on) throws SocketException
+    {
+        ch.config().setOption( ChannelOption.SO_KEEPALIVE, on );
+    }
+
+    @Override
+    public void setOOBInline(boolean on) throws SocketException
+    {
+        throw new UnsupportedOperationException( "Operation not supported on Channel wrapper." );
+    }
+
+    @Override
+    public void setPerformancePreferences(int connectionTime, int latency, int bandwidth)
+    {
+        throw new UnsupportedOperationException( "Operation not supported on Channel wrapper." );
+    }
+
+    @Override
+    public synchronized void setReceiveBufferSize(int size) throws SocketException
+    {
+        ch.config().setOption( ChannelOption.SO_RCVBUF, size );
+    }
+
+    @Override
+    public void setReuseAddress(boolean on) throws SocketException
+    {
+        ch.config().setOption( ChannelOption.SO_REUSEADDR, on );
+    }
+
+    @Override
+    public synchronized void setSendBufferSize(int size) throws SocketException
+    {
+        ch.config().setOption( ChannelOption.SO_SNDBUF, size );
+    }
+
+    @Override
+    public void setSoLinger(boolean on, int linger) throws SocketException
+    {
+        ch.config().setOption( ChannelOption.SO_LINGER, linger );
+    }
+
+    @Override
+    public synchronized void setSoTimeout(int timeout) throws SocketException
+    {
+        throw new UnsupportedOperationException( "Operation not supported on Channel wrapper." );
+    }
+
+    @Override
+    public void setTcpNoDelay(boolean on) throws SocketException
+    {
+        ch.config().setOption( ChannelOption.TCP_NODELAY, on );
+    }
+
+    @Override
+    public void setTrafficClass(int tc) throws SocketException
+    {
+        ch.config().setOption( ChannelOption.IP_TOS, tc );
+    }
+
+    @Override
+    public void shutdownInput() throws IOException
+    {
+        throw new UnsupportedOperationException( "Operation not supported on Channel wrapper." );
+    }
+
+    @Override
+    public void shutdownOutput() throws IOException
+    {
+        ch.shutdownOutput().syncUninterruptibly();
+    }
+
+    @Override
+    public String toString()
+    {
+        return ch.toString();
+    }
+}
diff --git a/src/main/java/org/spigotmc/netty/PacketDecoder.java b/src/main/java/org/spigotmc/netty/PacketDecoder.java
new file mode 100644
index 0000000..1eb2203
--- /dev/null
+++ b/src/main/java/org/spigotmc/netty/PacketDecoder.java
@@ -0,0 +1,76 @@
+package org.spigotmc.netty;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufInputStream;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.ByteToMessageDecoder;
+import java.io.DataInputStream;
+import java.util.List;
+import net.minecraft.server.Packet;
+import net.minecraft.server.Packet2Handshake;
+
+/**
+ * Packet decoding class backed by a reusable {@link DataInputStream} which
+ * backs the input {@link ByteBuf}. Reads an unsigned byte packet header and
+ * then decodes the packet accordingly.
+ */
+public class PacketDecoder extends ByteToMessageDecoder
+{
+
+    private Protocol protocol;
+
+    public PacketDecoder(Protocol prot)
+    {
+        this.protocol = prot;
+    }
+
+    public void setProtocol(Protocol protocol)
+    {
+        this.protocol = protocol;
+    }
+
+    @Override
+    protected void decodeLast(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception
+    {
+
+    }
+
+    @Override
+    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception
+    {
+        Protocol.ProtocolDirection dir = protocol.TO_SERVER;
+
+        int packetId = Packet.readVarInt( in );
+        Packet packet = dir.createPacket( packetId );
+
+        DataInputStream i = new DataInputStream( new ByteBufInputStream( in ) );
+
+        packet.a( i );
+
+        if ( in.readableBytes() != 0 )
+        {
+            throw new RuntimeException( "Did not read all bytes from packet " + packet.getClass() + " " + packetId + " Protocol " + protocol + " Direction " + dir + " Buf: " + in );
+        }
+        out.add( packet );
+
+        if ( packet instanceof Packet2Handshake )
+        {
+            Packet2Handshake handshake = (Packet2Handshake) packet;
+            switch ( handshake.state )
+            {
+                case 1:
+                    setProtocol( ctx, Protocol.STATUS );
+                    break;
+                case 2:
+                    setProtocol( ctx, Protocol.LOGIN );
+                    break;
+            }
+        }
+    }
+
+    public void setProtocol(ChannelHandlerContext channel, Protocol prot)
+    {
+        channel.pipeline().get( PacketDecoder.class ).setProtocol( prot );
+        channel.pipeline().get( PacketEncoder.class ).setProtocol( prot );
+    }
+}
diff --git a/src/main/java/org/spigotmc/netty/PacketEncoder.java b/src/main/java/org/spigotmc/netty/PacketEncoder.java
new file mode 100644
index 0000000..9121e9a
--- /dev/null
+++ b/src/main/java/org/spigotmc/netty/PacketEncoder.java
@@ -0,0 +1,46 @@
+package org.spigotmc.netty;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufOutputStream;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.MessageToByteEncoder;
+import java.io.DataOutputStream;
+import net.minecraft.server.Packet;
+import net.minecraft.server.PacketLoginSuccess;
+
+public class PacketEncoder extends MessageToByteEncoder<Packet>
+{
+
+    private Protocol protocol;
+
+    public PacketEncoder(Protocol prot)
+    {
+        this.protocol = prot;
+    }
+
+    public void setProtocol(Protocol protocol)
+    {
+        this.protocol = protocol;
+    }
+
+    @Override
+    protected void encode(ChannelHandlerContext ctx, Packet msg, ByteBuf out) throws Exception
+    {
+        Protocol.ProtocolDirection dir = protocol.TO_CLIENT;
+        Packet.writeVarInt( dir.getId( msg.getClass() ), out );
+
+        DataOutputStream outS = new DataOutputStream( new ByteBufOutputStream( out ) );
+        msg.a( outS );
+
+        if ( msg instanceof PacketLoginSuccess )
+        {
+            setProtocol( ctx, Protocol.GAME );
+        }
+    }
+
+    public void setProtocol(ChannelHandlerContext channel, Protocol prot)
+    {
+        channel.pipeline().get( PacketDecoder.class ).setProtocol( prot );
+        channel.pipeline().get( PacketEncoder.class ).setProtocol( prot );
+    }
+}
diff --git a/src/main/java/org/spigotmc/netty/PacketListener.java b/src/main/java/org/spigotmc/netty/PacketListener.java
new file mode 100644
index 0000000..965ba12
--- /dev/null
+++ b/src/main/java/org/spigotmc/netty/PacketListener.java
@@ -0,0 +1,112 @@
+package org.spigotmc.netty;
+
+import com.google.common.base.Preconditions;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.logging.Level;
+import net.minecraft.server.Connection;
+import net.minecraft.server.INetworkManager;
+import net.minecraft.server.Packet;
+import org.bukkit.Bukkit;
+import org.bukkit.plugin.Plugin;
+
+/**
+ * This class is used for plugins that wish to register to listen to incoming
+ * and outgoing packets. To use this class, simply create a new instance,
+ * override the methods you wish to use, and call
+ * {@link #register(org.spigotmc.netty.PacketListener, org.bukkit.plugin.Plugin)}.
+ */
+public class PacketListener
+{
+
+    /**
+     * A mapping of all registered listeners and their owning plugins.
+     */
+    private static final Map<PacketListener, Plugin> listeners = new HashMap<PacketListener, Plugin>();
+    /**
+     * A baked list of all listeners, for efficiency sake.
+     */
+    private static PacketListener[] baked = new PacketListener[ 0 ];
+
+    /**
+     * Used to register a handler for receiving notifications of packet
+     * activity.
+     *
+     * @param listener the listener to register
+     * @param plugin the plugin owning this listener
+     */
+    public static synchronized void register(PacketListener listener, Plugin plugin)
+    {
+        Preconditions.checkNotNull( listener, "listener" );
+        Preconditions.checkNotNull( plugin, "plugin" );
+        Preconditions.checkState( !listeners.containsKey( listener ), "listener already registered" );
+
+        int size = listeners.size();
+        Preconditions.checkState( baked.length == size );
+        listeners.put( listener, plugin );
+        baked = Arrays.copyOf( baked, size + 1 );
+        baked[size] = listener;
+    }
+
+    static Packet callReceived(INetworkManager networkManager, Connection connection, Packet packet)
+    {
+        for ( PacketListener listener : baked )
+        {
+            try
+            {
+                packet = listener.packetReceived( networkManager, connection, packet );
+            } catch ( Throwable t )
+            {
+                Bukkit.getServer().getLogger().log( Level.SEVERE, "Error whilst firing receive hook for packet", t );
+            }
+        }
+        return packet;
+    }
+
+    static Packet callQueued(INetworkManager networkManager, Connection connection, Packet packet)
+    {
+        for ( PacketListener listener : baked )
+        {
+            try
+            {
+                packet = listener.packetQueued( networkManager, connection, packet );
+            } catch ( Throwable t )
+            {
+                Bukkit.getServer().getLogger().log( Level.SEVERE, "Error whilst firing queued hook for packet", t );
+            }
+        }
+        return packet;
+    }
+
+    /**
+     * Called when a packet has been received and is about to be handled by the
+     * current {@link Connection}. The returned packet will be the packet passed
+     * on for handling, or in the case of null being returned, not handled at
+     * all.
+     *
+     * @param networkManager the NetworkManager receiving the packet
+     * @param connection the connection which will handle the packet
+     * @param packet the received packet
+     * @return the packet to be handled, or null to cancel
+     */
+    public Packet packetReceived(INetworkManager networkManager, Connection connection, Packet packet)
+    {
+        return packet;
+    }
+
+    /**
+     * Called when a packet is queued to be sent. The returned packet will be
+     * the packet sent. In the case of null being returned, the packet will not
+     * be sent.
+     *
+     * @param networkManager the NetworkManager which will send the packet
+     * @param connection the connection which queued the packet
+     * @param packet the queue packet
+     * @return the packet to be sent, or null if the packet will not be sent.
+     */
+    public Packet packetQueued(INetworkManager networkManager, Connection connection, Packet packet)
+    {
+        return packet;
+    }
+}
diff --git a/src/main/java/org/spigotmc/netty/Protocol.java b/src/main/java/org/spigotmc/netty/Protocol.java
new file mode 100644
index 0000000..3fd9276
--- /dev/null
+++ b/src/main/java/org/spigotmc/netty/Protocol.java
@@ -0,0 +1,311 @@
+package org.spigotmc.netty;
+
+import com.google.common.base.Preconditions;
+import gnu.trove.map.TObjectIntMap;
+import gnu.trove.map.hash.TObjectIntHashMap;
+import java.lang.reflect.Constructor;
+import net.minecraft.server.Packet;
+import net.minecraft.server.Packet0KeepAlive;
+import net.minecraft.server.Packet100OpenWindow;
+import net.minecraft.server.Packet101CloseWindow;
+import net.minecraft.server.Packet102WindowClick;
+import net.minecraft.server.Packet103SetSlot;
+import net.minecraft.server.Packet104WindowItems;
+import net.minecraft.server.Packet105CraftProgressBar;
+import net.minecraft.server.Packet106Transaction;
+import net.minecraft.server.Packet107SetCreativeSlot;
+import net.minecraft.server.Packet108ButtonClick;
+import net.minecraft.server.Packet10Flying;
+import net.minecraft.server.Packet11PlayerPosition;
+import net.minecraft.server.Packet12PlayerLook;
+import net.minecraft.server.Packet130UpdateSign;
+import net.minecraft.server.Packet131ItemData;
+import net.minecraft.server.Packet132TileEntityData;
+import net.minecraft.server.Packet133OpenTileEntity;
+import net.minecraft.server.Packet13PlayerLookMove;
+import net.minecraft.server.Packet14BlockDig;
+import net.minecraft.server.Packet15Place;
+import net.minecraft.server.Packet16BlockItemSwitch;
+import net.minecraft.server.Packet17EntityLocationAction;
+import net.minecraft.server.Packet18ArmAnimation;
+import net.minecraft.server.Packet19EntityAction;
+import net.minecraft.server.Packet1Login;
+import net.minecraft.server.Packet200Statistic;
+import net.minecraft.server.Packet201PlayerInfo;
+import net.minecraft.server.Packet202Abilities;
+import net.minecraft.server.Packet203TabComplete;
+import net.minecraft.server.Packet204LocaleAndViewDistance;
+import net.minecraft.server.Packet205ClientCommand;
+import net.minecraft.server.Packet206SetScoreboardObjective;
+import net.minecraft.server.Packet207SetScoreboardScore;
+import net.minecraft.server.Packet208SetScoreboardDisplayObjective;
+import net.minecraft.server.Packet209SetScoreboardTeam;
+import net.minecraft.server.Packet20NamedEntitySpawn;
+import net.minecraft.server.Packet22Collect;
+import net.minecraft.server.Packet23VehicleSpawn;
+import net.minecraft.server.Packet24MobSpawn;
+import net.minecraft.server.Packet250CustomPayload;
+import net.minecraft.server.Packet252KeyResponse;
+import net.minecraft.server.Packet253KeyRequest;
+import net.minecraft.server.Packet255KickDisconnect;
+import net.minecraft.server.Packet25EntityPainting;
+import net.minecraft.server.Packet26AddExpOrb;
+import net.minecraft.server.Packet27PlayerInput;
+import net.minecraft.server.Packet28EntityVelocity;
+import net.minecraft.server.Packet29DestroyEntity;
+import net.minecraft.server.Packet2Handshake;
+import net.minecraft.server.Packet30Entity;
+import net.minecraft.server.Packet31RelEntityMove;
+import net.minecraft.server.Packet32EntityLook;
+import net.minecraft.server.Packet33RelEntityMoveLook;
+import net.minecraft.server.Packet34EntityTeleport;
+import net.minecraft.server.Packet35EntityHeadRotation;
+import net.minecraft.server.Packet38EntityStatus;
+import net.minecraft.server.Packet39AttachEntity;
+import net.minecraft.server.Packet3Chat;
+import net.minecraft.server.Packet40EntityMetadata;
+import net.minecraft.server.Packet41MobEffect;
+import net.minecraft.server.Packet42RemoveMobEffect;
+import net.minecraft.server.Packet43SetExperience;
+import net.minecraft.server.Packet44UpdateAttributes;
+import net.minecraft.server.Packet4UpdateTime;
+import net.minecraft.server.Packet51MapChunk;
+import net.minecraft.server.Packet52MultiBlockChange;
+import net.minecraft.server.Packet53BlockChange;
+import net.minecraft.server.Packet54PlayNoteBlock;
+import net.minecraft.server.Packet55BlockBreakAnimation;
+import net.minecraft.server.Packet56MapChunkBulk;
+import net.minecraft.server.Packet5EntityEquipment;
+import net.minecraft.server.Packet60Explosion;
+import net.minecraft.server.Packet61WorldEvent;
+import net.minecraft.server.Packet62NamedSoundEffect;
+import net.minecraft.server.Packet63WorldParticles;
+import net.minecraft.server.Packet6SpawnPosition;
+import net.minecraft.server.Packet70Bed;
+import net.minecraft.server.Packet71Weather;
+import net.minecraft.server.Packet7UseEntity;
+import net.minecraft.server.Packet8UpdateHealth;
+import net.minecraft.server.Packet9Respawn;
+import net.minecraft.server.PacketLoginRequest;
+import net.minecraft.server.PacketLoginSuccess;
+import net.minecraft.server.PacketPingTime;
+import net.minecraft.server.PacketStatusRequest;
+
+public enum Protocol
+{
+
+    // Undef
+    HANDSHAKE
+            {
+
+                
+                {
+                    TO_SERVER.registerPacket( 0x00, Packet2Handshake.class );
+                }
+            },
+    // 0
+    GAME
+            {
+
+                
+                {
+                    TO_CLIENT.registerPacket( 0x00, Packet0KeepAlive.class );
+                    TO_CLIENT.registerPacket( 0x01, Packet1Login.class );
+                    TO_CLIENT.registerPacket( 0x02, Packet3Chat.class );
+                    TO_CLIENT.registerPacket( 0x03, Packet4UpdateTime.class );
+                    TO_CLIENT.registerPacket( 0x04, Packet5EntityEquipment.class );
+                    TO_CLIENT.registerPacket( 0x05, Packet6SpawnPosition.class );
+                    TO_CLIENT.registerPacket( 0x06, Packet8UpdateHealth.class );
+                    TO_CLIENT.registerPacket( 0x07, Packet9Respawn.class );
+                    TO_CLIENT.registerPacket( 0x08, Packet13PlayerLookMove.class );
+                    TO_CLIENT.registerPacket( 0x09, Packet16BlockItemSwitch.class );
+                    TO_CLIENT.registerPacket( 0x0A, Packet17EntityLocationAction.class );
+                    TO_CLIENT.registerPacket( 0x0B, Packet18ArmAnimation.class );
+                    TO_CLIENT.registerPacket( 0x0C, Packet20NamedEntitySpawn.class );
+                    TO_CLIENT.registerPacket( 0x0D, Packet22Collect.class );
+                    TO_CLIENT.registerPacket( 0x0E, Packet23VehicleSpawn.class );
+                    TO_CLIENT.registerPacket( 0x0F, Packet24MobSpawn.class );
+                    TO_CLIENT.registerPacket( 0x10, Packet25EntityPainting.class );
+                    TO_CLIENT.registerPacket( 0x11, Packet26AddExpOrb.class );
+                    TO_CLIENT.registerPacket( 0x12, Packet28EntityVelocity.class );
+                    TO_CLIENT.registerPacket( 0x13, Packet29DestroyEntity.class );
+                    TO_CLIENT.registerPacket( 0x14, Packet30Entity.class );
+                    TO_CLIENT.registerPacket( 0x15, Packet31RelEntityMove.class );
+                    TO_CLIENT.registerPacket( 0x16, Packet32EntityLook.class );
+                    TO_CLIENT.registerPacket( 0x17, Packet33RelEntityMoveLook.class );
+                    TO_CLIENT.registerPacket( 0x18, Packet34EntityTeleport.class );
+                    TO_CLIENT.registerPacket( 0x19, Packet35EntityHeadRotation.class );
+                    TO_CLIENT.registerPacket( 0x1A, Packet38EntityStatus.class );
+                    TO_CLIENT.registerPacket( 0x1B, Packet39AttachEntity.class );
+                    TO_CLIENT.registerPacket( 0x1C, Packet40EntityMetadata.class );
+                    TO_CLIENT.registerPacket( 0x1D, Packet41MobEffect.class );
+                    TO_CLIENT.registerPacket( 0x1E, Packet42RemoveMobEffect.class );
+                    TO_CLIENT.registerPacket( 0x1F, Packet43SetExperience.class );
+                    TO_CLIENT.registerPacket( 0x20, Packet44UpdateAttributes.class );
+                    TO_CLIENT.registerPacket( 0x21, Packet51MapChunk.class );
+                    TO_CLIENT.registerPacket( 0x22, Packet52MultiBlockChange.class );
+                    TO_CLIENT.registerPacket( 0x23, Packet53BlockChange.class );
+                    TO_CLIENT.registerPacket( 0x24, Packet54PlayNoteBlock.class );
+                    TO_CLIENT.registerPacket( 0x25, Packet55BlockBreakAnimation.class );
+                    TO_CLIENT.registerPacket( 0x26, Packet56MapChunkBulk.class );
+                    TO_CLIENT.registerPacket( 0x27, Packet60Explosion.class );
+                    TO_CLIENT.registerPacket( 0x28, Packet61WorldEvent.class );
+                    TO_CLIENT.registerPacket( 0x29, Packet62NamedSoundEffect.class );
+                    TO_CLIENT.registerPacket( 0x2A, Packet63WorldParticles.class );
+                    TO_CLIENT.registerPacket( 0x2B, Packet70Bed.class );
+                    TO_CLIENT.registerPacket( 0x2C, Packet71Weather.class );
+                    TO_CLIENT.registerPacket( 0x2D, Packet100OpenWindow.class );
+                    TO_CLIENT.registerPacket( 0x2E, Packet101CloseWindow.class );
+                    TO_CLIENT.registerPacket( 0x2F, Packet103SetSlot.class );
+                    TO_CLIENT.registerPacket( 0x30, Packet104WindowItems.class );
+                    TO_CLIENT.registerPacket( 0x31, Packet105CraftProgressBar.class );
+                    TO_CLIENT.registerPacket( 0x32, Packet106Transaction.class );
+                    TO_CLIENT.registerPacket( 0x33, Packet130UpdateSign.class );
+                    TO_CLIENT.registerPacket( 0x34, Packet131ItemData.class );
+                    TO_CLIENT.registerPacket( 0x35, Packet132TileEntityData.class );
+                    TO_CLIENT.registerPacket( 0x36, Packet133OpenTileEntity.class );
+                    TO_CLIENT.registerPacket( 0x37, Packet200Statistic.class );
+                    TO_CLIENT.registerPacket( 0x38, Packet201PlayerInfo.class );
+                    TO_CLIENT.registerPacket( 0x39, Packet202Abilities.class );
+                    TO_CLIENT.registerPacket( 0x3A, Packet203TabComplete.class );
+                    TO_CLIENT.registerPacket( 0x3B, Packet206SetScoreboardObjective.class );
+                    TO_CLIENT.registerPacket( 0x3C, Packet207SetScoreboardScore.class );
+                    TO_CLIENT.registerPacket( 0x3D, Packet208SetScoreboardDisplayObjective.class );
+                    TO_CLIENT.registerPacket( 0x3E, Packet209SetScoreboardTeam.class );
+                    TO_CLIENT.registerPacket( 0x3F, Packet250CustomPayload.class );
+                    TO_CLIENT.registerPacket( 0x40, Packet255KickDisconnect.class );
+
+                    TO_SERVER.registerPacket( 0x00, Packet0KeepAlive.class );
+                    TO_SERVER.registerPacket( 0x01, Packet3Chat.class );
+                    TO_SERVER.registerPacket( 0x02, Packet7UseEntity.class );
+                    TO_SERVER.registerPacket( 0x03, Packet10Flying.class );
+                    TO_SERVER.registerPacket( 0x04, Packet11PlayerPosition.class );
+                    TO_SERVER.registerPacket( 0x05, Packet12PlayerLook.class );
+                    TO_SERVER.registerPacket( 0x06, Packet13PlayerLookMove.class );
+                    TO_SERVER.registerPacket( 0x07, Packet14BlockDig.class );
+                    TO_SERVER.registerPacket( 0x08, Packet15Place.class );
+                    TO_SERVER.registerPacket( 0x09, Packet16BlockItemSwitch.class );
+                    TO_SERVER.registerPacket( 0x0A, Packet18ArmAnimation.class );
+                    TO_SERVER.registerPacket( 0x0B, Packet19EntityAction.class );
+                    TO_SERVER.registerPacket( 0x0C, Packet27PlayerInput.class );
+                    TO_SERVER.registerPacket( 0x0D, Packet101CloseWindow.class );
+                    TO_SERVER.registerPacket( 0x0E, Packet102WindowClick.class );
+                    TO_SERVER.registerPacket( 0x0F, Packet106Transaction.class );
+                    TO_SERVER.registerPacket( 0x10, Packet107SetCreativeSlot.class );
+                    TO_SERVER.registerPacket( 0x11, Packet108ButtonClick.class );
+                    TO_SERVER.registerPacket( 0x12, Packet130UpdateSign.class );
+                    TO_SERVER.registerPacket( 0x13, Packet202Abilities.class );
+                    TO_SERVER.registerPacket( 0x14, Packet203TabComplete.class );
+                    TO_SERVER.registerPacket( 0x15, Packet204LocaleAndViewDistance.class );
+                    TO_SERVER.registerPacket( 0x16, Packet205ClientCommand.class );
+                    TO_SERVER.registerPacket( 0x17, Packet250CustomPayload.class );
+
+                }
+            },
+    // 1
+    STATUS
+            {
+
+                
+                {
+                    TO_CLIENT.registerPacket( 0x00, Packet255KickDisconnect.class );
+                    TO_CLIENT.registerPacket( 0x01, PacketPingTime.class );
+
+                    TO_SERVER.registerPacket( 0x00, PacketStatusRequest.class );
+                    TO_SERVER.registerPacket( 0x01, PacketPingTime.class );
+                }
+            },
+    //2
+    LOGIN
+            {
+
+                
+                {
+                    TO_CLIENT.registerPacket( 0x00, Packet255KickDisconnect.class );
+                    TO_CLIENT.registerPacket( 0x01, Packet253KeyRequest.class );
+                    TO_CLIENT.registerPacket( 0x02, PacketLoginSuccess.class );
+
+                    TO_SERVER.registerPacket( 0x00, PacketLoginRequest.class );
+                    TO_SERVER.registerPacket( 0x01, Packet252KeyResponse.class );
+                }
+            };
+    /*========================================================================*/
+    public static final int MAX_PACKET_ID = 0xFF;
+    public static final int PROTOCOL_VERSION = 0x04;
+    public static final String MINECRAFT_VERSION = "1.7.2";
+    /*========================================================================*/
+    public final ProtocolDirection TO_SERVER = new ProtocolDirection( "TO_SERVER" );
+    public final ProtocolDirection TO_CLIENT = new ProtocolDirection( "TO_CLIENT" );
+
+    public class ProtocolDirection
+    {
+
+        public ProtocolDirection(String name)
+        {
+            this.name = name;
+        }
+
+        private final String name;
+        private final TObjectIntMap<Class<? extends Packet>> packetMap = new TObjectIntHashMap<Class<? extends Packet>>( MAX_PACKET_ID );
+        private final Class<? extends Packet>[] packetClasses = new Class[ MAX_PACKET_ID ];
+        private final Constructor<? extends Packet>[] packetConstructors = new Constructor[ MAX_PACKET_ID ];
+
+        public boolean hasPacket(int id)
+        {
+            return id < MAX_PACKET_ID && packetConstructors[id] != null;
+        }
+
+        @Override
+        public String toString()
+        {
+            return name;
+        }
+
+        public final Packet createPacket(int id)
+        {
+            if ( id > MAX_PACKET_ID )
+            {
+                throw new RuntimeException( "Packet with id " + id + " outside of range " );
+            }
+            if ( packetConstructors[id] == null )
+            {
+                throw new RuntimeException( "No packet with id " + id );
+            }
+
+            try
+            {
+                return packetClasses[id].newInstance();
+            } catch ( Exception ex )
+            {
+                throw new RuntimeException( "Could not construct packet with id " + id, ex );
+            }
+        }
+
+        protected final void registerPacket(int id, Class<? extends Packet> packetClass)
+        {
+            try
+            {
+                packetConstructors[id] = packetClass.getDeclaredConstructor();
+            } catch ( NoSuchMethodException ex )
+            {
+                throw new RuntimeException( "No NoArgsConstructor for packet class " + packetClass );
+            }
+            packetClasses[id] = packetClass;
+            packetMap.put( packetClass, id );
+        }
+
+        protected final void unregisterPacket(int id)
+        {
+            packetMap.remove( packetClasses[id] );
+            packetClasses[id] = null;
+            packetConstructors[id] = null;
+        }
+
+        final int getId(Class<? extends Packet> packet)
+        {
+            Preconditions.checkArgument( packetMap.containsKey( packet ), "Cannot get ID for packet " + packet );
+
+            return packetMap.get( packet );
+        }
+    }
+}
diff --git a/src/main/java/org/spigotmc/netty/ReadState.java b/src/main/java/org/spigotmc/netty/ReadState.java
new file mode 100644
index 0000000..d3a9cab
--- /dev/null
+++ b/src/main/java/org/spigotmc/netty/ReadState.java
@@ -0,0 +1,17 @@
+package org.spigotmc.netty;
+
+/**
+ * Stores the state of the packet currently being read.
+ */
+public enum ReadState
+{
+
+    /**
+     * Indicates the byte representing the ID has been read.
+     */
+    HEADER,
+    /**
+     * Shows the packet body is being read.
+     */
+    DATA;
+}
diff --git a/src/main/java/org/spigotmc/netty/ServerPing.java b/src/main/java/org/spigotmc/netty/ServerPing.java
new file mode 100644
index 0000000..46b15dd
--- /dev/null
+++ b/src/main/java/org/spigotmc/netty/ServerPing.java
@@ -0,0 +1,39 @@
+package org.spigotmc.netty;
+
+import lombok.AllArgsConstructor;
+import lombok.Data;
+import lombok.NoArgsConstructor;
+
+/**
+ * Represents the standard list data returned by opening a server in the
+ * Minecraft client server list, or hitting it with a packet 0xFE.
+ */
+@Data
+@NoArgsConstructor
+@AllArgsConstructor
+public class ServerPing
+{
+
+    private Protocol version;
+
+    @Data
+    @AllArgsConstructor
+    public static class Protocol
+    {
+
+        private String name;
+        private int protocol;
+    }
+    private Players players;
+
+    @Data
+    @AllArgsConstructor
+    public static class Players
+    {
+
+        private int max;
+        private int online;
+    }
+    private String description;
+    private String favicon;
+}
diff --git a/src/main/java/org/spigotmc/netty/Varint21FrameDecoder.java b/src/main/java/org/spigotmc/netty/Varint21FrameDecoder.java
new file mode 100644
index 0000000..4708c5f
--- /dev/null
+++ b/src/main/java/org/spigotmc/netty/Varint21FrameDecoder.java
@@ -0,0 +1,48 @@
+package org.spigotmc.netty;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.ByteToMessageDecoder;
+import io.netty.handler.codec.CorruptedFrameException;
+
+import java.util.List;
+import net.minecraft.server.Packet;
+
+public class Varint21FrameDecoder extends ByteToMessageDecoder
+{
+
+    @Override
+    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception
+    {
+        in.markReaderIndex();
+
+        final byte[] buf = new byte[ 3 ];
+        for ( int i = 0; i < buf.length; i++ )
+        {
+            if ( !in.isReadable() )
+            {
+                in.resetReaderIndex();
+                return;
+            }
+
+            buf[i] = in.readByte();
+            if ( buf[i] >= 0 )
+            {
+                int length = Packet.readVarInt( Unpooled.wrappedBuffer( buf ) );
+
+                if ( in.readableBytes() < length )
+                {
+                    in.resetReaderIndex();
+                    return;
+                } else
+                {
+                    out.add( in.readBytes( length ) );
+                    return;
+                }
+            }
+        }
+
+        throw new CorruptedFrameException( "length wider than 21-bit" );
+    }
+}
diff --git a/src/main/java/org/spigotmc/netty/Varint21LengthFieldPrepender.java b/src/main/java/org/spigotmc/netty/Varint21LengthFieldPrepender.java
new file mode 100644
index 0000000..9f1b549
--- /dev/null
+++ b/src/main/java/org/spigotmc/netty/Varint21LengthFieldPrepender.java
@@ -0,0 +1,44 @@
+package org.spigotmc.netty;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.MessageToByteEncoder;
+import io.netty.channel.ChannelHandler;
+import net.minecraft.server.Packet;
+
+@ChannelHandler.Sharable
+public class Varint21LengthFieldPrepender extends MessageToByteEncoder<ByteBuf>
+{
+
+    @Override
+    protected void encode(ChannelHandlerContext ctx, ByteBuf msg, ByteBuf out) throws Exception
+    {
+        int bodyLen = msg.readableBytes();
+        int headerLen = varintSize( bodyLen );
+        out.ensureWritable( headerLen + bodyLen );
+
+        Packet.writeVarInt( bodyLen, out );
+        out.writeBytes( msg );
+    }
+
+    private static int varintSize(int paramInt)
+    {
+        if ( ( paramInt & 0xFFFFFF80 ) == 0 )
+        {
+            return 1;
+        }
+        if ( ( paramInt & 0xFFFFC000 ) == 0 )
+        {
+            return 2;
+        }
+        if ( ( paramInt & 0xFFE00000 ) == 0 )
+        {
+            return 3;
+        }
+        if ( ( paramInt & 0xF0000000 ) == 0 )
+        {
+            return 4;
+        }
+        return 5;
+    }
+}
-- 
1.8.4.4

