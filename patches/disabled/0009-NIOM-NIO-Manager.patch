From 798267b33bade283ed3634fed068edda9e44b1f3 Mon Sep 17 00:00:00 2001
From: Aikar <aikar@aikar.co>
Date: Fri, 15 Feb 2013 20:10:44 -0500
Subject: [PATCH] NIOM - NIO Manager

Alternative to Netty
improve the existing network manager using Blocking NIO instead of IO (more effecient code)
Writes use a direct memory buffer for less copying, and more stable memory usage.

Reimplement Low Priority Queue
Optimized PacketQueue System that supports instant send notification to the writer thread
Removed packet queue walking since it will very unlikely ever be hit now.
Writer thread will now sleep longer until notified
Network threads are no longer interrupted every tick, letting them sleep as much as possible
---
 .../com/empireminecraft/niom/NiomOutputStream.java | 88 ++++++++++++++++++++++
 .../java/com/empireminecraft/niom/PacketQueue.java | 58 ++++++++++++++
 .../server/DedicatedServerConnectionThread.java    |  2 +-
 .../java/net/minecraft/server/NetworkManager.java  | 39 ++++++++--
 .../net/minecraft/server/NetworkWriterThread.java  |  8 +-
 .../net/minecraft/server/Packet56MapChunkBulk.java |  1 +
 6 files changed, 186 insertions(+), 10 deletions(-)
 create mode 100644 src/main/java/com/empireminecraft/niom/NiomOutputStream.java
 create mode 100644 src/main/java/com/empireminecraft/niom/PacketQueue.java

diff --git a/src/main/java/com/empireminecraft/niom/NiomOutputStream.java b/src/main/java/com/empireminecraft/niom/NiomOutputStream.java
new file mode 100644
index 0000000..7a781d1
--- /dev/null
+++ b/src/main/java/com/empireminecraft/niom/NiomOutputStream.java
@@ -0,0 +1,88 @@
+package com.empireminecraft.niom;
+
+import java.io.IOException;
+import java.io.OutputStream;
+import java.net.*;
+import java.nio.ByteBuffer;
+import java.nio.channels.ServerSocketChannel;
+import java.nio.channels.SocketChannel;
+
+public class NiomOutputStream extends OutputStream {
+    private final ByteBuffer buffer;
+    private final SocketChannel channel;
+
+    /**
+     * Creates an NIO ServerSocket that wraps IO sockets with NIO backend
+     * @param inetaddress
+     * @param port
+     * @return
+     * @throws IOException
+     */
+    public final static ServerSocket getServerSocket(InetAddress inetaddress, int port) throws IOException {
+        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
+        ServerSocket socket = serverSocketChannel.socket();
+
+        InetSocketAddress bind = new InetSocketAddress(inetaddress, port);
+        serverSocketChannel.configureBlocking(true);
+        socket.setPerformancePreferences(0, 2, 1);
+        socket.bind(bind);
+        return socket;
+    }
+
+    /**
+     * Output stream that backed by a Direct Memory buffer for zero copy socket writing
+     * @param channel
+     */
+    public NiomOutputStream(SocketChannel channel) {
+        this.channel = channel;
+        int bufSize = 1024 * 8;
+        try {
+            bufSize = channel.getOption(StandardSocketOptions.SO_SNDBUF);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+        this.buffer = ByteBuffer.allocateDirect(bufSize);
+    }
+
+    /**
+     * Writes the byte to the buffer, flushing if full
+     * @param b
+     * @throws IOException
+     */
+    @Override
+    public void write(int b) throws IOException {
+        if (buffer.position() >= buffer.capacity()) {
+            flush();
+        }
+        buffer.put((byte) b);
+    }
+
+    /**
+     * Sends the buffer to the channel and resets it.
+     * @throws IOException
+     */
+    @Override
+    public void flush() throws IOException {
+        if (buffer.position() > 0) {
+            buffer.flip();
+            while (buffer.hasRemaining()) {
+                channel.write(buffer);
+            }
+        }
+
+        buffer.clear();
+    }
+
+    /**
+     * Flushes the buffer and closes the channel
+     * @throws IOException
+     */
+    @Override
+    public void close() throws IOException {
+        try {
+            flush();
+        } catch (IOException ignored) {
+        }
+        channel.close();
+    }
+}
diff --git a/src/main/java/com/empireminecraft/niom/PacketQueue.java b/src/main/java/com/empireminecraft/niom/PacketQueue.java
new file mode 100644
index 0000000..142d98d
--- /dev/null
+++ b/src/main/java/com/empireminecraft/niom/PacketQueue.java
@@ -0,0 +1,58 @@
+package com.empireminecraft.niom;
+
+import net.minecraft.server.Packet;
+
+import java.util.AbstractList;
+import java.util.concurrent.ConcurrentLinkedQueue;
+
+public class PacketQueue extends AbstractList<Packet> {
+    ConcurrentLinkedQueue<Packet> queue = new ConcurrentLinkedQueue<Packet>();
+    ConcurrentLinkedQueue<Long> orderQueue = new ConcurrentLinkedQueue<Long>();
+
+    public static class PacketCounter {
+        long id = 1;
+        public long next() {
+            return id++;
+        }
+    }
+
+    PacketCounter counter;
+    public PacketQueue(PacketCounter counter) {
+        this.counter = counter;
+    }
+
+    @Override
+    public boolean add(Packet element) {
+        orderQueue.offer(counter.next());
+        return queue.offer(element);
+    }
+
+    @Override
+    public Packet get(int index) {
+        return poll();
+    }
+
+    public Packet poll() {
+        orderQueue.poll();
+        return queue.poll();
+    }
+    public long orderId() {
+        Long res = orderQueue.peek();
+        return res == null ? Long.MAX_VALUE : res;
+    }
+
+    @Override
+    public Packet remove(int index) {
+        return poll();
+    }
+
+    @Override
+    public int size() {
+        return queue.isEmpty() ? 0 : 1;
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return queue.isEmpty();
+    }
+}
diff --git a/src/main/java/net/minecraft/server/DedicatedServerConnectionThread.java b/src/main/java/net/minecraft/server/DedicatedServerConnectionThread.java
index e62f738..ec55db7 100644
--- a/src/main/java/net/minecraft/server/DedicatedServerConnectionThread.java
+++ b/src/main/java/net/minecraft/server/DedicatedServerConnectionThread.java
@@ -25,7 +25,7 @@ public class DedicatedServerConnectionThread extends Thread {
         super("Listen thread");
         this.e = serverconnection;
         this.g = i;
-        this.d = new ServerSocket(i, 0, inetaddress);
+        this.d = com.empireminecraft.niom.NiomOutputStream.getServerSocket(inetaddress, i); // EMC
         this.f = inetaddress == null ? this.d.getInetAddress() : inetaddress;
         this.d.setPerformancePreferences(0, 2, 1);
     }
diff --git a/src/main/java/net/minecraft/server/NetworkManager.java b/src/main/java/net/minecraft/server/NetworkManager.java
index fd6acab..db6f873 100644
--- a/src/main/java/net/minecraft/server/NetworkManager.java
+++ b/src/main/java/net/minecraft/server/NetworkManager.java
@@ -1,5 +1,11 @@
 package net.minecraft.server;
 
+// EMC start
+import com.empireminecraft.niom.NiomOutputStream;
+import com.empireminecraft.niom.PacketQueue;
+import java.nio.channels.ClosedByInterruptException;
+// EMC end
+
 import java.io.BufferedOutputStream;
 import java.io.DataInputStream;
 import java.io.DataOutput;
@@ -25,6 +31,7 @@ public class NetworkManager implements INetworkManager {
     public static AtomicInteger a = new AtomicInteger();
     public static AtomicInteger b = new AtomicInteger();
     private final Object h = new Object();
+    public final Object notifyLock = h; // EMC - Update notifyLock on rename
     private final IConsoleLogManager i;
     public Socket socket; // CraftBukkit - private -> public
     private SocketAddress k; // Spigot - remove final
@@ -33,8 +40,12 @@ public class NetworkManager implements INetworkManager {
     private volatile boolean n = true;
     private volatile boolean o;
     private Queue inboundQueue = new ConcurrentLinkedQueue();
-    private List highPriorityQueue = Collections.synchronizedList(new ArrayList());
-    private List lowPriorityQueue = Collections.synchronizedList(new ArrayList());
+    // EMC start
+    public final NiomOutputStream outputStream;
+    PacketQueue.PacketCounter counter = new PacketQueue.PacketCounter();
+    public List<Packet> highPriorityQueue = new PacketQueue(counter);
+    public List<Packet> lowPriorityQueue = new PacketQueue(counter);
+    // EMC end
     private Connection connection;
     private boolean t;
     private Thread u;
@@ -67,7 +78,8 @@ public class NetworkManager implements INetworkManager {
         }
 
         this.input = new DataInputStream(socket.getInputStream());
-        this.output = new DataOutputStream(new BufferedOutputStream(socket.getOutputStream(), 5120));
+        this.outputStream = new NiomOutputStream(socket.getChannel()); // EMC
+        this.output = new DataOutputStream(this.outputStream); // EMC
         this.v = new NetworkReaderThread(this, s + " read thread");
         this.u = new NetworkWriterThread(this, s + " write thread");
         this.v.start();
@@ -84,7 +96,13 @@ public class NetworkManager implements INetworkManager {
 
             synchronized (this.h) {
                 this.z += packet.a() + 1;
-                this.highPriorityQueue.add(packet);
+                // EMC start
+                boolean shouldNotify = lowPriorityQueue.isEmpty() && highPriorityQueue.isEmpty();
+                (packet.lowPriority ? lowPriorityQueue : highPriorityQueue).add(packet);
+                if (shouldNotify) {
+                    this.h.notify();
+                }
+                // EMC end
             }
         }
     }
@@ -97,7 +115,7 @@ public class NetworkManager implements INetworkManager {
             int i;
             int[] aint;
 
-            if (this.e == 0 || !this.highPriorityQueue.isEmpty() && MinecraftServer.aq() - ((Packet) this.highPriorityQueue.get(0)).timestamp >= (long) this.e) {
+            if (!this.highPriorityQueue.isEmpty()) { // EMC
                 packet = this.a(false);
                 if (packet != null) {
                     Packet.a(packet, (DataOutput) this.output);
@@ -117,7 +135,9 @@ public class NetworkManager implements INetworkManager {
             }
 
             // CraftBukkit - don't allow low priority packet to be sent unless it was placed in the queue before the first packet on the high priority queue TODO: is this still right?
-            if ((flag || this.lowPriorityQueueDelay-- <= 0) && !this.lowPriorityQueue.isEmpty() && (this.highPriorityQueue.isEmpty() || ((Packet) this.highPriorityQueue.get(0)).timestamp > ((Packet) this.lowPriorityQueue.get(0)).timestamp)) {
+            long lowId = ((PacketQueue) this.lowPriorityQueue).orderId(); // EMC
+            long highId = ((PacketQueue) this.highPriorityQueue).orderId(); // EMC
+            if (lowId != Long.MAX_VALUE && (lowId < highId)) { // EMC
                 packet = this.a(true);
                 if (packet != null) {
                     Packet.a(packet, (DataOutput) this.output);
@@ -148,6 +168,7 @@ public class NetworkManager implements INetworkManager {
             while (!list.isEmpty() && packet == null) {
                 packet = (Packet) list.remove(0);
                 this.z -= packet.a() + 1;
+                if (true) return packet; // EMC - we don't need to walk the packet array checking for futue
                 if (this.a(packet, flag)) {
                     packet = null;
                 }
@@ -179,6 +200,7 @@ public class NetworkManager implements INetworkManager {
     }
 
     public void a() {
+        if (true) return; // EMC
         if (this.v != null) {
             this.v.interrupt();
         }
@@ -222,6 +244,7 @@ public class NetworkManager implements INetworkManager {
             }
 
             return flag;
+        } catch (ClosedByInterruptException cbie) { return false; // EMC
         } catch (Exception exception) {
             if (!this.o) {
                 this.a(exception);
@@ -326,9 +349,9 @@ public class NetworkManager implements INetworkManager {
     private void k() throws IOException { // CraftBukkit - throws IOException
         this.output.flush();
         this.g = true;
-        BufferedOutputStream bufferedoutputstream = new BufferedOutputStream(MinecraftEncryption.a(this.A, this.socket.getOutputStream()), 5120);
+        //BufferedOutputStream bufferedoutputstream = new BufferedOutputStream(MinecraftEncryption.a(this.A, this.socket.getOutputStream()), 5120); // EMC
 
-        this.output = new DataOutputStream(bufferedoutputstream);
+        this.output = new DataOutputStream(MinecraftEncryption.a(this.A, this.outputStream)); // EMC
     }
 
     public int e() {
diff --git a/src/main/java/net/minecraft/server/NetworkWriterThread.java b/src/main/java/net/minecraft/server/NetworkWriterThread.java
index 68d84de..be24c6e 100644
--- a/src/main/java/net/minecraft/server/NetworkWriterThread.java
+++ b/src/main/java/net/minecraft/server/NetworkWriterThread.java
@@ -35,7 +35,13 @@ class NetworkWriterThread extends Thread {
                 }
 
                 try {
-                    sleep(2L);
+                    // EMC start - wait for notify
+                    synchronized (this.a.notifyLock) {
+                        if (this.a.highPriorityQueue.isEmpty() && this.a.lowPriorityQueue.isEmpty()) {
+                            this.a.notifyLock.wait(50);
+                        }
+                    }
+                    // EMC end
                 } catch (InterruptedException interruptedexception) {
                     ;
                 }
diff --git a/src/main/java/net/minecraft/server/Packet56MapChunkBulk.java b/src/main/java/net/minecraft/server/Packet56MapChunkBulk.java
index 63dd8d3..52cab58 100644
--- a/src/main/java/net/minecraft/server/Packet56MapChunkBulk.java
+++ b/src/main/java/net/minecraft/server/Packet56MapChunkBulk.java
@@ -30,6 +30,7 @@ public class Packet56MapChunkBulk extends Packet {
     // CraftBukkit end
     private World world; // Spigot
 
+    {lowPriority=true;} // EMC
     public Packet56MapChunkBulk() {}
 
     public Packet56MapChunkBulk(List list) {
-- 
1.8.4

